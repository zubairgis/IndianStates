{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geemap","text":"<p>A Python package for interactive mapping with Google Earth Engine, ipyleaflet, and ipywidgets.</p> <ul> <li>GitHub repo: https://github.com/gee-community/geemap</li> <li>Documentation: https://geemap.org</li> <li>PyPI: https://pypi.org/project/geemap</li> <li>Conda-forge: https://anaconda.org/conda-forge/geemap</li> <li>360+ GEE notebook examples: https://github.com/giswqs/earthengine-py-notebooks</li> <li>GEE Tutorials on YouTube: https://youtube.com/@giswqs</li> <li>Free software: MIT license</li> </ul> <p>Acknowledgment: This material is based upon work supported by the National Aeronautics and Space Administration (NASA) under Grant No. 80NSSC22K1742 issued through the Open Source Tools, Frameworks, and Libraries 2020 Program.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Geemap is a Python package for interactive mapping with Google Earth Engine (GEE), which is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. During the past few years, GEE has become very popular in the geospatial community and it has empowered numerous environmental applications at local, regional, and global scales. GEE provides both JavaScript and Python APIs for making computational requests to the Earth Engine servers. Compared with the comprehensive documentation and interactive IDE (i.e., GEE JavaScript Code Editor) of the GEE JavaScript API, the GEE Python API has relatively little documentation and limited functionality for visualizing results interactively. The geemap Python package was created to fill this gap. It is built upon ipyleaflet and ipywidgets, and enables users to analyze and visualize Earth Engine datasets interactively within a Jupyter-based environment.</p> <p>Geemap is intended for students and researchers, who would like to utilize the Python ecosystem of diverse libraries and tools to explore Google Earth Engine. It is also designed for existing GEE users who would like to transition from the GEE JavaScript API to Python API. The automated JavaScript-to-Python conversion module of the geemap package can greatly reduce the time needed to convert existing GEE JavaScripts to Python scripts and Jupyter notebooks.</p> <p>For video tutorials and notebook examples, please visit the examples page. For complete documentation on geemap modules and methods, please visit the API Reference.</p> <p>If you find geemap useful in your research, please consider citing the following papers to support my work. Thank you for your support.</p> <ul> <li>Wu, Q., (2020). geemap: A Python package for interactive mapping with Google Earth Engine. The Journal of Open Source Software, 5(51), 2305. https://doi.org/10.21105/joss.02305</li> <li>Wu, Q., Lane, C. R., Li, X., Zhao, K., Zhou, Y., Clinton, N., DeVries, B., Golden, H. E., &amp; Lang, M. W. (2019). Integrating LiDAR data and multi-temporal aerial imagery to map wetland inundation dynamics using Google Earth Engine. Remote Sensing of Environment, 228, 1-13. https://doi.org/10.1016/j.rse.2019.04.015 (pdf | source code)</li> </ul> <p>Check out the geemap workshop I presented at the GeoPython Conference 2021. This workshop gives a comprehensive introduction to the key features of geemap.</p> <p></p>"},{"location":"#key-features","title":"Key Features","text":"<p>Below is a partial list of features available for the geemap package. Please check the examples page for notebook examples, GIF animations, and video tutorials.</p> <ul> <li>Convert Earth Engine JavaScripts to Python scripts and Jupyter notebooks.</li> <li>Display Earth Engine data layers for interactive mapping.</li> <li>Support Earth Engine JavaScript API-styled functions in Python, such as <code>Map.addLayer()</code>, <code>Map.setCenter()</code>, <code>Map.centerObject()</code>, <code>Map.setOptions()</code>.</li> <li>Create split-panel maps with Earth Engine data.</li> <li>Retrieve Earth Engine data interactively using the Inspector Tool.</li> <li>Interactive plotting of Earth Engine data by simply clicking on the map.</li> <li>Convert data format between GeoJSON and Earth Engine.</li> <li>Use drawing tools to interact with Earth Engine data.</li> <li>Use shapefiles with Earth Engine without having to upload data to one's GEE account.</li> <li>Export Earth Engine FeatureCollection to other formats (i.e., shp, csv, json, kml, kmz).</li> <li>Export Earth Engine Image and ImageCollection as GeoTIFF.</li> <li>Extract pixels from an Earth Engine Image into a 3D numpy array.</li> <li>Calculate zonal statistics by group.</li> <li>Add a customized legend for Earth Engine data.</li> <li>Convert Earth Engine JavaScripts to Python code directly within Jupyter notebook.</li> <li>Add animated text to GIF images generated from Earth Engine data.</li> <li>Add colorbar and images to GIF animations generated from Earth Engine data.</li> <li>Create Landsat timelapse animations with animated text using Earth Engine.</li> <li>Search places and datasets from Earth Engine Data Catalog.</li> <li>Use timeseries inspector to visualize landscape changes over time.</li> <li>Export Earth Engine maps as HTML files and PNG images.</li> <li>Search Earth Engine API documentation within Jupyter notebooks.</li> <li>Import Earth Engine assets from personal account.</li> <li>Publish interactive GEE maps directly within Jupyter notebook.</li> <li>Add local raster datasets (e.g., GeoTIFF) to the map.</li> <li>Perform image classification and accuracy assessment.</li> <li>Extract pixel values interactively and export as shapefile and csv.</li> </ul>"},{"location":"#youtube-channel","title":"YouTube Channel","text":"<p>I have created a YouTube Channel for sharing geemap tutorials. You can subscribe to my channel for regular updates. If there is any specific tutorial you would like to see, please submit a feature request here.</p> <p></p>"},{"location":"basemaps/","title":"basemaps module","text":"<p>Module for basemaps. Each basemap is defined as item in the basemaps dictionary. For example, to access Google basemaps, use the following:</p> <p>basemaps['ROADMAP'], basemaps['SATELLITE'], basemaps['HYBRID'].</p> <p>More WMS basemaps can be found at the following websites:</p> <ol> <li> <p>USGS National Map: https://viewer.nationalmap.gov/services/</p> </li> <li> <p>MRLC NLCD Land Cover data: https://viewer.nationalmap.gov/services/</p> </li> <li> <p>FWS NWI Wetlands data: https://www.fws.gov/wetlands/Data/Web-Map-Services.html</p> </li> </ol>"},{"location":"basemaps/#geemap.basemaps.get_xyz_dict","title":"<code>get_xyz_dict(free_only=True, _collection=None, _output=None)</code>","text":"<p>Returns a dictionary of xyz services.</p> <p>Parameters:</p> Name Type Description Default <code>free_only</code> <code>bool</code> <p>Whether to return only free xyz tile services that do not require an access token. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of xyz services.</p> Source code in <code>geemap/basemaps.py</code> <pre><code>def get_xyz_dict(free_only=True, _collection=None, _output=None):\n\"\"\"Returns a dictionary of xyz services.\n\n    Args:\n        free_only (bool, optional): Whether to return only free xyz tile services that do not require an access token. Defaults to True.\n\n    Returns:\n        dict: A dictionary of xyz services.\n    \"\"\"\n\n    if _collection is None:\n        _collection = xyz\n\n    if _output is None:\n        _output = {}\n\n    for v in _collection.values():\n        if isinstance(v, TileProvider):\n            if not (v.requires_token() and free_only):\n                _output[v.name] = v\n        else:  # it's a Bunch\n            get_xyz_dict(free_only, v, _output)\n\n    return collections.OrderedDict(sorted(_output.items()))\n</code></pre>"},{"location":"basemaps/#geemap.basemaps.search_qms","title":"<code>search_qms(keywords, limit=10)</code>","text":"<p>Search qms files for keywords. Reference: https://github.com/geopandas/xyzservices/issues/65</p> <p>Parameters:</p> Name Type Description Default <code>keywords</code> <code>str</code> <p>Keywords to search for.</p> required <code>limit</code> <code>int</code> <p>Number of results to return.</p> <code>10</code> Source code in <code>geemap/basemaps.py</code> <pre><code>def search_qms(keywords, limit=10):\n\"\"\"Search qms files for keywords. Reference: https://github.com/geopandas/xyzservices/issues/65\n\n    Args:\n        keywords (str): Keywords to search for.\n        limit (int): Number of results to return.\n    \"\"\"\n    QMS_API = \"https://qms.nextgis.com/api/v1/geoservices\"\n\n    services = requests.get(\n        f\"{QMS_API}/?search={keywords}&amp;type=tms&amp;epsg=3857&amp;limit={str(limit)}\"\n    )\n    services = services.json()\n    if services[\"count\"] == 0:\n        return None\n    elif services[\"count\"] &lt;= limit:\n        return services[\"results\"]\n    else:\n        return services[\"results\"][:limit]\n</code></pre>"},{"location":"basemaps/#geemap.basemaps.xyz_to_folium","title":"<code>xyz_to_folium()</code>","text":"<p>Convert xyz tile services to folium tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of folium tile layers.</p> Source code in <code>geemap/basemaps.py</code> <pre><code>def xyz_to_folium():\n\"\"\"Convert xyz tile services to folium tile layers.\n\n    Returns:\n        dict: A dictionary of folium tile layers.\n    \"\"\"\n    folium_dict = {}\n\n    for key, tile in xyz_tiles.items():\n        folium_dict[key] = folium.TileLayer(\n            tiles=tile[\"url\"],\n            attr=tile[\"attribution\"],\n            name=tile[\"name\"],\n            overlay=True,\n            control=True,\n            max_zoom=22,\n        )\n\n    for key, tile in wms_tiles.items():\n        folium_dict[key] = folium.WmsTileLayer(\n            url=tile[\"url\"],\n            layers=tile[\"layers\"],\n            name=tile[\"name\"],\n            attr=tile[\"attribution\"],\n            fmt=tile[\"format\"],\n            transparent=tile[\"transparent\"],\n            overlay=True,\n            control=True,\n        )\n\n    for item in get_xyz_dict().values():\n        folium_dict[item.name] = folium.TileLayer(\n            tiles=item.build_url(),\n            attr=item.attribution,\n            name=item.name,\n            max_zoom=item.get(\"max_zoom\", 22),\n            overlay=True,\n            control=True,\n        )\n\n    if os.environ.get(\"PLANET_API_KEY\") is not None:\n        planet_dict = planet_tiles(tile_format=\"folium\")\n        folium_dict.update(planet_dict)\n\n    return folium_dict\n</code></pre>"},{"location":"basemaps/#geemap.basemaps.xyz_to_heremap","title":"<code>xyz_to_heremap()</code>","text":"<p>Convert xyz tile services to hermap tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of heremap tile layers.</p> Source code in <code>geemap/basemaps.py</code> <pre><code>def xyz_to_heremap():\n\"\"\"Convert xyz tile services to hermap tile layers.\n\n    Returns:\n        dict: A dictionary of heremap tile layers.\n    \"\"\"\n\n    try:\n        import here_map_widget\n    except ImportError:\n        raise ImportError(\n            'This module requires the hermap package. Please install it using \"pip install here-map-widget-for-jupyter\".'\n        )\n\n    # Built-in heremap tile services.\n    here_tiles = {\n        \"HERE_RASTER_NORMAL_MAP\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.normal.map\n        ),\n        \"HERE_RASTER_NORMAL_BASE\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.normal.base\n        ),\n        \"HERE_RASTER_NORMAL_BASE_NIGHT\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.normal.basenight\n        ),\n        \"HERE_RASTER_NORMAL_LABELS\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.normal.labels\n        ),\n        \"HERE_RASTER_NORMAL_TRANSIT\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.normal.transit\n        ),\n        \"HERE_RASTER_NORMAL_XBASE\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.normal.xbase\n        ),\n        \"HERE_RASTER_NORMAL_XBASE_NIGHT\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.normal.xbasenight\n        ),\n        \"HERE_RASTER_SATELLITE_MAP\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.satellite.map\n        ),\n        \"HERE_RASTER_SATELLITE_LABELS\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.satellite.labels\n        ),\n        \"HERE_RASTER_SATELLITE_BASE\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.satellite.base\n        ),\n        \"HERE_RASTER_SATELLITE_XBASE\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.satellite.xbase\n        ),\n        \"HERE_RASTER_TERRAIN_MAP\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.terrain.map\n        ),\n        \"HERE_RASTER_TERRAIN_LABELS\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.terrain.labels\n        ),\n        \"HERE_RASTER_TERRAIN_BASE\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.terrain.base\n        ),\n        \"HERE_RASTER_TERRAIN_XBASE\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.raster.terrain.xbase\n        ),\n        \"HERE_VECTOR_NORMAL_MAP\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.vector.normal.map\n        ),\n        \"HERE_VECTOR_NORMAL_TRUCK\": here_map_widget.DefaultLayers(\n            layer_name=here_map_widget.DefaultLayerNames.vector.normal.truck\n        ),\n    }\n\n    heremap_dict = {}\n\n    for key, tile in xyz_tiles.items():\n        heremap_dict[key] = here_map_widget.TileLayer(\n            provider=here_map_widget.ImageTileProvider(\n                url=tile[\"url\"], attribution=tile[\"attribution\"], name=tile[\"name\"]\n            )\n        )\n\n    for item in get_xyz_dict().values():\n        heremap_dict[item.name] = here_map_widget.TileLayer(\n            provider=here_map_widget.ImageTileProvider(\n                url=item.build_url(),\n                attribution=item.attribution,\n                name=item.name,\n                max_zoom=item.get(\"max_zoom\", 22),\n            )\n        )\n\n    heremap_dict.update(here_tiles)\n\n    return heremap_dict\n</code></pre>"},{"location":"basemaps/#geemap.basemaps.xyz_to_leaflet","title":"<code>xyz_to_leaflet()</code>","text":"<p>Convert xyz tile services to ipyleaflet tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of ipyleaflet tile layers.</p> Source code in <code>geemap/basemaps.py</code> <pre><code>def xyz_to_leaflet():\n\"\"\"Convert xyz tile services to ipyleaflet tile layers.\n\n    Returns:\n        dict: A dictionary of ipyleaflet tile layers.\n    \"\"\"\n    leaflet_dict = {}\n\n    for key, tile in xyz_tiles.items():\n        name = tile[\"name\"]\n        url = tile[\"url\"]\n        attribution = tile[\"attribution\"]\n        leaflet_dict[key] = ipyleaflet.TileLayer(\n            url=url, name=name, attribution=attribution, max_zoom=22\n        )\n\n    for key, tile in wms_tiles.items():\n        leaflet_dict[key] = ipyleaflet.WMSLayer(\n            url=tile[\"url\"],\n            layers=tile[\"layers\"],\n            name=tile[\"name\"],\n            attribution=tile[\"attribution\"],\n            format=tile[\"format\"],\n            transparent=tile[\"transparent\"],\n        )\n\n    for item in get_xyz_dict().values():\n        leaflet_dict[item.name] = ipyleaflet.TileLayer(\n            url=item.build_url(),\n            name=item.name,\n            max_zoom=item.get(\"max_zoom\", 22),\n            attribution=item.attribution,\n        )\n\n    if os.environ.get(\"PLANET_API_KEY\") is not None:\n        planet_dict = planet_tiles(tile_format=\"ipyleaflet\")\n        leaflet_dict.update(planet_dict)\n\n    return leaflet_dict\n</code></pre>"},{"location":"basemaps/#geemap.basemaps.xyz_to_plotly","title":"<code>xyz_to_plotly()</code>","text":"<p>Convert xyz tile services to plotly tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of plotly tile layers.</p> Source code in <code>geemap/basemaps.py</code> <pre><code>def xyz_to_plotly():\n\"\"\"Convert xyz tile services to plotly tile layers.\n\n    Returns:\n        dict: A dictionary of plotly tile layers.\n    \"\"\"\n    plotly_dict = {}\n\n    for key, tile in xyz_tiles.items():\n        plotly_dict[key] = {\n            \"below\": \"traces\",\n            \"sourcetype\": \"raster\",\n            \"sourceattribution\": tile[\"attribution\"],\n            \"source\": [tile[\"url\"]],\n            \"name\": key,\n        }\n\n    for item in get_xyz_dict().values():\n        plotly_dict[item.name] = {\n            \"below\": \"traces\",\n            \"sourcetype\": \"raster\",\n            \"sourceattribution\": item.attribution,\n            \"source\": [item.build_url()],\n            \"name\": item.name,\n        }\n\n    return plotly_dict\n</code></pre>"},{"location":"basemaps/#geemap.basemaps.xyz_to_pydeck","title":"<code>xyz_to_pydeck()</code>","text":"<p>Convert xyz tile services to pydeck custom tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of pydeck tile layers.</p> Source code in <code>geemap/basemaps.py</code> <pre><code>def xyz_to_pydeck():\n\"\"\"Convert xyz tile services to pydeck custom tile layers.\n\n    Returns:\n        dict: A dictionary of pydeck tile layers.\n    \"\"\"\n\n    check_package(\"pydeck\", \"https://deckgl.readthedocs.io/en/latest/installation.html\")\n    import pydeck as pdk\n\n    pydeck_dict = {}\n\n    for key, tile in xyz_tiles.items():\n        url = tile[\"url\"]\n        pydeck_dict[key] = url\n\n    for key, item in get_xyz_dict().items():\n        url = item.build_url()\n        pydeck_dict[key] = url\n\n        if os.environ.get(\"PLANET_API_KEY\") is not None:\n            planet_dict = planet_tiles(tile_format=\"ipyleaflet\")\n            for id_, tile in planet_dict.items():\n                pydeck_dict[id_] = tile.url\n\n    pdk.settings.custom_libraries = [\n        {\n            \"libraryName\": \"MyTileLayerLibrary\",\n            \"resourceUri\": \"https://cdn.jsdelivr.net/gh/giswqs/pydeck_myTileLayer@master/dist/bundle.js\",\n        }\n    ]\n\n    for key in pydeck_dict:\n        pydeck_dict[key] = pdk.Layer(\"MyTileLayer\", pydeck_dict[key], key)\n\n    return pydeck_dict\n</code></pre>"},{"location":"cartoee/","title":"cartoee module","text":""},{"location":"cartoee/#geemap.cartoee.add_colorbar","title":"<code>add_colorbar(ax, vis_params, loc=None, cmap='gray', discrete=False, label=None, **kwargs)</code>","text":"<p>Add a colorbar to the map based on visualization parameters provided</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes</code> <p>required cartopy GeoAxesSubplot object to add image overlay to</p> required <code>loc</code> <code>str</code> <p>string specifying the position</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.</p> required <code>**kwargs</code> <p>remaining keyword arguments are passed to colorbar()</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>Warning</code> <p>If 'discrete' is true when \"palette\" key is not in visParams</p> <code>ValueError</code> <p>If <code>ax</code> is not of type cartopy.mpl.geoaxes.GeoAxesSubplot</p> <code>ValueError</code> <p>If 'cmap' or \"palette\" key in visParams is not provided</p> <code>ValueError</code> <p>If \"min\" in visParams is not of type scalar</p> <code>ValueError</code> <p>If \"max\" in visParams is not of type scalar</p> <code>ValueError</code> <p>If 'loc' or 'cax' keywords are not provided</p> <code>ValueError</code> <p>If 'loc' is not of type str or does not equal available options</p> Source code in <code>geemap/cartoee.py</code> <pre><code>def add_colorbar(\n    ax, vis_params, loc=None, cmap=\"gray\", discrete=False, label=None, **kwargs\n):\n\"\"\"\n    Add a colorbar to the map based on visualization parameters provided\n    args:\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to add image overlay to\n        loc (str, optional): string specifying the position\n        vis_params (dict, optional): visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n        **kwargs: remaining keyword arguments are passed to colorbar()\n\n    raises:\n        Warning: If 'discrete' is true when \"palette\" key is not in visParams\n        ValueError: If `ax` is not of type cartopy.mpl.geoaxes.GeoAxesSubplot\n        ValueError: If 'cmap' or \"palette\" key in visParams is not provided\n        ValueError: If \"min\" in visParams is not of type scalar\n        ValueError: If \"max\" in visParams is not of type scalar\n        ValueError: If 'loc' or 'cax' keywords are not provided\n        ValueError: If 'loc' is not of type str or does not equal available options\n    \"\"\"\n\n    if type(ax) not in [GeoAxes, GeoAxesSubplot]:\n        raise ValueError(\n            \"provided axes not of type cartopy.mpl.geoaxes.GeoAxes \"\n            \"or cartopy.mpl.geoaxes.GeoAxesSubplot\"\n        )\n\n    if loc:\n        if (type(loc) == str) and (loc in [\"left\", \"right\", \"bottom\", \"top\"]):\n            if \"posOpts\" not in kwargs:\n                posOpts = {\n                    \"left\": [0.01, 0.25, 0.02, 0.5],\n                    \"right\": [0.88, 0.25, 0.02, 0.5],\n                    \"bottom\": [0.25, 0.15, 0.5, 0.02],\n                    \"top\": [0.25, 0.88, 0.5, 0.02],\n                }\n            else:\n                posOpts = {\n                    \"left\": kwargs[\"posOpts\"],\n                    \"right\": kwargs[\"posOpts\"],\n                    \"bottom\": kwargs[\"posOpts\"],\n                    \"top\": kwargs[\"posOpts\"],\n                }\n                del kwargs[\"posOpts\"]\n\n            cax = ax.figure.add_axes(posOpts[loc])\n\n            if loc == \"left\":\n                mpl.pyplot.subplots_adjust(left=0.18)\n            elif loc == \"right\":\n                mpl.pyplot.subplots_adjust(right=0.85)\n            else:\n                pass\n\n        else:\n            raise ValueError(\n                'provided loc not of type str. options are \"left\", '\n                '\"top\", \"right\", or \"bottom\"'\n            )\n\n    elif \"cax\" in kwargs:\n        cax = kwargs[\"cax\"]\n        kwargs = {key: kwargs[key] for key in kwargs.keys() if key != \"cax\"}\n\n    else:\n        raise ValueError(\"loc or cax keywords must be specified\")\n\n    vis_keys = list(vis_params.keys())\n    if vis_params:\n        if \"min\" in vis_params:\n            vmin = vis_params[\"min\"]\n            if type(vmin) not in (int, float):\n                raise ValueError(\"provided min value not of scalar type\")\n        else:\n            vmin = 0\n\n        if \"max\" in vis_params:\n            vmax = vis_params[\"max\"]\n            if type(vmax) not in (int, float):\n                raise ValueError(\"provided max value not of scalar type\")\n        else:\n            vmax = 1\n\n        if \"opacity\" in vis_params:\n            alpha = vis_params[\"opacity\"]\n            if type(alpha) not in (int, float):\n                raise ValueError(\"provided opacity value of not type scalar\")\n        elif \"alpha\" in kwargs:\n            alpha = kwargs[\"alpha\"]\n        else:\n            alpha = 1\n\n        if cmap is not None:\n            if discrete:\n                warnings.warn(\n                    'discrete keyword used when \"palette\" key is '\n                    \"supplied with visParams, creating a continuous \"\n                    \"colorbar...\"\n                )\n\n            cmap = mpl.pyplot.get_cmap(cmap)\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n        if \"palette\" in vis_keys:\n            hexcodes = vis_params[\"palette\"]\n            hexcodes = [i if i[0] == \"#\" else \"#\" + i for i in hexcodes]\n\n            if discrete:\n                cmap = mpl.colors.ListedColormap(hexcodes)\n                vals = np.linspace(vmin, vmax, cmap.N + 1)\n                norm = mpl.colors.BoundaryNorm(vals, cmap.N)\n\n            else:\n                cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                    \"custom\", hexcodes, N=256\n                )\n                norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n        elif cmap is not None:\n            if discrete:\n                warnings.warn(\n                    'discrete keyword used when \"palette\" key is '\n                    \"supplied with visParams, creating a continuous \"\n                    \"colorbar...\"\n                )\n\n            cmap = mpl.pyplot.get_cmap(cmap)\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n        else:\n            raise ValueError(\n                'cmap keyword or \"palette\" key in visParams must be provided'\n            )\n\n    tick_font_size = None\n    if \"tick_font_size\" in kwargs:\n        tick_font_size = kwargs.pop(\"tick_font_size\")\n\n    label_font_family = None\n    if \"label_font_family\" in kwargs:\n        label_font_family = kwargs.pop(\"label_font_family\")\n\n    label_font_size = None\n    if \"label_font_size\" in kwargs:\n        label_font_size = kwargs.pop(\"label_font_size\")\n\n    cb = mpl.colorbar.ColorbarBase(cax, norm=norm, alpha=alpha, cmap=cmap, **kwargs)\n\n    if label is not None:\n        if label_font_size is not None and label_font_family is not None:\n            cb.set_label(label, fontsize=label_font_size, family=label_font_family)\n        elif label_font_size is not None and label_font_family is None:\n            cb.set_label(label, fontsize=label_font_size)\n        elif label_font_size is None and label_font_family is not None:\n            cb.set_label(label, family=label_font_family)\n        else:\n            cb.set_label(label)\n    elif \"bands\" in vis_keys:\n        cb.set_label(vis_params[\"bands\"])\n\n    if tick_font_size is not None:\n        cb.ax.tick_params(labelsize=tick_font_size)\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.add_gridlines","title":"<code>add_gridlines(ax, interval=None, n_ticks=None, xs=None, ys=None, buffer_out=True, xtick_rotation='horizontal', ytick_rotation='horizontal', **kwargs)</code>","text":"<p>Helper function to add gridlines and format ticks to map</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes</code> <p>required cartopy GeoAxesSubplot object to add the gridlines to</p> required <code>interval</code> <code>float | list[float]</code> <p>float specifying an interval at which to create gridlines, units are decimal degrees. lists will be interpreted a [x_interval, y_interval]. default = None</p> <code>None</code> <code>n_ticks</code> <code>int | list[int]</code> <p>integer specifying number gridlines to create within map extent. lists will be interpreted a [nx, ny]. default = None</p> <code>None</code> <code>xs</code> <code>list</code> <p>list of x coordinates to create gridlines. default = None</p> <code>None</code> <code>ys</code> <code>list</code> <p>list of y coordinates to create gridlines. default = None</p> <code>None</code> <code>buffer_out</code> <code>boolean</code> <p>boolean option to buffer out the extent to insure coordinates created cover map extent. default=true</p> <code>True</code> <code>xtick_rotation</code> <code>str | float</code> <code>'horizontal'</code> <code>ytick_rotation</code> <code>str | float</code> <code>'horizontal'</code> <code>**kwargs</code> <p>remaining keyword arguments are passed to gridlines()</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if all interval, n_ticks, or (xs,ys) are set to None</p> Source code in <code>geemap/cartoee.py</code> <pre><code>def add_gridlines(\n    ax,\n    interval=None,\n    n_ticks=None,\n    xs=None,\n    ys=None,\n    buffer_out=True,\n    xtick_rotation=\"horizontal\",\n    ytick_rotation=\"horizontal\",\n    **kwargs,\n):\n\"\"\"Helper function to add gridlines and format ticks to map\n\n    args:\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to add the gridlines to\n        interval (float | list[float], optional): float specifying an interval at which to create gridlines, units are decimal degrees. lists will be interpreted a [x_interval, y_interval]. default = None\n        n_ticks (int | list[int], optional): integer specifying number gridlines to create within map extent. lists will be interpreted a [nx, ny]. default = None\n        xs (list, optional): list of x coordinates to create gridlines. default = None\n        ys (list, optional): list of y coordinates to create gridlines. default = None\n        buffer_out (boolean, optional): boolean option to buffer out the extent to insure coordinates created cover map extent. default=true\n        xtick_rotation (str | float, optional):\n        ytick_rotation (str | float, optional):\n        **kwargs: remaining keyword arguments are passed to gridlines()\n\n    raises:\n        ValueError: if all interval, n_ticks, or (xs,ys) are set to None\n\n    \"\"\"\n\n    view_extent = ax.get_extent()\n    extent = view_extent\n\n    if xs is not None:\n        xmain = xs\n\n    elif interval is not None:\n        if isinstance(interval, Iterable):\n            xspace = interval[0]\n        else:\n            xspace = interval\n\n        if buffer_out:\n            extent = _buffer_box(extent, xspace)\n\n        xmain = np.arange(extent[0], extent[1] + xspace, xspace)\n\n    elif n_ticks is not None:\n        if isinstance(n_ticks, Iterable):\n            n_x = n_ticks[0]\n        else:\n            n_x = n_ticks\n\n        xmain = np.linspace(extent[0], extent[1], n_x)\n    else:\n        raise ValueError(\n            \"one of variables interval, n_ticks, or xs must be defined. If you would like default gridlines, please use `ax.gridlines()`\"\n        )\n\n    if ys is not None:\n        ymain = ys\n\n    elif interval is not None:\n        if isinstance(interval, Iterable):\n            yspace = interval[1]\n        else:\n            yspace = interval\n\n        if buffer_out:\n            extent = _buffer_box(extent, yspace)\n\n        ymain = np.arange(extent[2], extent[3] + yspace, yspace)\n\n    elif n_ticks is not None:\n        if isinstance(n_ticks, Iterable):\n            n_y = n_ticks[1]\n        else:\n            n_y = n_ticks\n\n        ymain = np.linspace(extent[2], extent[3], n_y)\n\n    else:\n        raise ValueError(\n            \"one of variables interval, n_ticks, or ys must be defined. If you would like default gridlines, please use `ax.gridlines()`\"\n        )\n\n    ax.gridlines(xlocs=xmain, ylocs=ymain, **kwargs)\n\n    xin = xmain[(xmain &gt;= view_extent[0]) &amp; (xmain &lt;= view_extent[1])]\n    yin = ymain[(ymain &gt;= view_extent[2]) &amp; (ymain &lt;= view_extent[3])]\n\n    # set tick labels\n    ax.set_xticks(xin, crs=ccrs.PlateCarree())\n    ax.set_yticks(yin, crs=ccrs.PlateCarree())\n\n    ax.set_xticklabels(xin, rotation=xtick_rotation, ha=\"center\")\n    ax.set_yticklabels(yin, rotation=ytick_rotation, va=\"center\")\n\n    ax.xaxis.set_major_formatter(LONGITUDE_FORMATTER)\n    ax.yaxis.set_major_formatter(LATITUDE_FORMATTER)\n\n    return\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.add_layer","title":"<code>add_layer(ax, ee_object, dims=1000, region=None, cmap=None, vis_params=None, **kwargs)</code>","text":"<p>Add an Earth Engine image to a cartopy plot.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.Image | ee.FeatureCollection</code> <p>Earth Engine image result to plot.</p> required <code>ax</code> <code>cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes</code> <p>required cartopy GeoAxesSubplot object to add image overlay to</p> required <code>dims</code> <code>list | tuple | int</code> <p>dimensions to request earth engine result as [WIDTH,HEIGHT]. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Default None and infers dimensions</p> <code>1000</code> <code>region</code> <code>list | tuple</code> <p>geospatial region of the image to render in format [E,S,W,N]. By default, the whole image</p> <code>None</code> <code>cmap</code> <code>str</code> <p>string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options</p> <code>None</code> <p>Returns:</p> Type Description <code>ax (cartopy.mpl.geoaxes.GeoAxesSubplot)</code> <p>cartopy GeoAxesSubplot object with Earth Engine results displayed</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If <code>dims</code> is not of type list, tuple, or int</p> <code>ValueError</code> <p>If <code>imgObj</code> is not of type ee.image.Image</p> <code>ValueError</code> <p>If <code>ax</code> if not of type cartopy.mpl.geoaxes.GeoAxesSubplot '</p> Source code in <code>geemap/cartoee.py</code> <pre><code>def add_layer(\n    ax, ee_object, dims=1000, region=None, cmap=None, vis_params=None, **kwargs\n):\n\"\"\"Add an Earth Engine image to a cartopy plot.\n\n    args:\n        ee_object (ee.Image | ee.FeatureCollection): Earth Engine image result to plot.\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to add image overlay to\n        dims (list | tuple | int, optional): dimensions to request earth engine result as [WIDTH,HEIGHT]. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Default None and infers dimensions\n        region (list | tuple, optional): geospatial region of the image to render in format [E,S,W,N]. By default, the whole image\n        cmap (str, optional): string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key\n        vis_params (dict, optional): visualization parameters as a dictionary. See https://developers.google.com/earth-engine/image_visualization for options\n\n    returns:\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot): cartopy GeoAxesSubplot object with Earth Engine results displayed\n\n    raises:\n        ValueError: If `dims` is not of type list, tuple, or int\n        ValueError: If `imgObj` is not of type ee.image.Image\n        ValueError: If `ax` if not of type cartopy.mpl.geoaxes.GeoAxesSubplot '\n    \"\"\"\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        if \"style\" in kwargs and kwargs[\"style\"] is not None:\n            style = kwargs[\"style\"]\n        else:\n            style = {}\n\n        props = features.first().propertyNames().getInfo()\n        if \"style\" in props:\n            ee_object = features.style(**{\"styleProperty\": \"style\"})\n        else:\n            ee_object = features.style(**style)\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        ee_object = ee_object.mosaic()\n\n    if type(ee_object) is not ee.image.Image:\n        raise ValueError(\"provided `ee_object` is not of type ee.Image\")\n\n    if region is not None:\n        map_region = ee.Geometry.Rectangle(region).getInfo()[\"coordinates\"]\n        view_extent = (region[2], region[0], region[1], region[3])\n    else:\n        map_region = ee_object.geometry(100).bounds(1).getInfo()[\"coordinates\"]\n        # get the image bounds\n        x, y = list(zip(*map_region[0]))\n        view_extent = [min(x), max(x), min(y), max(y)]\n\n        if ee_object.bandNames().getInfo() == [\"vis-red\", \"vis-green\", \"vis-blue\"]:\n            warnings.warn(\n                f\"The region parameter is not specified. Using the default region {map_region}. Please specify a region if you get a blank image.\"\n            )\n\n    if type(dims) not in [list, tuple, int]:\n        raise ValueError(\"provided dims not of type list, tuple, or int\")\n\n    if type(ax) not in [GeoAxes, GeoAxesSubplot]:\n        raise ValueError(\n            \"provided axes not of type cartopy.mpl.geoaxes.GeoAxes \"\n            \"or cartopy.mpl.geoaxes.GeoAxesSubplot\"\n        )\n\n    args = {\"format\": \"png\", \"crs\": \"EPSG:4326\"}\n    args[\"region\"] = map_region\n    if dims:\n        args[\"dimensions\"] = dims\n\n    if vis_params:\n        keys = list(vis_params.keys())\n        if cmap and (\"palette\" in keys):\n            raise KeyError(\n                \"cannot provide `palette` in vis_params if `cmap` is specified\"\n            )\n        elif cmap:\n            args[\"palette\"] = \",\".join(build_palette(cmap))\n        else:\n            pass\n\n        args = {**args, **vis_params}\n\n    url = ee_object.getThumbUrl(args)\n    response = requests.get(url)\n    if response.status_code != 200:\n        error = eval(response.content)[\"error\"]\n        raise requests.exceptions.HTTPError(f\"{error}\")\n\n    image = np.array(Image.open(BytesIO(response.content)))\n\n    if image.shape[-1] == 2:\n        image = np.concatenate(\n            [np.repeat(image[:, :, 0:1], 3, axis=2), image[:, :, -1:]], axis=2\n        )\n\n    ax.imshow(\n        np.squeeze(image),\n        extent=view_extent,\n        origin=\"upper\",\n        transform=ccrs.PlateCarree(),\n        zorder=1,\n    )\n\n    return\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.add_legend","title":"<code>add_legend(ax, legend_elements=None, loc='lower right', font_size=14, font_weight='normal', font_color='black', font_family=None, title=None, title_fontize=16, title_fontproperties=None, **kwargs)</code>","text":"<p>Adds a legend to the map. The legend elements can be formatted as: legend_elements = [Line2D([], [], color='#00ffff', lw=2, label='Coastline'),     Line2D([], [], marker='o', color='#A8321D', label='City', markerfacecolor='#A8321D', markersize=10, ls ='')]     For more legend properties, see: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.legend.html</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes</code> <p>required cartopy GeoAxesSubplot object.</p> required <code>legend_elements</code> <code>list</code> <p>A list of legend elements. Defaults to None.</p> <code>None</code> <code>loc</code> <code>str</code> <p>Location of the legend, can be any of ['upper left', 'upper right', 'lower left', 'lower right']. Defaults to \"lower right\".</p> <code>'lower right'</code> <code>font_size(int|string,</code> <code>optional</code> <p>Font size. Either an absolute font size or an relative value of 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'. defaults to 14.</p> required <code>font_weight(string|int,</code> <code>optional</code> <p>Font weight. A numeric value in the range 0-1000 or one of 'ultralight', 'light', 'normal' (default), 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black'. Defaults to 'normal'.</p> required <code>font_color(str,</code> <code>optional</code> <p>Text color. Defaults to \"black\".</p> required <code>font_family(string,</code> <code>optional</code> <p>Name of font family. Set to a font family like 'SimHei' if you want to show Chinese in the legend. Defaults to None.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>If the legend fails to add.</p> Source code in <code>geemap/cartoee.py</code> <pre><code>def add_legend(\n    ax,\n    legend_elements=None,\n    loc=\"lower right\",\n    font_size=14,\n    font_weight=\"normal\",\n    font_color=\"black\",\n    font_family=None,\n    title=None,\n    title_fontize=16,\n    title_fontproperties=None,\n    **kwargs,\n):\n\"\"\"Adds a legend to the map. The legend elements can be formatted as:\n    legend_elements = [Line2D([], [], color='#00ffff', lw=2, label='Coastline'),\n        Line2D([], [], marker='o', color='#A8321D', label='City', markerfacecolor='#A8321D', markersize=10, ls ='')]\n        For more legend properties, see: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.legend.html\n\n    Args:\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object.\n        legend_elements (list, optional): A list of legend elements. Defaults to None.\n        loc (str, optional): Location of the legend, can be any of ['upper left', 'upper right', 'lower left', 'lower right']. Defaults to \"lower right\".\n        font_size(int|string, optional): Font size. Either an absolute font size or an relative value of 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'. defaults to 14.\n        font_weight(string|int, optional): Font weight. A numeric value in the range 0-1000 or one of 'ultralight', 'light', 'normal' (default), 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black'. Defaults to 'normal'.\n        font_color(str, optional): Text color. Defaults to \"black\".\n        font_family(string, optional): Name of font family. Set to a font family like 'SimHei' if you want to show Chinese in the legend. Defaults to None.\n    Raises:\n        Exception: If the legend fails to add.\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    if title_fontize is not None and (title_fontproperties is not None):\n        raise ValueError(\"title_fontize and title_fontproperties cannot be both set.\")\n    elif title_fontize is not None:\n        kwargs[\"title_fontsize\"] = title_fontize\n    elif title_fontproperties is not None:\n        kwargs[\"title_fontproperties\"] = title_fontproperties\n\n    try:\n        if legend_elements is None:\n            legend_elements = [\n                Line2D([], [], color=\"#00ffff\", lw=2, label=\"Coastline\"),\n                Line2D(\n                    [],\n                    [],\n                    marker=\"o\",\n                    color=\"#A8321D\",\n                    label=\"City\",\n                    markerfacecolor=\"#A8321D\",\n                    markersize=10,\n                    ls=\"\",\n                ),\n            ]\n        if font_family is not None:\n            fontdict = {\"family\": font_family, \"size\": font_size, \"weight\": font_weight}\n        else:\n            fontdict = {\"size\": font_size, \"weight\": font_weight}\n        leg = ax.legend(\n            handles=legend_elements,\n            loc=loc,\n            prop=fontdict,\n            title=title,\n            **kwargs,\n        )\n\n        # Change font color If default color is changed.\n        if font_color != \"black\":\n            for text in leg.get_texts():\n                text.set_color(font_color)\n        return\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.add_north_arrow","title":"<code>add_north_arrow(ax, text='N', xy=(0.1, 0.1), arrow_length=0.1, text_color='black', arrow_color='black', fontsize=20, width=5, headwidth=15, ha='center', va='center')</code>","text":"<p>Add a north arrow to the map.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes</code> <p>required cartopy GeoAxesSubplot object.</p> required <code>text</code> <code>str</code> <p>Text for north arrow. Defaults to \"N\".</p> <code>'N'</code> <code>xy</code> <code>tuple</code> <p>Location of the north arrow. Each number representing the percentage length of the map from the lower-left cornor. Defaults to (0.1, 0.1).</p> <code>(0.1, 0.1)</code> <code>arrow_length</code> <code>float</code> <p>Length of the north arrow. Defaults to 0.1 (10% length of the map).</p> <code>0.1</code> <code>text_color</code> <code>str</code> <p>Text color. Defaults to \"black\".</p> <code>'black'</code> <code>arrow_color</code> <code>str</code> <p>North arrow color. Defaults to \"black\".</p> <code>'black'</code> <code>fontsize</code> <code>int</code> <p>Text font size. Defaults to 20.</p> <code>20</code> <code>width</code> <code>int</code> <p>Width of the north arrow. Defaults to 5.</p> <code>5</code> <code>headwidth</code> <code>int</code> <p>head width of the north arrow. Defaults to 15.</p> <code>15</code> <code>ha</code> <code>str</code> <p>Horizontal alignment. Defaults to \"center\".</p> <code>'center'</code> <code>va</code> <code>str</code> <p>Vertical alignment. Defaults to \"center\".</p> <code>'center'</code> Source code in <code>geemap/cartoee.py</code> <pre><code>def add_north_arrow(\n    ax,\n    text=\"N\",\n    xy=(0.1, 0.1),\n    arrow_length=0.1,\n    text_color=\"black\",\n    arrow_color=\"black\",\n    fontsize=20,\n    width=5,\n    headwidth=15,\n    ha=\"center\",\n    va=\"center\",\n):\n\"\"\"Add a north arrow to the map.\n\n    Args:\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object.\n        text (str, optional): Text for north arrow. Defaults to \"N\".\n        xy (tuple, optional): Location of the north arrow. Each number representing the percentage length of the map from the lower-left cornor. Defaults to (0.1, 0.1).\n        arrow_length (float, optional): Length of the north arrow. Defaults to 0.1 (10% length of the map).\n        text_color (str, optional): Text color. Defaults to \"black\".\n        arrow_color (str, optional): North arrow color. Defaults to \"black\".\n        fontsize (int, optional): Text font size. Defaults to 20.\n        width (int, optional): Width of the north arrow. Defaults to 5.\n        headwidth (int, optional): head width of the north arrow. Defaults to 15.\n        ha (str, optional): Horizontal alignment. Defaults to \"center\".\n        va (str, optional): Vertical alignment. Defaults to \"center\".\n    \"\"\"\n    ax.annotate(\n        text,\n        xy=xy,\n        xytext=(xy[0], xy[1] - arrow_length),\n        color=text_color,\n        arrowprops=dict(facecolor=arrow_color, width=width, headwidth=headwidth),\n        ha=ha,\n        va=va,\n        fontsize=fontsize,\n        xycoords=ax.transAxes,\n    )\n\n    return\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.add_scale_bar","title":"<code>add_scale_bar(ax, metric_distance=4, unit='km', at_x=(0.05, 0.5), at_y=(0.08, 0.11), max_stripes=5, ytick_label_margins=0.25, fontsize=8, font_weight='bold', rotation=0, zorder=999, paddings={'xmin': 0.05, 'xmax': 0.05, 'ymin': 1.5, 'ymax': 0.5}, bbox_kwargs={'facecolor': 'white', 'edgecolor': 'black', 'alpha': 0.5})</code>","text":"<p>Add a scale bar to the map.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes</code> <p>required cartopy GeoAxesSubplot object.</p> required <code>metric_distance</code> <code>int | float</code> <p>length in meters of each region of the scale bar. Default to 4.</p> <code>4</code> <code>unit</code> <code>str</code> <p>scale bar distance unit. Default to \"km\"</p> <code>'km'</code> <code>at_x</code> <code>float</code> <p>target axes X coordinates (0..1) of box (= left, right). Default to (0.05, 0.2).</p> <code>(0.05, 0.5)</code> <code>at_y</code> <code>float</code> <p>axes Y coordinates (0..1) of box (= lower, upper). Default to (0.08, 0.11).</p> <code>(0.08, 0.11)</code> <code>max_stripes</code> <code>int</code> <p>typical/maximum number of black+white regions. Default to 5.</p> <code>5</code> <code>ytick_label_margins</code> <code>float</code> <p>Location of distance labels on the Y axis. Default to 0.25.</p> <code>0.25</code> <code>fontsize</code> <code>int</code> <p>scale bar text size. Default to 8.</p> <code>8</code> <code>font_weight</code> <code>str</code> <p>font weight. Default to 'bold'.</p> <code>'bold'</code> <code>rotation</code> <code>int</code> <p>rotation of the length labels for each region of the scale bar. Default to 0.</p> <code>0</code> <code>zorder</code> <code>float</code> <p>z order of the text bounding box.</p> <code>999</code> <code>paddings</code> <code>dict</code> <p>boundaries of the box that contains the scale bar.</p> <code>{'xmin': 0.05, 'xmax': 0.05, 'ymin': 1.5, 'ymax': 0.5}</code> <code>bbox_kwargs</code> <code>dict</code> <p>style of the box containing the scale bar.</p> <code>{'facecolor': 'white', 'edgecolor': 'black', 'alpha': 0.5}</code> Source code in <code>geemap/cartoee.py</code> <pre><code>def add_scale_bar(\n    ax,\n    metric_distance=4,\n    unit=\"km\",\n    at_x=(0.05, 0.5),\n    at_y=(0.08, 0.11),\n    max_stripes=5,\n    ytick_label_margins=0.25,\n    fontsize=8,\n    font_weight=\"bold\",\n    rotation=0,\n    zorder=999,\n    paddings={\"xmin\": 0.05, \"xmax\": 0.05, \"ymin\": 1.5, \"ymax\": 0.5},\n    bbox_kwargs={\"facecolor\": \"white\", \"edgecolor\": \"black\", \"alpha\": 0.5},\n):\n\"\"\"\n    Add a scale bar to the map.\n\n    Args:\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object.\n        metric_distance (int | float, optional): length in meters of each region of the scale bar. Default to 4.\n        unit (str, optional): scale bar distance unit. Default to \"km\"\n        at_x (float, optional): target axes X coordinates (0..1) of box (= left, right). Default to (0.05, 0.2).\n        at_y (float, optional): axes Y coordinates (0..1) of box (= lower, upper). Default to (0.08, 0.11).\n        max_stripes (int, optional): typical/maximum number of black+white regions. Default to 5.\n        ytick_label_margins (float, optional): Location of distance labels on the Y axis. Default to 0.25.\n        fontsize (int, optional): scale bar text size. Default to 8.\n        font_weight (str, optional):font weight. Default to 'bold'.\n        rotation (int, optional): rotation of the length labels for each region of the scale bar. Default to 0.\n        zorder (float, optional): z order of the text bounding box.\n        paddings (dict, optional): boundaries of the box that contains the scale bar.\n        bbox_kwargs (dict, optional): style of the box containing the scale bar.\n\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    # --------------------------------------------------------------------------\n    # Auxiliary functions\n\n    def _crs_coord_project(crs_target, xcoords, ycoords, crs_source):\n\"\"\"metric coordinates (x, y) from cartopy.crs_source\"\"\"\n\n        axes_coords = crs_target.transform_points(crs_source, xcoords, ycoords)\n\n        return axes_coords\n\n    def _add_bbox(ax, list_of_patches, paddings={}, bbox_kwargs={}):\n\"\"\"\n        Description:\n            This helper function adds a box behind the scalebar:\n                Code inspired by: https://stackoverflow.com/questions/17086847/box-around-text-in-matplotlib\n\n        \"\"\"\n\n        zorder = list_of_patches[0].get_zorder() - 1\n\n        xmin = min([t.get_window_extent().xmin for t in list_of_patches])\n        xmax = max([t.get_window_extent().xmax for t in list_of_patches])\n        ymin = min([t.get_window_extent().ymin for t in list_of_patches])\n        ymax = max([t.get_window_extent().ymax for t in list_of_patches])\n\n        xmin, ymin = ax.transData.inverted().transform((xmin, ymin))\n        xmax, ymax = ax.transData.inverted().transform((xmax, ymax))\n\n        xmin = xmin - ((xmax - xmin) * paddings[\"xmin\"])\n        ymin = ymin - ((ymax - ymin) * paddings[\"ymin\"])\n\n        xmax = xmax + ((xmax - xmin) * paddings[\"xmax\"])\n        ymax = ymax + ((ymax - ymin) * paddings[\"ymax\"])\n\n        width = xmax - xmin\n        height = ymax - ymin\n\n        # Setting xmin according to height\n        rect = patches.Rectangle(\n            (xmin, ymin),\n            width,\n            height,\n            facecolor=bbox_kwargs[\"facecolor\"],\n            edgecolor=bbox_kwargs[\"edgecolor\"],\n            alpha=bbox_kwargs[\"alpha\"],\n            transform=ax.projection,\n            fill=True,\n            clip_on=False,\n            zorder=zorder,\n        )\n\n        ax.add_patch(rect)\n        return ax\n\n    # --------------------------------------------------------------------------\n\n    old_proj = ax.projection\n    ax.projection = ccrs.PlateCarree()\n\n    # Set a planar (metric) projection for the centroid of a given axes projection:\n    # First get centroid lon and lat coordinates:\n\n    lon_0, lon_1, lat_0, lat_1 = ax.get_extent(ax.projection.as_geodetic())\n\n    central_lon = np.mean([lon_0, lon_1])\n    central_lat = np.mean([lat_0, lat_1])\n\n    # Second: set the planar (metric) projection centered in the centroid of the axes;\n    # Centroid coordinates must be in lon/lat.\n    proj = ccrs.EquidistantConic(\n        central_longitude=central_lon, central_latitude=central_lat\n    )\n\n    # fetch axes coordinates in meters\n    x0, _, y0, y1 = ax.get_extent(proj)\n    ymean = np.mean([y0, y1])\n\n    # set target rectangle in-visible-area (aka 'Axes') coordinates\n    axfrac_ini, _ = at_x\n    ayfrac_ini, ayfrac_final = at_y\n\n    # choose exact X points as sensible grid ticks with Axis 'ticker' helper\n    converted_metric_distance = convert_SI(metric_distance, unit, \"m\")\n\n    xcoords = []\n    ycoords = []\n    xlabels = []\n    for i in range(0, 1 + max_stripes):\n        dx = (converted_metric_distance * i) + x0\n        xlabels.append(metric_distance * i)\n        xcoords.append(dx)\n        ycoords.append(ymean)\n\n    # Convertin to arrays:\n    xcoords = np.asanyarray(xcoords)\n    ycoords = np.asanyarray(ycoords)\n\n    # Ensuring that the coordinate projection is in degrees:\n    x_targets, _, _ = _crs_coord_project(ax.projection, xcoords, ycoords, proj).T\n    x_targets = [x + (axfrac_ini * (lon_1 - lon_0)) for x in x_targets]\n\n    # Checking x_ticks in axes projection coordinates\n    # print('x_targets', x_targets)\n\n    # Setting transform for plotting\n    transform = ax.projection\n\n    # grab min+max for limits\n    xl0, xl1 = x_targets[0], x_targets[-1]\n\n    # calculate Axes Y coordinates of box top+bottom\n    yl0, yl1 = [\n        lat_0 + ay_frac * (lat_1 - lat_0) for ay_frac in [ayfrac_ini, ayfrac_final]\n    ]\n\n    # calculate Axes Y distance of ticks + label margins\n    y_margin = (yl1 - yl0) * ytick_label_margins\n\n    # fill black/white 'stripes' and draw their boundaries\n    fill_colors = [\"black\", \"white\"]\n    i_color = 0\n\n    filled_boxs = []\n    for xi0, xi1 in zip(x_targets[:-1], x_targets[1:]):\n        # fill region\n        filled_box = plt.fill(\n            (xi0, xi1, xi1, xi0, xi0),\n            (yl0, yl0, yl1, yl1, yl0),\n            fill_colors[i_color],\n            transform=transform,\n            clip_on=False,\n            zorder=zorder,\n        )\n\n        filled_boxs.append(filled_box[0])\n\n        # draw boundary\n        plt.plot(\n            (xi0, xi1, xi1, xi0, xi0),\n            (yl0, yl0, yl1, yl1, yl0),\n            \"black\",\n            clip_on=False,\n            transform=transform,\n            zorder=zorder,\n        )\n\n        i_color = 1 - i_color\n\n    # adding boxes\n    _add_bbox(ax, filled_boxs, bbox_kwargs=bbox_kwargs, paddings=paddings)\n\n    # add short tick lines\n    for x in x_targets:\n        plt.plot(\n            (x, x),\n            (yl0, yl0 - y_margin),\n            \"black\",\n            transform=transform,\n            zorder=zorder,\n            clip_on=False,\n        )\n\n    # add a scale legend unit\n    font_props = mfonts.FontProperties(size=fontsize, weight=font_weight)\n\n    plt.text(\n        0.5 * (xl0 + xl1),\n        yl1 + y_margin,\n        unit,\n        color=\"black\",\n        verticalalignment=\"bottom\",\n        horizontalalignment=\"center\",\n        fontproperties=font_props,\n        transform=transform,\n        clip_on=False,\n        zorder=zorder,\n    )\n\n    # add numeric labels\n    for x, xlabel in zip(x_targets, xlabels):\n        # print(\"Label set in: \", x, yl0 - 2 * y_margin)\n        plt.text(\n            x,\n            yl0 - 2 * y_margin,\n            \"{:g}\".format((xlabel)),\n            verticalalignment=\"top\",\n            horizontalalignment=\"center\",\n            fontproperties=font_props,\n            transform=transform,\n            rotation=rotation,\n            clip_on=False,\n            zorder=zorder + 1,\n            # bbox=dict(facecolor='red', alpha=0.5) # this would add a box only around the xticks\n        )\n\n    # Adjusting figure borders to ensure that the scalebar is within its limits\n    ax.projection = old_proj\n    ax.get_figure().canvas.draw()\n    # fig.tight_layout()\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.add_scale_bar_lite","title":"<code>add_scale_bar_lite(ax, length=None, xy=(0.5, 0.05), linewidth=3, fontsize=20, color='black', unit='km', ha='center', va='bottom')</code>","text":"<p>Add a lite version of scale bar to the map. Reference: https://stackoverflow.com/a/50674451/2676166</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes</code> <p>required cartopy GeoAxesSubplot object.</p> required <code>length</code> <code>[type]</code> <p>Length of the scale car. Defaults to None.</p> <code>None</code> <code>xy</code> <code>tuple</code> <p>Location of the north arrow. Each number representing the percentage length of the map from the lower-left cornor. Defaults to (0.1, 0.1).</p> <code>(0.5, 0.05)</code> <code>linewidth</code> <code>int</code> <p>Line width of the scale bar. Defaults to 3.</p> <code>3</code> <code>fontsize</code> <code>int</code> <p>Text font size. Defaults to 20.</p> <code>20</code> <code>color</code> <code>str</code> <p>Color for the scale bar. Defaults to \"black\".</p> <code>'black'</code> <code>unit</code> <code>str</code> <p>Length unit for the scale bar. Defaults to \"km\".</p> <code>'km'</code> <code>ha</code> <code>str</code> <p>Horizontal alignment. Defaults to \"center\".</p> <code>'center'</code> <code>va</code> <code>str</code> <p>Vertical alignment. Defaults to \"bottom\".</p> <code>'bottom'</code> Source code in <code>geemap/cartoee.py</code> <pre><code>def add_scale_bar_lite(\n    ax,\n    length=None,\n    xy=(0.5, 0.05),\n    linewidth=3,\n    fontsize=20,\n    color=\"black\",\n    unit=\"km\",\n    ha=\"center\",\n    va=\"bottom\",\n):\n\"\"\"Add a lite version of scale bar to the map. Reference: https://stackoverflow.com/a/50674451/2676166\n\n    Args:\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object.\n        length ([type], optional): Length of the scale car. Defaults to None.\n        xy (tuple, optional): Location of the north arrow. Each number representing the percentage length of the map from the lower-left cornor. Defaults to (0.1, 0.1).\n        linewidth (int, optional): Line width of the scale bar. Defaults to 3.\n        fontsize (int, optional): Text font size. Defaults to 20.\n        color (str, optional): Color for the scale bar. Defaults to \"black\".\n        unit (str, optional): Length unit for the scale bar. Defaults to \"km\".\n        ha (str, optional): Horizontal alignment. Defaults to \"center\".\n        va (str, optional): Vertical alignment. Defaults to \"bottom\".\n\n    \"\"\"\n\n    allow_units = [\"cm\", \"m\", \"km\", \"inch\", \"foot\", \"mile\"]\n    if unit not in allow_units:\n        print(\n            \"The unit must be one of the following: {}\".format(\", \".join(allow_units))\n        )\n        return\n\n    num = length\n\n    # Get the limits of the axis in lat long\n    llx0, llx1, lly0, lly1 = ax.get_extent(ccrs.PlateCarree())\n    # Make tmc horizontally centred on the middle of the map,\n    # vertically at scale bar location\n    sbllx = (llx1 + llx0) / 2\n    sblly = lly0 + (lly1 - lly0) * xy[1]\n    tmc = ccrs.TransverseMercator(sbllx, sblly, approx=True)\n    # Get the extent of the plotted area in coordinates in metres\n    x0, x1, y0, y1 = ax.get_extent(tmc)\n    # Turn the specified scalebar location into coordinates in metres\n    sbx = x0 + (x1 - x0) * xy[0]\n    sby = y0 + (y1 - y0) * xy[1]\n\n    # Calculate a scale bar length if none has been given\n    # (There's probably a more pythonic way of rounding the number but this works)\n    if not length:\n        length = (x1 - x0) / 5000  # in km\n        ndim = int(np.floor(np.log10(length)))  # number of digits in number\n        length = round(length, -ndim)  # round to 1sf\n        # Returns numbers starting with the list\n\n        def scale_number(x):\n            if str(x)[0] in [\"1\", \"2\", \"5\"]:\n                return int(x)\n            else:\n                return scale_number(x - 10**ndim)\n\n        length = scale_number(length)\n        num = length\n    else:\n        length = convert_SI(length, unit, \"km\")\n\n    # Generate the x coordinate for the ends of the scalebar\n    bar_xs = [sbx - length * 500, sbx + length * 500]\n    # Plot the scalebar\n    ax.plot(bar_xs, [sby, sby], transform=tmc, color=color, linewidth=linewidth)\n    # Plot the scalebar label\n    ax.text(\n        sbx,\n        sby,\n        str(num) + \" \" + unit,\n        transform=tmc,\n        horizontalalignment=ha,\n        verticalalignment=va,\n        color=color,\n        fontsize=fontsize,\n    )\n\n    return\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.bbox_to_extent","title":"<code>bbox_to_extent(bbox)</code>","text":"<p>Helper function to reorder a list of coordinates from [W,S,E,N] to [W,E,S,N]</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list[float]</code> <p>list (or tuple) or coordinates in the order of [W,S,E,N]</p> required <p>Returns:</p> Type Description <code>extent (tuple[float])</code> <p>tuple of coordinates in the order of [W,E,S,N]</p> Source code in <code>geemap/cartoee.py</code> <pre><code>def bbox_to_extent(bbox):\n\"\"\"Helper function to reorder a list of coordinates from [W,S,E,N] to [W,E,S,N]\n\n    args:\n        bbox (list[float]): list (or tuple) or coordinates in the order of [W,S,E,N]\n\n    returns:\n        extent (tuple[float]): tuple of coordinates in the order of [W,E,S,N]\n    \"\"\"\n    return (bbox[0], bbox[2], bbox[1], bbox[3])\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.build_palette","title":"<code>build_palette(cmap, n=256)</code>","text":"<p>Creates hex color code palette from a matplotlib colormap</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str</code> <p>string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key</p> required <code>n</code> <code>int</code> <p>Number of hex color codes to create from colormap. Default is 256</p> <code>256</code> <p>Returns:</p> Type Description <code>palette (list[str])</code> <p>list of hex color codes from matplotlib colormap for n intervals</p> Source code in <code>geemap/cartoee.py</code> <pre><code>def build_palette(cmap, n=256):\n\"\"\"Creates hex color code palette from a matplotlib colormap\n\n    args:\n        cmap (str): string specifying matplotlib colormap to colorize image. If cmap is specified visParams cannot contain 'palette' key\n        n (int, optional): Number of hex color codes to create from colormap. Default is 256\n\n    returns:\n        palette (list[str]): list of hex color codes from matplotlib colormap for n intervals\n    \"\"\"\n\n    colormap = cm.get_cmap(cmap, n)\n    vals = np.linspace(0, 1, n)\n    palette = list(map(lambda x: colors.rgb2hex(colormap(x)[:3]), vals))\n\n    return palette\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.check_dependencies","title":"<code>check_dependencies()</code>","text":"<p>Helper function to check dependencies used for cartoee Dependencies not included in main geemap are: cartopy, PIL, and scipys</p> <p>Exceptions:</p> Type Description <code>Exception</code> <p>when conda is not found in path</p> <code>Exception</code> <p>when auto install fails to install/import packages</p> Source code in <code>geemap/cartoee.py</code> <pre><code>def check_dependencies():\n\"\"\"Helper function to check dependencies used for cartoee\n    Dependencies not included in main geemap are: cartopy, PIL, and scipys\n\n    raises:\n        Exception: when conda is not found in path\n        Exception: when auto install fails to install/import packages\n    \"\"\"\n\n    import importlib\n\n    # check if conda in in path and available to use\n    is_conda = os.path.exists(os.path.join(sys.prefix, \"conda-meta\"))\n\n    # raise error if conda not found\n    if not is_conda:\n        raise Exception(\n            \"Auto installation requires `conda`. Please install conda using the following instructions before use: https://docs.conda.io/projects/conda/en/latest/user-guide/install/\"\n        )\n\n    # list of dependencies to check, ordered in decreasing complexity\n    # i.e. cartopy install should install PIL\n    dependencies = [\"cartopy\", \"pillow\", \"scipy\"]\n\n    # loop through dependency list and check if we can import module\n    # if not try to install\n    # install fail will be silent to continue through others if there is a failure\n    # correct install will be checked later\n    for dependency in dependencies:\n        try:\n            # see if we can import\n            importlib.import_module(dependency)\n        except ImportError:\n            # change the dependency name if it is PIL\n            # import vs install names are different for PIL...\n            # dependency = dependency if dependency is not \"PIL\" else \"pillow\"\n\n            # print info if not installed\n            logging.info(\n                f\"The {dependency} package is not installed. Trying install...\"\n            )\n\n            logging.info(f\"Installing {dependency} ...\")\n\n            # run the command\n            cmd = f\"conda install -c conda-forge {dependency} -y\"\n            proc = subprocess.Popen(\n                cmd,\n                shell=True,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n            )\n            # send command\n            out, _ = proc.communicate()\n\n            logging.info(out.decode())\n\n    # second pass through dependencies to check if everything was installed correctly\n    failed = []\n\n    for dependency in dependencies:\n        try:\n            importlib.import_module(dependency)\n        except ImportError:\n            # append failed imports\n            failed.append(dependency)\n\n    # check if there were any failed imports after trying install\n    if len(failed) &gt; 0:\n        failed_str = \",\".join(failed)\n        raise Exception(\n            f\"Auto installation failed...the following dependencies were not installed '{failed_str}'\"\n        )\n    else:\n        logging.info(\"All dependencies are successfully imported/installed!\")\n\n    return\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.convert_SI","title":"<code>convert_SI(val, unit_in, unit_out)</code>","text":"<p>Unit converter.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>The value to convert.</p> required <code>unit_in</code> <code>str</code> <p>The input unit.</p> required <code>unit_out</code> <code>str</code> <p>The output unit.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value after unit conversion.</p> Source code in <code>geemap/cartoee.py</code> <pre><code>def convert_SI(val, unit_in, unit_out):\n\"\"\"Unit converter.\n\n    Args:\n        val (float): The value to convert.\n        unit_in (str): The input unit.\n        unit_out (str): The output unit.\n\n    Returns:\n        float: The value after unit conversion.\n    \"\"\"\n    SI = {\n        \"cm\": 0.01,\n        \"m\": 1.0,\n        \"km\": 1000.0,\n        \"inch\": 0.0254,\n        \"foot\": 0.3048,\n        \"mile\": 1609.34,\n    }\n    return val * SI[unit_in] / SI[unit_out]\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.get_image_collection_gif","title":"<code>get_image_collection_gif(ee_ic, out_dir, out_gif, vis_params, region, cmap=None, proj=None, fps=10, mp4=False, grid_interval=None, plot_title='', date_format='YYYY-MM-dd', fig_size=(10, 10), dpi_plot=100, file_format='png', north_arrow_dict={}, scale_bar_dict={}, verbose=True)</code>","text":"<p>Download all the images in an image collection and use them to generate a gif/video.</p> <p>Parameters:</p> Name Type Description Default <code>ee_ic</code> <code>object</code> <p>ee.ImageCollection</p> required <code>out_dir</code> <code>str</code> <p>The output directory of images and video.</p> required <code>out_gif</code> <code>str</code> <p>The name of the gif file.</p> required <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary.</p> required <code>region</code> <code>list | tuple</code> <p>Geospatial region of the image to render in format [E,S,W,N].</p> required <code>fps</code> <code>int</code> <p>Video frames per second. Defaults to 10.</p> <code>10</code> <code>mp4</code> <code>bool</code> <p>Whether to create mp4 video.</p> <code>False</code> <code>grid_interval</code> <code>float | tuple[float]</code> <p>Float specifying an interval at which to create gridlines, units are decimal degrees. lists will be interpreted a (x_interval, y_interval), such as (0.1, 0.1). Defaults to None.</p> <code>None</code> <code>plot_title</code> <code>str</code> <p>Plot title. Defaults to \"\".</p> <code>''</code> <code>date_format</code> <code>str</code> <p>A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to \"YYYY-MM-dd\".</p> <code>'YYYY-MM-dd'</code> <code>fig_size</code> <code>tuple</code> <p>Size of the figure.</p> <code>(10, 10)</code> <code>dpi_plot</code> <code>int</code> <p>The resolution in dots per inch of the plot.</p> <code>100</code> <code>file_format</code> <code>str</code> <p>Either 'png' or 'jpg'.</p> <code>'png'</code> <code>north_arrow_dict</code> <code>dict</code> <p>Parameters for the north arrow. See https://geemap.org/cartoee/#geemap.cartoee.add_north_arrow. Defaults to {}.</p> <code>{}</code> <code>scale_bar_dict</code> <code>dict</code> <p>Parameters for the scale bar. See https://geemap.org/cartoee/#geemap.cartoee.add_scale_bar. Defaults. to {}.</p> <code>{}</code> <code>verbose</code> <code>bool</code> <p>Whether or not to print text when the program is running. Defaults to True.</p> <code>True</code> Source code in <code>geemap/cartoee.py</code> <pre><code>def get_image_collection_gif(\n    ee_ic,\n    out_dir,\n    out_gif,\n    vis_params,\n    region,\n    cmap=None,\n    proj=None,\n    fps=10,\n    mp4=False,\n    grid_interval=None,\n    plot_title=\"\",\n    date_format=\"YYYY-MM-dd\",\n    fig_size=(10, 10),\n    dpi_plot=100,\n    file_format=\"png\",\n    north_arrow_dict={},\n    scale_bar_dict={},\n    verbose=True,\n):\n\"\"\"Download all the images in an image collection and use them to generate a gif/video.\n    Args:\n        ee_ic (object): ee.ImageCollection\n        out_dir (str): The output directory of images and video.\n        out_gif (str): The name of the gif file.\n        vis_params (dict): Visualization parameters as a dictionary.\n        region (list | tuple): Geospatial region of the image to render in format [E,S,W,N].\n        fps (int, optional): Video frames per second. Defaults to 10.\n        mp4 (bool, optional): Whether to create mp4 video.\n        grid_interval (float | tuple[float]): Float specifying an interval at which to create gridlines, units are decimal degrees. lists will be interpreted a (x_interval, y_interval), such as (0.1, 0.1). Defaults to None.\n        plot_title (str): Plot title. Defaults to \"\".\n        date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to \"YYYY-MM-dd\".\n        fig_size (tuple, optional): Size of the figure.\n        dpi_plot (int, optional): The resolution in dots per inch of the plot.\n        file_format (str, optional): Either 'png' or 'jpg'.\n        north_arrow_dict (dict, optional): Parameters for the north arrow. See https://geemap.org/cartoee/#geemap.cartoee.add_north_arrow. Defaults to {}.\n        scale_bar_dict (dict, optional): Parameters for the scale bar. See https://geemap.org/cartoee/#geemap.cartoee.add_scale_bar. Defaults. to {}.\n        verbose (bool, optional): Whether or not to print text when the program is running. Defaults to True.\n    \"\"\"\n\n    from .geemap import png_to_gif, jpg_to_gif\n\n    out_dir = os.path.abspath(out_dir)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    out_gif = os.path.join(out_dir, out_gif)\n\n    count = int(ee_ic.size().getInfo())\n    names = ee_ic.aggregate_array(\"system:index\").getInfo()\n    images = ee_ic.toList(count)\n\n    dates = ee_ic.aggregate_array(\"system:time_start\")\n    dates = dates.map(lambda d: ee.Date(d).format(date_format)).getInfo()\n\n    digits = len(str(len(dates)))\n\n    # list of file name\n    img_list = []\n\n    for i, date in enumerate(dates):\n        image = ee.Image(images.get(i))\n        name = str(i + 1).zfill(digits) + \".\" + file_format\n        out_img = os.path.join(out_dir, name)\n        img_list.append(out_img)\n\n        if verbose:\n            print(f\"Downloading {i+1}/{count}: {name} ...\")\n\n        # Size plot\n        fig = plt.figure(figsize=fig_size)\n\n        # Set the facecolor\n        fig.patch.set_facecolor(\"white\")\n\n        # Plot image\n        ax = get_map(image, region=region, vis_params=vis_params, cmap=cmap, proj=proj)\n\n        # Add grid\n        if grid_interval is not None:\n            add_gridlines(ax, interval=grid_interval, linestyle=\":\")\n\n        # Add title\n        if len(plot_title) &gt; 0:\n            ax.set_title(label=plot_title + \" \" + date + \"\\n\", fontsize=15)\n\n        # Add scale bar\n        if len(scale_bar_dict) &gt; 0:\n            add_scale_bar_lite(ax, **scale_bar_dict)\n        # Add north arrow\n        if len(north_arrow_dict) &gt; 0:\n            add_north_arrow(ax, **north_arrow_dict)\n\n        # Save plot\n        plt.savefig(\n            fname=out_img,\n            dpi=dpi_plot,\n            bbox_inches=\"tight\",\n            facecolor=fig.get_facecolor(),\n        )\n\n        plt.clf()\n        plt.close()\n\n    out_gif = os.path.abspath(out_gif)\n    if file_format == \"png\":\n        png_to_gif(out_dir, out_gif, fps)\n    elif file_format == \"jpg\":\n        jpg_to_gif(out_dir, out_gif, fps)\n    if verbose:\n        print(f\"GIF saved to {out_gif}\")\n\n    if mp4:\n        video_filename = out_gif.replace(\".gif\", \".mp4\")\n\n        try:\n            import cv2\n        except ImportError:\n            print(\"Installing opencv-python ...\")\n            subprocess.check_call([\"python\", \"-m\", \"pip\", \"install\", \"opencv-python\"])\n            import cv2\n\n        # Video file name\n        output_video_file_name = os.path.join(out_dir, video_filename)\n\n        frame = cv2.imread(img_list[0])\n        height, width, _ = frame.shape\n        frame_size = (width, height)\n        fps_video = fps\n\n        # Make mp4\n        fourcc = cv2.VideoWriter_fourcc(*\"mp4v\")\n\n        # Function\n        def convert_frames_to_video(\n            input_list, output_video_file_name, fps_video, frame_size\n        ):\n\"\"\"Convert frames to video\n\n            Args:\n\n                input_list (list): Downloaded Image Name List.\n                output_video_file_name (str): The name of the video file in the image directory.\n                fps_video (int): Video frames per second.\n                frame_size (tuple): Frame size.\n            \"\"\"\n            out = cv2.VideoWriter(output_video_file_name, fourcc, fps_video, frame_size)\n            num_frames = len(input_list)\n\n            for i in range(num_frames):\n                img_path = input_list[i]\n                img = cv2.imread(img_path)\n                out.write(img)\n\n            out.release()\n            cv2.destroyAllWindows()\n\n        # Use function\n        convert_frames_to_video(\n            input_list=img_list,\n            output_video_file_name=output_video_file_name,\n            fps_video=fps_video,\n            frame_size=frame_size,\n        )\n\n        if verbose:\n            print(f\"MP4 saved to {output_video_file_name}\")\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.get_map","title":"<code>get_map(ee_object, proj=None, basemap=None, zoom_level=2, **kwargs)</code>","text":"<p>Wrapper function to create a new cartopy plot with project and adds Earth Engine image results</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.Image | ee.FeatureCollection</code> <p>Earth Engine image result to plot</p> required <code>proj</code> <code>cartopy.crs</code> <p>Cartopy projection that determines the projection of the resulting plot. By default uses an equirectangular projection, PlateCarree</p> <code>None</code> <code>basemap</code> <code>str</code> <p>Basemap to use. It can be one of [\"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\"] or cartopy.io.img_tiles, such as cimgt.StamenTerrain(). Defaults to None. See https://scitools.org.uk/cartopy/docs/v0.19/cartopy/io/img_tiles.html</p> <code>None</code> <code>zoom_level</code> <code>int</code> <p>Zoom level of the basemap. Defaults to 2.</p> <code>2</code> <code>**kwargs</code> <p>remaining keyword arguments are passed to addLayer()</p> <code>{}</code> <p>Returns:</p> Type Description <code>ax (cartopy.mpl.geoaxes.GeoAxesSubplot)</code> <p>cartopy GeoAxesSubplot object with Earth Engine results displayed</p> Source code in <code>geemap/cartoee.py</code> <pre><code>def get_map(ee_object, proj=None, basemap=None, zoom_level=2, **kwargs):\n\"\"\"\n    Wrapper function to create a new cartopy plot with project and adds Earth\n    Engine image results\n    Args:\n        ee_object (ee.Image | ee.FeatureCollection): Earth Engine image result to plot\n        proj (cartopy.crs, optional): Cartopy projection that determines the projection of the resulting plot. By default uses an equirectangular projection, PlateCarree\n        basemap (str, optional): Basemap to use. It can be one of [\"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\"] or cartopy.io.img_tiles, such as cimgt.StamenTerrain(). Defaults to None. See https://scitools.org.uk/cartopy/docs/v0.19/cartopy/io/img_tiles.html\n        zoom_level (int, optional): Zoom level of the basemap. Defaults to 2.\n        **kwargs: remaining keyword arguments are passed to addLayer()\n    Returns:\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot): cartopy GeoAxesSubplot object with Earth Engine results displayed\n    \"\"\"\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        if \"style\" in kwargs and kwargs[\"style\"] is not None:\n            style = kwargs[\"style\"]\n        else:\n            style = {}\n\n        props = features.first().propertyNames().getInfo()\n        if \"style\" in props:\n            ee_object = features.style(**{\"styleProperty\": \"style\"})\n        else:\n            ee_object = features.style(**style)\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        ee_object = ee_object.mosaic()\n\n    if proj is None:\n        proj = ccrs.PlateCarree()\n\n    if \"style\" in kwargs:\n        del kwargs[\"style\"]\n\n    ax = mpl.pyplot.axes(projection=proj)\n\n    if basemap is not None:\n        if isinstance(basemap, str):\n            if basemap.upper() in [\"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\"]:\n                basemap = cimgt.GoogleTiles(url=xyz_tiles[basemap.upper()][\"url\"])\n\n        try:\n            ax.add_image(basemap, zoom_level)\n        except Exception as e:\n            print(\"Failed to add basemap: \", e)\n\n    add_layer(ax, ee_object, **kwargs)\n\n    return ax\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.pad_view","title":"<code>pad_view(ax, factor=0.05)</code>","text":"<p>Function to pad area around the view extent of a map, used for visual appeal</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes</code> <p>required cartopy GeoAxesSubplot object to pad view extent</p> required <code>factor</code> <code>float | list[float]</code> <p>factor to pad view extent accepts float [0-1] of a list of floats which will be interpreted at [xfactor, yfactor]</p> <code>0.05</code> Source code in <code>geemap/cartoee.py</code> <pre><code>def pad_view(ax, factor=0.05):\n\"\"\"Function to pad area around the view extent of a map, used for visual appeal\n\n    args:\n        ax (cartopy.mpl.geoaxes.GeoAxesSubplot | cartopy.mpl.geoaxes.GeoAxes): required cartopy GeoAxesSubplot object to pad view extent\n        factor (float | list[float], optional): factor to pad view extent accepts float [0-1] of a list of floats which will be interpreted at [xfactor, yfactor]\n\n    \"\"\"\n\n    view_extent = ax.get_extent()\n\n    if isinstance(factor, Iterable):\n        xfactor, yfactor = factor\n    else:\n        xfactor, yfactor = factor, factor\n\n    x_diff = view_extent[1] - view_extent[0]\n    y_diff = view_extent[3] - view_extent[2]\n\n    xmin = view_extent[0] - (x_diff * xfactor)\n    xmax = view_extent[1] + (x_diff * xfactor)\n    ymin = view_extent[2] - (y_diff * yfactor)\n    ymax = view_extent[3] + (y_diff * yfactor)\n\n    ax.set_ylim(ymin, ymax)\n    ax.set_xlim(xmin, xmax)\n\n    return\n</code></pre>"},{"location":"cartoee/#geemap.cartoee.savefig","title":"<code>savefig(fig, fname, dpi='figure', bbox_inches='tight', **kwargs)</code>","text":"<p>Save figure to file. It wraps the matplotlib.pyplot.savefig() function.         See https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.savefig.html for more details.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>matplotlib.figure.Figure</code> <p>The figure to save.</p> required <code>fname</code> <code>str</code> <p>A path to a file, or a Python file-like object.</p> required <code>dpi</code> <code>int | str</code> <p>The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to 'figure'.</p> <code>'figure'</code> <code>bbox_inches</code> <code>str</code> <p>Bounding box in inches: only the given portion of the figure is saved. If 'tight', try to figure out the tight bbox of the figure.</p> <code>'tight'</code> <code>kwargs</code> <code>dict</code> <p>Additional keyword arguments are passed on to the savefig() method.</p> <code>{}</code> Source code in <code>geemap/cartoee.py</code> <pre><code>def savefig(fig, fname, dpi=\"figure\", bbox_inches=\"tight\", **kwargs):\n\"\"\"Save figure to file. It wraps the matplotlib.pyplot.savefig() function.\n            See https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.savefig.html for more details.\n\n    Args:\n        fig (matplotlib.figure.Figure): The figure to save.\n        fname (str): A path to a file, or a Python file-like object.\n        dpi (int | str, optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to 'figure'.\n        bbox_inches (str, optional): Bounding box in inches: only the given portion of the figure is saved.\n            If 'tight', try to figure out the tight bbox of the figure.\n        kwargs (dict, optional): Additional keyword arguments are passed on to the savefig() method.\n    \"\"\"\n\n    fig.savefig(fname=fname, dpi=dpi, bbox_inches=bbox_inches, **kwargs)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v0207-may-16-2023","title":"v0.20.7 - May 16, 2023","text":"<p>New Features</p> <ul> <li>Added ee_to_geotiff function (#1519)</li> <li>Added netlify deployment for pull requests (#1516)</li> </ul> <p>Improvement</p> <ul> <li>Added ee.data.setUserAgent (#1535)</li> <li>Fixed dimensions in timelapse module not accepting number pairs (#1534)</li> <li>Fixed ArcGIS add layer bug (#1518)</li> <li>Fixed for faulty exception handling when request.get raises an exception</li> </ul>"},{"location":"changelog/#v0206-apr-18-2023","title":"v0.20.6 - Apr 18, 2023","text":"<p>New Features</p> <ul> <li>Added landsat_scaling function (#1503)</li> </ul> <p>Improvement</p> <ul> <li>Improved data catalog search GUI (#1496)</li> <li>Fixed ee.Geometry visualization bug (#1495)</li> <li>Fixed plotly import error</li> <li>Updated docker image url</li> </ul>"},{"location":"changelog/#v0205-apr-6-2023","title":"v0.20.5 - Apr 6, 2023","text":"<p>Improvement</p> <ul> <li>Moved the repo to gee-community and updated the Repo URL (#1490)</li> <li>Reorganized dependencies (#1489)</li> <li>Dropped support for Python 3.7 (#1486)</li> </ul>"},{"location":"changelog/#v0204-mar-27-2023","title":"v0.20.4 - Mar 27, 2023","text":"<p>Improvement</p> <ul> <li>Fixed image export file per band bug (#1481)</li> <li>Added filenames parameter to export image collection (#1478)</li> <li>Removed ipykernel import</li> </ul>"},{"location":"changelog/#v0203-mar-22-2023","title":"v0.20.3 - Mar 22, 2023","text":"<p>Improvement</p> <ul> <li>Fixed ipywidgets comm error (#1474)</li> </ul>"},{"location":"changelog/#v0202-mar-19-2023","title":"v0.20.2 - Mar 19, 2023","text":"<p>New Features</p> <ul> <li>Added AmericaView workshop notebook (#1459)</li> <li>Added geemap docker image (#1456)</li> <li>Added geemap logo (#1448)</li> </ul> <p>Improvement</p> <ul> <li>Cleaned up notebooks (#1469)</li> <li>Fixed zonal stats by group bug (#1441)</li> <li>Disable docs search due to large file #1437</li> <li>Fixed datapane bug #1450 (#1452)</li> </ul>"},{"location":"changelog/#v0200-feb-18-2023","title":"v0.20.0 - Feb 18, 2023","text":"<p>New Features</p> <ul> <li>Added support for gradio for developing interactive web apps (#1436)</li> </ul> <p>Improvement</p> <ul> <li>Updated JRC water product to v1.4 (#1428)</li> <li>Fixed tar file bug CVE-2007-4559 (#1419)</li> <li>zonal_stats_by_group patch (#1418)</li> </ul>"},{"location":"changelog/#v0196-jan-23-2023","title":"v0.19.6 - Jan 23, 2023","text":"<p>Improvement</p> <ul> <li>Automatically copy converted JavaScript to Python script to clipboard (#1411)</li> </ul>"},{"location":"changelog/#v0195-jan-19-2023","title":"v0.19.5 - Jan 19, 2023","text":"<p>Improvement</p> <ul> <li>Pin ipywidgets version &lt;8.0 as VS Code does not support ipywidgets 8.x (#1408)</li> </ul>"},{"location":"changelog/#v0194-jan-19-2023","title":"v0.19.4 - Jan 19, 2023","text":"<p>Improvement</p> <ul> <li>Added layer control to split map (#1405)</li> <li>Improved JavaScript to Python conversion (#1405)</li> </ul>"},{"location":"changelog/#v0193-jan-17-2023","title":"v0.19.3 - Jan 17, 2023","text":"<p>Improvement</p> <ul> <li>Updated timelapse default end year #1400</li> </ul>"},{"location":"changelog/#v0192-jan-11-2023","title":"v0.19.2 - Jan 11, 2023","text":"<p>Improvement</p> <ul> <li>Fixed add_labels bug (#1391)</li> <li>Removed LGTM badge (#1389)</li> <li>Improved cartoee legend and savefig (#1380)</li> <li>Updated vector_to_gif notebook</li> </ul>"},{"location":"changelog/#v0191-dec-22-2022","title":"v0.19.1 - Dec 22, 2022","text":"<p>New Features</p> <ul> <li>Added colorbar support for folium (#1372)</li> </ul>"},{"location":"changelog/#v0190-dec-5-2022","title":"v0.19.0 - Dec 5, 2022","text":"<p>New Features</p> <ul> <li>Added support for ArcGIS Pro (#1361)</li> </ul>"},{"location":"changelog/#v0183-dec-1-2022","title":"v0.18.3 - Dec 1, 2022","text":"<p>Improvement</p> <ul> <li>Fixed draw control bug (#1352)</li> </ul>"},{"location":"changelog/#v0182-dec-1-2022","title":"v0.18.2 - Dec 1, 2022","text":"<p>New Features</p> <ul> <li>Added support for print objects using eerepr (#1354)</li> <li>Added support for using custom TiTiler endpoint (#1353)</li> </ul> <p>Improvement</p> <ul> <li>Fixed <code>geojson_to_ee</code> bug (#1351)</li> </ul>"},{"location":"changelog/#v0181-nov-28-2022","title":"v0.18.1 - Nov 28, 2022","text":"<p>New Features</p> <ul> <li>Added <code>vector_to_gif()</code> function (#1348)</li> <li>Changed jupyterlab dependency to optional. Now compatible with Colab. No need to restart runtime after installation (#1347)</li> </ul>"},{"location":"changelog/#v0180-nov-27-2022","title":"v0.18.0 - Nov 27, 2022","text":"<p>New Features</p> <ul> <li>Added functions for creating legends and adding widgets to the map (#1345)(#1346)</li> <li>New functions include <code>create_legend()</code>, <code>add_legend()</code>, <code>add_text()</code>, <code>add_image()</code>, <code>add_html()</code>, and <code>add_widget()</code></li> <li>Added two notebook examples for using newly added functions</li> <li>Split-map now supports adding multiple legends</li> <li>Added ESA World Cover 2021 basemaps</li> <li>Added mkdocs dark mode (#1338)</li> </ul> <p>Improvement</p> <ul> <li>Removed misc notebook to reduce mkdocs size</li> </ul>"},{"location":"changelog/#v0173-nov-19-2022","title":"v0.17.3 - Nov 19, 2022","text":"<p>Improvement</p> <ul> <li>Added GEE workshop notebooks (#1337)</li> <li>Updated KML methods (#1335)</li> <li>Fixed ipyleaflet.Map broken link (#1321)</li> </ul>"},{"location":"changelog/#v0172-oct-31-2022","title":"v0.17.2 - Oct 31, 2022","text":"<p>Improvement</p> <ul> <li>Added NASA funding acknowledgment</li> <li>Added unmask_value parameter to download image #1270</li> <li>Added Japan GEE workshop notebook</li> <li>Improved Colab error message</li> <li>Added support for Python 3.11</li> <li>Added asset type to search result</li> <li>zonal_stats: additions to allowed_statistics #1308</li> <li>Fixed max zoom bug</li> <li>Improved split control</li> <li>Improved local tile</li> </ul>"},{"location":"changelog/#v0171-sep-18-2022","title":"v0.17.1 - Sep 18, 2022","text":"<p>New Features:</p> <ul> <li>Added new Inspector GUI #1264</li> <li>Added more sample datasets</li> <li>Added codeql.yml</li> <li>Added dependency-review.yml</li> </ul> <p>Improvement</p> <ul> <li>Improved chart options</li> </ul>"},{"location":"changelog/#v0170-sep-11-2022","title":"v0.17.0 - Sep 11, 2022","text":"<p>New Features:</p> <ul> <li>Added reproject image function #1245</li> <li>Added Map.show_layer() function</li> <li>Added plotly charts to import</li> <li>Added cropland mapping notebook #1251</li> </ul> <p>Improvement</p> <ul> <li>Improved chart and legend and colormap #1250</li> </ul>"},{"location":"changelog/#v0169-sep-6-2022","title":"v0.16.9 - Sep 6, 2022","text":"<p>Improvement</p> <ul> <li>Fixed download NED bug</li> </ul>"},{"location":"changelog/#v0168-sep-6-2022","title":"v0.16.8 - Sep 6, 2022","text":"<p>Improvement</p> <ul> <li>Added bands param goes_timelapse #1242</li> <li>Improved download image function #1238</li> <li>Improved download NED function</li> </ul>"},{"location":"changelog/#v0167-aug-19-2022","title":"v0.16.7 - Aug 19, 2022","text":"<p>Improvement</p> <ul> <li>Fixed ee service account authentication bug</li> </ul>"},{"location":"changelog/#v0166-aug-19-2022","title":"v0.16.6 - Aug 19, 2022","text":"<p>New Features:</p> <ul> <li>Added auth support for ee service account #1220</li> <li>Added a mosaic function #1219</li> <li>Added download_ned function #1218</li> </ul>"},{"location":"changelog/#v0165-aug-16-2022","title":"v0.16.5 - Aug 16, 2022","text":"<p>Improvement</p> <ul> <li>Add band param for image_count #1209</li> <li>Improved exporting image to asset #1208</li> <li>Fixed Sentinel-1 timelapse bug #1210</li> <li>Fixed pie chart Windows bug</li> <li>Added popup fields for add_geojson</li> <li>Updated zonal stats function</li> </ul>"},{"location":"changelog/#v0164-aug-11-2022","title":"v0.16.4 - Aug 11, 2022","text":"<p>New Features:</p> <ul> <li>Added support for searching Awesome GEE Community Datasets #1197 #1201 #1202</li> <li>Added support for retrieving GEE JS code examples and converting to Python</li> <li>Added colorbar background color and image convolution</li> <li>Added html_to_streamlit function</li> </ul> <p>Improvement</p> <ul> <li>Improved the search data GUI</li> </ul>"},{"location":"changelog/#v0163-aug-9-2022","title":"v0.16.3 - Aug 9, 2022","text":"<p>Improvement</p> <ul> <li>Fixed colab import issue #1192</li> <li>Allow single color rather than list #1191</li> <li>Use json to parse the gee credentials #1178</li> </ul>"},{"location":"changelog/#v0162-aug-4-2022","title":"v0.16.2 - Aug 4, 2022","text":"<p>New Features:</p> <ul> <li>Added image_histogram and jrc_hist_monthly_history functions</li> </ul>"},{"location":"changelog/#v0161-jul-31-2022","title":"v0.16.1 - Jul 31, 2022","text":"<p>New Features:</p> <ul> <li>Added support for plotly.express charts (bar, line, histogram, pie) #1170</li> </ul>"},{"location":"changelog/#v0160-jul-30-2022","title":"v0.16.0 - Jul 30, 2022","text":"<p>New Features:</p> <ul> <li>Added support for creating S1 timelapse #752 #1168</li> <li>Added cloud_pct option for dynamic world ts #1165</li> <li>Added get_ee_path function</li> </ul> <p>Improvement</p> <ul> <li>Renamed region to roi for timelapse func</li> <li>Added lidar tutorial</li> <li>Improved support for Colab</li> <li>Fixed js py conversion bug</li> <li>Improved COG and STAC for short URL</li> <li>Improved requireJS function</li> <li>Added book link</li> <li>Added vector_styling explicit args #1155</li> </ul>"},{"location":"changelog/#v0155-jul-22-2022","title":"v0.15.5 - Jul 22, 2022","text":"<p>New Features:</p> <ul> <li>Added get_direct_url function</li> <li>Added more lidar functions #1149</li> </ul> <p>Improvement</p> <ul> <li>Improved load_GeoTIFF function</li> <li>Fixed image palette bug</li> <li>Updated vector styling notebook</li> </ul>"},{"location":"changelog/#v0154-jul-15-2022","title":"v0.15.4 - Jul 15, 2022","text":"<p>New Features:</p> <ul> <li>Added support for vector styling #1148</li> <li>Added csv_to_vector function #1144</li> </ul> <p>Improvement</p> <ul> <li>Improved add_legend and points_from_xy</li> <li>Updated data conversion functions</li> <li>Renamed datasets from hyphen to underscore</li> <li>Updated sample datasets</li> <li>Fixed folium split map bug</li> </ul>"},{"location":"changelog/#v0153-jul-11-2022","title":"v0.15.3 - Jul 11, 2022","text":"<p>Improvement</p> <ul> <li>Pin ipyleaflet version for Colab #1132 #1143</li> <li>Improved add vector functions</li> </ul>"},{"location":"changelog/#v0152-jul-9-2022","title":"v0.15.2 - Jul 9, 2022","text":"<p>New Features:</p> <ul> <li>Improved support for loading JavaScript modules with <code>require()</code> functions #1140</li> </ul>"},{"location":"changelog/#v0151-jul-8-2022","title":"v0.15.1 - Jul 8, 2022","text":"<p>New Features:</p> <ul> <li>Added support for Open Earth Engine Library (OEEL) #1137</li> </ul>"},{"location":"changelog/#v0150-jul-8-2022","title":"v0.15.0 - Jul 8, 2022","text":"<p>New Features:</p> <ul> <li>Added support for changing geojson layer opacity #1135</li> <li>Added Map user roi bbox function #1134</li> </ul> <p>Improvement</p> <ul> <li>Fixed colormap bug #1133</li> <li>Cleaned notebook output #1129</li> <li>Fixed clip image bug</li> </ul>"},{"location":"changelog/#v0143-jul-1-2022","title":"v0.14.3 - Jul 1, 2022","text":"<p>New Features:</p> <ul> <li>Added plotting raster in 3D #1127</li> <li>Added scooby report #1127</li> <li>Added sankee datasets #1126</li> </ul>"},{"location":"changelog/#v0142-jun-27-2022","title":"v0.14.2 - Jun 27, 2022","text":"<p>New Features:</p> <ul> <li>Added more ee export functions #1121</li> <li>Added COG/STAC Inspector GUI for getting pixel values interactively #1123</li> </ul>"},{"location":"changelog/#v0141-jun-26-2022","title":"v0.14.1 - Jun 26, 2022","text":"<p>Improvement</p> <ul> <li>Added support for Python 3.10 #1119</li> <li>Made mapclassify pkg optional #1120</li> </ul>"},{"location":"changelog/#v0140-jun-18-2022","title":"v0.14.0 - Jun 18, 2022","text":"<p>New Features:</p> <ul> <li>Added fishnet function #1111</li> <li>Added download image with geedim #1110</li> </ul> <p>Improvement</p> <ul> <li>Improved zonal stats</li> </ul>"},{"location":"changelog/#v01311-jun-14-2022","title":"v0.13.11 - Jun 14, 2022","text":"<p>New Features:</p> <ul> <li>Added function for creating Dynamic World land cover timeseries #1108</li> <li>Added land cover comparison notebook #1106</li> </ul>"},{"location":"changelog/#v01310-jun-10-2022","title":"v0.13.10 - Jun 10, 2022","text":"<p>New Features:</p> <ul> <li>Added support for Dynamic World Land Cover #1098</li> </ul>"},{"location":"changelog/#v0139-jun-7-2022","title":"v0.13.9 - Jun 7, 2022","text":"<p>Improvement</p> <ul> <li>Improved palette support, accepting a string palette (e.g., terrain, ndvi) vis_params for Map.addLayer().</li> </ul>"},{"location":"changelog/#v0138-jun-5-2022","title":"v0.13.8 - Jun 5, 2022","text":"<p>New Features:</p> <ul> <li>Added check_cmap function #1084</li> <li>Added ESA and USGS basemaps #1089</li> <li>Added Earth Engine support for pydeck #1090</li> </ul> <p>Improvement</p> <ul> <li>Fixed add local tile bug</li> <li>Fixed image_area_by_group bug</li> <li>Improved blend function</li> <li>Fixed links redirect</li> <li>Fixed basemap docs #1075</li> <li>Upgraded add_raster function #1083</li> <li>Fixed raster GUI band bug</li> </ul>"},{"location":"changelog/#v0137-may-25-2022","title":"v0.13.7 - May 25, 2022","text":"<p>New Features:</p> <ul> <li>Added image_area_by_group function #1073</li> </ul> <p>Improvement</p> <ul> <li>Updated cartoee basemap notebook #1067</li> <li>Refactored basemap #1075</li> <li>Sorted raster colormap options</li> <li>Fixed colormap GUI bug</li> <li>Fixed stac stats bug</li> </ul>"},{"location":"changelog/#v0136-may-22-2022","title":"v0.13.6 - May 22, 2022","text":"<p>Improvement</p> <ul> <li>Added cartoee basemap support #1067</li> <li>Updated Landsat LE7_TOA_5YEAR Image ID</li> </ul>"},{"location":"changelog/#v0135-may-17-2022","title":"v0.13.5 - May 17, 2022","text":"<p>Improvement</p> <ul> <li>Improved JS-PY conversion #1061</li> <li>Updated FAQ</li> <li>Improved get wms layers</li> <li>Updated NLCD notebook</li> <li>Added proxy settings to export data functions</li> <li>Added colorbar to image count notebook</li> <li>Added image_count function and notebook</li> </ul>"},{"location":"changelog/#v0134-apr-27-2022","title":"v0.13.4 - Apr 27, 2022","text":"<p>New Features:</p> <ul> <li>Added support for creating interactive choropleth maps with a variety of classification schemes #1043</li> </ul>"},{"location":"changelog/#v0133-apr-25-2022","title":"v0.13.3 - Apr 25, 2022","text":"<p>New Features:</p> <ul> <li>Added an examples module</li> <li>Added creating coordinate grids notebook</li> <li>Added image zonal stats notebook</li> </ul> <p>Improvement</p> <ul> <li>Improved chart module #1026</li> <li>Improved chart histogram #1032</li> </ul>"},{"location":"changelog/#v0132-apr-15-2022","title":"v0.13.2 - Apr 15, 2022","text":"<p>New Features:</p> <ul> <li>Added image_value_list function #1010</li> <li>Added image_stats_by_zone #1012</li> <li>Added support for creating grids #1014</li> <li>Added landforms legend</li> </ul> <p>Improvement</p> <ul> <li>Updated cartoee add_colorbar #1006</li> <li>Added layer control for ipyleaflet #1017</li> <li>Updated authentication method #1018</li> <li>Fixed add_colorbar bug</li> </ul>"},{"location":"changelog/#v0131-apr-2-2022","title":"v0.13.1 - Apr 2, 2022","text":"<p>Improvement</p> <ul> <li>Fixed heremap import error</li> </ul>"},{"location":"changelog/#v0130-apr-2-2022","title":"v0.13.0 - Apr 2, 2022","text":"<p>Improvement</p> <ul> <li>Reduced number of dependencies, making plotting backends optional except ipyleaflet and folium #1003</li> <li>Improved cartoee.add_legend #997</li> <li>Added deck and kepler to docs</li> <li>Skip export with GitHub Actions</li> <li>Update folium module</li> <li>Updated clip image notebook</li> </ul>"},{"location":"changelog/#v0121-mar-22-2022","title":"v0.12.1 - Mar 22, 2022","text":"<p>New Features:</p> <ul> <li>Added support for pydeck and kepler.gl #993</li> </ul> <p>Improvement</p> <ul> <li>Renamed basemaps</li> <li>Added GEE-Courses link</li> <li>Updated folium module</li> </ul>"},{"location":"changelog/#v0120-mar-19-2022","title":"v0.12.0 - Mar 19, 2022","text":"<p>New Features:</p> <ul> <li>Added support for NetCDF data #991</li> <li>Converting NetCDF data to GeoTIFF</li> <li>Adding velocity map with NetCDF data</li> <li>Added clip image by mask #986</li> <li>Added streamlit bidirectional functionality #985</li> </ul> <p>Improvement</p> <ul> <li>Added requests timeout #989</li> <li>Renamed folium basemaps #978</li> <li>Set draw export to False by default</li> <li>Added font family setting for cartoee #863 #977</li> </ul>"},{"location":"changelog/#v0118-mar-12-2022","title":"v0.11.8 - Mar 12, 2022","text":"<p>New Features:</p> <ul> <li>Added split map for folium and streamlit #970</li> <li>Updated Landsat timelapse to Collection 2 #974</li> </ul> <p>Improvement</p> <ul> <li>Fixed typos and broken links #971</li> <li>Updated netCDF notebook</li> </ul>"},{"location":"changelog/#v0117-mar-8-2022","title":"v0.11.7 - Mar 8, 2022","text":"<p>New Features:</p> <ul> <li>Added blend function for creating shaded relief maps blended with hillshade</li> </ul> <p>Improvement</p> <ul> <li>Added mode reducer to zonal stats #960</li> </ul>"},{"location":"changelog/#v0116-mar-3-2022","title":"v0.11.6 - Mar 3, 2022","text":"<p>New Features:</p> <ul> <li>Added support for visualizing LiDAR data in 3D #957</li> <li>Added date option for gdf_to_ee #950</li> </ul> <p>Improvement</p> <ul> <li>Improved chart histogram #953</li> <li>Fixed LGTM false alarm #939</li> </ul>"},{"location":"changelog/#v0115-feb-22-2022","title":"v0.11.5 - Feb 22, 2022","text":"<p>New Features:</p> <ul> <li>Added numpy to COG #945</li> <li>Added gdf_bounds #939</li> <li>Added Landsat 9 notebook</li> <li>Added ESRI Global Land Cover legend</li> </ul> <p>Improvement</p> <ul> <li>Fixed stac tile bug #944</li> <li>Added None to vis_params as optional #943</li> <li>Reformatted code using black</li> </ul>"},{"location":"changelog/#v0114-feb-14-2022","title":"v0.11.4 - Feb 14, 2022","text":"<p>New Features:</p> <ul> <li>Added timelapse fading effect #925</li> </ul>"},{"location":"changelog/#v0113-feb-7-2022","title":"v0.11.3 - Feb 7, 2022","text":"<p>New Features:</p> <ul> <li>Added support for joining attribute tables <code>ee_join_table()</code> #916</li> <li>Added <code>gdf_to_df()</code> and <code>geojson_to_df()</code> functions</li> </ul>"},{"location":"changelog/#v0112-feb-4-2022","title":"v0.11.2 - Feb 4, 2022","text":"<p>New Features:</p> <ul> <li>Added remove_colorbars function #881</li> <li>Added remove_legends function #881</li> </ul> <p>Improvement</p> <ul> <li>Update get_image_collection_gif() #905</li> <li>Fixed timelapse ND bug #904</li> <li>Improved open raster #902</li> <li>Fixed zonal stats bug #899</li> <li>Fixed Landsat timelapse bug #885</li> </ul>"},{"location":"changelog/#v0111-jan-24-2022","title":"v0.11.1 - Jan 24, 2022","text":"<p>New Features:</p> <ul> <li>Added ee_extra to algorithms #868</li> <li>Added COG creation bc83fdf</li> <li>Added heremap plotting backend #382</li> <li>Added COG Inspector GUI #841</li> </ul> <p>Improvement</p> <ul> <li>Improved GitHub workflows #879</li> <li>Fixed ee_stac_list bug #873</li> <li>Fixed js py conversion ce7fee0</li> <li>Updated notebook 07 #871</li> <li>Added IR band to goes_timelapse #870</li> <li>Updated ee_basemaps #869</li> <li>Removed COG mosaic</li> <li>Fixed cartoee legend bug</li> <li>Updated installation instructions</li> </ul>"},{"location":"changelog/#v0110-jan-7-2022","title":"v0.11.0 - Jan 7, 2022","text":"<p>New Features:</p> <ul> <li>Added support for plotly #842</li> <li>Added colorbar to timelapse #846</li> <li>Added save_colorbar function #846</li> <li>Added ocean color timelapse #845</li> <li>Added support for xyzservices basemaps #795</li> <li>Added labeling gdf shp geojson #815</li> <li>Added remove_labels #815</li> <li>Added Planetary Computer STAC support</li> <li>Added bbox_to_gdf function</li> </ul> <p>Improvement</p> <ul> <li>Fixed cartoee projection bug #843</li> <li>Improved COG visualization #844</li> <li>Updated STAC notebook example #841</li> <li>Improved stac tile functions #839</li> <li>Removed pangeo broken binder links</li> </ul>"},{"location":"changelog/#v0102-dec-23-2021","title":"v0.10.2 - Dec 23, 2021","text":"<p>New Features:</p> <ul> <li>Add locate control to folium #809</li> <li>Added add_points_from_xy function #812</li> <li>Added heatmap function</li> <li>Added add_labels function #815</li> <li>Added NAIP timelapse #789</li> </ul> <p>Improvement</p> <ul> <li>Improved js_to_py function #805</li> <li>Renamed popups to popup #812</li> <li>Changed default map view #821</li> <li>Fixed centerObject bug #823</li> <li>Fixed typo #824</li> </ul>"},{"location":"changelog/#v0101-dec-6-2021","title":"v0.10.1 - Dec 6, 2021","text":"<p>Improvement</p> <ul> <li>A temporary fix for ipyleaflet basemap error #795</li> </ul>"},{"location":"changelog/#v0100-nov-28-2021","title":"v0.10.0 - Nov 28, 2021","text":"<p>New Features:</p> <ul> <li>Added remove_legend function #761</li> <li>Added add_marker function #765</li> <li>Added support for local tile and raster GUI #758, #769</li> <li>Added a new osm module #770 #772</li> <li>Added support for PostGIS #771 #772</li> <li>Added ImageOverlay from local files #773</li> </ul>"},{"location":"changelog/#v095-nov-22-2021","title":"v0.9.5 - Nov 22, 2021","text":"<p>New Features:</p> <ul> <li>Added timelapse module</li> <li>Added quarter and monthly timelapse #746</li> <li>Improved create timeseries #736</li> <li>Added Sentinel-2 timelapse #733 #736</li> <li>Added MODIS NDVI timelapse #728</li> <li>Added GOES timelapse #717</li> <li>Added time slider opacity param #720</li> <li>Added contour function #688</li> <li>Added more gif functions</li> <li>Added make_gif and gif_to_mp4 functions</li> <li>Improved date sequence</li> <li>Added Alibaba font type</li> <li>Added ESA Land Cover legend</li> <li>Added zoom to bounds function</li> <li>Added streamlit download button</li> </ul> <p>Improvement</p> <ul> <li>Fixed encoding bug #747</li> </ul>"},{"location":"changelog/#v094-oct-23-2021","title":"v0.9.4 - Oct 23, 2021","text":"<p>New Features:</p> <ul> <li>Made streamlit map width responsive #713</li> <li>Added function read file from url</li> </ul> <p>Improvement</p> <ul> <li>Fixed map width bug #712</li> <li>Fixed algorithms module bug</li> <li>Updated environment.yml</li> </ul>"},{"location":"changelog/#v093-oct-23-2021","title":"v0.9.3 - Oct 23, 2021","text":"<p>New Features:</p> <ul> <li>Added streamlit support #697</li> <li>Added point layer function #702</li> <li>Added river width module #682</li> <li>Added census data and xyzservices</li> <li>Added nlcd notebook</li> <li>Added river width module notebook</li> <li>Added GEE workshop notebook</li> </ul> <p>Improvement</p> <ul> <li>Fixed geojson style callback bug #692</li> <li>Fixed open vector bug #124</li> <li>Removed py36 due to xyzservices</li> </ul>"},{"location":"changelog/#v092-oct-1-2021","title":"v0.9.2 - Oct 1, 2021","text":"<p>New Features:</p> <ul> <li>Added RivWidthCloud module #682</li> <li>Added RivWidthCloud notebook #682</li> <li>Added NLCD notebook</li> <li>Added a close button to timeseries inspector</li> </ul> <p>Improvement</p> <ul> <li>Fixed hover countries notebook #686</li> <li>Improved cartoee colorbar with custom label size #681</li> </ul>"},{"location":"changelog/#v091-sep-17-2021","title":"v0.9.1 - Sep 17, 2021","text":"<p>New Features:</p> <ul> <li>Added <code>sandbox_path</code> option allowing users to restrict Voila app access to system directories #673</li> </ul>"},{"location":"changelog/#v090-sep-10-2021","title":"v0.9.0 - Sep 10, 2021","text":"<p>New Features:</p> <ul> <li>Get current device latlon #618</li> </ul> <p>Improvement</p> <ul> <li>Improved Colab support #661</li> <li>Improved folium colorbar #586</li> <li>Fixed broken link #653</li> <li>Fixed extract pixel values bug #610</li> <li>Fixed color palette bug #605</li> <li>Fixed typos #589</li> </ul>"},{"location":"changelog/#v0818-jul-8-2021","title":"v0.8.18 - Jul 8, 2021","text":"<p>New Features:</p> <ul> <li>Added df_to_geojson #557</li> <li>Added feature_histogram function to chart module #553</li> <li>Added feature_groups function to chart module #539</li> <li>Added random forest probability output #550</li> </ul> <p>Improvement</p> <ul> <li>Renamed eefolium module to foliumap</li> <li>Changed COG and STAC to lowercase</li> <li>Changed .format() to fstring #561</li> <li>Fixed random forest string to label bug #545</li> <li>Improved split-panel map #543</li> <li>Updated otsu example #535</li> </ul>"},{"location":"changelog/#v0817-jun-20-2021","title":"v0.8.17 - Jun 20, 2021","text":"<p>New Features:</p> <ul> <li>Added Planet global mosaic #527</li> <li>Add LCMS dataset option for sankee #517</li> <li>Added add_osm function #503</li> </ul> <p>Improvement</p> <ul> <li>Added otsu example #535</li> <li>Fixed timeseries plotting bug #513</li> <li>Fixed shp deletion bug #509</li> <li>Fixed csv_to_points bug #490</li> <li>Improved ee_to_geojson #486</li> <li>Improved random sampling notebook #479</li> <li>Fixed link bug #480</li> <li>Improved sankee notebook #471</li> <li>Updated installation docs</li> <li>Added binder env</li> </ul>"},{"location":"changelog/#v0816-may-10-2021","title":"v0.8.16 - May 10, 2021","text":"<p>New Features:</p> <ul> <li>Added csv_to_points GUI #461</li> <li>Added GUI for creating transects #454</li> <li>Added csv_to_ee and csv_to_makers #461</li> <li>Added geopandas support #455</li> </ul> <p>Improvement</p> <ul> <li>Improved geojson style #459 #460</li> <li>Improved vector support #455</li> <li>Improved add_colorbar function #450</li> <li>Improved add_raster function #449</li> <li>Updated notebooks</li> </ul>"},{"location":"changelog/#v0815-apr-28-2021","title":"v0.8.15 - Apr 28, 2021","text":"<p>Improvement</p> <ul> <li>Improved shp_to_geojson function #430</li> <li>Improved add_styled_vector function #432</li> <li>Fixed map publish bug #445</li> <li>Improved add_colorbar function dc7e548</li> </ul>"},{"location":"changelog/#v0814-apr-20-2021","title":"v0.8.14 - Apr 20, 2021","text":"<p>New Features:</p> <ul> <li>Added timelapse GUI #359</li> <li>Added timeslider GUI #359 #387</li> </ul> <p>Improvement</p> <ul> <li>Improved add_geojson function 731e59e</li> <li>Added GeoPython workshop notebook 6efd5e</li> <li>Improved cartoee colorbar #413</li> <li>Improved cartoee add_layer function #368</li> </ul>"},{"location":"changelog/#v0813-mar-22-2021","title":"v0.8.13 - Mar 22, 2021","text":"<p>New Features:</p> <ul> <li>Added linked maps #375</li> <li>Added cartoee legend #343</li> <li>Added chart by feature property #339</li> <li>Added tool gui template #239</li> <li>Added GEE Toolbox GUI #362</li> <li>Added support for multiple legends #365</li> </ul> <p>Improvement</p> <ul> <li>Improved dataset module to use GEE STAC #346</li> <li>Improved training sample tool #326</li> <li>Added netcdf_to_ee example #285</li> <li>Improved to_html function #361</li> <li>Changed colorbar plotting backend #372</li> <li>Improved get_colorbar function #372</li> <li>Added vector styling example</li> <li>Improved zonal statistics</li> </ul>"},{"location":"changelog/#v0812-mar-8-2021","title":"v0.8.12 - Mar 8, 2021","text":"<p>New Features:</p> <ul> <li>Added a dataset module for accessing the Earth Engine Data Catalog via dot notation #345</li> <li>Added a chart module for creating interactive charts for Earth Engine data #343</li> <li>Added a time slider for visualizing Earth Engine time-series images #335  #344</li> <li>Added a <code>netcdf_to_ee</code> function #342</li> <li>Added a <code>numpy_to_ee</code> function #337</li> <li>Added vertical colorbar support #322</li> <li>Added GUI for creating training samples #326</li> </ul> <p>Improvement</p> <ul> <li>Added layer control by default to folium map #323</li> <li>Added geemap matplotlib example #319</li> <li>Added lgtm continuous integration #330</li> <li>Fixed layer palette bug #334</li> <li>Fixed minimap zoom parameter #329</li> <li>Fixed centerObject bug</li> </ul>"},{"location":"changelog/#v0811-feb-23-2021","title":"v0.8.11 - Feb 23, 2021","text":"<p>New Features:</p> <ul> <li>Added a colormap module #302</li> <li>Added a new cartoee scale bar function #313</li> <li>Added extract pixel values function #315</li> <li>Visualizing Earth Engine image with &gt;200 matplotlib colormaps via dot notation (example)</li> </ul> <p>Improvement</p> <ul> <li>Improved the basemap module accessible via dot notation #302</li> <li>Added googledrivedownloader and python-box to requirements #310</li> <li>Fixed folium layer name bug #314</li> </ul>"},{"location":"changelog/#v0810-feb-16-2021","title":"v0.8.10 - Feb 16, 2021","text":"<p>New Features:</p> <ul> <li>Added default basemap options when creating the Map #293</li> <li>Added GUI for change basemaps #294</li> <li>Added GUI for js2py conversion #296</li> <li>Added geemap cheat sheet #276</li> <li>Added <code>Map.zoomToObject()</code> method #303</li> </ul> <p>Improvement</p> <ul> <li>Improved <code>Map.centerObject()</code> method #303</li> </ul>"},{"location":"changelog/#v089-feb-4-2021","title":"v0.8.9 - Feb 4, 2021","text":"<p>New Features:</p> <ul> <li>Added whiteboxgui with 477 geoprocessing tools #254</li> </ul> <p>Improvement</p> <ul> <li>Fixed file open encoding bug</li> </ul>"},{"location":"changelog/#v088-jan-17-2021","title":"v0.8.8 - Jan 17, 2021","text":"<p>New Features:</p> <ul> <li>Added support for converting Pandas/GeoPandas DataFrame to ee.FeatureCollection and vice versa #268</li> <li>Added KML/KMZ support #247</li> <li>Added Code of Conduct</li> </ul> <p>Improvement</p> <ul> <li>Fixed CSV encoding bug #267</li> <li>Improved downloading shp support #263</li> <li>Fixed WMS bug #250</li> <li>Added cartoee subplots example #238</li> <li>Reformatted code using black formatter</li> <li>Improved support for shp and geojson #244</li> <li>Fixed layer control bug</li> <li>Added cartoee blend tutorial #241</li> <li>Improved drawing tools #240</li> <li>Improved Inspector tool</li> </ul>"},{"location":"changelog/#v087-dec-27-2020","title":"v0.8.7 - Dec 27, 2020","text":"<p>New Features:</p> <ul> <li>Added toolbar GUI #215</li> <li>Added layer vis #215</li> <li>Added raster/vector colormap #215</li> <li>Added support for linking legend with layer #234</li> <li>Added styled vector function #235</li> <li>Added mouse click observe to toolbar #215</li> <li>Added new tool for opening local data #239</li> </ul> <p>Improvement</p> <ul> <li>Fixed COG mosaic bug #236 and #237</li> </ul>"},{"location":"changelog/#v086-dec-22-2020","title":"v0.8.6 - Dec 22, 2020","text":"<p>New Features:</p> <ul> <li>Added GUI for changing layer visualization interactively #215</li> <li>Added a toolbar #215</li> <li>Added color bar support #223</li> <li>Added draggable legend to folium maps #224</li> <li>Added <code>get_image_collection_gif()</code> function #225</li> <li>Added <code>image_dates()</code> function #216</li> </ul> <p>Improvement</p> <ul> <li>Added <code>max_zoom</code> parameter to <code>add_tile_layer()</code> #227</li> <li>Added mouse latlon to insepctor tool #229</li> <li>Added download icon to notebooks #202</li> <li>Added GitHub issue template #202</li> <li>Added more tutorials (cartoee gif, legend, color bar, vis GUI, etc.)</li> <li>Fixed remove control bug #218</li> <li>Fixed split-panel map bug</li> <li>Improved Exception handling</li> </ul>"},{"location":"changelog/#v085-dec-12-2020","title":"v0.8.5 - Dec 12, 2020","text":"<p>New Features:</p> <ul> <li>Add toolbar #6</li> <li>Add functions for downloading imgae thumbnails #214</li> <li>Add func for getting image collection dates #216</li> <li>Add cartoee scale bar and north arrow #191</li> <li>Add support for COG mosaic #200</li> </ul> <p>Improvement</p> <ul> <li>Improve support for locally trained models #210</li> <li>Add verbose option of downloading functions #197</li> <li>Improve Inspector tool for point geometry #198</li> <li>Add tutorials (COG, STAC, local RF, image thumbnails)</li> </ul>"},{"location":"changelog/#v084-dec-6-2020","title":"v0.8.4 - Dec 6, 2020","text":"<p>New Features:</p> <ul> <li>Add support for Cloud Optimized GeoTIFF (COG) and SpatioTemporal Asset Catalog (STAC) #192</li> <li>Add Map.add_cog_layer() and Map.add_stac_layer()</li> <li>Add new COG functions, e.g., <code>cog_tile()</code>, <code>cog_bounds()</code>, <code>cog_center()</code>, <code>cog_bands()</code></li> <li>Add new STAC functions, e.g., <code>stac_tile()</code>, <code>stac_bounds()</code>, <code>stac_center()</code>, <code>stac_bands()</code></li> </ul> <p>Improvements:</p> <ul> <li>Improve Google Colab support #193. Use <code>import geemap</code> rather than <code>import geemap.foliumap as geemap</code></li> <li>Add <code>Open in Colab</code> button to notebooks #194</li> </ul>"},{"location":"changelog/#v083-dec-2-2020","title":"v0.8.3 - Dec 2, 2020","text":"<p>New Features:</p> <ul> <li>Add button for removing user-drawn features #182</li> <li>Add function for moving drawn layer to top</li> <li>Add remove_last_drawn() function #130</li> <li>Add support for QGIS Layer Style File #174</li> <li>Add mouse click get coordinates example #173</li> <li>Add cartoee colab example #157</li> <li>Add notebooks to mkdocs</li> </ul> <p>Improvements:</p> <ul> <li>Improve ee_Initialize() #189 #190</li> <li>Fix cartoee map orientation bug #177 #183</li> <li>Fix problematic Date field in shapefile #176</li> <li>Fix Windows unzip bug</li> </ul>"},{"location":"changelog/#v082-nov-6-2020","title":"v0.8.2 - Nov 6, 2020","text":"<p>Improvements</p> <ul> <li>Reorganize modules</li> <li>Add a new module common.py</li> <li>Add new domain geemap.org</li> <li>Format code using black</li> <li>Add more init options for Map class</li> </ul>"},{"location":"changelog/#v081-oct-27-2020","title":"v0.8.1 - Oct 27, 2020","text":"<p>New Features:</p> <ul> <li>Add machine learning module #124 #156</li> <li>Add cartoee module #157 #161</li> <li>Add more tutorials (e.g., timelapse, water app, ipywidgets)</li> </ul> <p>Improvements:</p> <ul> <li>Make ee_Initialize() optional for Map class</li> </ul> <p>BIG THANK YOU to Kel Markert for adding the cartoee and ml modules!!</p>"},{"location":"changelog/#v080-oct-10-2020","title":"v0.8.0 - Oct 10, 2020","text":"<p>Improvements</p> <ul> <li>Add support for loading Cloud Optimized GeoTIFFs as ee.Image and ee.ImageCollection</li> <li>Make fmask optional when creating Landsat timelapse</li> <li>Add support for creating timelapse of spectral indices (e.g., NDWI, NDVI)</li> <li>Add geemap Colab tutorial</li> <li>Add timelapse download option for voila</li> <li>Add pydeck tutorial for visualizing 3D terrain data</li> <li>Add qualityMosaic() tutorial</li> </ul> <p>Fixes</p> <ul> <li>Fix Windows zipfile bug</li> </ul>"},{"location":"changelog/#v0713-sep-15-2020","title":"v0.7.13 - Sep 15, 2020","text":"<p>Improvements</p> <ul> <li>Improve ee authentication in Colab #145</li> <li>Improve non-interactive mode #138</li> <li>Add Colab notebook example</li> </ul> <p>Fixes</p> <ul> <li>Fix automated testing error</li> <li>Fix Windows ee_search() bug</li> </ul>"},{"location":"changelog/#v0712-sep-1-2020","title":"v0.7.12 - Sep 1, 2020","text":"<p>Improvements</p> <ul> <li>Rebuild docs using mkdocs-material</li> <li>Add Internet proxy function</li> <li>Add support for exporting shp and geojson #63</li> </ul> <p>Fixes</p> <ul> <li>Fix heroko config bug</li> <li>Fix landsat timelapse bug #99 #134</li> <li>Fix js_py conversion bug #136</li> </ul>"},{"location":"changelog/#v0711-aug-16-2020","title":"v0.7.11 - Aug 16, 2020","text":"<p>Improvements:</p> <ul> <li>Add function for removing drawn features #130</li> <li>Add function for extracting pixel values #131</li> <li>Add function for interactive region reduction #35</li> <li>Add machine learning tutorials</li> </ul> <p>Fixes:</p> <ul> <li>Fix js_py conversion bug</li> <li>Fix typos</li> </ul>"},{"location":"changelog/#v0710-aug-5-2020","title":"v0.7.10 - Aug 5, 2020","text":"<p>Improvements:</p> <ul> <li>Add function for getting image properties</li> <li>Add function for calculating descriptive statistics (i.e., min, max, mean, std, sum)</li> <li>Add more utils functions</li> </ul>"},{"location":"changelog/#v077-aug-5-2020","title":"v0.7.7 - Aug 5, 2020","text":"<p>Improvements:</p> <ul> <li>Add support for publishing maps #109</li> <li>Add <code>find_layer()</code> function</li> <li>Add <code>layer_opacity()</code> function</li> <li>Update Readthedocs</li> </ul> <p>Fixes:</p> <ul> <li>Fix duplicate layer bug</li> </ul>"},{"location":"changelog/#v070-may-22-2020","title":"v0.7.0 - May 22, 2020","text":""},{"location":"changelog/#v060-apr-5-2020","title":"v0.6.0 - Apr 5, 2020","text":""},{"location":"changelog/#v050-mar-23-2020","title":"v0.5.0 - Mar 23, 2020","text":""},{"location":"changelog/#v040-mar-19-2020","title":"v0.4.0 - Mar 19, 2020","text":""},{"location":"changelog/#v030-mar-18-2020","title":"v0.3.0 - Mar 18, 2020","text":""},{"location":"changelog/#v020-mar-17-2020","title":"v0.2.0 - Mar 17, 2020","text":""},{"location":"changelog/#v010-mar-8-2020","title":"v0.1.0 - Mar 8, 2020","text":""},{"location":"chart/","title":"chart module","text":"<p>Module for creating charts for Earth Engine data.</p>"},{"location":"chart/#geemap.chart.BarChart","title":"<code> BarChart            (BaseChartClass)         </code>","text":"<p>Create Bar Chart. All histogram/bar charts can use this object.</p> Source code in <code>geemap/chart.py</code> <pre><code>class BarChart(BaseChartClass):\n\"\"\"Create Bar Chart. All histogram/bar charts can use this object.\"\"\"\n\n    def __init__(self, features, default_labels, name, type=\"grouped\", **kwargs):\n        super().__init__(features, default_labels, name, **kwargs)\n        self.type = type\n\n    def generate_tooltip(self):\n        if (self.xlabel is not None) and (self.ylabel is not None):\n            self.bar_chart.tooltip = Tooltip(\n                fields=[\"x\", \"y\"], labels=[self.xlabel, self.ylabel]\n            )\n        else:\n            self.bar_chart.tooltip = Tooltip(fields=[\"x\", \"y\"])\n\n    def get_ylim(self):\n        if self.ylim:\n            ylim_min, ylim_max = self.ylim[0], self.ylim[1]\n        else:\n            if self.name in [\"feature.byFeature\", \"feature.byProperty\"]:\n                ylim_min = np.min(self.y_data)\n                ylim_max = np.max(self.y_data) + 0.2 * (\n                    np.max(self.y_data) - np.min(self.y_data)\n                )\n            if self.name in [\"feature.groups\"]:\n                ylim_min = np.min(self.df[self.yProperty])\n                ylim_max = np.max(self.df[self.yProperty])\n                ylim_max = ylim_max + 0.2 * (ylim_max - ylim_min)\n        return (ylim_min, ylim_max)\n\n    def plot_chart(self):\n        fig = plt.figure(\n            title=self.title,\n            legend_location=self.legend_location,\n        )\n\n        self.bar_chart = plt.bar(\n            self.x_data,\n            self.y_data,\n            labels=self.labels,\n            display_legend=self.display_legend,\n        )\n\n        self.generate_tooltip()\n        plt.ylim(*self.get_ylim())\n        plt.xlabel(self.xlabel)\n        plt.ylabel(self.ylabel)\n\n        if self.width:\n            fig.layout.width = self.width\n        if self.height:\n            fig.layout.height = self.height\n\n        self.bar_chart.colors = self.colors\n        self.bar_chart.type = self.type\n\n        plt.show()\n</code></pre>"},{"location":"chart/#geemap.chart.BaseChartClass","title":"<code> BaseChartClass        </code>","text":"<p>This should include everything a chart module requires to plot figures.</p> Source code in <code>geemap/chart.py</code> <pre><code>class BaseChartClass:\n\"\"\"This should include everything a chart module requires to plot figures.\"\"\"\n\n    def __init__(self, features, default_labels, name, **kwargs):\n        self.ylim = None\n        self.xlim = None\n        self.title = \"\"\n        self.legend_location = \"top-left\"\n        self.layout_width = None\n        self.layout_height = None\n        self.display_legend = True\n        self.xlabel = None\n        self.ylabel = None\n        self.labels = default_labels\n        self.width = None\n        self.height = None\n        self.colors = \"black\"\n        self.df = ee_to_df(features)\n        self.name = name\n\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n    @classmethod\n    def get_data(self):\n        pass\n\n    @classmethod\n    def plot_chart(self):\n        pass\n\n    def __repr__(self):\n        return self.name\n</code></pre>"},{"location":"chart/#geemap.chart.Feature_ByFeature","title":"<code> Feature_ByFeature            (BarChart)         </code>","text":"<p>A object to define variables and get_data method.</p> Source code in <code>geemap/chart.py</code> <pre><code>class Feature_ByFeature(BarChart):\n\"\"\"A object to define variables and get_data method.\"\"\"\n\n    def __init__(\n        self, features, xProperty, yProperties, name=\"feature.byFeature\", **kwargs\n    ):\n        default_labels = yProperties\n        super().__init__(features, default_labels, name, **kwargs)\n        self.x_data, self.y_data = self.get_data(xProperty, yProperties)\n\n    def get_data(self, xProperty, yProperties):\n        x_data = list(self.df[xProperty])\n        y_data = list(self.df[yProperties].values.T)\n        return x_data, y_data\n</code></pre>"},{"location":"chart/#geemap.chart.Feature_ByProperty","title":"<code> Feature_ByProperty            (BarChart)         </code>","text":"<p>A object to define variables and get_data method.</p> Source code in <code>geemap/chart.py</code> <pre><code>class Feature_ByProperty(BarChart):\n\"\"\"A object to define variables and get_data method.\"\"\"\n\n    def __init__(\n        self, features, xProperties, seriesProperty, name=\"feature.byProperty\", **kwargs\n    ):\n        default_labels = None\n        super().__init__(features, default_labels, name, **kwargs)\n        if \"labels\" in kwargs:\n            raise Exception(\"Please remove labels in kwargs and try again.\")\n\n        self.labels = list(self.df[seriesProperty])\n        self.x_data, self.y_data = self.get_data(xProperties)\n\n    def get_data(self, xProperties):\n        if isinstance(xProperties, list):\n            x_data = xProperties\n            y_data = self.df[xProperties].values\n        elif isinstance(xProperties, dict):\n            x_data = list(xProperties.values())\n            y_data = self.df[list(xProperties.keys())].values\n        else:\n            raise Exception(\"xProperties must be a list or dictionary.\")\n\n        return x_data, y_data\n</code></pre>"},{"location":"chart/#geemap.chart.Feature_Groups","title":"<code> Feature_Groups            (BarChart)         </code>","text":"<p>A object to define variables and get_data method.</p> Source code in <code>geemap/chart.py</code> <pre><code>class Feature_Groups(BarChart):\n\"\"\"A object to define variables and get_data method.\"\"\"\n\n    def __init__(\n        self,\n        features,\n        xProperty,\n        yProperty,\n        seriesProperty,\n        name=\"feature.groups\",\n        type=\"stacked\",\n        **kwargs,\n    ):\n        df = ee_to_df(features)\n        self.unique_series_values = df[seriesProperty].unique().tolist()\n        default_labels = [str(x) for x in self.unique_series_values]\n        self.yProperty = yProperty\n        super().__init__(features, default_labels, name, type, **kwargs)\n\n        self.new_column_names = self.get_column_names(seriesProperty, yProperty)\n        self.x_data, self.y_data = self.get_data(xProperty, self.new_column_names)\n\n    def get_column_names(self, seriesProperty, yProperty):\n        new_column_names = []\n\n        for value in self.unique_series_values:\n            sample_filter = (self.df[seriesProperty] == value).map({True: 1, False: 0})\n            column_name = str(yProperty) + \"_\" + str(value)\n            self.df[column_name] = self.df[yProperty] * sample_filter\n            new_column_names.append(column_name)\n\n        return new_column_names\n\n    def get_data(self, xProperty, new_column_names):\n        x_data = list(self.df[xProperty])\n        y_data = [self.df[x] for x in new_column_names]\n\n        return x_data, y_data\n</code></pre>"},{"location":"chart/#geemap.chart.feature_byFeature","title":"<code>feature_byFeature(features, xProperty, yProperties, **kwargs)</code>","text":"<p>Generates a Chart from a set of features. Plots the value of one or more properties for each feature. Reference: https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturebyfeature</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>ee.FeatureCollection</code> <p>The feature collection to generate a chart from.</p> required <code>xProperty</code> <code>str</code> <p>Features labeled by xProperty.</p> required <code>yProperties</code> <code>list</code> <p>Values of yProperties.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>Errors when creating the chart.</p> Source code in <code>geemap/chart.py</code> <pre><code>def feature_byFeature(\n    features: ee.FeatureCollection, xProperty: str, yProperties: list, **kwargs\n):\n\"\"\"Generates a Chart from a set of features. Plots the value of one or more properties for each feature.\n    Reference: https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturebyfeature\n\n    Args:\n        features (ee.FeatureCollection): The feature collection to generate a chart from.\n        xProperty (str): Features labeled by xProperty.\n        yProperties (list): Values of yProperties.\n\n    Raises:\n        Exception: Errors when creating the chart.\n    \"\"\"\n    bar = Feature_ByFeature(\n        features=features, xProperty=xProperty, yProperties=yProperties, **kwargs\n    )\n\n    try:\n        bar.plot_chart()\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"chart/#geemap.chart.feature_byProperty","title":"<code>feature_byProperty(features, xProperties, seriesProperty, **kwargs)</code>","text":"<p>Generates a Chart from a set of features. Plots property values of one or more features. Reference: https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturebyproperty</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>ee.FeatureCollection</code> <p>The features to include in the chart.</p> required <code>xProperties</code> <code>list | dict</code> <p>One of (1) a list of properties to be plotted on the x-axis; or (2) a (property, label) dictionary specifying labels for properties to be used as values on the x-axis.</p> required <code>seriesProperty</code> <code>str</code> <p>The name of the property used to label each feature in the legend.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>If the provided xProperties is not a list or dict.</p> <code>Exception</code> <p>If the chart fails to create.</p> Source code in <code>geemap/chart.py</code> <pre><code>def feature_byProperty(\n    features: ee.FeatureCollection,\n    xProperties: Union[list, dict],\n    seriesProperty: str,\n    **kwargs,\n):\n\"\"\"Generates a Chart from a set of features. Plots property values of one or more features.\n    Reference: https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturebyproperty\n\n    Args:\n        features (ee.FeatureCollection): The features to include in the chart.\n        xProperties (list | dict): One of (1) a list of properties to be plotted on the x-axis; or\n            (2) a (property, label) dictionary specifying labels for properties to be used as values on the x-axis.\n        seriesProperty (str): The name of the property used to label each feature in the legend.\n\n    Raises:\n        Exception: If the provided xProperties is not a list or dict.\n        Exception: If the chart fails to create.\n    \"\"\"\n    bar = Feature_ByProperty(\n        features=features,\n        xProperties=xProperties,\n        seriesProperty=seriesProperty,\n        **kwargs,\n    )\n\n    try:\n        bar.plot_chart()\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"chart/#geemap.chart.feature_groups","title":"<code>feature_groups(features, xProperty, yProperty, seriesProperty, **kwargs)</code>","text":"<p>Generates a Chart from a set of features. Plots the value of one property for each feature. Reference: https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturegroups</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>ee.FeatureCollection</code> <p>The feature collection to make a chart from.</p> required <code>xProperty</code> <code>str</code> <p>Features labeled by xProperty.</p> required <code>yProperty</code> <code>str</code> <p>Features labeled by yProperty.</p> required <code>seriesProperty</code> <code>str</code> <p>The property used to label each feature in the legend.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>Errors when creating the chart.</p> Source code in <code>geemap/chart.py</code> <pre><code>def feature_groups(features, xProperty, yProperty, seriesProperty, **kwargs):\n\"\"\"Generates a Chart from a set of features.\n    Plots the value of one property for each feature.\n    Reference:\n    https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturegroups\n    Args:\n        features (ee.FeatureCollection): The feature collection to make a chart from.\n        xProperty (str): Features labeled by xProperty.\n        yProperty (str): Features labeled by yProperty.\n        seriesProperty (str): The property used to label each feature in the legend.\n    Raises:\n        Exception: Errors when creating the chart.\n    \"\"\"\n\n    bar = Feature_Groups(\n        features=features,\n        xProperty=xProperty,\n        yProperty=yProperty,\n        seriesProperty=seriesProperty,\n        **kwargs,\n    )\n\n    try:\n        bar.plot_chart()\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"chart/#geemap.chart.feature_histogram","title":"<code>feature_histogram(features, property, maxBuckets=None, minBucketWidth=None, show=True, **kwargs)</code>","text":"<p>Generates a Chart from a set of features. Computes and plots a histogram of the given property. - X-axis = Histogram buckets (of property value). - Y-axis = Frequency</p> <p>Reference: https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturehistogram</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code> (ee.FeatureCollection</code> <p>The features to include in the chart.</p> required <code>property</code> <code>                  (str</code> <p>The name of the property to generate the histogram for.</p> required <code>maxBuckets</code> <code>      (int</code> <p>The maximum number of buckets (bins) to use when building a histogram;                               will be rounded up to a power of 2.</p> <code>None</code> <code>minBucketWidth</code> <code>float</code> <p>The minimum histogram bucket width, or null to allow any power of 2.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to show the chart. If not, it will return the bqplot chart object, which can be used to retrieve data for the chart. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>Exception</code> <p>If the provided xProperties is not a list or dict.</p> <code>Exception</code> <p>If the chart fails to create.</p> Source code in <code>geemap/chart.py</code> <pre><code>def feature_histogram(\n    features, property, maxBuckets=None, minBucketWidth=None, show=True, **kwargs\n):\n\"\"\"\n    Generates a Chart from a set of features.\n    Computes and plots a histogram of the given property.\n    - X-axis = Histogram buckets (of property value).\n    - Y-axis = Frequency\n\n    Reference:\n    https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturehistogram\n\n    Args:\n        features  (ee.FeatureCollection): The features to include in the chart.\n        property                   (str): The name of the property to generate the histogram for.\n        maxBuckets       (int, optional): The maximum number of buckets (bins) to use when building a histogram;\n                                          will be rounded up to a power of 2.\n        minBucketWidth (float, optional): The minimum histogram bucket width, or null to allow any power of 2.\n        show (bool, optional): Whether to show the chart. If not, it will return the bqplot chart object, which can be used to retrieve data for the chart. Defaults to True.\n\n    Raises:\n        Exception: If the provided xProperties is not a list or dict.\n        Exception: If the chart fails to create.\n    \"\"\"\n    import math\n\n    if not isinstance(features, ee.FeatureCollection):\n        raise Exception(\"features must be an ee.FeatureCollection\")\n\n    first = features.first()\n    props = first.propertyNames().getInfo()\n    if property not in props:\n        raise Exception(\n            f\"property {property} not found. Available properties: {', '.join(props)}\"\n        )\n\n    def nextPowerOf2(n):\n        return pow(2, math.ceil(math.log2(n)))\n\n    def grow_bin(bin_size, ref):\n        while bin_size &lt; ref:\n            bin_size *= 2\n        return bin_size\n\n    try:\n        raw_data = pd.to_numeric(\n            pd.Series(features.aggregate_array(property).getInfo())\n        )\n        y_data = raw_data.tolist()\n\n        if \"ylim\" in kwargs:\n            min_value = kwargs[\"ylim\"][0]\n            max_value = kwargs[\"ylim\"][1]\n        else:\n            min_value = raw_data.min()\n            max_value = raw_data.max()\n\n        data_range = max_value - min_value\n\n        if not maxBuckets:\n            initial_bin_size = nextPowerOf2(data_range / pow(2, 8))\n            if minBucketWidth:\n                if minBucketWidth &lt; initial_bin_size:\n                    bin_size = grow_bin(minBucketWidth, initial_bin_size)\n                else:\n                    bin_size = minBucketWidth\n            else:\n                bin_size = initial_bin_size\n        else:\n            initial_bin_size = math.ceil(data_range / nextPowerOf2(maxBuckets))\n            if minBucketWidth:\n                if minBucketWidth &lt; initial_bin_size:\n                    bin_size = grow_bin(minBucketWidth, initial_bin_size)\n                else:\n                    bin_size = minBucketWidth\n            else:\n                bin_size = initial_bin_size\n\n        start_bins = (math.floor(min_value / bin_size) * bin_size) - (bin_size / 2)\n        end_bins = (math.ceil(max_value / bin_size) * bin_size) + (bin_size / 2)\n\n        if start_bins &lt; min_value:\n            y_data.append(start_bins)\n        else:\n            y_data[y_data.index(min_value)] = start_bins\n        if end_bins &gt; max_value:\n            y_data.append(end_bins)\n        else:\n            y_data[y_data.index(max_value)] = end_bins\n\n        num_bins = math.floor((end_bins - start_bins) / bin_size)\n\n        if \"title\" not in kwargs:\n            title = \"\"\n        else:\n            title = kwargs[\"title\"]\n\n        fig = plt.figure(title=title)\n\n        if \"width\" in kwargs:\n            fig.layout.width = kwargs[\"width\"]\n        if \"height\" in kwargs:\n            fig.layout.height = kwargs[\"height\"]\n\n        if \"xlabel\" not in kwargs:\n            xlabel = \"\"\n        else:\n            xlabel = kwargs[\"xlabel\"]\n\n        if \"ylabel\" not in kwargs:\n            ylabel = \"\"\n        else:\n            ylabel = kwargs[\"ylabel\"]\n\n        histogram = plt.hist(\n            sample=y_data,\n            bins=num_bins,\n            axes_options={\"count\": {\"label\": ylabel}, \"sample\": {\"label\": xlabel}},\n        )\n\n        if \"colors\" in kwargs:\n            histogram.colors = kwargs[\"colors\"]\n        if \"stroke\" in kwargs:\n            histogram.stroke = kwargs[\"stroke\"]\n        else:\n            histogram.stroke = \"#ffffff00\"\n        if \"stroke_width\" in kwargs:\n            histogram.stroke_width = kwargs[\"stroke_width\"]\n        else:\n            histogram.stroke_width = 0\n\n        if (\"xlabel\" in kwargs) and (\"ylabel\" in kwargs):\n            histogram.tooltip = Tooltip(\n                fields=[\"midpoint\", \"count\"],\n                labels=[kwargs[\"xlabel\"], kwargs[\"ylabel\"]],\n            )\n        else:\n            histogram.tooltip = Tooltip(fields=[\"midpoint\", \"count\"])\n\n        if show:\n            plt.show()\n        else:\n            return histogram\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"cheatsheet/","title":"geemap cheat sheet","text":""},{"location":"cheatsheet/#installation","title":"Installation","text":""},{"location":"cheatsheet/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install geemap\n</code></pre>"},{"location":"cheatsheet/#install-from-conda-forge","title":"Install from conda-forge","text":"<pre><code>conda install geemap -c conda-forge\n</code></pre>"},{"location":"cheatsheet/#create-a-new-conda-env","title":"Create a new conda env","text":"<pre><code>conda create -n gee python=3.9\nconda activate gee\nconda install geemap -c conda-forge\n</code></pre>"},{"location":"cheatsheet/#upgrade","title":"Upgrade","text":""},{"location":"cheatsheet/#upgrade-from-pypi","title":"Upgrade from PyPI","text":"<pre><code>pip install -U geemap\n</code></pre>"},{"location":"cheatsheet/#upgrade-from-conda-forge","title":"Upgrade from conda-forge","text":"<pre><code>conda update geemap -c conda-forge\n</code></pre>"},{"location":"cheatsheet/#upgrade-from-github","title":"Upgrade from GitHub","text":"<pre><code>import geemap\ngeemap.update_package()\n</code></pre>"},{"location":"cheatsheet/#map","title":"Map","text":""},{"location":"cheatsheet/#create-an-interactive-map","title":"Create an interactive map","text":"<pre><code>Map = geemap.Map(center=(lat, lon), zoom=4)\nMap\n</code></pre>"},{"location":"cheatsheet/#change-the-default-basemap","title":"Change the default basemap","text":"<pre><code>Map = geemap.Map(basemap='HYBRID')\n</code></pre>"},{"location":"cheatsheet/#add-basemaps","title":"Add basemaps","text":"<pre><code>Map.add_basemap('OpenTopoMap')\n</code></pre>"},{"location":"cheatsheet/#add-xyz-layers","title":"Add XYZ layers","text":"<pre><code>url = 'https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}'\nMap.add_tile_layer(url, name='Google Satellite', attribution='Google')\n</code></pre>"},{"location":"cheatsheet/#add-wms-layers","title":"Add WMS layers","text":"<pre><code>url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?'\nMap.add_wms_layer(url=url, layers='0', name='NAIP Imagery', format='image/png', shown=True)\n</code></pre>"},{"location":"cheatsheet/#add-earth-engine-layers","title":"Add Earth Engine layers","text":"<pre><code>image = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n  'min': 0,\n  'max': 4000,\n  'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']\n  }\nMap.addLayer(image, vis_params, 'SRTM DEM', True, 0.5)\n</code></pre>"},{"location":"cheatsheet/#set-map-center","title":"Set map center","text":"<pre><code>Map.setCenter(lon, lat, zoom)\n</code></pre>"},{"location":"cheatsheet/#center-map-around-an-object","title":"Center map around an object","text":"<pre><code>Map.centerObject(ee_object, zoom)\n</code></pre>"},{"location":"cheatsheet/#add-built-in-legends","title":"Add built-in legends","text":"<pre><code>Map.add_legend(builtin_legend='NLCD')\n</code></pre>"},{"location":"cheatsheet/#add-custom-legends","title":"Add custom legends","text":"<pre><code>Map.add_legend(legend_title, legend_dict, layer_name)\n</code></pre>"},{"location":"cheatsheet/#export-data","title":"Export data","text":""},{"location":"cheatsheet/#export-vector-to-local","title":"Export vector to local","text":"<pre><code>geemap.ee_to_shp(ee_object, filename)\ngeemap.ee_export_geojson(ee_object, filename)\ngeemap.ee_export_vector(ee_object, filename)\n</code></pre>"},{"location":"cheatsheet/#export-vector-to-google-drive","title":"Export vector to Google Drive","text":"<pre><code>ee_export_vector_to_drive(ee_object, description, folder, file_format='shp', selectors=None)\n</code></pre>"},{"location":"cheatsheet/#export-image-to-local","title":"Export image to local","text":"<pre><code>ee_export_image(ee_object, filename, scale=None, crs=None, region=None, file_per_band=False)\n</code></pre>"},{"location":"cheatsheet/#export-image-collection-to-local","title":"Export image collection to local","text":"<pre><code>ee_export_image_collection(ee_object, out_dir, scale=None, crs=None, region=None, file_per_band=False)\n</code></pre>"},{"location":"cheatsheet/#export-image-to-google-drive","title":"Export image to Google Drive","text":"<pre><code>ee_export_image_to_drive(ee_object, description, folder=None, region=None, scale=None, crs=None, file_format='GeoTIFF')\n</code></pre>"},{"location":"cheatsheet/#export-image-collection-to-google-drive","title":"Export image collection to Google Drive","text":"<pre><code>ee_export_image_collection_to_drive(ee_object, descriptions=None, folder=None, region=None, scale=None, crs=None, file_format='GeoTIFF')\n</code></pre>"},{"location":"citations/","title":"Citations","text":"<p>If you find geemap useful in your research, please consider citing the following papers to support my work. Thank you for your support.</p> <ul> <li>Wu, Q., (2020). geemap: A Python package for interactive mapping with Google Earth Engine. The Journal of Open Source Software, 5(51), 2305. https://doi.org/10.21105/joss.02305</li> <li>Wu, Q., Lane, C. R., Li, X., Zhao, K., Zhou, Y., Clinton, N., DeVries, B., Golden, H. E., &amp; Lang, M. W. (2019). Integrating LiDAR data and multi-temporal aerial imagery to map wetland inundation dynamics using Google Earth Engine. Remote Sensing of Environment, 228, 1-13. https://doi.org/10.1016/j.rse.2019.04.015 (pdf | source code)</li> </ul>"},{"location":"colormaps/","title":"colormaps module","text":"<p>Module for commonly used colormaps and palettes for visualizing Earth Engine data.</p>"},{"location":"colormaps/#geemap.colormaps.get_colorbar","title":"<code>get_colorbar(colors, vmin=0, vmax=1, width=6.0, height=0.4, orientation='horizontal', discrete=False, return_fig=False)</code>","text":"<p>Creates a colorbar based on custom colors.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>A list of hex colors.</p> required <code>vmin</code> <code>float</code> <p>The minimum value range. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximum value range. Defaults to 1.0.</p> <code>1</code> <code>width</code> <code>float</code> <p>The width of the colormap. Defaults to 6.0.</p> <code>6.0</code> <code>height</code> <code>float</code> <p>The height of the colormap. Defaults to 0.4.</p> <code>0.4</code> <code>orientation</code> <code>str</code> <p>The orientation of the colormap. Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colormap.</p> <code>False</code> <code>return_fig</code> <code>bool</code> <p>Whether to return the figure. Defaults to False.</p> <code>False</code> Source code in <code>geemap/colormaps.py</code> <pre><code>def get_colorbar(\n    colors,\n    vmin=0,\n    vmax=1,\n    width=6.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    discrete=False,\n    return_fig=False,\n):\n\"\"\"Creates a colorbar based on custom colors.\n\n    Args:\n        colors (list): A list of hex colors.\n        vmin (float, optional): The minimum value range. Defaults to 0.\n        vmax (float, optional): The maximum value range. Defaults to 1.0.\n        width (float, optional): The width of the colormap. Defaults to 6.0.\n        height (float, optional): The height of the colormap. Defaults to 0.4.\n        orientation (str, optional): The orientation of the colormap. Defaults to \"horizontal\".\n        discrete (bool, optional): Whether to create a discrete colormap.\n        return_fig (bool, optional): Whether to return the figure. Defaults to False.\n    \"\"\"\n    hexcodes = [i if i[0] == \"#\" else \"#\" + i for i in colors]\n    fig, ax = plt.subplots(figsize=(width, height))\n    if discrete:\n        cmap = mpl.colors.ListedColormap(hexcodes)\n        vals = np.linspace(vmin, vmax, cmap.N + 1)\n        norm = mpl.colors.BoundaryNorm(vals, cmap.N)\n    else:\n        cmap = mpl.colors.LinearSegmentedColormap.from_list(\"custom\", hexcodes, N=256)\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n    mpl.colorbar.ColorbarBase(ax, norm=norm, cmap=cmap, orientation=orientation)\n    if return_fig:\n        return fig\n    else:\n        plt.show()\n</code></pre>"},{"location":"colormaps/#geemap.colormaps.get_palette","title":"<code>get_palette(cmap_name=None, n_class=None, hashtag=False)</code>","text":"<p>Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>The name of the matplotlib colormap. Defaults to None.</p> <code>None</code> <code>n_class</code> <code>int</code> <p>The number of colors. Defaults to None.</p> <code>None</code> <code>hashtag</code> <code>bool</code> <p>Whether to return a list of hex colors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of hex colors.</p> Source code in <code>geemap/colormaps.py</code> <pre><code>def get_palette(cmap_name=None, n_class=None, hashtag=False):\n\"\"\"Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Args:\n        cmap_name (str, optional): The name of the matplotlib colormap. Defaults to None.\n        n_class (int, optional): The number of colors. Defaults to None.\n        hashtag (bool, optional): Whether to return a list of hex colors. Defaults to False.\n\n    Returns:\n        list: A list of hex colors.\n    \"\"\"\n\n    if cmap_name in [\"ndvi\", \"ndwi\", \"dem\", \"dw\", \"esri_lulc\"]:\n        colors = _palette_dict[cmap_name]\n    else:\n        cmap = plt.cm.get_cmap(cmap_name, n_class)\n        colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n    if hashtag:\n        colors = [\"#\" + i for i in colors]\n\n    return colors\n</code></pre>"},{"location":"colormaps/#geemap.colormaps.list_colormaps","title":"<code>list_colormaps(add_extra=False, lowercase=False)</code>","text":"<p>List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of colormap names.</p> Source code in <code>geemap/colormaps.py</code> <pre><code>def list_colormaps(add_extra=False, lowercase=False):\n\"\"\"List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Returns:\n        list: The list of colormap names.\n    \"\"\"\n    result = plt.colormaps()\n    if add_extra:\n        result += [\"dem\", \"ndvi\", \"ndwi\"]\n    if lowercase:\n        result = [i.lower() for i in result]\n    result.sort()\n    return result\n</code></pre>"},{"location":"colormaps/#geemap.colormaps.plot_colormap","title":"<code>plot_colormap(cmap, width=8.0, height=0.4, orientation='horizontal', vmin=0, vmax=1.0, axis_off=True, show_name=False, font_size=12, return_fig=False)</code>","text":"<p>Plot a matplotlib colormap.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str</code> <p>The name of the colormap.</p> required <code>width</code> <code>float</code> <p>The width of the colormap. Defaults to 8.0.</p> <code>8.0</code> <code>height</code> <code>float</code> <p>The height of the colormap. Defaults to 0.4.</p> <code>0.4</code> <code>orientation</code> <code>str</code> <p>The orientation of the colormap. Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>vmin</code> <code>float</code> <p>The minimum value range. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximum value range. Defaults to 1.0.</p> <code>1.0</code> <code>axis_off</code> <code>bool</code> <p>Whether to turn axis off. Defaults to True.</p> <code>True</code> <code>show_name</code> <code>bool</code> <p>Whether to show the colormap name. Defaults to False.</p> <code>False</code> <code>font_size</code> <code>int</code> <p>Font size of the text. Defaults to 12.</p> <code>12</code> <code>return_fig</code> <code>bool</code> <p>Whether to return the figure. Defaults to False.</p> <code>False</code> Source code in <code>geemap/colormaps.py</code> <pre><code>def plot_colormap(\n    cmap,\n    width=8.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=1.0,\n    axis_off=True,\n    show_name=False,\n    font_size=12,\n    return_fig=False,\n):\n\"\"\"Plot a matplotlib colormap.\n\n    Args:\n        cmap (str): The name of the colormap.\n        width (float, optional): The width of the colormap. Defaults to 8.0.\n        height (float, optional): The height of the colormap. Defaults to 0.4.\n        orientation (str, optional): The orientation of the colormap. Defaults to \"horizontal\".\n        vmin (float, optional): The minimum value range. Defaults to 0.\n        vmax (float, optional): The maximum value range. Defaults to 1.0.\n        axis_off (bool, optional): Whether to turn axis off. Defaults to True.\n        show_name (bool, optional): Whether to show the colormap name. Defaults to False.\n        font_size (int, optional): Font size of the text. Defaults to 12.\n        return_fig (bool, optional): Whether to return the figure. Defaults to False.\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(width, height))\n    col_map = plt.get_cmap(cmap)\n\n    norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    mpl.colorbar.ColorbarBase(ax, norm=norm, cmap=col_map, orientation=orientation)\n    if axis_off:\n        ax.set_axis_off()\n\n    if show_name:\n        pos = list(ax.get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3] / 2.0\n        fig.text(x_text, y_text, cmap, va=\"center\", ha=\"right\", fontsize=font_size)\n\n    if return_fig:\n        return fig\n    else:\n        plt.show()\n</code></pre>"},{"location":"colormaps/#geemap.colormaps.plot_colormaps","title":"<code>plot_colormaps(width=8.0, height=0.4)</code>","text":"<p>Plot all available colormaps.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the colormap. Defaults to 8.0.</p> <code>8.0</code> <code>height</code> <code>float</code> <p>Height of the colormap. Defaults to 0.4.</p> <code>0.4</code> Source code in <code>geemap/colormaps.py</code> <pre><code>def plot_colormaps(width=8.0, height=0.4):\n\"\"\"Plot all available colormaps.\n\n    Args:\n        width (float, optional): Width of the colormap. Defaults to 8.0.\n        height (float, optional): Height of the colormap. Defaults to 0.4.\n    \"\"\"\n    cmap_list = list_colormaps()\n    nrows = len(cmap_list)\n    fig, axes = plt.subplots(nrows=nrows, figsize=(width, height * nrows))\n    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99)\n\n    gradient = np.linspace(0, 1, 256)\n    gradient = np.vstack((gradient, gradient))\n\n    for ax, name in zip(axes, cmap_list):\n        ax.imshow(gradient, aspect=\"auto\", cmap=plt.get_cmap(name))\n        ax.set_axis_off()\n        pos = list(ax.get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3] / 2.0\n        fig.text(x_text, y_text, name, va=\"center\", ha=\"right\", fontsize=12)\n\n    # Turn off *all* ticks &amp; spines, not just the ones with colormaps.\n    for ax in axes:\n        ax.set_axis_off()\n\n    plt.show()\n</code></pre>"},{"location":"common/","title":"common module","text":"<p>This module contains some common functions for both folium and ipyleaflet to interact with the Earth Engine Python API.</p>"},{"location":"common/#geemap.common.PlanetaryComputerEndpoint","title":"<code> PlanetaryComputerEndpoint            (TitilerEndpoint)         </code>","text":"<p>This class contains the methods for the Microsoft Planetary Computer endpoint.</p> Source code in <code>geemap/common.py</code> <pre><code>class PlanetaryComputerEndpoint(TitilerEndpoint):\n\"\"\"This class contains the methods for the Microsoft Planetary Computer endpoint.\"\"\"\n\n    def __init__(\n        self,\n        endpoint=\"https://planetarycomputer.microsoft.com/api/data/v1\",\n        name=\"item\",\n        TileMatrixSetId=\"WebMercatorQuad\",\n    ):\n\"\"\"Initialize the PlanetaryComputerEndpoint object.\n\n        Args:\n            endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://planetarycomputer.microsoft.com/api/data/v1\".\n            name (str, optional): The name to be used in the file path. Defaults to \"item\".\n            TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n        \"\"\"\n        super().__init__(endpoint, name, TileMatrixSetId)\n\n    def url_for_stac_collection(self):\n        return f\"{self.endpoint}/collection/{self.TileMatrixSetId}/tilejson.json\"\n\n    def url_for_collection_assets(self):\n        return f\"{self.endpoint}/collection/assets\"\n\n    def url_for_collection_bounds(self):\n        return f\"{self.endpoint}/collection/bounds\"\n\n    def url_for_collection_info(self):\n        return f\"{self.endpoint}/collection/info\"\n\n    def url_for_collection_info_geojson(self):\n        return f\"{self.endpoint}/collection/info.geojson\"\n\n    def url_for_collection_pixel_value(self, lon, lat):\n        return f\"{self.endpoint}/collection/point/{lon},{lat}\"\n\n    def url_for_collection_wmts(self):\n        return f\"{self.endpoint}/collection/{self.TileMatrixSetId}/WMTSCapabilities.xml\"\n\n    def url_for_collection_lat_lon_assets(self, lng, lat):\n        return f\"{self.endpoint}/collection/{lng},{lat}/assets\"\n\n    def url_for_collection_bbox_assets(self, minx, miny, maxx, maxy):\n        return f\"{self.endpoint}/collection/{minx},{miny},{maxx},{maxy}/assets\"\n\n    def url_for_stac_mosaic(self, searchid):\n        return f\"{self.endpoint}/mosaic/{searchid}/{self.TileMatrixSetId}/tilejson.json\"\n\n    def url_for_mosaic_info(self, searchid):\n        return f\"{self.endpoint}/mosaic/{searchid}/info\"\n\n    def url_for_mosaic_lat_lon_assets(self, searchid, lon, lat):\n        return f\"{self.endpoint}/mosaic/{searchid}/{lon},{lat}/assets\"\n</code></pre>"},{"location":"common/#geemap.common.PlanetaryComputerEndpoint.__init__","title":"<code>__init__(self, endpoint='https://planetarycomputer.microsoft.com/api/data/v1', name='item', TileMatrixSetId='WebMercatorQuad')</code>  <code>special</code>","text":"<p>Initialize the PlanetaryComputerEndpoint object.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint of the titiler server. Defaults to \"https://planetarycomputer.microsoft.com/api/data/v1\".</p> <code>'https://planetarycomputer.microsoft.com/api/data/v1'</code> <code>name</code> <code>str</code> <p>The name to be used in the file path. Defaults to \"item\".</p> <code>'item'</code> <code>TileMatrixSetId</code> <code>str</code> <p>The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".</p> <code>'WebMercatorQuad'</code> Source code in <code>geemap/common.py</code> <pre><code>def __init__(\n    self,\n    endpoint=\"https://planetarycomputer.microsoft.com/api/data/v1\",\n    name=\"item\",\n    TileMatrixSetId=\"WebMercatorQuad\",\n):\n\"\"\"Initialize the PlanetaryComputerEndpoint object.\n\n    Args:\n        endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://planetarycomputer.microsoft.com/api/data/v1\".\n        name (str, optional): The name to be used in the file path. Defaults to \"item\".\n        TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n    \"\"\"\n    super().__init__(endpoint, name, TileMatrixSetId)\n</code></pre>"},{"location":"common/#geemap.common.TitilerEndpoint","title":"<code> TitilerEndpoint        </code>","text":"<p>This class contains the methods for the titiler endpoint.</p> Source code in <code>geemap/common.py</code> <pre><code>class TitilerEndpoint:\n\"\"\"This class contains the methods for the titiler endpoint.\"\"\"\n\n    def __init__(\n        self,\n        endpoint=\"https://titiler.xyz\",\n        name=\"stac\",\n        TileMatrixSetId=\"WebMercatorQuad\",\n    ):\n\"\"\"Initialize the TitilerEndpoint object.\n\n        Args:\n            endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://titiler.xyz\".\n            name (str, optional): The name to be used in the file path. Defaults to \"stac\".\n            TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n        \"\"\"\n        self.endpoint = endpoint\n        self.name = name\n        self.TileMatrixSetId = TileMatrixSetId\n\n    def url_for_stac_item(self):\n        return f\"{self.endpoint}/{self.name}/{self.TileMatrixSetId}/tilejson.json\"\n\n    def url_for_stac_assets(self):\n        return f\"{self.endpoint}/{self.name}/assets\"\n\n    def url_for_stac_bounds(self):\n        return f\"{self.endpoint}/{self.name}/bounds\"\n\n    def url_for_stac_info(self):\n        return f\"{self.endpoint}/{self.name}/info\"\n\n    def url_for_stac_info_geojson(self):\n        return f\"{self.endpoint}/{self.name}/info.geojson\"\n\n    def url_for_stac_statistics(self):\n        return f\"{self.endpoint}/{self.name}/statistics\"\n\n    def url_for_stac_pixel_value(self, lon, lat):\n        return f\"{self.endpoint}/{self.name}/point/{lon},{lat}\"\n\n    def url_for_stac_wmts(self):\n        return (\n            f\"{self.endpoint}/{self.name}/{self.TileMatrixSetId}/WMTSCapabilities.xml\"\n        )\n</code></pre>"},{"location":"common/#geemap.common.TitilerEndpoint.__init__","title":"<code>__init__(self, endpoint='https://titiler.xyz', name='stac', TileMatrixSetId='WebMercatorQuad')</code>  <code>special</code>","text":"<p>Initialize the TitilerEndpoint object.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint of the titiler server. Defaults to \"https://titiler.xyz\".</p> <code>'https://titiler.xyz'</code> <code>name</code> <code>str</code> <p>The name to be used in the file path. Defaults to \"stac\".</p> <code>'stac'</code> <code>TileMatrixSetId</code> <code>str</code> <p>The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".</p> <code>'WebMercatorQuad'</code> Source code in <code>geemap/common.py</code> <pre><code>def __init__(\n    self,\n    endpoint=\"https://titiler.xyz\",\n    name=\"stac\",\n    TileMatrixSetId=\"WebMercatorQuad\",\n):\n\"\"\"Initialize the TitilerEndpoint object.\n\n    Args:\n        endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://titiler.xyz\".\n        name (str, optional): The name to be used in the file path. Defaults to \"stac\".\n        TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n    \"\"\"\n    self.endpoint = endpoint\n    self.name = name\n    self.TileMatrixSetId = TileMatrixSetId\n</code></pre>"},{"location":"common/#geemap.common.add_crs","title":"<code>add_crs(filename, epsg)</code>","text":"<p>Add a CRS to a raster dataset.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the raster dataset.</p> required <code>epsg</code> <code>int | str</code> <p>The EPSG code of the CRS.</p> required Source code in <code>geemap/common.py</code> <pre><code>def add_crs(filename, epsg):\n\"\"\"Add a CRS to a raster dataset.\n\n    Args:\n        filename (str): The filename of the raster dataset.\n        epsg (int | str): The EPSG code of the CRS.\n\n    \"\"\"\n    try:\n        import rasterio\n    except ImportError:\n        raise ImportError(\n            \"rasterio is required for adding a CRS to a raster. Please install it using 'pip install rasterio'.\"\n        )\n\n    if not os.path.exists(filename):\n        raise ValueError(\"filename must exist.\")\n\n    if isinstance(epsg, int):\n        epsg = f\"EPSG:{epsg}\"\n    elif isinstance(epsg, str):\n        epsg = \"EPSG:\" + epsg\n    else:\n        raise ValueError(\"epsg must be an integer or string.\")\n\n    crs = rasterio.crs.CRS({\"init\": epsg})\n    with rasterio.open(filename, mode=\"r+\") as src:\n        src.crs = crs\n</code></pre>"},{"location":"common/#geemap.common.adjust_longitude","title":"<code>adjust_longitude(in_fc)</code>","text":"<p>Adjusts longitude if it is less than -180 or greater than 180.</p> <p>Parameters:</p> Name Type Description Default <code>in_fc</code> <code>dict</code> <p>The input dictionary containing coordinates.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the converted longitudes</p> Source code in <code>geemap/common.py</code> <pre><code>def adjust_longitude(in_fc):\n\"\"\"Adjusts longitude if it is less than -180 or greater than 180.\n\n    Args:\n        in_fc (dict): The input dictionary containing coordinates.\n\n    Returns:\n        dict: A dictionary containing the converted longitudes\n    \"\"\"\n    try:\n        keys = in_fc.keys()\n\n        if \"geometry\" in keys:\n            coordinates = in_fc[\"geometry\"][\"coordinates\"]\n\n            if in_fc[\"geometry\"][\"type\"] == \"Point\":\n                longitude = coordinates[0]\n                if longitude &lt; -180:\n                    longitude = 360 + longitude\n                elif longitude &gt; 180:\n                    longitude = longitude - 360\n                in_fc[\"geometry\"][\"coordinates\"][0] = longitude\n\n            elif in_fc[\"geometry\"][\"type\"] == \"Polygon\":\n                for index1, item in enumerate(coordinates):\n                    for index2, element in enumerate(item):\n                        longitude = element[0]\n                        if longitude &lt; -180:\n                            longitude = 360 + longitude\n                        elif longitude &gt; 180:\n                            longitude = longitude - 360\n                        in_fc[\"geometry\"][\"coordinates\"][index1][index2][0] = longitude\n\n            elif in_fc[\"geometry\"][\"type\"] == \"LineString\":\n                for index, element in enumerate(coordinates):\n                    longitude = element[0]\n                    if longitude &lt; -180:\n                        longitude = 360 + longitude\n                    elif longitude &gt; 180:\n                        longitude = longitude - 360\n                    in_fc[\"geometry\"][\"coordinates\"][index][0] = longitude\n\n        elif \"type\" in keys:\n            coordinates = in_fc[\"coordinates\"]\n\n            if in_fc[\"type\"] == \"Point\":\n                longitude = coordinates[0]\n                if longitude &lt; -180:\n                    longitude = 360 + longitude\n                elif longitude &gt; 180:\n                    longitude = longitude - 360\n                in_fc[\"coordinates\"][0] = longitude\n\n            elif in_fc[\"type\"] == \"Polygon\":\n                for index1, item in enumerate(coordinates):\n                    for index2, element in enumerate(item):\n                        longitude = element[0]\n                        if longitude &lt; -180:\n                            longitude = 360 + longitude\n                        elif longitude &gt; 180:\n                            longitude = longitude - 360\n                        in_fc[\"coordinates\"][index1][index2][0] = longitude\n\n            elif in_fc[\"type\"] == \"LineString\":\n                for index, element in enumerate(coordinates):\n                    longitude = element[0]\n                    if longitude &lt; -180:\n                        longitude = 360 + longitude\n                    elif longitude &gt; 180:\n                        longitude = longitude - 360\n                    in_fc[\"coordinates\"][index][0] = longitude\n\n        return in_fc\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"common/#geemap.common.annual_NAIP","title":"<code>annual_NAIP(year, region)</code>","text":"<p>Create an NAIP mosaic of a specified year for a specified region.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The specified year to create the mosaic for.</p> required <code>region</code> <code>object</code> <p>ee.Geometry</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.Image</p> Source code in <code>geemap/common.py</code> <pre><code>def annual_NAIP(year, region):\n\"\"\"Create an NAIP mosaic of a specified year for a specified region.\n\n    Args:\n        year (int): The specified year to create the mosaic for.\n        region (object): ee.Geometry\n\n    Returns:\n        object: ee.Image\n    \"\"\"\n\n    start_date = ee.Date.fromYMD(year, 1, 1)\n    end_date = ee.Date.fromYMD(year, 12, 31)\n    collection = (\n        ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n        .filterDate(start_date, end_date)\n        .filterBounds(region)\n    )\n\n    time_start = ee.Date(\n        ee.List(collection.aggregate_array(\"system:time_start\")).sort().get(0)\n    )\n    time_end = ee.Date(\n        ee.List(collection.aggregate_array(\"system:time_end\")).sort().get(-1)\n    )\n    image = ee.Image(collection.mosaic().clip(region))\n    NDWI = ee.Image(image).normalizedDifference([\"G\", \"N\"]).select([\"nd\"], [\"ndwi\"])\n    NDVI = ee.Image(image).normalizedDifference([\"N\", \"R\"]).select([\"nd\"], [\"ndvi\"])\n    image = image.addBands(NDWI)\n    image = image.addBands(NDVI)\n    return image.set({\"system:time_start\": time_start, \"system:time_end\": time_end})\n</code></pre>"},{"location":"common/#geemap.common.api_docs","title":"<code>api_docs()</code>","text":"<p>Open a browser and navigate to the geemap API documentation.</p> Source code in <code>geemap/common.py</code> <pre><code>def api_docs():\n\"\"\"Open a browser and navigate to the geemap API documentation.\"\"\"\n    import webbrowser\n\n    url = \"https://geemap.org/geemap\"\n    webbrowser.open_new_tab(url)\n</code></pre>"},{"location":"common/#geemap.common.arc_active_map","title":"<code>arc_active_map()</code>","text":"<p>Get the active map in ArcGIS Pro.</p> <p>Returns:</p> Type Description <code>arcpy.Map</code> <p>The active map in ArcGIS Pro.</p> Source code in <code>geemap/common.py</code> <pre><code>def arc_active_map():\n\"\"\"Get the active map in ArcGIS Pro.\n\n    Returns:\n        arcpy.Map: The active map in ArcGIS Pro.\n    \"\"\"\n    if is_arcpy():\n        import arcpy\n\n        aprx = arcpy.mp.ArcGISProject(\"CURRENT\")\n        m = aprx.activeMap\n        return m\n    else:\n        return None\n</code></pre>"},{"location":"common/#geemap.common.arc_active_view","title":"<code>arc_active_view()</code>","text":"<p>Get the active view in ArcGIS Pro.</p> <p>Returns:</p> Type Description <code>arcpy.MapView</code> <p>The active view in ArcGIS Pro.</p> Source code in <code>geemap/common.py</code> <pre><code>def arc_active_view():\n\"\"\"Get the active view in ArcGIS Pro.\n\n    Returns:\n        arcpy.MapView: The active view in ArcGIS Pro.\n    \"\"\"\n    if is_arcpy():\n        import arcpy\n\n        aprx = arcpy.mp.ArcGISProject(\"CURRENT\")\n        view = aprx.activeView\n        return view\n    else:\n        return None\n</code></pre>"},{"location":"common/#geemap.common.arc_add_layer","title":"<code>arc_add_layer(url, name=None, shown=True, opacity=1.0)</code>","text":"<p>Add a layer to the active map in ArcGIS Pro.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer to add.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Defaults to None.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>Whether the layer is shown. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>geemap/common.py</code> <pre><code>def arc_add_layer(url, name=None, shown=True, opacity=1.0):\n\"\"\"Add a layer to the active map in ArcGIS Pro.\n\n    Args:\n        url (str): The URL of the tile layer to add.\n        name (str, optional): The name of the layer. Defaults to None.\n        shown (bool, optional): Whether the layer is shown. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n    \"\"\"\n    if is_arcpy():\n        m = arc_active_map()\n        if m is not None:\n            m.addDataFromPath(url)\n            if isinstance(name, str):\n                layers = m.listLayers(\"Tiled service layer\")\n                if len(layers) &gt; 0:\n                    layer = layers[0]\n                    layer.name = name\n                    layer.visible = shown\n                    layer.transparency = 100 - (opacity * 100)\n</code></pre>"},{"location":"common/#geemap.common.arc_zoom_to_extent","title":"<code>arc_zoom_to_extent(xmin, ymin, xmax, ymax)</code>","text":"<p>Zoom to an extent in ArcGIS Pro.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>The minimum x value of the extent.</p> required <code>ymin</code> <code>float</code> <p>The minimum y value of the extent.</p> required <code>xmax</code> <code>float</code> <p>The maximum x value of the extent.</p> required <code>ymax</code> <code>float</code> <p>The maximum y value of the extent.</p> required Source code in <code>geemap/common.py</code> <pre><code>def arc_zoom_to_extent(xmin, ymin, xmax, ymax):\n\"\"\"Zoom to an extent in ArcGIS Pro.\n\n    Args:\n        xmin (float): The minimum x value of the extent.\n        ymin (float): The minimum y value of the extent.\n        xmax (float): The maximum x value of the extent.\n        ymax (float): The maximum y value of the extent.\n    \"\"\"\n    if is_arcpy():\n        import arcpy\n\n        view = arc_active_view()\n        if view is not None:\n            view.camera.setExtent(\n                arcpy.Extent(\n                    xmin,\n                    ymin,\n                    xmax,\n                    ymax,\n                    spatial_reference=arcpy.SpatialReference(4326),\n                )\n            )\n\n        # if isinstance(zoom, int):\n        #     scale = 156543.04 * math.cos(0) / math.pow(2, zoom)\n        #     view.camera.scale = scale  # Not working properly\n</code></pre>"},{"location":"common/#geemap.common.array_mean","title":"<code>array_mean(arr)</code>","text":"<p>Calculates the mean of an array along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>object</code> <p>Array to calculate mean.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.Number</p> Source code in <code>geemap/common.py</code> <pre><code>def array_mean(arr):\n\"\"\"Calculates the mean of an array along the given axis.\n\n    Args:\n        arr (object): Array to calculate mean.\n\n    Returns:\n        object: ee.Number\n    \"\"\"\n    total = ee.Array(arr).accum(0).get([-1])\n    size = arr.length()\n    return ee.Number(total.divide(size))\n</code></pre>"},{"location":"common/#geemap.common.array_sum","title":"<code>array_sum(arr)</code>","text":"<p>Accumulates elements of an array along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>object</code> <p>Array to accumulate.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.Number</p> Source code in <code>geemap/common.py</code> <pre><code>def array_sum(arr):\n\"\"\"Accumulates elements of an array along the given axis.\n\n    Args:\n        arr (object): Array to accumulate.\n\n    Returns:\n        object: ee.Number\n    \"\"\"\n    return ee.Array(arr).accum(0).get([-1])\n</code></pre>"},{"location":"common/#geemap.common.bands_to_image_collection","title":"<code>bands_to_image_collection(img)</code>","text":"<p>Converts all bands in an image to an image collection.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>The image to convert.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.ImageCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def bands_to_image_collection(img):\n\"\"\"Converts all bands in an image to an image collection.\n\n    Args:\n        img (object): The image to convert.\n\n    Returns:\n        object: ee.ImageCollection\n    \"\"\"\n    collection = ee.ImageCollection(img.bandNames().map(lambda b: img.select([b])))\n    return collection\n</code></pre>"},{"location":"common/#geemap.common.bbox_coords","title":"<code>bbox_coords(geometry, decimals=4)</code>","text":"<p>Get the bounding box coordinates of a geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The input geometry.</p> required <code>decimals</code> <code>int</code> <p>The number of decimals to round to. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>list</code> <p>The bounding box coordinates in the form [west, south, east, north].</p> Source code in <code>geemap/common.py</code> <pre><code>def bbox_coords(geometry, decimals=4):\n\"\"\"Get the bounding box coordinates of a geometry.\n\n    Args:\n        geometry (ee.Geometry | ee.FeatureCollection): The input geometry.\n        decimals (int, optional): The number of decimals to round to. Defaults to 4.\n\n    Returns:\n        list: The bounding box coordinates in the form [west, south, east, north].\n    \"\"\"\n    if isinstance(geometry, ee.FeatureCollection):\n        geometry = geometry.geometry()\n\n    if geometry is not None:\n        if not isinstance(geometry, ee.Geometry):\n            raise ValueError(\"geometry must be an ee.Geometry.\")\n\n        coords = geometry.bounds().coordinates().getInfo()[0]\n        x = [p[0] for p in coords]\n        y = [p[1] for p in coords]\n        west = round(min(x), decimals)\n        east = round(max(x), decimals)\n        south = round(min(y), decimals)\n        north = round(max(y), decimals)\n        return [west, south, east, north]\n    else:\n        return None\n</code></pre>"},{"location":"common/#geemap.common.bbox_to_gdf","title":"<code>bbox_to_gdf(bbox, crs='EPSG:4326')</code>","text":"<p>Converts a bounding box to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>tuple</code> <p>A bounding box in the form of a tuple (minx, miny, maxx, maxy).</p> required <code>crs</code> <code>str</code> <p>The coordinate reference system of the bounding box to convert to. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A GeoDataFrame containing the bounding box.</p> Source code in <code>geemap/common.py</code> <pre><code>def bbox_to_gdf(bbox, crs=\"EPSG:4326\"):\n\"\"\"Converts a bounding box to a GeoDataFrame.\n\n    Args:\n        bbox (tuple): A bounding box in the form of a tuple (minx, miny, maxx, maxy).\n        crs (str, optional): The coordinate reference system of the bounding box to convert to. Defaults to \"EPSG:4326\".\n\n    Returns:\n        geopandas.GeoDataFrame: A GeoDataFrame containing the bounding box.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    from shapely.geometry import box\n    import geopandas as gpd\n\n    minx, miny, maxx, maxy = bbox\n    geometry = box(minx, miny, maxx, maxy)\n    d = {\"geometry\": [geometry]}\n    gdf = gpd.GeoDataFrame(d, crs=\"EPSG:4326\")\n    gdf.to_crs(crs=crs, inplace=True)\n    return gdf\n</code></pre>"},{"location":"common/#geemap.common.bbox_to_geojson","title":"<code>bbox_to_geojson(bounds)</code>","text":"<p>Convert coordinates of a bounding box to a geojson.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list</code> <p>A list of coordinates representing [left, bottom, right, top].</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A geojson feature.</p> Source code in <code>geemap/common.py</code> <pre><code>def bbox_to_geojson(bounds):\n\"\"\"Convert coordinates of a bounding box to a geojson.\n\n    Args:\n        bounds (list): A list of coordinates representing [left, bottom, right, top].\n\n    Returns:\n        dict: A geojson feature.\n    \"\"\"\n    return {\n        \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n                [\n                    [bounds[0], bounds[3]],\n                    [bounds[0], bounds[1]],\n                    [bounds[2], bounds[1]],\n                    [bounds[2], bounds[3]],\n                    [bounds[0], bounds[3]],\n                ]\n            ],\n        },\n        \"type\": \"Feature\",\n    }\n</code></pre>"},{"location":"common/#geemap.common.blend","title":"<code>blend(top_layer, bottom_layer=None, top_vis=None, bottom_vis=None, hillshade=True, expression='a*b', **kwargs)</code>","text":"<p>Create a blended image that is a combination of two images, e.g., DEM and hillshade. This function was inspired by Jesse Anderson. See https://github.com/jessjaco/gee-blend.</p> <p>Parameters:</p> Name Type Description Default <code>top_layer</code> <code>ee.Image</code> <p>The top layer image, e.g., ee.Image(\"CGIAR/SRTM90_V4\")</p> required <code>bottom_layer</code> <code>ee.Image</code> <p>The bottom layer image. If not specified, it will use the top layer image.</p> <code>None</code> <code>top_vis</code> <code>dict</code> <p>The top layer image vis parameters as a dictionary. Defaults to None.</p> <code>None</code> <code>bottom_vis</code> <code>dict</code> <p>The bottom layer image vis parameters as a dictionary. Defaults to None.</p> <code>None</code> <code>hillshade</code> <code>bool</code> <p>Flag to use hillshade. Defaults to True.</p> <code>True</code> <code>expression</code> <code>str</code> <p>The expression to use for the blend. Defaults to 'a*b'.</p> <code>'a*b'</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The blended image.</p> Source code in <code>geemap/common.py</code> <pre><code>def blend(\n    top_layer,\n    bottom_layer=None,\n    top_vis=None,\n    bottom_vis=None,\n    hillshade=True,\n    expression=\"a*b\",\n    **kwargs,\n):\n\"\"\"Create a blended image that is a combination of two images, e.g., DEM and hillshade. This function was inspired by Jesse Anderson. See https://github.com/jessjaco/gee-blend.\n\n    Args:\n        top_layer (ee.Image): The top layer image, e.g., ee.Image(\"CGIAR/SRTM90_V4\")\n        bottom_layer (ee.Image, optional): The bottom layer image. If not specified, it will use the top layer image.\n        top_vis (dict, optional): The top layer image vis parameters as a dictionary. Defaults to None.\n        bottom_vis (dict, optional): The bottom layer image vis parameters as a dictionary. Defaults to None.\n        hillshade (bool, optional): Flag to use hillshade. Defaults to True.\n        expression (str, optional): The expression to use for the blend. Defaults to 'a*b'.\n\n    Returns:\n        ee.Image: The blended image.\n    \"\"\"\n    from box import Box\n\n    if not isinstance(top_layer, ee.Image):\n        raise ValueError(\"top_layer must be an ee.Image.\")\n\n    if bottom_layer is None:\n        bottom_layer = top_layer\n\n    if not isinstance(bottom_layer, ee.Image):\n        raise ValueError(\"bottom_layer must be an ee.Image.\")\n\n    if top_vis is not None:\n        if not isinstance(top_vis, dict):\n            raise ValueError(\"top_vis must be a dictionary.\")\n        elif \"palette\" in top_vis and isinstance(top_vis[\"palette\"], Box):\n            try:\n                top_vis[\"palette\"] = top_vis[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n\n    if bottom_vis is not None:\n        if not isinstance(bottom_vis, dict):\n            raise ValueError(\"top_vis must be a dictionary.\")\n        elif \"palette\" in bottom_vis and isinstance(bottom_vis[\"palette\"], Box):\n            try:\n                bottom_vis[\"palette\"] = bottom_vis[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n\n    if top_vis is None:\n        top_bands = top_layer.bandNames().getInfo()\n        top_vis = {\"bands\": top_bands}\n        if hillshade:\n            top_vis[\"palette\"] = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\n            top_vis[\"min\"] = 0\n            top_vis[\"max\"] = 6000\n\n    if bottom_vis is None:\n        bottom_bands = bottom_layer.bandNames().getInfo()\n        bottom_vis = {\"bands\": bottom_bands}\n        if hillshade:\n            bottom_vis[\"bands\"] = [\"hillshade\"]\n\n    top = top_layer.visualize(**top_vis).divide(255)\n\n    if hillshade:\n        bottom = ee.Terrain.hillshade(bottom_layer).visualize(**bottom_vis).divide(255)\n    else:\n        bottom = bottom_layer.visualize(**bottom_vis).divide(255)\n\n    if \"a\" not in expression or (\"b\" not in expression):\n        raise ValueError(\"expression must contain 'a' and 'b'.\")\n\n    result = ee.Image().expression(expression, {\"a\": top, \"b\": bottom})\n    return result\n</code></pre>"},{"location":"common/#geemap.common.bounds_to_xy_range","title":"<code>bounds_to_xy_range(bounds)</code>","text":"<p>Convert bounds to x and y range to be used as input to bokeh map.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list</code> <p>A list of bounds in the form [(south, west), (north, east)] or [xmin, ymin, xmax, ymax].</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x_range, y_range).</p> Source code in <code>geemap/common.py</code> <pre><code>def bounds_to_xy_range(bounds):\n\"\"\"Convert bounds to x and y range to be used as input to bokeh map.\n\n    Args:\n        bounds (list): A list of bounds in the form [(south, west), (north, east)] or [xmin, ymin, xmax, ymax].\n\n    Returns:\n        tuple: A tuple of (x_range, y_range).\n    \"\"\"\n\n    if isinstance(bounds, tuple):\n        bounds = list(bounds)\n    elif not isinstance(bounds, list):\n        raise TypeError(\"bounds must be a list\")\n\n    if len(bounds) == 4:\n        west, south, east, north = bounds\n    elif len(bounds) == 2:\n        south, west = bounds[0]\n        north, east = bounds[1]\n\n    xmin, ymin = lnglat_to_meters(west, south)\n    xmax, ymax = lnglat_to_meters(east, north)\n    x_range = (xmin, xmax)\n    y_range = (ymin, ymax)\n    return x_range, y_range\n</code></pre>"},{"location":"common/#geemap.common.build_api_tree","title":"<code>build_api_tree(api_dict, output_widget, layout_width='100%')</code>","text":"<p>Builds an Earth Engine API tree view.</p> <p>Parameters:</p> Name Type Description Default <code>api_dict</code> <code>dict</code> <p>The dictionary containing information about each Earth Engine API function.</p> required <code>output_widget</code> <code>object</code> <p>An Output widget.</p> required <code>layout_width</code> <code>str</code> <p>The percentage width of the widget. Defaults to '100%'.</p> <code>'100%'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Returns a tuple containing two items: a tree Output widget and a tree dictionary.</p> Source code in <code>geemap/common.py</code> <pre><code>def build_api_tree(api_dict, output_widget, layout_width=\"100%\"):\n\"\"\"Builds an Earth Engine API tree view.\n\n    Args:\n        api_dict (dict): The dictionary containing information about each Earth Engine API function.\n        output_widget (object): An Output widget.\n        layout_width (str, optional): The percentage width of the widget. Defaults to '100%'.\n\n    Returns:\n        tuple: Returns a tuple containing two items: a tree Output widget and a tree dictionary.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    tree = Tree()\n    tree_dict = {}\n\n    names = api_dict.keys()\n\n    def handle_click(event):\n        if event[\"new\"]:\n            name = event[\"owner\"].name\n            values = api_dict[name]\n\n            with output_widget:\n                output_widget.clear_output()\n                html_widget = widgets.HTML(value=values[\"html\"])\n                display(html_widget)\n\n    for name in names:\n        func_list = ee_function_tree(name)\n        first = func_list[0]\n\n        if first not in tree_dict.keys():\n            tree_dict[first] = Node(first)\n            tree_dict[first].opened = False\n            tree.add_node(tree_dict[first])\n\n        for index, func in enumerate(func_list):\n            if index &gt; 0:\n                if func not in tree_dict.keys():\n                    node = tree_dict[func_list[index - 1]]\n                    node.opened = False\n                    tree_dict[func] = Node(func)\n                    node.add_node(tree_dict[func])\n\n                    if index == len(func_list) - 1:\n                        node = tree_dict[func_list[index]]\n                        node.icon = \"file\"\n                        node.observe(handle_click, \"selected\")\n\n    return tree, tree_dict\n</code></pre>"},{"location":"common/#geemap.common.build_repo_tree","title":"<code>build_repo_tree(out_dir=None, name='gee_repos')</code>","text":"<p>Builds a repo tree for GEE account.</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>str</code> <p>The output directory for the repos. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The output name for the repo directory. Defaults to 'gee_repos'.</p> <code>'gee_repos'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Returns a tuple containing a tree widget, an output widget, and a tree dictionary containing nodes.</p> Source code in <code>geemap/common.py</code> <pre><code>def build_repo_tree(out_dir=None, name=\"gee_repos\"):\n\"\"\"Builds a repo tree for GEE account.\n\n    Args:\n        out_dir (str): The output directory for the repos. Defaults to None.\n        name (str, optional): The output name for the repo directory. Defaults to 'gee_repos'.\n\n    Returns:\n        tuple: Returns a tuple containing a tree widget, an output widget, and a tree dictionary containing nodes.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    if out_dir is None:\n        out_dir = os.path.join(os.path.expanduser(\"~\"))\n\n    repo_dir = os.path.join(out_dir, name)\n    if not os.path.exists(repo_dir):\n        os.makedirs(repo_dir)\n\n    URLs = {\n        # 'Owner': 'https://earthengine.googlesource.com/{ee_user_id()}/default',\n        \"Writer\": \"\",\n        \"Reader\": \"https://github.com/gee-community/geemap\",\n        \"Examples\": \"https://github.com/giswqs/earthengine-py-examples\",\n        \"Archive\": \"https://earthengine.googlesource.com/EGU2017-EE101\",\n    }\n\n    user_id = ee_user_id()\n    if user_id is not None:\n        URLs[\"Owner\"] = f\"https://earthengine.googlesource.com/{ee_user_id()}/default\"\n\n    path_widget = widgets.Text(placeholder=\"Enter the link to a Git repository here...\")\n    path_widget.layout.width = \"475px\"\n    clone_widget = widgets.Button(\n        description=\"Clone\",\n        button_style=\"primary\",\n        tooltip=\"Clone the repository to folder.\",\n    )\n    info_widget = widgets.HBox()\n\n    groups = [\"Owner\", \"Writer\", \"Reader\", \"Examples\", \"Archive\"]\n    for group in groups:\n        group_dir = os.path.join(repo_dir, group)\n        if not os.path.exists(group_dir):\n            os.makedirs(group_dir)\n\n    example_dir = os.path.join(repo_dir, \"Examples/earthengine-py-examples\")\n    if not os.path.exists(example_dir):\n        clone_github_repo(URLs[\"Examples\"], out_dir=example_dir)\n\n    left_widget, right_widget, tree_dict = file_browser(\n        in_dir=repo_dir,\n        add_root_node=False,\n        search_description=\"Filter scripts...\",\n        use_import=True,\n        return_sep_widgets=True,\n    )\n    info_widget.children = [right_widget]\n\n    def handle_folder_click(event):\n        if event[\"new\"]:\n            url = \"\"\n            selected = event[\"owner\"]\n            if selected.name in URLs.keys():\n                url = URLs[selected.name]\n\n            path_widget.value = url\n            clone_widget.disabled = False\n            info_widget.children = [path_widget, clone_widget]\n        else:\n            info_widget.children = [right_widget]\n\n    for group in groups:\n        dirname = os.path.join(repo_dir, group)\n        node = tree_dict[dirname]\n        node.observe(handle_folder_click, \"selected\")\n\n    def handle_clone_click(b):\n        url = path_widget.value\n        default_dir = os.path.join(repo_dir, \"Examples\")\n        if url == \"\":\n            path_widget.value = \"Please enter a valid URL to the repository.\"\n        else:\n            for group in groups:\n                key = os.path.join(repo_dir, group)\n                node = tree_dict[key]\n                if node.selected:\n                    default_dir = key\n            try:\n                path_widget.value = \"Cloning...\"\n                clone_dir = os.path.join(default_dir, os.path.basename(url))\n                if url.find(\"github.com\") != -1:\n                    clone_github_repo(url, out_dir=clone_dir)\n                elif url.find(\"googlesource\") != -1:\n                    clone_google_repo(url, out_dir=clone_dir)\n                path_widget.value = \"Cloned to {}\".format(clone_dir)\n                clone_widget.disabled = True\n            except Exception as e:\n                path_widget.value = (\n                    \"An error occurred when trying to clone the repository \" + str(e)\n                )\n                clone_widget.disabled = True\n\n    clone_widget.on_click(handle_clone_click)\n\n    return left_widget, info_widget, tree_dict\n</code></pre>"},{"location":"common/#geemap.common.center_zoom_to_xy_range","title":"<code>center_zoom_to_xy_range(center, zoom)</code>","text":"<p>Convert center and zoom to x and y range to be used as input to bokeh map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>A tuple of (latitude, longitude).</p> required <code>zoom</code> <code>int</code> <p>The zoom level.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x_range, y_range).</p> Source code in <code>geemap/common.py</code> <pre><code>def center_zoom_to_xy_range(center, zoom):\n\"\"\"Convert center and zoom to x and y range to be used as input to bokeh map.\n\n    Args:\n        center (tuple): A tuple of (latitude, longitude).\n        zoom (int): The zoom level.\n\n    Returns:\n        tuple: A tuple of (x_range, y_range).\n    \"\"\"\n\n    if isinstance(center, tuple) or isinstance(center, list):\n        pass\n    else:\n        raise TypeError(\"center must be a tuple or list\")\n\n    if not isinstance(zoom, int):\n        raise TypeError(\"zoom must be an integer\")\n\n    latitude, longitude = center\n    x_range = (-179, 179)\n    y_range = (-70, 70)\n    x_full_length = x_range[1] - x_range[0]\n    y_full_length = y_range[1] - y_range[0]\n\n    x_length = x_full_length / 2 ** (zoom - 2)\n    y_length = y_full_length / 2 ** (zoom - 2)\n\n    south = latitude - y_length / 2\n    north = latitude + y_length / 2\n    west = longitude - x_length / 2\n    east = longitude + x_length / 2\n\n    xmin, ymin = lnglat_to_meters(west, south)\n    xmax, ymax = lnglat_to_meters(east, north)\n\n    x_range = (xmin, xmax)\n    y_range = (ymin, ymax)\n\n    return x_range, y_range\n</code></pre>"},{"location":"common/#geemap.common.check_cmap","title":"<code>check_cmap(cmap)</code>","text":"<p>Check the colormap and return a list of colors.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str | list | Box</code> <p>The colormap to check.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of colors.</p> Source code in <code>geemap/common.py</code> <pre><code>def check_cmap(cmap):\n\"\"\"Check the colormap and return a list of colors.\n\n    Args:\n        cmap (str | list | Box): The colormap to check.\n\n    Returns:\n        list: A list of colors.\n    \"\"\"\n\n    from box import Box\n    from .colormaps import get_palette\n\n    if isinstance(cmap, str):\n        try:\n            palette = get_palette(cmap)\n            if isinstance(palette, dict):\n                palette = palette[\"default\"]\n            return palette\n        except Exception as e:\n            try:\n                return check_color(cmap)\n            except Exception as e:\n                raise Exception(f\"{cmap} is not a valid colormap.\")\n    elif isinstance(cmap, Box):\n        return list(cmap[\"default\"])\n    elif isinstance(cmap, list) or isinstance(cmap, tuple):\n        return cmap\n    else:\n        raise Exception(f\"{cmap} is not a valid colormap.\")\n</code></pre>"},{"location":"common/#geemap.common.check_color","title":"<code>check_color(in_color)</code>","text":"<p>Checks the input color and returns the corresponding hex color code.</p> <p>Parameters:</p> Name Type Description Default <code>in_color</code> <code>str or tuple</code> <p>It can be a string (e.g., 'red', '#ffff00', 'ffff00', 'ff0') or RGB tuple (e.g., (255, 127, 0)).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A hex color code.</p> Source code in <code>geemap/common.py</code> <pre><code>def check_color(in_color):\n\"\"\"Checks the input color and returns the corresponding hex color code.\n\n    Args:\n        in_color (str or tuple): It can be a string (e.g., 'red', '#ffff00', 'ffff00', 'ff0') or RGB tuple (e.g., (255, 127, 0)).\n\n    Returns:\n        str: A hex color code.\n    \"\"\"\n    import colour\n\n    out_color = \"#000000\"  # default black color\n    if isinstance(in_color, tuple) and len(in_color) == 3:\n        # rescale color if necessary\n        if all(isinstance(item, int) for item in in_color):\n            in_color = [c / 255.0 for c in in_color]\n\n        return colour.Color(rgb=tuple(in_color)).hex_l\n\n    else:\n        # try to guess the color system\n        try:\n            return colour.Color(in_color).hex_l\n\n        except Exception as e:\n            pass\n\n        # try again by adding an extra # (GEE handle hex codes without #)\n        try:\n            return colour.Color(f\"#{in_color}\").hex_l\n\n        except Exception as e:\n            print(\n                f\"The provided color ({in_color}) is invalid. Using the default black color.\"\n            )\n            print(e)\n\n        return out_color\n</code></pre>"},{"location":"common/#geemap.common.check_dir","title":"<code>check_dir(dir_path, make_dirs=True)</code>","text":"<p>Checks if a directory exists and creates it if it does not.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>[str</code> <p>The path to the directory.</p> required <code>make_dirs</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the directory could not be found.</p> <code>TypeError</code> <p>If the input directory path is not a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path to the directory.</p> Source code in <code>geemap/common.py</code> <pre><code>def check_dir(dir_path, make_dirs=True):\n\"\"\"Checks if a directory exists and creates it if it does not.\n\n    Args:\n        dir_path ([str): The path to the directory.\n        make_dirs (bool, optional): Whether to create the directory if it does not exist. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the directory could not be found.\n        TypeError: If the input directory path is not a string.\n\n    Returns:\n        str: The path to the directory.\n    \"\"\"\n\n    if isinstance(dir_path, str):\n        if dir_path.startswith(\"~\"):\n            dir_path = os.path.expanduser(dir_path)\n        else:\n            dir_path = os.path.abspath(dir_path)\n\n        if not os.path.exists(dir_path) and make_dirs:\n            os.makedirs(dir_path)\n\n        if os.path.exists(dir_path):\n            return dir_path\n        else:\n            raise FileNotFoundError(\"The provided directory could not be found.\")\n    else:\n        raise TypeError(\"The provided directory path must be a string.\")\n</code></pre>"},{"location":"common/#geemap.common.check_file_path","title":"<code>check_file_path(file_path, make_dirs=True)</code>","text":"<p>Gets the absolute file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>[str</code> <p>The path to the file.</p> required <code>make_dirs</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the directory could not be found.</p> <code>TypeError</code> <p>If the input directory path is not a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The absolute path to the file.</p> Source code in <code>geemap/common.py</code> <pre><code>def check_file_path(file_path, make_dirs=True):\n\"\"\"Gets the absolute file path.\n\n    Args:\n        file_path ([str): The path to the file.\n        make_dirs (bool, optional): Whether to create the directory if it does not exist. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the directory could not be found.\n        TypeError: If the input directory path is not a string.\n\n    Returns:\n        str: The absolute path to the file.\n    \"\"\"\n    if isinstance(file_path, str):\n        if file_path.startswith(\"~\"):\n            file_path = os.path.expanduser(file_path)\n        else:\n            file_path = os.path.abspath(file_path)\n\n        file_dir = os.path.dirname(file_path)\n        if not os.path.exists(file_dir) and make_dirs:\n            os.makedirs(file_dir)\n\n        return file_path\n\n    else:\n        raise TypeError(\"The provided file path must be a string.\")\n</code></pre>"},{"location":"common/#geemap.common.check_git_install","title":"<code>check_git_install()</code>","text":"<p>Checks if Git is installed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if Git is installed, otherwise returns False.</p> Source code in <code>geemap/common.py</code> <pre><code>def check_git_install():\n\"\"\"Checks if Git is installed.\n\n    Returns:\n        bool: Returns True if Git is installed, otherwise returns False.\n    \"\"\"\n    import webbrowser\n\n    cmd = \"git --version\"\n    output = os.popen(cmd).read()\n\n    if \"git version\" in output:\n        return True\n    else:\n        url = \"https://git-scm.com/downloads\"\n        print(f\"Git is not installed. Please download Git from {url} and install it.\")\n        webbrowser.open_new_tab(url)\n        return False\n</code></pre>"},{"location":"common/#geemap.common.check_install","title":"<code>check_install(package)</code>","text":"<p>Checks whether a package is installed. If not, it will install the package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The name of the package to check.</p> required Source code in <code>geemap/common.py</code> <pre><code>def check_install(package):\n\"\"\"Checks whether a package is installed. If not, it will install the package.\n\n    Args:\n        package (str): The name of the package to check.\n    \"\"\"\n    import subprocess\n\n    try:\n        __import__(package)\n        # print('{} is already installed.'.format(package))\n    except ImportError:\n        print(f\"{package} is not installed. Installing ...\")\n        try:\n            subprocess.check_call([\"python\", \"-m\", \"pip\", \"install\", package])\n        except Exception as e:\n            print(f\"Failed to install {package}\")\n            print(e)\n        print(f\"{package} has been installed successfully.\")\n</code></pre>"},{"location":"common/#geemap.common.check_titiler_endpoint","title":"<code>check_titiler_endpoint(titiler_endpoint=None)</code>","text":"<p>Returns the default titiler endpoint.</p> <p>Returns:</p> Type Description <code>object</code> <p>A titiler endpoint.</p> Source code in <code>geemap/common.py</code> <pre><code>def check_titiler_endpoint(titiler_endpoint=None):\n\"\"\"Returns the default titiler endpoint.\n\n    Returns:\n        object: A titiler endpoint.\n    \"\"\"\n    if titiler_endpoint is None:\n        if os.environ.get(\"TITILER_ENDPOINT\") is not None:\n            titiler_endpoint = os.environ.get(\"TITILER_ENDPOINT\")\n\n            if titiler_endpoint == \"planetary-computer\":\n                titiler_endpoint = PlanetaryComputerEndpoint()\n        else:\n            titiler_endpoint = \"https://titiler.xyz\"\n    elif titiler_endpoint in [\"planetary-computer\", \"pc\"]:\n        titiler_endpoint = PlanetaryComputerEndpoint()\n\n    return titiler_endpoint\n</code></pre>"},{"location":"common/#geemap.common.classify","title":"<code>classify(data, column, cmap=None, colors=None, labels=None, scheme='Quantiles', k=5, legend_kwds=None, classification_kwds=None)</code>","text":"<p>Classify a dataframe column using a variety of classification schemes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame | gpd.GeoDataFrame</code> <p>The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.</p> required <code>column</code> <code>str</code> <p>The column to classify.</p> required <code>cmap</code> <code>str</code> <p>The name of a colormap recognized by matplotlib. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of colors to use for the classification. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of labels to use for the legend. Defaults to None.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>Name of a choropleth classification scheme (requires mapclassify). Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if scheme is None or if column is categorical). Default to 5.</p> <code>5</code> <code>legend_kwds</code> <code>dict</code> <p>Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or <code>matplotlib.pyplot.colorbar</code>. Defaults to None. Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or Additional accepted keywords when <code>scheme</code> is specified: fmt : string     A formatting specification for the bin edges of the classes in the     legend. For example, to have no decimals: <code>{\"fmt\": \"{:.0f}\"}</code>. labels : list-like     A list of legend labels to override the auto-generated labblels.     Needs to have the same number of elements as the number of     classes (<code>k</code>). interval : boolean (default False)     An option to control brackets from mapclassify legend.     If True, open/closed interval brackets are shown in the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Keyword arguments to pass to mapclassify. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame, dict</code> <p>A pandas dataframe with the classification applied and a legend dictionary.</p> Source code in <code>geemap/common.py</code> <pre><code>def classify(\n    data,\n    column,\n    cmap=None,\n    colors=None,\n    labels=None,\n    scheme=\"Quantiles\",\n    k=5,\n    legend_kwds=None,\n    classification_kwds=None,\n):\n\"\"\"Classify a dataframe column using a variety of classification schemes.\n\n    Args:\n        data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n        column (str): The column to classify.\n        cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n        colors (list, optional): A list of colors to use for the classification. Defaults to None.\n        labels (list, optional): A list of labels to use for the legend. Defaults to None.\n        scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n        legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n            Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n            Additional accepted keywords when `scheme` is specified:\n            fmt : string\n                A formatting specification for the bin edges of the classes in the\n                legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n            labels : list-like\n                A list of legend labels to override the auto-generated labblels.\n                Needs to have the same number of elements as the number of\n                classes (`k`).\n            interval : boolean (default False)\n                An option to control brackets from mapclassify legend.\n                If True, open/closed interval brackets are shown in the legend.\n        classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n\n    Returns:\n        pd.DataFrame, dict: A pandas dataframe with the classification applied and a legend dictionary.\n    \"\"\"\n\n    import numpy as np\n    import pandas as pd\n    import geopandas as gpd\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    try:\n        import mapclassify\n    except ImportError:\n        raise ImportError(\n            'mapclassify is required for this function. Install with \"pip install mapclassify\".'\n        )\n\n    if isinstance(data, gpd.GeoDataFrame) or isinstance(data, pd.DataFrame):\n        df = data\n    else:\n        try:\n            df = gpd.read_file(data)\n        except Exception:\n            raise TypeError(\n                \"Data must be a GeoDataFrame or a path to a file that can be read by geopandas.read_file().\"\n            )\n\n    if df.empty:\n        warnings.warn(\n            \"The GeoDataFrame you are attempting to plot is \"\n            \"empty. Nothing has been displayed.\",\n            UserWarning,\n        )\n        return\n\n    columns = df.columns.values.tolist()\n    if column not in columns:\n        raise ValueError(\n            f\"{column} is not a column in the GeoDataFrame. It must be one of {columns}.\"\n        )\n\n    # Convert categorical data to numeric\n    init_column = None\n    value_list = None\n    if np.issubdtype(df[column].dtype, np.object0):\n        value_list = df[column].unique().tolist()\n        value_list.sort()\n        df[\"category\"] = df[column].replace(value_list, range(0, len(value_list)))\n        init_column = column\n        column = \"category\"\n        k = len(value_list)\n\n    if legend_kwds is not None:\n        legend_kwds = legend_kwds.copy()\n\n    # To accept pd.Series and np.arrays as column\n    if isinstance(column, (np.ndarray, pd.Series)):\n        if column.shape[0] != df.shape[0]:\n            raise ValueError(\n                \"The dataframe and given column have different number of rows.\"\n            )\n        else:\n            values = column\n\n            # Make sure index of a Series matches index of df\n            if isinstance(values, pd.Series):\n                values = values.reindex(df.index)\n    else:\n        values = df[column]\n\n    values = df[column]\n    nan_idx = np.asarray(pd.isna(values), dtype=\"bool\")\n\n    if cmap is None:\n        cmap = \"Blues\"\n    cmap = plt.cm.get_cmap(cmap, k)\n    if colors is None:\n        colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n        colors = [\"#\" + i for i in colors]\n    elif isinstance(colors, list):\n        colors = [check_color(i) for i in colors]\n    elif isinstance(colors, str):\n        colors = [check_color(colors)] * k\n\n    allowed_schemes = [\n        \"BoxPlot\",\n        \"EqualInterval\",\n        \"FisherJenks\",\n        \"FisherJenksSampled\",\n        \"HeadTailBreaks\",\n        \"JenksCaspall\",\n        \"JenksCaspallForced\",\n        \"JenksCaspallSampled\",\n        \"MaxP\",\n        \"MaximumBreaks\",\n        \"NaturalBreaks\",\n        \"Quantiles\",\n        \"Percentiles\",\n        \"StdMean\",\n        \"UserDefined\",\n    ]\n\n    if scheme.lower() not in [s.lower() for s in allowed_schemes]:\n        raise ValueError(\n            f\"{scheme} is not a valid scheme. It must be one of {allowed_schemes}.\"\n        )\n\n    if classification_kwds is None:\n        classification_kwds = {}\n    if \"k\" not in classification_kwds:\n        classification_kwds[\"k\"] = k\n\n    binning = mapclassify.classify(\n        np.asarray(values[~nan_idx]), scheme, **classification_kwds\n    )\n    df[\"category\"] = binning.yb\n    df[\"color\"] = [colors[i] for i in df[\"category\"]]\n\n    if legend_kwds is None:\n        legend_kwds = {}\n\n    if \"interval\" not in legend_kwds:\n        legend_kwds[\"interval\"] = True\n\n    if \"fmt\" not in legend_kwds:\n        if np.issubdtype(df[column].dtype, np.floating):\n            legend_kwds[\"fmt\"] = \"{:.2f}\"\n        else:\n            legend_kwds[\"fmt\"] = \"{:.0f}\"\n\n    if labels is None:\n        # set categorical to True for creating the legend\n        if legend_kwds is not None and \"labels\" in legend_kwds:\n            if len(legend_kwds[\"labels\"]) != binning.k:\n                raise ValueError(\n                    \"Number of labels must match number of bins, \"\n                    \"received {} labels for {} bins\".format(\n                        len(legend_kwds[\"labels\"]), binning.k\n                    )\n                )\n            else:\n                labels = list(legend_kwds.pop(\"labels\"))\n        else:\n            # fmt = \"{:.2f}\"\n            if legend_kwds is not None and \"fmt\" in legend_kwds:\n                fmt = legend_kwds.pop(\"fmt\")\n\n            labels = binning.get_legend_classes(fmt)\n            if legend_kwds is not None:\n                show_interval = legend_kwds.pop(\"interval\", False)\n            else:\n                show_interval = False\n            if not show_interval:\n                labels = [c[1:-1] for c in labels]\n\n        if init_column is not None:\n            labels = value_list\n    elif isinstance(labels, list):\n        if len(labels) != len(colors):\n            raise ValueError(\"The number of labels must match the number of colors.\")\n    else:\n        raise ValueError(\"labels must be a list or None.\")\n\n    legend_dict = dict(zip(labels, colors))\n    df[\"category\"] = df[\"category\"] + 1\n    return df, legend_dict\n</code></pre>"},{"location":"common/#geemap.common.clip_image","title":"<code>clip_image(image, mask, output)</code>","text":"<p>Clip an image by mask.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Path to the image file in GeoTIFF format.</p> required <code>mask</code> <code>str | list | dict</code> <p>The mask used to extract the image. It can be a path to vector datasets (e.g., GeoJSON, Shapefile), a list of coordinates, or m.user_roi.</p> required <code>output</code> <code>str</code> <p>Path to the output file.</p> required <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the fiona or rasterio package is not installed.</p> <code>FileNotFoundError</code> <p>If the image is not found.</p> <code>ValueError</code> <p>If the mask is not a valid GeoJSON or raster file.</p> <code>FileNotFoundError</code> <p>If the mask file is not found.</p> Source code in <code>geemap/common.py</code> <pre><code>def clip_image(image, mask, output):\n\"\"\"Clip an image by mask.\n\n    Args:\n        image (str): Path to the image file in GeoTIFF format.\n        mask (str | list | dict): The mask used to extract the image. It can be a path to vector datasets (e.g., GeoJSON, Shapefile), a list of coordinates, or m.user_roi.\n        output (str): Path to the output file.\n\n    Raises:\n        ImportError: If the fiona or rasterio package is not installed.\n        FileNotFoundError: If the image is not found.\n        ValueError: If the mask is not a valid GeoJSON or raster file.\n        FileNotFoundError: If the mask file is not found.\n    \"\"\"\n    try:\n        import fiona\n        import rasterio\n        import rasterio.mask\n    except ImportError as e:\n        raise ImportError(e)\n\n    if not os.path.exists(image):\n        raise FileNotFoundError(f\"{image} does not exist.\")\n\n    if not output.endswith(\".tif\"):\n        raise ValueError(\"Output must be a tif file.\")\n\n    output = check_file_path(output)\n\n    if isinstance(mask, ee.Geometry):\n        mask = mask.coordinates().getInfo()[0]\n\n    if isinstance(mask, str):\n        if mask.startswith(\"http\"):\n            mask = download_file(mask, output)\n        if not os.path.exists(mask):\n            raise FileNotFoundError(f\"{mask} does not exist.\")\n    elif isinstance(mask, list) or isinstance(mask, dict):\n        if isinstance(mask, list):\n            geojson = {\n                \"type\": \"FeatureCollection\",\n                \"features\": [\n                    {\n                        \"type\": \"Feature\",\n                        \"properties\": {},\n                        \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [mask]},\n                    }\n                ],\n            }\n        else:\n            geojson = {\n                \"type\": \"FeatureCollection\",\n                \"features\": [mask],\n            }\n        mask = temp_file_path(\".geojson\")\n        with open(mask, \"w\") as f:\n            json.dump(geojson, f)\n\n    with fiona.open(mask, \"r\") as shapefile:\n        shapes = [feature[\"geometry\"] for feature in shapefile]\n\n    with rasterio.open(image) as src:\n        out_image, out_transform = rasterio.mask.mask(src, shapes, crop=True)\n        out_meta = src.meta\n\n    out_meta.update(\n        {\n            \"driver\": \"GTiff\",\n            \"height\": out_image.shape[1],\n            \"width\": out_image.shape[2],\n            \"transform\": out_transform,\n        }\n    )\n\n    with rasterio.open(output, \"w\", **out_meta) as dest:\n        dest.write(out_image)\n</code></pre>"},{"location":"common/#geemap.common.clone_github_repo","title":"<code>clone_github_repo(url, out_dir)</code>","text":"<p>Clones a GitHub repository.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The link to the GitHub repository</p> required <code>out_dir</code> <code>str</code> <p>The output directory for the cloned repository.</p> required Source code in <code>geemap/common.py</code> <pre><code>def clone_github_repo(url, out_dir):\n\"\"\"Clones a GitHub repository.\n\n    Args:\n        url (str): The link to the GitHub repository\n        out_dir (str): The output directory for the cloned repository.\n    \"\"\"\n\n    repo_name = os.path.basename(url)\n    # url_zip = os.path.join(url, 'archive/master.zip')\n    url_zip = url + \"/archive/master.zip\"\n\n    if os.path.exists(out_dir):\n        print(\n            \"The specified output directory already exists. Please choose a new directory.\"\n        )\n        return\n\n    parent_dir = os.path.dirname(out_dir)\n    out_file_path = os.path.join(parent_dir, repo_name + \".zip\")\n\n    try:\n        urllib.request.urlretrieve(url_zip, out_file_path)\n    except Exception:\n        print(\"The provided URL is invalid. Please double check the URL.\")\n        return\n\n    with zipfile.ZipFile(out_file_path, \"r\") as zip_ref:\n        zip_ref.extractall(parent_dir)\n\n    src = out_file_path.replace(\".zip\", \"-master\")\n    os.rename(src, out_dir)\n    os.remove(out_file_path)\n</code></pre>"},{"location":"common/#geemap.common.clone_google_repo","title":"<code>clone_google_repo(url, out_dir=None)</code>","text":"<p>Clones an Earth Engine repository from https://earthengine.googlesource.com, such as https://earthengine.googlesource.com/users/google/datasets</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The link to the Earth Engine repository</p> required <code>out_dir</code> <code>str</code> <p>The output directory for the cloned repository. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def clone_google_repo(url, out_dir=None):\n\"\"\"Clones an Earth Engine repository from https://earthengine.googlesource.com, such as https://earthengine.googlesource.com/users/google/datasets\n\n    Args:\n        url (str): The link to the Earth Engine repository\n        out_dir (str, optional): The output directory for the cloned repository. Defaults to None.\n    \"\"\"\n    repo_name = os.path.basename(url)\n\n    if out_dir is None:\n        out_dir = os.path.join(os.getcwd(), repo_name)\n\n    if not os.path.exists(os.path.dirname(out_dir)):\n        os.makedirs(os.path.dirname(out_dir))\n\n    if os.path.exists(out_dir):\n        print(\n            \"The specified output directory already exists. Please choose a new directory.\"\n        )\n        return\n\n    if check_git_install():\n        cmd = f'git clone \"{url}\" \"{out_dir}\"'\n        os.popen(cmd).read()\n</code></pre>"},{"location":"common/#geemap.common.clone_repo","title":"<code>clone_repo(out_dir='.', unzip=True)</code>","text":"<p>Clones the geemap GitHub repository.</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>str</code> <p>Output folder for the repo. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the repository. Defaults to True.</p> <code>True</code> Source code in <code>geemap/common.py</code> <pre><code>def clone_repo(out_dir=\".\", unzip=True):\n\"\"\"Clones the geemap GitHub repository.\n\n    Args:\n        out_dir (str, optional): Output folder for the repo. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the repository. Defaults to True.\n    \"\"\"\n    url = \"https://github.com/gee-community/geemap/archive/master.zip\"\n    filename = \"geemap-master.zip\"\n    download_from_url(url, out_file_name=filename, out_dir=out_dir, unzip=unzip)\n</code></pre>"},{"location":"common/#geemap.common.cog_bands","title":"<code>cog_bands(url, titiler_endpoint=None, timeout=300)</code>","text":"<p>Get band names of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of band names</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_bands(url, titiler_endpoint=None, timeout=300):\n\"\"\"Get band names of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A list of band names\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    url = get_direct_url(url)\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/info\",\n        params={\n            \"url\": url,\n        },\n        timeout=timeout,\n    ).json()\n\n    bands = [b[0] for b in r[\"band_descriptions\"]]\n    return bands\n</code></pre>"},{"location":"common/#geemap.common.cog_bounds","title":"<code>cog_bounds(url, titiler_endpoint=None, timeout=300)</code>","text":"<p>Get the bounding box of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of values representing [left, bottom, right, top]</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_bounds(url, titiler_endpoint=None, timeout=300):\n\"\"\"Get the bounding box of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A list of values representing [left, bottom, right, top]\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    url = get_direct_url(url)\n\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/bounds\", params={\"url\": url}, timeout=timeout\n    ).json()\n\n    if \"bounds\" in r.keys():\n        bounds = r[\"bounds\"]\n    else:\n        bounds = None\n    return bounds\n</code></pre>"},{"location":"common/#geemap.common.cog_center","title":"<code>cog_center(url, titiler_endpoint=None)</code>","text":"<p>Get the centroid of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing (longitude, latitude)</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_center(url, titiler_endpoint=None):\n\"\"\"Get the centroid of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        tuple: A tuple representing (longitude, latitude)\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    url = get_direct_url(url)\n    bounds = cog_bounds(url, titiler_endpoint)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lat, lon)\n    return center\n</code></pre>"},{"location":"common/#geemap.common.cog_info","title":"<code>cog_info(url, titiler_endpoint=None, return_geojson=False, timeout=300)</code>","text":"<p>Get band statistics of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_info(url, titiler_endpoint=None, return_geojson=False, timeout=300):\n\"\"\"Get band statistics of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    url = get_direct_url(url)\n    info = \"info\"\n    if return_geojson:\n        info = \"info.geojson\"\n\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/{info}\",\n        params={\n            \"url\": url,\n        },\n        timeout=timeout,\n    ).json()\n\n    return r\n</code></pre>"},{"location":"common/#geemap.common.cog_mosaic","title":"<code>cog_mosaic(links, titiler_endpoint=None, username='anonymous', layername=None, overwrite=False, verbose=True, timeout=300, **kwargs)</code>","text":"<p>Creates a COG mosaic from a list of COG URLs.</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>list</code> <p>A list containing COG HTTP URLs.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>username</code> <code>str</code> <p>User name for the titiler endpoint. Defaults to \"anonymous\".</p> <code>'anonymous'</code> <code>layername</code> <code>[type]</code> <p>Layer name to use. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the layer name if existing. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive information. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Exceptions:</p> Type Description <code>Exception</code> <p>If the COG mosaic fails to create.</p> <p>Returns:</p> Type Description <code>str</code> <p>The tile URL for the COG mosaic.</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_mosaic(\n    links,\n    titiler_endpoint=None,\n    username=\"anonymous\",\n    layername=None,\n    overwrite=False,\n    verbose=True,\n    timeout=300,\n    **kwargs,\n):\n\"\"\"Creates a COG mosaic from a list of COG URLs.\n\n    Args:\n        links (list): A list containing COG HTTP URLs.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        username (str, optional): User name for the titiler endpoint. Defaults to \"anonymous\".\n        layername ([type], optional): Layer name to use. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite the layer name if existing. Defaults to False.\n        verbose (bool, optional): Whether to print out descriptive information. Defaults to True.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Raises:\n        Exception: If the COG mosaic fails to create.\n\n    Returns:\n        str: The tile URL for the COG mosaic.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if layername is None:\n        layername = \"layer_\" + random_string(5)\n\n    try:\n        if verbose:\n            print(\"Creating COG masaic ...\")\n\n        # Create token\n        r = requests.post(\n            f\"{titiler_endpoint}/tokens/create\",\n            json={\"username\": username, \"scope\": [\"mosaic:read\", \"mosaic:create\"]},\n        ).json()\n        token = r[\"token\"]\n\n        # Create mosaic\n        requests.post(\n            f\"{titiler_endpoint}/mosaicjson/create\",\n            json={\n                \"username\": username,\n                \"layername\": layername,\n                \"files\": links,\n                # \"overwrite\": overwrite\n            },\n            params={\n                \"access_token\": token,\n            },\n        ).json()\n\n        r2 = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/{username}.{layername}/tilejson.json\",\n            timeout=timeout,\n        ).json()\n\n        return r2[\"tiles\"][0]\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.cog_mosaic_from_file","title":"<code>cog_mosaic_from_file(filepath, skip_rows=0, titiler_endpoint=None, username='anonymous', layername=None, overwrite=False, verbose=True, **kwargs)</code>","text":"<p>Creates a COG mosaic from a csv/txt file stored locally for through HTTP URL.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Local path or HTTP URL to the csv/txt file containing COG URLs.</p> required <code>skip_rows</code> <code>int</code> <p>The number of rows to skip in the file. Defaults to 0.</p> <code>0</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>username</code> <code>str</code> <p>User name for the titiler endpoint. Defaults to \"anonymous\".</p> <code>'anonymous'</code> <code>layername</code> <code>[type]</code> <p>Layer name to use. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the layer name if existing. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive information. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The tile URL for the COG mosaic.</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_mosaic_from_file(\n    filepath,\n    skip_rows=0,\n    titiler_endpoint=None,\n    username=\"anonymous\",\n    layername=None,\n    overwrite=False,\n    verbose=True,\n    **kwargs,\n):\n\"\"\"Creates a COG mosaic from a csv/txt file stored locally for through HTTP URL.\n\n    Args:\n        filepath (str): Local path or HTTP URL to the csv/txt file containing COG URLs.\n        skip_rows (int, optional): The number of rows to skip in the file. Defaults to 0.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        username (str, optional): User name for the titiler endpoint. Defaults to \"anonymous\".\n        layername ([type], optional): Layer name to use. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite the layer name if existing. Defaults to False.\n        verbose (bool, optional): Whether to print out descriptive information. Defaults to True.\n\n    Returns:\n        str: The tile URL for the COG mosaic.\n    \"\"\"\n    import urllib\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    links = []\n    if filepath.startswith(\"http\"):\n        data = urllib.request.urlopen(filepath)\n        for line in data:\n            links.append(line.decode(\"utf-8\").strip())\n\n    else:\n        with open(filepath) as f:\n            links = [line.strip() for line in f.readlines()]\n\n    links = links[skip_rows:]\n    # print(links)\n    mosaic = cog_mosaic(\n        links, titiler_endpoint, username, layername, overwrite, verbose, **kwargs\n    )\n    return mosaic\n</code></pre>"},{"location":"common/#geemap.common.cog_pixel_value","title":"<code>cog_pixel_value(lon, lat, url, bidx=None, titiler_endpoint=None, timeout=300, **kwargs)</code>","text":"<p>Get pixel value from COG.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'</p> required <code>bidx</code> <code>str</code> <p>Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_pixel_value(\n    lon,\n    lat,\n    url,\n    bidx=None,\n    titiler_endpoint=None,\n    timeout=300,\n    **kwargs,\n):\n\"\"\"Get pixel value from COG.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a COG, e.g., 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\n        bidx (str, optional): Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    url = get_direct_url(url)\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    kwargs[\"url\"] = url\n    if bidx is not None:\n        kwargs[\"bidx\"] = bidx\n\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/point/{lon},{lat}\", params=kwargs, timeout=timeout\n    ).json()\n    bands = cog_bands(url, titiler_endpoint)\n    # if isinstance(titiler_endpoint, str):\n    #     r = requests.get(f\"{titiler_endpoint}/cog/point/{lon},{lat}\", params=kwargs).json()\n    # else:\n    #     r = requests.get(\n    #         titiler_endpoint.url_for_stac_pixel_value(lon, lat), params=kwargs\n    #     ).json()\n\n    if \"detail\" in r:\n        print(r[\"detail\"])\n        return None\n    else:\n        values = r[\"values\"]\n        result = dict(zip(bands, values))\n        return result\n</code></pre>"},{"location":"common/#geemap.common.cog_stats","title":"<code>cog_stats(url, titiler_endpoint=None, timeout=300)</code>","text":"<p>Get band statistics of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band statistics.</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_stats(url, titiler_endpoint=None, timeout=300):\n\"\"\"Get band statistics of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A dictionary of band statistics.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    url = get_direct_url(url)\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/statistics\",\n        params={\n            \"url\": url,\n        },\n        timeout=timeout,\n    ).json()\n\n    return r\n</code></pre>"},{"location":"common/#geemap.common.cog_tile","title":"<code>cog_tile(url, bands=None, titiler_endpoint=None, timeout=300, proxies=None, **kwargs)</code>","text":"<p>Get a tile layer from a Cloud Optimized GeoTIFF (COG).     Source code adapted from https://developmentseed.org/titiler/examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>Proxies to use. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Returns the COG Tile layer URL and bounds.</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_tile(\n    url,\n    bands=None,\n    titiler_endpoint=None,\n    timeout=300,\n    proxies=None,\n    **kwargs,\n):\n\"\"\"Get a tile layer from a Cloud Optimized GeoTIFF (COG).\n        Source code adapted from https://developmentseed.org/titiler/examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n        proxies (dict, optional): Proxies to use. Defaults to None.\n\n    Returns:\n        tuple: Returns the COG Tile layer URL and bounds.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    url = get_direct_url(url)\n\n    kwargs[\"url\"] = url\n\n    band_names = cog_bands(url, titiler_endpoint)\n\n    if bands is None and \"bidx\" not in kwargs:\n        if len(band_names) &gt;= 3:\n            kwargs[\"bidx\"] = [1, 2, 3]\n    elif bands is not None and \"bidx\" not in kwargs:\n        if all(isinstance(x, int) for x in bands):\n            kwargs[\"bidx\"] = bands\n        elif all(isinstance(x, str) for x in bands):\n            kwargs[\"bidx\"] = [band_names.index(x) + 1 for x in bands]\n        else:\n            raise ValueError(\"Bands must be a list of integers or strings.\")\n\n    if \"palette\" in kwargs:\n        kwargs[\"colormap_name\"] = kwargs[\"palette\"]\n        del kwargs[\"palette\"]\n\n    if \"rescale\" not in kwargs:\n        stats = cog_stats(url, titiler_endpoint)\n        percentile_2 = min([stats[s][\"percentile_2\"] for s in stats])\n        percentile_98 = max([stats[s][\"percentile_98\"] for s in stats])\n        kwargs[\"rescale\"] = f\"{percentile_2},{percentile_98}\"\n\n    TileMatrixSetId = \"WebMercatorQuad\"\n    if \"TileMatrixSetId\" in kwargs.keys():\n        TileMatrixSetId = kwargs[\"TileMatrixSetId\"]\n        kwargs.pop(\"TileMatrixSetId\")\n\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/{TileMatrixSetId}/tilejson.json\",\n        params=kwargs,\n        timeout=timeout,\n        proxies=proxies,\n    ).json()\n\n    return r[\"tiles\"][0]\n</code></pre>"},{"location":"common/#geemap.common.cog_validate","title":"<code>cog_validate(source, verbose=False)</code>","text":"<p>Validate Cloud Optimized Geotiff.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>A dataset path or URL. Will be opened in \"r\" mode.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print the output of the validation. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the rio-cogeo package is not installed.</p> <code>FileNotFoundError</code> <p>If the provided file could not be found.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the validation results (True is src_path is a valid COG, List of validation errors, and a list of validation warnings).</p> Source code in <code>geemap/common.py</code> <pre><code>def cog_validate(source, verbose=False):\n\"\"\"Validate Cloud Optimized Geotiff.\n\n    Args:\n        source (str): A dataset path or URL. Will be opened in \"r\" mode.\n        verbose (bool, optional): Whether to print the output of the validation. Defaults to False.\n\n    Raises:\n        ImportError: If the rio-cogeo package is not installed.\n        FileNotFoundError: If the provided file could not be found.\n\n    Returns:\n        tuple: A tuple containing the validation results (True is src_path is a valid COG, List of validation errors, and a list of validation warnings).\n    \"\"\"\n    try:\n        from rio_cogeo.cogeo import cog_validate, cog_info\n    except ImportError:\n        raise ImportError(\n            \"The rio-cogeo package is not installed. Please install it with `pip install rio-cogeo` or `conda install rio-cogeo -c conda-forge`.\"\n        )\n\n    if not source.startswith(\"http\"):\n        source = check_file_path(source)\n\n        if not os.path.exists(source):\n            raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    if verbose:\n        return cog_info(source)\n    else:\n        return cog_validate(source)\n</code></pre>"},{"location":"common/#geemap.common.column_stats","title":"<code>column_stats(collection, column, stats_type)</code>","text":"<p>Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>FeatureCollection</code> <p>The input feature collection to calculate statistics.</p> required <code>column</code> <code>str</code> <p>The name of the column to calculate statistics.</p> required <code>stats_type</code> <code>str</code> <p>The type of statistics to calculate.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The dictionary containing information about the requested statistics.</p> Source code in <code>geemap/common.py</code> <pre><code>def column_stats(collection, column, stats_type):\n\"\"\"Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean,\n    sample standard deviation, sample variance, total standard deviation and total variance of the selected property.\n\n    Args:\n        collection (FeatureCollection): The input feature collection to calculate statistics.\n        column (str): The name of the column to calculate statistics.\n        stats_type (str): The type of statistics to calculate.\n\n    Returns:\n        dict: The dictionary containing information about the requested statistics.\n    \"\"\"\n    stats_type = stats_type.lower()\n    allowed_stats = [\"min\", \"max\", \"mean\", \"median\", \"sum\", \"stdDev\", \"variance\"]\n    if stats_type not in allowed_stats:\n        print(\n            \"The stats type must be one of the following: {}\".format(\n                \",\".join(allowed_stats)\n            )\n        )\n        return\n\n    stats_dict = {\n        \"min\": ee.Reducer.min(),\n        \"max\": ee.Reducer.max(),\n        \"mean\": ee.Reducer.mean(),\n        \"median\": ee.Reducer.median(),\n        \"sum\": ee.Reducer.sum(),\n        \"stdDev\": ee.Reducer.stdDev(),\n        \"variance\": ee.Reducer.variance(),\n    }\n\n    selectors = [column]\n    stats = collection.reduceColumns(\n        **{\"selectors\": selectors, \"reducer\": stats_dict[stats_type]}\n    )\n\n    return stats\n</code></pre>"},{"location":"common/#geemap.common.connect_postgis","title":"<code>connect_postgis(database, host='localhost', user=None, password=None, port=5432, use_env_var=False)</code>","text":"<p>Connects to a PostGIS database.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str</code> <p>Name of the database</p> required <code>host</code> <code>str</code> <p>Hosting server for the database. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>user</code> <code>str</code> <p>User name to access the database. Defaults to None.</p> <code>None</code> <code>password</code> <code>str</code> <p>Password to access the database. Defaults to None.</p> <code>None</code> <code>port</code> <code>int</code> <p>Port number to connect to at the server host. Defaults to 5432.</p> <code>5432</code> <code>use_env_var</code> <code>bool</code> <p>Whether to use environment variables. It set to True, user and password are treated as an environment variables with default values user=\"SQL_USER\" and password=\"SQL_PASSWORD\". Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If user is not specified.</p> <code>ValueError</code> <p>If password is not specified.</p> <p>Returns:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>geemap/common.py</code> <pre><code>def connect_postgis(\n    database, host=\"localhost\", user=None, password=None, port=5432, use_env_var=False\n):\n\"\"\"Connects to a PostGIS database.\n\n    Args:\n        database (str): Name of the database\n        host (str, optional): Hosting server for the database. Defaults to \"localhost\".\n        user (str, optional): User name to access the database. Defaults to None.\n        password (str, optional): Password to access the database. Defaults to None.\n        port (int, optional): Port number to connect to at the server host. Defaults to 5432.\n        use_env_var (bool, optional): Whether to use environment variables. It set to True, user and password are treated as an environment variables with default values user=\"SQL_USER\" and password=\"SQL_PASSWORD\". Defaults to False.\n\n    Raises:\n        ValueError: If user is not specified.\n        ValueError: If password is not specified.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    check_package(\n        name=\"sqlalchemy\",\n        URL=\"https://docs.sqlalchemy.org/en/14/intro.html#installation\",\n    )\n\n    from sqlalchemy import create_engine\n\n    if use_env_var:\n        if user is not None:\n            user = os.getenv(user)\n        else:\n            user = os.getenv(\"SQL_USER\")\n\n        if password is not None:\n            password = os.getenv(password)\n        else:\n            password = os.getenv(\"SQL_PASSWORD\")\n\n        if user is None:\n            raise ValueError(\"user is not specified.\")\n        if password is None:\n            raise ValueError(\"password is not specified.\")\n\n    connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n    engine = create_engine(connection_string)\n\n    return engine\n</code></pre>"},{"location":"common/#geemap.common.convert_lidar","title":"<code>convert_lidar(source, destination=None, point_format_id=None, file_version=None, **kwargs)</code>","text":"<p>Converts a Las from one point format to another Automatically upgrades the file version if source file version     is not compatible with the new point_format_id</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | laspy.lasdatas.base.LasBase</code> <p>The source data to be converted.</p> required <code>destination</code> <code>str</code> <p>The destination file path. Defaults to None.</p> <code>None</code> <code>point_format_id</code> <code>int</code> <p>The new point format id (the default is None, which won't change the source format id).</p> <code>None</code> <code>file_version</code> <code>str</code> <p>The new file version. None by default which means that the file_version may be upgraded for compatibility with the new point_format. The file version will not be downgraded.</p> <code>None</code> <p>Returns:</p> Type Description <code>aspy.lasdatas.base.LasBase</code> <p>The converted LasData object.</p> Source code in <code>geemap/common.py</code> <pre><code>def convert_lidar(\n    source, destination=None, point_format_id=None, file_version=None, **kwargs\n):\n\"\"\"Converts a Las from one point format to another Automatically upgrades the file version if source file version\n        is not compatible with the new point_format_id\n\n    Args:\n        source (str | laspy.lasdatas.base.LasBase): The source data to be converted.\n        destination (str, optional): The destination file path. Defaults to None.\n        point_format_id (int, optional): The new point format id (the default is None, which won't change the source format id).\n        file_version (str, optional): The new file version. None by default which means that the file_version may be upgraded\n            for compatibility with the new point_format. The file version will not be downgraded.\n\n    Returns:\n        aspy.lasdatas.base.LasBase: The converted LasData object.\n    \"\"\"\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if isinstance(source, str):\n        source = read_lidar(source)\n\n    las = laspy.convert(\n        source, point_format_id=point_format_id, file_version=file_version\n    )\n\n    if destination is None:\n        return las\n    else:\n        destination = check_file_path(destination)\n        write_lidar(las, destination, **kwargs)\n        return destination\n</code></pre>"},{"location":"common/#geemap.common.coords_to_geojson","title":"<code>coords_to_geojson(coords)</code>","text":"<p>Convert a list of bbox coordinates representing [left, bottom, right, top] to geojson FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of bbox coordinates representing [left, bottom, right, top].</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A geojson FeatureCollection.</p> Source code in <code>geemap/common.py</code> <pre><code>def coords_to_geojson(coords):\n\"\"\"Convert a list of bbox coordinates representing [left, bottom, right, top] to geojson FeatureCollection.\n\n    Args:\n        coords (list): A list of bbox coordinates representing [left, bottom, right, top].\n\n    Returns:\n        dict: A geojson FeatureCollection.\n    \"\"\"\n\n    features = []\n    for bbox in coords:\n        features.append(bbox_to_geojson(bbox))\n    return {\"type\": \"FeatureCollection\", \"features\": features}\n</code></pre>"},{"location":"common/#geemap.common.copy_credentials_to_colab","title":"<code>copy_credentials_to_colab()</code>","text":"<p>Copies ee credentials from Google Drive to Google Colab.</p> Source code in <code>geemap/common.py</code> <pre><code>def copy_credentials_to_colab():\n\"\"\"Copies ee credentials from Google Drive to Google Colab.\"\"\"\n    src = \"/content/drive/My Drive/.config/earthengine/credentials\"\n    dst = \"/root/.config/earthengine/credentials\"\n\n    wd = os.path.dirname(dst)\n    if not os.path.exists(wd):\n        os.makedirs(wd)\n\n    shutil.copyfile(src, dst)\n</code></pre>"},{"location":"common/#geemap.common.copy_credentials_to_drive","title":"<code>copy_credentials_to_drive()</code>","text":"<p>Copies ee credentials from Google Colab to Google Drive.</p> Source code in <code>geemap/common.py</code> <pre><code>def copy_credentials_to_drive():\n\"\"\"Copies ee credentials from Google Colab to Google Drive.\"\"\"\n    src = \"/root/.config/earthengine/credentials\"\n    dst = \"/content/drive/My Drive/.config/earthengine/credentials\"\n\n    wd = os.path.dirname(dst)\n    if not os.path.exists(wd):\n        os.makedirs(wd)\n\n    shutil.copyfile(src, dst)\n</code></pre>"},{"location":"common/#geemap.common.create_code_cell","title":"<code>create_code_cell(code='', where='below')</code>","text":"<p>Creates a code cell in the IPython Notebook.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Code to fill the new code cell with. Defaults to ''.</p> <code>''</code> <code>where</code> <code>str</code> <p>Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.</p> <code>'below'</code> Source code in <code>geemap/common.py</code> <pre><code>def create_code_cell(code=\"\", where=\"below\"):\n\"\"\"Creates a code cell in the IPython Notebook.\n\n    Args:\n        code (str, optional): Code to fill the new code cell with. Defaults to ''.\n        where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.\n    \"\"\"\n\n    import base64\n    import pyperclip\n\n    from IPython.display import Javascript, display\n\n    try:\n        pyperclip.copy(str(code))\n    except Exception as e:\n        pass\n\n    encoded_code = (base64.b64encode(str.encode(code))).decode()\n    display(\n        Javascript(\n\"\"\"\n        var code = IPython.notebook.insert_cell_{0}('code');\n        code.set_text(atob(\"{1}\"));\n    \"\"\".format(\n                where, encoded_code\n            )\n        )\n    )\n</code></pre>"},{"location":"common/#geemap.common.create_colorbar","title":"<code>create_colorbar(width=150, height=30, palette=['blue', 'green', 'red'], add_ticks=True, add_labels=True, labels=None, vertical=False, out_file=None, font_type='arial.ttf', font_size=12, font_color='black', add_outline=True, outline_color='black')</code>","text":"<p>Creates a colorbar based on the provided palette.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the colorbar in pixels. Defaults to 150.</p> <code>150</code> <code>height</code> <code>int</code> <p>Height of the colorbar in pixels. Defaults to 30.</p> <code>30</code> <code>palette</code> <code>list</code> <p>Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red'].</p> <code>['blue', 'green', 'red']</code> <code>add_ticks</code> <code>bool</code> <p>Whether to add tick markers to the colorbar. Defaults to True.</p> <code>True</code> <code>add_labels</code> <code>bool</code> <p>Whether to add labels to the colorbar. Defaults to True.</p> <code>True</code> <code>labels</code> <code>list</code> <p>A list of labels to add to the colorbar. Defaults to None.</p> <code>None</code> <code>vertical</code> <code>bool</code> <p>Whether to rotate the colorbar vertically. Defaults to False.</p> <code>False</code> <code>out_file</code> <code>str</code> <p>File path to the output colorbar in png format. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type to use for labels. Defaults to 'arial.ttf'.</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size to use for labels. Defaults to 12.</p> <code>12</code> <code>font_color</code> <code>str</code> <p>Font color to use for labels. Defaults to 'black'.</p> <code>'black'</code> <code>add_outline</code> <code>bool</code> <p>Whether to add an outline to the colorbar. Defaults to True.</p> <code>True</code> <code>outline_color</code> <code>str</code> <p>Color for the outline of the colorbar. Defaults to 'black'.</p> <code>'black'</code> <p>Returns:</p> Type Description <code>str</code> <p>File path of the output colorbar in png format.</p> Source code in <code>geemap/common.py</code> <pre><code>def create_colorbar(\n    width=150,\n    height=30,\n    palette=[\"blue\", \"green\", \"red\"],\n    add_ticks=True,\n    add_labels=True,\n    labels=None,\n    vertical=False,\n    out_file=None,\n    font_type=\"arial.ttf\",\n    font_size=12,\n    font_color=\"black\",\n    add_outline=True,\n    outline_color=\"black\",\n):\n\"\"\"Creates a colorbar based on the provided palette.\n\n    Args:\n        width (int, optional): Width of the colorbar in pixels. Defaults to 150.\n        height (int, optional): Height of the colorbar in pixels. Defaults to 30.\n        palette (list, optional): Palette for the colorbar. Each color can be provided as a string (e.g., 'red'), a hex string (e.g., '#ff0000'), or an RGB tuple (255, 0, 255). Defaults to ['blue', 'green', 'red'].\n        add_ticks (bool, optional): Whether to add tick markers to the colorbar. Defaults to True.\n        add_labels (bool, optional): Whether to add labels to the colorbar. Defaults to True.\n        labels (list, optional): A list of labels to add to the colorbar. Defaults to None.\n        vertical (bool, optional): Whether to rotate the colorbar vertically. Defaults to False.\n        out_file (str, optional): File path to the output colorbar in png format. Defaults to None.\n        font_type (str, optional): Font type to use for labels. Defaults to 'arial.ttf'.\n        font_size (int, optional): Font size to use for labels. Defaults to 12.\n        font_color (str, optional): Font color to use for labels. Defaults to 'black'.\n        add_outline (bool, optional): Whether to add an outline to the colorbar. Defaults to True.\n        outline_color (str, optional): Color for the outline of the colorbar. Defaults to 'black'.\n\n    Returns:\n        str: File path of the output colorbar in png format.\n\n    \"\"\"\n    import decimal\n\n    # import io\n    import pkg_resources\n    from colour import Color\n    from PIL import Image, ImageDraw, ImageFont\n\n    warnings.simplefilter(\"ignore\")\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n\n    if out_file is None:\n        filename = \"colorbar_\" + random_string() + \".png\"\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        out_file = os.path.join(out_dir, filename)\n    elif not out_file.endswith(\".png\"):\n        print(\"The output file must end with .png\")\n        return\n    else:\n        out_file = os.path.abspath(out_file)\n\n    if not os.path.exists(os.path.dirname(out_file)):\n        os.makedirs(os.path.dirname(out_file))\n\n    im = Image.new(\"RGBA\", (width, height))\n    ld = im.load()\n\n    def float_range(start, stop, step):\n        while start &lt; stop:\n            yield float(start)\n            start += decimal.Decimal(step)\n\n    n_colors = len(palette)\n    decimal_places = 2\n    rgb_colors = [Color(check_color(c)).rgb for c in palette]\n    keys = [\n        round(c, decimal_places)\n        for c in list(float_range(0, 1.0001, 1.0 / (n_colors - 1)))\n    ]\n\n    heatmap = []\n    for index, item in enumerate(keys):\n        pair = [item, rgb_colors[index]]\n        heatmap.append(pair)\n\n    def gaussian(x, a, b, c, d=0):\n        return a * math.exp(-((x - b) ** 2) / (2 * c**2)) + d\n\n    def pixel(x, width=100, map=[], spread=1):\n        width = float(width)\n        r = sum(\n            [\n                gaussian(x, p[1][0], p[0] * width, width / (spread * len(map)))\n                for p in map\n            ]\n        )\n        g = sum(\n            [\n                gaussian(x, p[1][1], p[0] * width, width / (spread * len(map)))\n                for p in map\n            ]\n        )\n        b = sum(\n            [\n                gaussian(x, p[1][2], p[0] * width, width / (spread * len(map)))\n                for p in map\n            ]\n        )\n        return min(1.0, r), min(1.0, g), min(1.0, b)\n\n    for x in range(im.size[0]):\n        r, g, b = pixel(x, width=width, map=heatmap)\n        r, g, b = [int(256 * v) for v in (r, g, b)]\n        for y in range(im.size[1]):\n            ld[x, y] = r, g, b\n\n    if add_outline:\n        draw = ImageDraw.Draw(im)\n        draw.rectangle(\n            [(0, 0), (width - 1, height - 1)], outline=check_color(outline_color)\n        )\n        del draw\n\n    if add_ticks:\n        tick_length = height * 0.1\n        x = [key * width for key in keys]\n        y_top = height - tick_length\n        y_bottom = height\n        draw = ImageDraw.Draw(im)\n        for i in x:\n            shape = [(i, y_top), (i, y_bottom)]\n            draw.line(shape, fill=\"black\", width=0)\n        del draw\n\n    if vertical:\n        im = im.transpose(Image.ROTATE_90)\n\n    width, height = im.size\n\n    if labels is None:\n        labels = [str(c) for c in keys]\n    elif len(labels) == 2:\n        try:\n            lowerbound = float(labels[0])\n            upperbound = float(labels[1])\n            step = (upperbound - lowerbound) / (len(palette) - 1)\n            labels = [str(lowerbound + c * step) for c in range(0, len(palette))]\n        except Exception as e:\n            print(e)\n            print(\"The labels are invalid.\")\n            return\n    elif len(labels) == len(palette):\n        labels = [str(c) for c in labels]\n    else:\n        print(\"The labels must have the same length as the palette.\")\n        return\n\n    if add_labels:\n        default_font = os.path.join(pkg_dir, \"data/fonts/arial.ttf\")\n        if font_type == \"arial.ttf\":\n            font = ImageFont.truetype(default_font, font_size)\n        else:\n            try:\n                font_list = system_fonts(show_full_path=True)\n                font_names = [os.path.basename(f) for f in font_list]\n                if (font_type in font_list) or (font_type in font_names):\n                    font = ImageFont.truetype(font_type, font_size)\n                else:\n                    print(\n                        \"The specified font type could not be found on your system. Using the default font instead.\"\n                    )\n                    font = ImageFont.truetype(default_font, font_size)\n            except Exception as e:\n                print(e)\n                font = ImageFont.truetype(default_font, font_size)\n\n        font_color = check_color(font_color)\n\n        draw = ImageDraw.Draw(im)\n        w, h = draw.textsize(labels[0], font=font)\n\n        for label in labels:\n            w_tmp, h_tmp = draw.textsize(label, font)\n            if w_tmp &gt; w:\n                w = w_tmp\n            if h_tmp &gt; h:\n                h = h_tmp\n\n        W, H = width + w * 2, height + h * 2\n        background = Image.new(\"RGBA\", (W, H))\n        draw = ImageDraw.Draw(background)\n\n        if vertical:\n            xy = (0, h)\n        else:\n            xy = (w, 0)\n        background.paste(im, xy, im)\n\n        for index, label in enumerate(labels):\n            w_tmp, h_tmp = draw.textsize(label, font)\n\n            if vertical:\n                spacing = 5\n                x = width + spacing\n                y = int(height + h - keys[index] * height - h_tmp / 2 - 1)\n                draw.text((x, y), label, font=font, fill=font_color)\n\n            else:\n                x = int(keys[index] * width + w - w_tmp / 2)\n                spacing = int(h * 0.05)\n                y = height + spacing\n                draw.text((x, y), label, font=font, fill=font_color)\n\n        im = background.copy()\n\n    im.save(out_file)\n    return out_file\n</code></pre>"},{"location":"common/#geemap.common.create_contours","title":"<code>create_contours(image, min_value, max_value, interval, kernel=None, region=None, values=None)</code>","text":"<p>Creates contours from an image. Code adapted from https://mygeoblog.com/2017/01/28/contour-lines-in-gee. Credits to MyGeoBlog.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>An image to create contours.</p> required <code>min_value</code> <code>float</code> <p>The minimum value of contours.</p> required <code>max_value</code> <code>float</code> <p>The maximum value of contours.</p> required <code>interval</code> <code>float</code> <p>The interval between contours.</p> required <code>kernel</code> <code>ee.Kernel</code> <p>The kernel to use for smoothing image. Defaults to None.</p> <code>None</code> <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region of interest. Defaults to None.</p> <code>None</code> <code>values</code> <code>list</code> <p>A list of values to create contours for. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>The image must be an ee.Image.</p> <code>TypeError</code> <p>The region must be an ee.Geometry or ee.FeatureCollection.</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The image containing contours.</p> Source code in <code>geemap/common.py</code> <pre><code>def create_contours(\n    image, min_value, max_value, interval, kernel=None, region=None, values=None\n):\n\"\"\"Creates contours from an image. Code adapted from https://mygeoblog.com/2017/01/28/contour-lines-in-gee. Credits to MyGeoBlog.\n\n    Args:\n        image (ee.Image): An image to create contours.\n        min_value (float): The minimum value of contours.\n        max_value (float): The maximum value of contours.\n        interval (float):  The interval between contours.\n        kernel (ee.Kernel, optional): The kernel to use for smoothing image. Defaults to None.\n        region (ee.Geometry | ee.FeatureCollection, optional): The region of interest. Defaults to None.\n        values (list, optional): A list of values to create contours for. Defaults to None.\n\n    Raises:\n        TypeError: The image must be an ee.Image.\n        TypeError: The region must be an ee.Geometry or ee.FeatureCollection.\n\n    Returns:\n        ee.Image: The image containing contours.\n    \"\"\"\n    if not isinstance(image, ee.Image):\n        raise TypeError(\"The image must be an ee.Image.\")\n    if region is not None:\n        if isinstance(region, ee.FeatureCollection) or isinstance(region, ee.Geometry):\n            pass\n        else:\n            raise TypeError(\n                \"The region must be an ee.Geometry or ee.FeatureCollection.\"\n            )\n\n    if kernel is None:\n        kernel = ee.Kernel.gaussian(5, 3)\n\n    if isinstance(values, list):\n        values = ee.List(values)\n    elif isinstance(values, ee.List):\n        pass\n\n    if values is None:\n        values = ee.List.sequence(min_value, max_value, interval)\n\n    def contouring(value):\n        mycountour = (\n            image.convolve(kernel)\n            .subtract(ee.Image.constant(value))\n            .zeroCrossing()\n            .multiply(ee.Image.constant(value).toFloat())\n        )\n        return mycountour.mask(mycountour)\n\n    contours = values.map(contouring)\n\n    if region is not None:\n        if isinstance(region, ee.FeatureCollection):\n            return ee.ImageCollection(contours).mosaic().clipToCollection(region)\n        elif isinstance(region, ee.Geometry):\n            return ee.ImageCollection(contours).mosaic().clip(region)\n    else:\n        return ee.ImageCollection(contours).mosaic()\n</code></pre>"},{"location":"common/#geemap.common.create_download_button","title":"<code>create_download_button(label, data, file_name=None, mime=None, key=None, help=None, on_click=None, args=None, **kwargs)</code>","text":"<p>Streamlit function to create a download button.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>A short label explaining to the user what this button is for..</p> required <code>data</code> <code>str | list</code> <p>The contents of the file to be downloaded. See example below for caching techniques to avoid recomputing this data unnecessarily.</p> required <code>file_name</code> <code>str</code> <p>An optional string to use as the name of the file to be downloaded, such as 'my_file.csv'. If not specified, the name will be automatically generated. Defaults to None.</p> <code>None</code> <code>mime</code> <code>str</code> <p>The MIME type of the data. If None, defaults to \"text/plain\" (if data is of type str or is a textual file) or \"application/octet-stream\" (if data is of type bytes or is a binary file). Defaults to None.</p> <code>None</code> <code>key</code> <code>str</code> <p>An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. Defaults to None.</p> <code>None</code> <code>help</code> <code>str</code> <p>An optional tooltip that gets displayed when the button is hovered over. Defaults to None.</p> <code>None</code> <code>on_click</code> <code>str</code> <p>An optional callback invoked when this button is clicked. Defaults to None.</p> <code>None</code> <code>args</code> <code>list</code> <p>An optional tuple of args to pass to the callback. Defaults to None.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>An optional tuple of args to pass to the callback.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def create_download_button(\n    label,\n    data,\n    file_name=None,\n    mime=None,\n    key=None,\n    help=None,\n    on_click=None,\n    args=None,\n    **kwargs,\n):\n\"\"\"Streamlit function to create a download button.\n\n    Args:\n        label (str): A short label explaining to the user what this button is for..\n        data (str | list): The contents of the file to be downloaded. See example below for caching techniques to avoid recomputing this data unnecessarily.\n        file_name (str, optional): An optional string to use as the name of the file to be downloaded, such as 'my_file.csv'. If not specified, the name will be automatically generated. Defaults to None.\n        mime (str, optional): The MIME type of the data. If None, defaults to \"text/plain\" (if data is of type str or is a textual file) or \"application/octet-stream\" (if data is of type bytes or is a binary file). Defaults to None.\n        key (str, optional): An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. Defaults to None.\n        help (str, optional): An optional tooltip that gets displayed when the button is hovered over. Defaults to None.\n        on_click (str, optional): An optional callback invoked when this button is clicked. Defaults to None.\n        args (list, optional): An optional tuple of args to pass to the callback. Defaults to None.\n        kwargs (dict, optional): An optional tuple of args to pass to the callback.\n\n    \"\"\"\n    try:\n        import streamlit as st\n        import pandas as pd\n\n        if isinstance(data, str):\n            if file_name is None:\n                file_name = data.split(\"/\")[-1]\n\n            if data.endswith(\".csv\"):\n                data = pd.read_csv(data).to_csv()\n                if mime is None:\n                    mime = \"text/csv\"\n                return st.download_button(\n                    label, data, file_name, mime, key, help, on_click, args, **kwargs\n                )\n            elif (\n                data.endswith(\".gif\") or data.endswith(\".png\") or data.endswith(\".jpg\")\n            ):\n                if mime is None:\n                    mime = f\"image/{os.path.splitext(data)[1][1:]}\"\n\n                with open(data, \"rb\") as file:\n                    return st.download_button(\n                        label,\n                        file,\n                        file_name,\n                        mime,\n                        key,\n                        help,\n                        on_click,\n                        args,\n                        **kwargs,\n                    )\n\n            else:\n                return st.download_button(\n                    label,\n                    label,\n                    data,\n                    file_name,\n                    mime,\n                    key,\n                    help,\n                    on_click,\n                    args,\n                    **kwargs,\n                )\n\n    except ImportError:\n        print(\"Streamlit is not installed. Please run 'pip install streamlit'.\")\n        return\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.create_download_link","title":"<code>create_download_link(filename, title='Click here to download: ')</code>","text":"<p>Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file path to the file to download</p> required <code>title</code> <code>str</code> <p>str. Defaults to \"Click here to download: \".</p> <code>'Click here to download: '</code> <p>Returns:</p> Type Description <code>str</code> <p>HTML download URL.</p> Source code in <code>geemap/common.py</code> <pre><code>def create_download_link(filename, title=\"Click here to download: \"):\n\"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578\n\n    Args:\n        filename (str): The file path to the file to download\n        title (str, optional): str. Defaults to \"Click here to download: \".\n\n    Returns:\n        str: HTML download URL.\n    \"\"\"\n    import base64\n\n    from IPython.display import HTML\n\n    data = open(filename, \"rb\").read()\n    b64 = base64.b64encode(data)\n    payload = b64.decode()\n    basename = os.path.basename(filename)\n    html = '&lt;a download=\"{filename}\" href=\"data:text/csv;base64,{payload}\" style=\"color:#0000FF;\" target=\"_blank\"&gt;{title}&lt;/a&gt;'\n    html = html.format(payload=payload, title=title + f\" {basename}\", filename=basename)\n    return HTML(html)\n</code></pre>"},{"location":"common/#geemap.common.create_legend","title":"<code>create_legend(title='Legend', labels=None, colors=None, legend_dict=None, builtin_legend=None, opacity=1.0, position='bottomright', draggable=True, output=None, style={})</code>","text":"<p>Create a legend in HTML format. Reference: https://bit.ly/3oV6vnH</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".</p> <code>'Legend'</code> <code>colors</code> <code>list</code> <p>A list of legend colors. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of legend labels. Defaults to None.</p> <code>None</code> <code>legend_dict</code> <code>dict</code> <p>A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.</p> <code>None</code> <code>builtin_legend</code> <code>str</code> <p>Name of the builtin legend to add to the map. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the legend. Defaults to 1.0.</p> <code>1.0</code> <code>position</code> <code>str</code> <p>The position of the legend, can be one of the following: \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>draggable</code> <code>bool</code> <p>If True, the legend can be dragged to a new position. Defaults to True.</p> <code>True</code> <code>output</code> <code>str</code> <p>The output file path (*.html) to save the legend. Defaults to None.</p> <code>None</code> <code>style</code> <p>Additional keyword arguments to style the legend, such as position, bottom, right, z-index, border, background-color, border-radius, padding, font-size, etc. The default style is: style = {     'position': 'fixed',     'z-index': '9999',     'border': '2px solid grey',     'background-color': 'rgba(255, 255, 255, 0.8)',     'border-radius': '5px',     'padding': '10px',     'font-size': '14px',     'bottom': '20px',     'right': '5px' }</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of the legend.</p> Source code in <code>geemap/common.py</code> <pre><code>def create_legend(\n    title=\"Legend\",\n    labels=None,\n    colors=None,\n    legend_dict=None,\n    builtin_legend=None,\n    opacity=1.0,\n    position=\"bottomright\",\n    draggable=True,\n    output=None,\n    style={},\n):\n\"\"\"Create a legend in HTML format. Reference: https://bit.ly/3oV6vnH\n\n    Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".\n        colors (list, optional): A list of legend colors. Defaults to None.\n        labels (list, optional): A list of legend labels. Defaults to None.\n        legend_dict (dict, optional): A dictionary containing legend items as keys and color as values.\n            If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n        builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n        opacity (float, optional): The opacity of the legend. Defaults to 1.0.\n        position (str, optional): The position of the legend, can be one of the following:\n            \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n        draggable (bool, optional): If True, the legend can be dragged to a new position. Defaults to True.\n        output (str, optional): The output file path (*.html) to save the legend. Defaults to None.\n        style: Additional keyword arguments to style the legend, such as position, bottom, right, z-index,\n            border, background-color, border-radius, padding, font-size, etc. The default style is:\n            style = {\n                'position': 'fixed',\n                'z-index': '9999',\n                'border': '2px solid grey',\n                'background-color': 'rgba(255, 255, 255, 0.8)',\n                'border-radius': '5px',\n                'padding': '10px',\n                'font-size': '14px',\n                'bottom': '20px',\n                'right': '5px'\n            }\n\n    Returns:\n        str: The HTML code of the legend.\n    \"\"\"\n\n    import pkg_resources\n    from .legends import builtin_legends\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    legend_template = os.path.join(pkg_dir, \"data/template/legend_style.html\")\n\n    if draggable:\n        legend_template = os.path.join(pkg_dir, \"data/template/legend.txt\")\n\n    if not os.path.exists(legend_template):\n        raise FileNotFoundError(\"The legend template does not exist.\")\n\n    if labels is not None:\n        if not isinstance(labels, list):\n            print(\"The legend keys must be a list.\")\n            return\n    else:\n        labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n\n    if colors is not None:\n        if not isinstance(colors, list):\n            print(\"The legend colors must be a list.\")\n            return\n        elif all(isinstance(item, tuple) for item in colors):\n            try:\n                colors = [rgb_to_hex(x) for x in colors]\n            except Exception as e:\n                print(e)\n        elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n            pass\n        elif all((len(item) == 6) for item in colors):\n            pass\n        else:\n            print(\"The legend colors must be a list of tuples.\")\n            return\n    else:\n        colors = [\n            \"#8DD3C7\",\n            \"#FFFFB3\",\n            \"#BEBADA\",\n            \"#FB8072\",\n            \"#80B1D3\",\n        ]\n\n    if len(labels) != len(colors):\n        print(\"The legend keys and values must be the same length.\")\n        return\n\n    allowed_builtin_legends = builtin_legends.keys()\n    if builtin_legend is not None:\n        if builtin_legend not in allowed_builtin_legends:\n            print(\n                \"The builtin legend must be one of the following: {}\".format(\n                    \", \".join(allowed_builtin_legends)\n                )\n            )\n            return\n        else:\n            legend_dict = builtin_legends[builtin_legend]\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n\n    if legend_dict is not None:\n        if not isinstance(legend_dict, dict):\n            print(\"The legend dict must be a dictionary.\")\n            return\n        else:\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n            if all(isinstance(item, tuple) for item in colors):\n                try:\n                    colors = [rgb_to_hex(x) for x in colors]\n                except Exception as e:\n                    print(e)\n\n    allowed_positions = [\n        \"topleft\",\n        \"topright\",\n        \"bottomleft\",\n        \"bottomright\",\n    ]\n    if position not in allowed_positions:\n        raise ValueError(\n            \"The position must be one of the following: {}\".format(\n                \", \".join(allowed_positions)\n            )\n        )\n\n    if position == \"bottomright\":\n        if \"bottom\" not in style:\n            style[\"bottom\"] = \"20px\"\n        if \"right\" not in style:\n            style[\"right\"] = \"5px\"\n        if \"left\" in style:\n            del style[\"left\"]\n        if \"top\" in style:\n            del style[\"top\"]\n    elif position == \"bottomleft\":\n        if \"bottom\" not in style:\n            style[\"bottom\"] = \"5px\"\n        if \"left\" not in style:\n            style[\"left\"] = \"5px\"\n        if \"right\" in style:\n            del style[\"right\"]\n        if \"top\" in style:\n            del style[\"top\"]\n    elif position == \"topright\":\n        if \"top\" not in style:\n            style[\"top\"] = \"5px\"\n        if \"right\" not in style:\n            style[\"right\"] = \"5px\"\n        if \"left\" in style:\n            del style[\"left\"]\n        if \"bottom\" in style:\n            del style[\"bottom\"]\n    elif position == \"topleft\":\n        if \"top\" not in style:\n            style[\"top\"] = \"5px\"\n        if \"left\" not in style:\n            style[\"left\"] = \"5px\"\n        if \"right\" in style:\n            del style[\"right\"]\n        if \"bottom\" in style:\n            del style[\"bottom\"]\n\n    if \"position\" not in style:\n        style[\"position\"] = \"fixed\"\n    if \"z-index\" not in style:\n        style[\"z-index\"] = \"9999\"\n    if \"background-color\" not in style:\n        style[\"background-color\"] = \"rgba(255, 255, 255, 0.8)\"\n    if \"padding\" not in style:\n        style[\"padding\"] = \"10px\"\n    if \"border-radius\" not in style:\n        style[\"border-radius\"] = \"5px\"\n    if \"font-size\" not in style:\n        style[\"font-size\"] = \"14px\"\n\n    content = []\n\n    with open(legend_template) as f:\n        lines = f.readlines()\n\n    if draggable:\n        for index, line in enumerate(lines):\n            if index &lt; 36:\n                content.append(line)\n            elif index == 36:\n                line = lines[index].replace(\"Legend\", title)\n                content.append(line)\n            elif index &lt; 39:\n                content.append(line)\n            elif index == 39:\n                for i, color in enumerate(colors):\n                    item = f\"    &lt;li&gt;&lt;span style='background:{check_color(color)};opacity:{opacity};'&gt;&lt;/span&gt;{labels[i]}&lt;/li&gt;\\n\"\n                    content.append(item)\n            elif index &gt; 41:\n                content.append(line)\n        content = content[3:-1]\n\n    else:\n        for index, line in enumerate(lines):\n            if index &lt; 8:\n                content.append(line)\n            elif index == 8:\n                for key, value in style.items():\n                    content.append(\n                        \"              {}: {};\\n\".format(key.replace(\"_\", \"-\"), value)\n                    )\n            elif index &lt; 17:\n                pass\n            elif index &lt; 19:\n                content.append(line)\n            elif index == 19:\n                content.append(line.replace(\"Legend\", title))\n            elif index &lt; 22:\n                content.append(line)\n            elif index == 22:\n                for index, key in enumerate(labels):\n                    color = colors[index]\n                    if not color.startswith(\"#\"):\n                        color = \"#\" + color\n                    item = \"                    &lt;li&gt;&lt;span style='background:{};opacity:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n                        color, opacity, key\n                    )\n                    content.append(item)\n            elif index &lt; 33:\n                pass\n            else:\n                content.append(line)\n\n    legend_text = \"\".join(content)\n\n    if output is not None:\n        with open(output, \"w\") as f:\n            f.write(legend_text)\n    else:\n        return legend_text\n</code></pre>"},{"location":"common/#geemap.common.create_nlcd_qml","title":"<code>create_nlcd_qml(out_qml)</code>","text":"<p>Create a QGIS Layer Style (.qml) for NLCD data</p> <p>Parameters:</p> Name Type Description Default <code>out_qml</code> <code>str</code> <p>File path to the output qml.</p> required Source code in <code>geemap/common.py</code> <pre><code>def create_nlcd_qml(out_qml):\n\"\"\"Create a QGIS Layer Style (.qml) for NLCD data\n\n    Args:\n        out_qml (str): File path to the output qml.\n    \"\"\"\n    import pkg_resources\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    data_dir = os.path.join(pkg_dir, \"data\")\n    template_dir = os.path.join(data_dir, \"template\")\n    qml_template = os.path.join(template_dir, \"NLCD.qml\")\n\n    out_dir = os.path.dirname(out_qml)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    shutil.copyfile(qml_template, out_qml)\n</code></pre>"},{"location":"common/#geemap.common.credentials_in_colab","title":"<code>credentials_in_colab()</code>","text":"<p>Checks if the ee credentials file exists in Google Colab.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if Google Drive is mounted, False otherwise.</p> Source code in <code>geemap/common.py</code> <pre><code>def credentials_in_colab():\n\"\"\"Checks if the ee credentials file exists in Google Colab.\n\n    Returns:\n        bool: Returns True if Google Drive is mounted, False otherwise.\n    \"\"\"\n    credentials_path = \"/root/.config/earthengine/credentials\"\n    if os.path.exists(credentials_path):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#geemap.common.credentials_in_drive","title":"<code>credentials_in_drive()</code>","text":"<p>Checks if the ee credentials file exists in Google Drive.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if Google Drive is mounted, False otherwise.</p> Source code in <code>geemap/common.py</code> <pre><code>def credentials_in_drive():\n\"\"\"Checks if the ee credentials file exists in Google Drive.\n\n    Returns:\n        bool: Returns True if Google Drive is mounted, False otherwise.\n    \"\"\"\n    credentials_path = \"/content/drive/My Drive/.config/earthengine/credentials\"\n    if os.path.exists(credentials_path):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#geemap.common.csv_points_to_shp","title":"<code>csv_points_to_shp(in_csv, out_shp, latitude='latitude', longitude='longitude')</code>","text":"<p>Converts a csv file containing points (latitude, longitude) into a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/giswqs/data/main/world/world_cities.csv</p> required <code>out_shp</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>latitude</code> <code>str</code> <p>Column name for the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>Column name for the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> Source code in <code>geemap/common.py</code> <pre><code>def csv_points_to_shp(in_csv, out_shp, latitude=\"latitude\", longitude=\"longitude\"):\n\"\"\"Converts a csv file containing points (latitude, longitude) into a shapefile.\n\n    Args:\n        in_csv (str): File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/giswqs/data/main/world/world_cities.csv\n        out_shp (str): File path to the output shapefile.\n        latitude (str, optional): Column name for the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): Column name for the longitude column. Defaults to 'longitude'.\n\n    \"\"\"\n    import whitebox\n\n    if in_csv.startswith(\"http\") and in_csv.endswith(\".csv\"):\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        out_name = os.path.basename(in_csv)\n\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        download_from_url(in_csv, out_dir=out_dir, verbose=False)\n        in_csv = os.path.join(out_dir, out_name)\n\n    wbt = whitebox.WhiteboxTools()\n    in_csv = os.path.abspath(in_csv)\n    out_shp = os.path.abspath(out_shp)\n\n    if not os.path.exists(in_csv):\n        raise Exception(\"The provided csv file does not exist.\")\n\n    with open(in_csv, encoding=\"utf-8\") as csv_file:\n        reader = csv.DictReader(csv_file)\n        fields = reader.fieldnames\n        xfield = fields.index(longitude)\n        yfield = fields.index(latitude)\n\n    wbt.csv_points_to_vector(in_csv, out_shp, xfield=xfield, yfield=yfield, epsg=4326)\n</code></pre>"},{"location":"common/#geemap.common.csv_to_df","title":"<code>csv_to_df(in_csv, **kwargs)</code>","text":"<p>Converts a CSV file to pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path to the input CSV.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pandas DataFrame</p> Source code in <code>geemap/common.py</code> <pre><code>def csv_to_df(in_csv, **kwargs):\n\"\"\"Converts a CSV file to pandas dataframe.\n\n    Args:\n        in_csv (str): File path to the input CSV.\n\n    Returns:\n        pd.DataFrame: pandas DataFrame\n    \"\"\"\n    import pandas as pd\n\n    in_csv = github_raw_url(in_csv)\n\n    try:\n        return pd.read_csv(in_csv, **kwargs)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.csv_to_ee","title":"<code>csv_to_ee(in_csv, latitude='latitude', longitude='longitude', encoding='utf-8', geodesic=True)</code>","text":"<p>Creates points for a CSV file and exports data as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>geodesic</code> <code>bool</code> <p>Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee_object</code> <p>An ee.Geometry object</p> Source code in <code>geemap/common.py</code> <pre><code>def csv_to_ee(\n    in_csv, latitude=\"latitude\", longitude=\"longitude\", encoding=\"utf-8\", geodesic=True\n):\n\"\"\"Creates points for a CSV file and exports data as a GeoJSON.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n        geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.\n\n    Returns:\n        ee_object: An ee.Geometry object\n    \"\"\"\n\n    geojson = csv_to_geojson(\n        in_csv, latitude=latitude, longitude=longitude, encoding=encoding\n    )\n    fc = geojson_to_ee(geojson, geodesic=geodesic)\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.csv_to_gdf","title":"<code>csv_to_gdf(in_csv, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a CSV file and converts them to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>object</code> <p>GeoDataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def csv_to_gdf(in_csv, latitude=\"latitude\", longitude=\"longitude\", encoding=\"utf-8\"):\n\"\"\"Creates points for a CSV file and converts them to a GeoDataFrame.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    Returns:\n        object: GeoDataFrame.\n    \"\"\"\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    out_dir = os.getcwd()\n\n    out_geojson = os.path.join(out_dir, random_string() + \".geojson\")\n    csv_to_geojson(in_csv, out_geojson, latitude, longitude, encoding)\n\n    gdf = gpd.read_file(out_geojson)\n    os.remove(out_geojson)\n    return gdf\n</code></pre>"},{"location":"common/#geemap.common.csv_to_geojson","title":"<code>csv_to_geojson(in_csv, out_geojson=None, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a CSV file and exports data as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the exported GeoJSON. Default to None.</p> <code>None</code> <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geemap/common.py</code> <pre><code>def csv_to_geojson(\n    in_csv,\n    out_geojson=None,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n):\n\"\"\"Creates points for a CSV file and exports data as a GeoJSON.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        out_geojson (str): The file path to the exported GeoJSON. Default to None.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n\n    import pandas as pd\n\n    in_csv = github_raw_url(in_csv)\n\n    if out_geojson is not None:\n        out_geojson = check_file_path(out_geojson)\n\n    df = pd.read_csv(in_csv)\n    geojson = df_to_geojson(\n        df, latitude=latitude, longitude=longitude, encoding=encoding\n    )\n\n    if out_geojson is None:\n        return geojson\n    else:\n        with open(out_geojson, \"w\", encoding=encoding) as f:\n            f.write(json.dumps(geojson))\n</code></pre>"},{"location":"common/#geemap.common.csv_to_shp","title":"<code>csv_to_shp(in_csv, out_shp, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Converts a csv file with latlon info to a point shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The input csv file containing longitude and latitude columns.</p> required <code>out_shp</code> <code>str</code> <p>The file path to the output shapefile.</p> required <code>latitude</code> <code>str</code> <p>The column name of the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> Source code in <code>geemap/common.py</code> <pre><code>def csv_to_shp(\n    in_csv, out_shp, latitude=\"latitude\", longitude=\"longitude\", encoding=\"utf-8\"\n):\n\"\"\"Converts a csv file with latlon info to a point shapefile.\n\n    Args:\n        in_csv (str): The input csv file containing longitude and latitude columns.\n        out_shp (str): The file path to the output shapefile.\n        latitude (str, optional): The column name of the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): The column name of the longitude column. Defaults to 'longitude'.\n    \"\"\"\n    import shapefile as shp\n\n    if in_csv.startswith(\"http\") and in_csv.endswith(\".csv\"):\n        in_csv = github_raw_url(in_csv)\n        in_csv = download_file(in_csv, quiet=True, overwrite=True)\n\n    try:\n        points = shp.Writer(out_shp, shapeType=shp.POINT)\n        with open(in_csv, encoding=encoding) as csvfile:\n            csvreader = csv.DictReader(csvfile)\n            header = csvreader.fieldnames\n            [points.field(field) for field in header]\n            for row in csvreader:\n                points.point((float(row[longitude])), (float(row[latitude])))\n                points.record(*tuple([row[f] for f in header]))\n\n        out_prj = out_shp.replace(\".shp\", \".prj\")\n        with open(out_prj, \"w\") as f:\n            prj_str = 'GEOGCS[\"GCS_WGS_1984\",DATUM[\"D_WGS_1984\",SPHEROID[\"WGS_1984\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]] '\n            f.write(prj_str)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.csv_to_vector","title":"<code>csv_to_vector(in_csv, output, latitude='latitude', longitude='longitude', encoding='utf-8', **kwargs)</code>","text":"<p>Creates points for a CSV file and converts them to a vector dataset.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>output</code> <code>str</code> <p>The file path to the output vector dataset.</p> required <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geemap/common.py</code> <pre><code>def csv_to_vector(\n    in_csv,\n    output,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n\"\"\"Creates points for a CSV file and converts them to a vector dataset.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        output (str): The file path to the output vector dataset.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n    gdf = csv_to_gdf(in_csv, latitude, longitude, encoding)\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#geemap.common.date_sequence","title":"<code>date_sequence(start, end, unit, date_format='YYYY-MM-dd')</code>","text":"<p>Creates a date sequence.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>The start date, e.g., '2000-01-01'.</p> required <code>end</code> <code>str</code> <p>The end date, e.g., '2000-12-31'.</p> required <code>unit</code> <code>str</code> <p>One of 'year', 'quarter', 'month' 'week', 'day', 'hour', 'minute', or 'second'.</p> required <code>date_format</code> <code>str</code> <p>A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.</p> <code>'YYYY-MM-dd'</code> <p>Returns:</p> Type Description <code>ee.List</code> <p>A list of date sequence.</p> Source code in <code>geemap/common.py</code> <pre><code>def date_sequence(start, end, unit, date_format=\"YYYY-MM-dd\"):\n\"\"\"Creates a date sequence.\n\n    Args:\n        start (str): The start date, e.g., '2000-01-01'.\n        end (str): The end date, e.g., '2000-12-31'.\n        unit (str): One of 'year', 'quarter', 'month' 'week', 'day', 'hour', 'minute', or 'second'.\n        date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.\n\n    Returns:\n        ee.List: A list of date sequence.\n    \"\"\"\n\n    def get_quarter(d):\n        return str((int(d[5:7]) - 1) // 3 * 3 + 1).zfill(2)\n\n    def get_monday(d):\n        date_obj = datetime.datetime.strptime(d, \"%Y-%m-%d\")\n        start_of_week = date_obj - datetime.timedelta(days=date_obj.weekday())\n        return start_of_week.strftime(\"%Y-%m-%d\")\n\n    if unit == \"year\":\n        start = start[:4] + \"-01-01\"\n    elif unit == \"month\":\n        start = start[:7] + \"-01\"\n    elif unit == \"quarter\":\n        start = start[:5] + get_quarter(start) + \"-01\"\n    elif unit == \"week\":\n        start = get_monday(start)\n\n    start_date = ee.Date(start)\n    end_date = ee.Date(end)\n\n    if unit != \"quarter\":\n        count = ee.Number(end_date.difference(start_date, unit)).toInt()\n        num_seq = ee.List.sequence(0, count)\n        date_seq = num_seq.map(\n            lambda d: start_date.advance(d, unit).format(date_format)\n        )\n\n    else:\n        unit = \"month\"\n        count = ee.Number(end_date.difference(start_date, unit)).divide(3).toInt()\n        num_seq = ee.List.sequence(0, count.multiply(3), 3)\n        date_seq = num_seq.map(\n            lambda d: start_date.advance(d, unit).format(date_format)\n        )\n\n    return date_seq\n</code></pre>"},{"location":"common/#geemap.common.delete_shp","title":"<code>delete_shp(in_shp, verbose=False)</code>","text":"<p>Deletes a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input shapefile to delete.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive text. Defaults to False.</p> <code>False</code> Source code in <code>geemap/common.py</code> <pre><code>def delete_shp(in_shp, verbose=False):\n\"\"\"Deletes a shapefile.\n\n    Args:\n        in_shp (str): The input shapefile to delete.\n        verbose (bool, optional): Whether to print out descriptive text. Defaults to False.\n    \"\"\"\n    from pathlib import Path\n\n    in_shp = os.path.abspath(in_shp)\n    in_dir = os.path.dirname(in_shp)\n    basename = os.path.basename(in_shp).replace(\".shp\", \"\")\n\n    files = Path(in_dir).rglob(basename + \".*\")\n\n    for file in files:\n        filepath = os.path.join(in_dir, str(file))\n        try:\n            os.remove(filepath)\n            if verbose:\n                print(f\"Deleted {filepath}\")\n        except Exception as e:\n            if verbose:\n                print(e)\n</code></pre>"},{"location":"common/#geemap.common.df_to_ee","title":"<code>df_to_ee(df, latitude='latitude', longitude='longitude', **kwargs)</code>","text":"<p>Converts a pandas DataFrame to ee.FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>An input pandas.DataFrame.</p> required <code>latitude</code> <code>str</code> <p>Column name for the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>Column name for the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>The input data type must be pandas.DataFrame.</p> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>The ee.FeatureCollection converted from the input pandas DataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def df_to_ee(df, latitude=\"latitude\", longitude=\"longitude\", **kwargs):\n\"\"\"Converts a pandas DataFrame to ee.FeatureCollection.\n\n    Args:\n        df (pandas.DataFrame): An input pandas.DataFrame.\n        latitude (str, optional): Column name for the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): Column name for the longitude column. Defaults to 'longitude'.\n\n    Raises:\n        TypeError: The input data type must be pandas.DataFrame.\n\n    Returns:\n        ee.FeatureCollection: The ee.FeatureCollection converted from the input pandas DataFrame.\n    \"\"\"\n    import pandas as pd\n\n    if not isinstance(df, pd.DataFrame):\n        raise TypeError(\"The input data type must be pandas.DataFrame.\")\n\n    geojson = df_to_geojson(df, latitude=latitude, longitude=longitude)\n    fc = geojson_to_ee(geojson)\n\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.df_to_geojson","title":"<code>df_to_geojson(df, out_geojson=None, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a Pandas DataFrame and exports data as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The input Pandas DataFrame.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the exported GeoJSON. Default to None.</p> <code>None</code> <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geemap/common.py</code> <pre><code>def df_to_geojson(\n    df,\n    out_geojson=None,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n):\n\"\"\"Creates points for a Pandas DataFrame and exports data as a GeoJSON.\n\n    Args:\n        df (pandas.DataFrame): The input Pandas DataFrame.\n        out_geojson (str): The file path to the exported GeoJSON. Default to None.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n\n    from geojson import Feature, FeatureCollection, Point\n\n    if out_geojson is not None:\n        out_dir = os.path.dirname(os.path.abspath(out_geojson))\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n    features = df.apply(\n        lambda row: Feature(\n            geometry=Point((float(row[longitude]), float(row[latitude]))),\n            properties=dict(row),\n        ),\n        axis=1,\n    ).tolist()\n\n    geojson = FeatureCollection(features=features)\n\n    if out_geojson is None:\n        return geojson\n    else:\n        with open(out_geojson, \"w\", encoding=encoding) as f:\n            f.write(json.dumps(geojson))\n</code></pre>"},{"location":"common/#geemap.common.dict_to_csv","title":"<code>dict_to_csv(data_dict, out_csv, by_row=False, timeout=300, proxies=None)</code>","text":"<p>Downloads an ee.Dictionary as a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>data_dict</code> <code>ee.Dictionary</code> <p>The input ee.Dictionary.</p> required <code>out_csv</code> <code>str</code> <p>The output file path to the CSV file.</p> required <code>by_row</code> <code>bool</code> <p>Whether to use by row or by column. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300 seconds.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>Proxy settings. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def dict_to_csv(data_dict, out_csv, by_row=False, timeout=300, proxies=None):\n\"\"\"Downloads an ee.Dictionary as a CSV file.\n\n    Args:\n        data_dict (ee.Dictionary): The input ee.Dictionary.\n        out_csv (str): The output file path to the CSV file.\n        by_row (bool, optional): Whether to use by row or by column. Defaults to False.\n        timeout (int, optional): Timeout in seconds. Defaults to 300 seconds.\n        proxies (dict, optional): Proxy settings. Defaults to None.\n    \"\"\"\n\n    out_dir = os.path.dirname(out_csv)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if not by_row:\n        csv_feature = ee.Feature(None, data_dict)\n        csv_feat_col = ee.FeatureCollection([csv_feature])\n    else:\n        keys = data_dict.keys()\n        data = keys.map(lambda k: ee.Dictionary({\"name\": k, \"value\": data_dict.get(k)}))\n        csv_feature = data.map(lambda f: ee.Feature(None, f))\n        csv_feat_col = ee.FeatureCollection(csv_feature)\n\n    ee_export_vector(csv_feat_col, out_csv, timeout=timeout, proxies=proxies)\n</code></pre>"},{"location":"common/#geemap.common.display_html","title":"<code>display_html(src, width=950, height=600)</code>","text":"<p>Display an HTML file in a Jupyter Notebook.</p> <p>Args     src (str): File path to HTML file.     width (int, optional): Width of the map. Defaults to 950.     height (int, optional): Height of the map. Defaults to 600.</p> Source code in <code>geemap/common.py</code> <pre><code>def display_html(src, width=950, height=600):\n\"\"\"Display an HTML file in a Jupyter Notebook.\n\n    Args\n        src (str): File path to HTML file.\n        width (int, optional): Width of the map. Defaults to 950.\n        height (int, optional): Height of the map. Defaults to 600.\n    \"\"\"\n    if not os.path.isfile(src):\n        raise ValueError(f\"{src} is not a valid file path.\")\n    display(IFrame(src=src, width=width, height=height))\n</code></pre>"},{"location":"common/#geemap.common.download_ee_image","title":"<code>download_ee_image(image, filename, region=None, crs=None, crs_transform=None, scale=None, resampling='near', dtype=None, overwrite=True, num_threads=None, max_tile_size=None, max_tile_dim=None, shape=None, scale_offset=False, unmask_value=None, **kwargs)</code>","text":"<p>Download an Earth Engine Image as a GeoTIFF. Images larger than the `Earth Engine size limit are split and downloaded as     separate tiles, then re-assembled into a single GeoTIFF. See https://github.com/dugalh/geedim/blob/main/geedim/download.py#L574</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The image to be downloaded.</p> required <code>filename</code> <code>str</code> <p>Name of the destination file.</p> required <code>region</code> <code>ee.Geometry</code> <p>Region defined by geojson polygon in WGS84. Defaults to the entire image granule.</p> <code>None</code> <code>crs</code> <code>str</code> <p>Reproject image(s) to this EPSG or WKT CRS.  Where image bands have different CRSs, all are re-projected to this CRS. Defaults to the CRS of the minimum scale band.</p> <code>None</code> <code>crs_transform</code> <code>list</code> <p>tuple of float, list of float, rio.Affine, optional List of 6 numbers specifying an affine transform in the specified CRS.  In row-major order: [xScale, xShearing, xTranslation, yShearing, yScale, yTranslation].  All bands are re-projected to this transform.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Resample image(s) to this pixel scale (size) (m).  Where image bands have different scales, all are resampled to this scale.  Defaults to the minimum scale of image bands.</p> <code>None</code> <code>resampling</code> <code>ResamplingMethod</code> <p>Resampling method, can be 'near', 'bilinear', 'bicubic', or 'average'. Defaults to None.</p> <code>'near'</code> <code>dtype</code> <code>str</code> <p>Convert to this data type (<code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>uint32</code>, <code>int32</code>, <code>float32</code> or <code>float64</code>).  Defaults to auto select a minimum size type that can represent the range of pixel values.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the destination file if it exists. Defaults to True.</p> <code>True</code> <code>num_threads</code> <code>int</code> <p>Number of tiles to download concurrently. Defaults to a sensible auto value.</p> <code>None</code> <code>max_tile_size</code> <p>int, optional Maximum tile size (MB).  If None, defaults to the Earth Engine download size limit (32 MB).</p> <code>None</code> <code>max_tile_dim</code> <p>int, optional Maximum tile width/height (pixels).  If None, defaults to Earth Engine download limit (10000).</p> <code>None</code> <code>shape</code> <p>tuple of int, optional (height, width) dimensions to export (pixels).</p> <code>None</code> <code>scale_offset</code> <p>bool, optional Whether to apply any EE band scales and offsets to the image.</p> <code>False</code> <code>unmask_value</code> <code>float</code> <p>The value to use for pixels that are masked in the input image. If the exported image contains zero values, you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def download_ee_image(\n    image,\n    filename,\n    region=None,\n    crs=None,\n    crs_transform=None,\n    scale=None,\n    resampling=\"near\",\n    dtype=None,\n    overwrite=True,\n    num_threads=None,\n    max_tile_size=None,\n    max_tile_dim=None,\n    shape=None,\n    scale_offset=False,\n    unmask_value=None,\n    **kwargs,\n):\n\"\"\"Download an Earth Engine Image as a GeoTIFF. Images larger than the `Earth Engine size limit are split and downloaded as\n        separate tiles, then re-assembled into a single GeoTIFF. See https://github.com/dugalh/geedim/blob/main/geedim/download.py#L574\n\n    Args:\n        image (ee.Image): The image to be downloaded.\n        filename (str): Name of the destination file.\n        region (ee.Geometry, optional): Region defined by geojson polygon in WGS84. Defaults to the entire image granule.\n        crs (str, optional): Reproject image(s) to this EPSG or WKT CRS.  Where image bands have different CRSs, all are\n            re-projected to this CRS. Defaults to the CRS of the minimum scale band.\n        crs_transform (list, optional): tuple of float, list of float, rio.Affine, optional\n            List of 6 numbers specifying an affine transform in the specified CRS.  In row-major order:\n            [xScale, xShearing, xTranslation, yShearing, yScale, yTranslation].  All bands are re-projected to\n            this transform.\n        scale (float, optional): Resample image(s) to this pixel scale (size) (m).  Where image bands have different scales,\n            all are resampled to this scale.  Defaults to the minimum scale of image bands.\n        resampling (ResamplingMethod, optional): Resampling method, can be 'near', 'bilinear', 'bicubic', or 'average'. Defaults to None.\n        dtype (str, optional): Convert to this data type (`uint8`, `int8`, `uint16`, `int16`, `uint32`, `int32`, `float32`\n            or `float64`).  Defaults to auto select a minimum size type that can represent the range of pixel values.\n        overwrite (bool, optional): Overwrite the destination file if it exists. Defaults to True.\n        num_threads (int, optional): Number of tiles to download concurrently. Defaults to a sensible auto value.\n        max_tile_size: int, optional\n            Maximum tile size (MB).  If None, defaults to the Earth Engine download size limit (32 MB).\n        max_tile_dim: int, optional\n            Maximum tile width/height (pixels).  If None, defaults to Earth Engine download limit (10000).\n        shape: tuple of int, optional\n            (height, width) dimensions to export (pixels).\n        scale_offset: bool, optional\n            Whether to apply any EE band scales and offsets to the image.\n        unmask_value (float, optional): The value to use for pixels that are masked in the input image. If the exported image contains\n            zero values, you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.\n\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    try:\n        import geedim as gd\n    except ImportError:\n        raise ImportError(\n            \"Please install geedim using `pip install geedim` or `conda install -c conda-forge geedim`\"\n        )\n\n    if not isinstance(image, ee.Image):\n        raise ValueError(\"image must be an ee.Image.\")\n\n    if unmask_value is not None:\n        image = image.selfMask().unmask(unmask_value)\n        if isinstance(region, ee.Geometry):\n            image = image.clip(region)\n        elif isinstance(region, ee.FeatureCollection):\n            image = image.clipToCollection(region)\n\n    if region is not None:\n        kwargs[\"region\"] = region\n\n    if crs is not None:\n        kwargs[\"crs\"] = crs\n\n    if crs_transform is not None:\n        kwargs[\"crs_transform\"] = crs_transform\n\n    if scale is not None:\n        kwargs[\"scale\"] = scale\n\n    if resampling is not None:\n        kwargs[\"resampling\"] = resampling\n\n    if dtype is not None:\n        kwargs[\"dtype\"] = dtype\n\n    if max_tile_size is not None:\n        kwargs[\"max_tile_size\"] = max_tile_size\n\n    if max_tile_dim is not None:\n        kwargs[\"max_tile_dim\"] = max_tile_dim\n\n    if shape is not None:\n        kwargs[\"shape\"] = shape\n\n    if scale_offset:\n        kwargs[\"scale_offset\"] = scale_offset\n\n    img = gd.download.BaseImage(image)\n    img.download(filename, overwrite=overwrite, num_threads=num_threads, **kwargs)\n</code></pre>"},{"location":"common/#geemap.common.download_ee_image_collection","title":"<code>download_ee_image_collection(collection, out_dir=None, filenames=None, region=None, crs=None, crs_transform=None, scale=None, resampling='near', dtype=None, overwrite=True, num_threads=None, max_tile_size=None, max_tile_dim=None, shape=None, scale_offset=False, unmask_value=None, **kwargs)</code>","text":"<p>Download an Earth Engine ImageCollection as GeoTIFFs. Images larger than the `Earth Engine size limit are split and downloaded as     separate tiles, then re-assembled into a single GeoTIFF. See https://github.com/dugalh/geedim/blob/main/geedim/download.py#L574</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>ee.ImageCollection</code> <p>The image collection to be downloaded.</p> required <code>out_dir</code> <code>str</code> <p>The directory to save the downloaded images. Defaults to the current directory.</p> <code>None</code> <code>filenames</code> <code>list</code> <p>A list of filenames to use for the downloaded images. Defaults to the image ID.</p> <code>None</code> <code>region</code> <code>ee.Geometry</code> <p>Region defined by geojson polygon in WGS84. Defaults to the entire image granule.</p> <code>None</code> <code>crs</code> <code>str</code> <p>Reproject image(s) to this EPSG or WKT CRS.  Where image bands have different CRSs, all are re-projected to this CRS. Defaults to the CRS of the minimum scale band.</p> <code>None</code> <code>crs_transform</code> <code>list</code> <p>tuple of float, list of float, rio.Affine, optional List of 6 numbers specifying an affine transform in the specified CRS.  In row-major order: [xScale, xShearing, xTranslation, yShearing, yScale, yTranslation].  All bands are re-projected to this transform.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Resample image(s) to this pixel scale (size) (m).  Where image bands have different scales, all are resampled to this scale.  Defaults to the minimum scale of image bands.</p> <code>None</code> <code>resampling</code> <code>ResamplingMethod</code> <p>Resampling method, can be 'near', 'bilinear', 'bicubic', or 'average'. Defaults to None.</p> <code>'near'</code> <code>dtype</code> <code>str</code> <p>Convert to this data type (<code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>uint32</code>, <code>int32</code>, <code>float32</code> or <code>float64</code>).  Defaults to auto select a minimum size type that can represent the range of pixel values.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the destination file if it exists. Defaults to True.</p> <code>True</code> <code>num_threads</code> <code>int</code> <p>Number of tiles to download concurrently. Defaults to a sensible auto value.</p> <code>None</code> <code>max_tile_size</code> <p>int, optional Maximum tile size (MB).  If None, defaults to the Earth Engine download size limit (32 MB).</p> <code>None</code> <code>max_tile_dim</code> <p>int, optional Maximum tile width/height (pixels).  If None, defaults to Earth Engine download limit (10000).</p> <code>None</code> <code>shape</code> <p>tuple of int, optional (height, width) dimensions to export (pixels).</p> <code>None</code> <code>scale_offset</code> <p>bool, optional Whether to apply any EE band scales and offsets to the image.</p> <code>False</code> <code>unmask_value</code> <code>float</code> <p>The value to use for pixels that are masked in the input image. If the exported image contains zero values, you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def download_ee_image_collection(\n    collection,\n    out_dir=None,\n    filenames=None,\n    region=None,\n    crs=None,\n    crs_transform=None,\n    scale=None,\n    resampling=\"near\",\n    dtype=None,\n    overwrite=True,\n    num_threads=None,\n    max_tile_size=None,\n    max_tile_dim=None,\n    shape=None,\n    scale_offset=False,\n    unmask_value=None,\n    **kwargs,\n):\n\"\"\"Download an Earth Engine ImageCollection as GeoTIFFs. Images larger than the `Earth Engine size limit are split and downloaded as\n        separate tiles, then re-assembled into a single GeoTIFF. See https://github.com/dugalh/geedim/blob/main/geedim/download.py#L574\n\n    Args:\n        collection (ee.ImageCollection): The image collection to be downloaded.\n        out_dir (str, optional): The directory to save the downloaded images. Defaults to the current directory.\n        filenames (list, optional): A list of filenames to use for the downloaded images. Defaults to the image ID.\n        region (ee.Geometry, optional): Region defined by geojson polygon in WGS84. Defaults to the entire image granule.\n        crs (str, optional): Reproject image(s) to this EPSG or WKT CRS.  Where image bands have different CRSs, all are\n            re-projected to this CRS. Defaults to the CRS of the minimum scale band.\n        crs_transform (list, optional): tuple of float, list of float, rio.Affine, optional\n            List of 6 numbers specifying an affine transform in the specified CRS.  In row-major order:\n            [xScale, xShearing, xTranslation, yShearing, yScale, yTranslation].  All bands are re-projected to\n            this transform.\n        scale (float, optional): Resample image(s) to this pixel scale (size) (m).  Where image bands have different scales,\n            all are resampled to this scale.  Defaults to the minimum scale of image bands.\n        resampling (ResamplingMethod, optional): Resampling method, can be 'near', 'bilinear', 'bicubic', or 'average'. Defaults to None.\n        dtype (str, optional): Convert to this data type (`uint8`, `int8`, `uint16`, `int16`, `uint32`, `int32`, `float32`\n            or `float64`).  Defaults to auto select a minimum size type that can represent the range of pixel values.\n        overwrite (bool, optional): Overwrite the destination file if it exists. Defaults to True.\n        num_threads (int, optional): Number of tiles to download concurrently. Defaults to a sensible auto value.\n        max_tile_size: int, optional\n            Maximum tile size (MB).  If None, defaults to the Earth Engine download size limit (32 MB).\n        max_tile_dim: int, optional\n            Maximum tile width/height (pixels).  If None, defaults to Earth Engine download limit (10000).\n        shape: tuple of int, optional\n            (height, width) dimensions to export (pixels).\n        scale_offset: bool, optional\n            Whether to apply any EE band scales and offsets to the image.\n        unmask_value (float, optional): The value to use for pixels that are masked in the input image. If the exported image contains zero values,\n            you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.\n    \"\"\"\n\n    if not isinstance(collection, ee.ImageCollection):\n        raise ValueError(\"ee_object must be an ee.ImageCollection.\")\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    try:\n        count = int(collection.size().getInfo())\n        print(f\"Total number of images: {count}\\n\")\n\n        if filenames is not None:\n            if len(filenames) != count:\n                raise ValueError(\n                    f\"The number of filenames must match the number of image: {count}\"\n                )\n\n        for i in range(0, count):\n            image = ee.Image(collection.toList(count).get(i))\n            if filenames is not None:\n                name = filenames[i]\n                if not name.endswith(\".tif\"):\n                    name = name + \".tif\"\n            else:\n                name = image.get(\"system:index\").getInfo() + \".tif\"\n            filename = os.path.join(os.path.abspath(out_dir), name)\n            print(f\"Downloading {i + 1}/{count}: {name}\")\n            download_ee_image(\n                image,\n                filename,\n                region,\n                crs,\n                crs_transform,\n                scale,\n                resampling,\n                dtype,\n                overwrite,\n                num_threads,\n                max_tile_size,\n                max_tile_dim,\n                shape,\n                scale_offset,\n                unmask_value,\n                **kwargs,\n            )\n\n    except Exception as e:\n        raise Exception(f\"Error downloading image collection: {e}\")\n</code></pre>"},{"location":"common/#geemap.common.download_ee_image_tiles","title":"<code>download_ee_image_tiles(image, features, out_dir=None, prefix=None, crs=None, crs_transform=None, scale=None, resampling='near', dtype=None, overwrite=True, num_threads=None, max_tile_size=None, max_tile_dim=None, shape=None, scale_offset=False, unmask_value=None, **kwargs)</code>","text":"<p>Download an Earth Engine Image as small tiles based on ee.FeatureCollection. Images larger than the `Earth Engine size limit are split and downloaded as     separate tiles, then re-assembled into a single GeoTIFF. See https://github.com/dugalh/geedim/blob/main/geedim/download.py#L574</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The image to be downloaded.</p> required <code>features</code> <code>ee.FeatureCollection</code> <p>The features to loop through to download image.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>The prefix for the output file. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>Reproject image(s) to this EPSG or WKT CRS.  Where image bands have different CRSs, all are re-projected to this CRS. Defaults to the CRS of the minimum scale band.</p> <code>None</code> <code>crs_transform</code> <code>list</code> <p>tuple of float, list of float, rio.Affine, optional List of 6 numbers specifying an affine transform in the specified CRS.  In row-major order: [xScale, xShearing, xTranslation, yShearing, yScale, yTranslation].  All bands are re-projected to this transform.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Resample image(s) to this pixel scale (size) (m).  Where image bands have different scales, all are resampled to this scale.  Defaults to the minimum scale of image bands.</p> <code>None</code> <code>resampling</code> <code>ResamplingMethod</code> <p>Resampling method, can be 'near', 'bilinear', 'bicubic', or 'average'. Defaults to None.</p> <code>'near'</code> <code>dtype</code> <code>str</code> <p>Convert to this data type (<code>uint8</code>, <code>int8</code>, <code>uint16</code>, <code>int16</code>, <code>uint32</code>, <code>int32</code>, <code>float32</code> or <code>float64</code>).  Defaults to auto select a minimum size type that can represent the range of pixel values.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the destination file if it exists. Defaults to True.</p> <code>True</code> <code>num_threads</code> <code>int</code> <p>Number of tiles to download concurrently. Defaults to a sensible auto value.</p> <code>None</code> <code>max_tile_size</code> <p>int, optional Maximum tile size (MB).  If None, defaults to the Earth Engine download size limit (32 MB).</p> <code>None</code> <code>max_tile_dim</code> <p>int, optional Maximum tile width/height (pixels).  If None, defaults to Earth Engine download limit (10000).</p> <code>None</code> <code>shape</code> <p>tuple of int, optional (height, width) dimensions to export (pixels).</p> <code>None</code> <code>scale_offset</code> <p>bool, optional Whether to apply any EE band scales and offsets to the image.</p> <code>False</code> <code>unmask_value</code> <code>float</code> <p>The value to use for pixels that are masked in the input image. If the exported image contains zero values, you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def download_ee_image_tiles(\n    image,\n    features,\n    out_dir=None,\n    prefix=None,\n    crs=None,\n    crs_transform=None,\n    scale=None,\n    resampling=\"near\",\n    dtype=None,\n    overwrite=True,\n    num_threads=None,\n    max_tile_size=None,\n    max_tile_dim=None,\n    shape=None,\n    scale_offset=False,\n    unmask_value=None,\n    **kwargs,\n):\n\"\"\"Download an Earth Engine Image as small tiles based on ee.FeatureCollection. Images larger than the `Earth Engine size limit are split and downloaded as\n        separate tiles, then re-assembled into a single GeoTIFF. See https://github.com/dugalh/geedim/blob/main/geedim/download.py#L574\n\n    Args:\n        image (ee.Image): The image to be downloaded.\n        features (ee.FeatureCollection): The features to loop through to download image.\n        out_dir (str, optional): The output directory. Defaults to None.\n        prefix (str, optional): The prefix for the output file. Defaults to None.\n        crs (str, optional): Reproject image(s) to this EPSG or WKT CRS.  Where image bands have different CRSs, all are\n            re-projected to this CRS. Defaults to the CRS of the minimum scale band.\n        crs_transform (list, optional): tuple of float, list of float, rio.Affine, optional\n            List of 6 numbers specifying an affine transform in the specified CRS.  In row-major order:\n            [xScale, xShearing, xTranslation, yShearing, yScale, yTranslation].  All bands are re-projected to\n            this transform.\n        scale (float, optional): Resample image(s) to this pixel scale (size) (m).  Where image bands have different scales,\n            all are resampled to this scale.  Defaults to the minimum scale of image bands.\n        resampling (ResamplingMethod, optional): Resampling method, can be 'near', 'bilinear', 'bicubic', or 'average'. Defaults to None.\n        dtype (str, optional): Convert to this data type (`uint8`, `int8`, `uint16`, `int16`, `uint32`, `int32`, `float32`\n            or `float64`).  Defaults to auto select a minimum size type that can represent the range of pixel values.\n        overwrite (bool, optional): Overwrite the destination file if it exists. Defaults to True.\n        num_threads (int, optional): Number of tiles to download concurrently. Defaults to a sensible auto value.\n        max_tile_size: int, optional\n            Maximum tile size (MB).  If None, defaults to the Earth Engine download size limit (32 MB).\n        max_tile_dim: int, optional\n            Maximum tile width/height (pixels).  If None, defaults to Earth Engine download limit (10000).\n        shape: tuple of int, optional\n            (height, width) dimensions to export (pixels).\n        scale_offset: bool, optional\n            Whether to apply any EE band scales and offsets to the image.\n        unmask_value (float, optional): The value to use for pixels that are masked in the input image. If the exported image contains zero values,\n            you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.\n\n    \"\"\"\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if not isinstance(features, ee.FeatureCollection):\n        raise ValueError(\"features must be an ee.FeatureCollection.\")\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if prefix is None:\n        prefix = \"\"\n\n    count = features.size().getInfo()\n    collection = features.toList(count)\n\n    for i in range(count):\n        region = ee.Feature(collection.get(i)).geometry()\n        filename = os.path.join(\n            out_dir, \"{}{}.tif\".format(prefix, str(i + 1).zfill(len(str(count))))\n        )\n        print(f\"Downloading {i + 1}/{count}: {filename}\")\n        download_ee_image(\n            image,\n            filename,\n            region,\n            crs,\n            crs_transform,\n            scale,\n            resampling,\n            dtype,\n            overwrite,\n            num_threads,\n            max_tile_size,\n            max_tile_dim,\n            shape,\n            scale_offset,\n            unmask_value,\n            **kwargs,\n        )\n</code></pre>"},{"location":"common/#geemap.common.download_ee_video","title":"<code>download_ee_video(collection, video_args, out_gif, timeout=300, proxies=None)</code>","text":"<p>Downloads a video thumbnail as a GIF image from Earth Engine.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>object</code> <p>An ee.ImageCollection.</p> required <code>video_args</code> <code>object</code> <p>Parameters for expring the video thumbnail.</p> required <code>out_gif</code> <code>str</code> <p>File path to the output GIF.</p> required <code>timeout</code> <code>int</code> <p>The number of seconds the request will be timed out. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxy servers to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def download_ee_video(collection, video_args, out_gif, timeout=300, proxies=None):\n\"\"\"Downloads a video thumbnail as a GIF image from Earth Engine.\n\n    Args:\n        collection (object): An ee.ImageCollection.\n        video_args (object): Parameters for expring the video thumbnail.\n        out_gif (str): File path to the output GIF.\n        timeout (int, optional): The number of seconds the request will be timed out. Defaults to 300.\n        proxies (dict, optional): A dictionary of proxy servers to use. Defaults to None.\n    \"\"\"\n\n    out_gif = os.path.abspath(out_gif)\n    if not out_gif.endswith(\".gif\"):\n        print(\"The output file must have an extension of .gif.\")\n        return\n\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if \"region\" in video_args.keys():\n        roi = video_args[\"region\"]\n\n        if not isinstance(roi, ee.Geometry):\n            try:\n                roi = roi.geometry()\n            except Exception as e:\n                print(\"Could not convert the provided roi to ee.Geometry\")\n                print(e)\n                return\n\n        video_args[\"region\"] = roi\n    if \"dimensions\" not in video_args:\n        video_args[\"dimensions\"] = 768\n\n    try:\n        print(\"Generating URL...\")\n        url = collection.getVideoThumbURL(video_args)\n\n        print(f\"Downloading GIF image from {url}\\nPlease wait ...\")\n        r = requests.get(url, stream=True, timeout=timeout, proxies=proxies)\n\n        if r.status_code != 200:\n            print(\"An error occurred while downloading.\")\n            print(r.json()[\"error\"][\"message\"])\n            return\n        else:\n            with open(out_gif, \"wb\") as fd:\n                for chunk in r.iter_content(chunk_size=1024):\n                    fd.write(chunk)\n            print(f\"The GIF image has been saved to: {out_gif}\")\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.download_file","title":"<code>download_file(url=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False)</code>","text":"<p>Download a file from URL, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Google Drive URL is also supported. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The output file path.</p> Source code in <code>geemap/common.py</code> <pre><code>def download_file(\n    url=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n):\n\"\"\"Download a file from URL, including Google Drive shared URL.\n\n    Args:\n        url (str, optional): Google Drive URL is also supported. Defaults to None.\n        output (str, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n\n    Returns:\n        str: The output file path.\n    \"\"\"\n\n    import gdown\n\n    if output is None:\n        if isinstance(url, str) and url.startswith(\"http\"):\n            output = os.path.basename(url)\n\n    if isinstance(url, str):\n        if os.path.exists(os.path.abspath(output)) and (not overwrite):\n            print(\n                f\"{output} already exists. Skip downloading. Set overwrite=True to overwrite.\"\n            )\n            return os.path.abspath(output)\n        else:\n            url = github_raw_url(url)\n\n    if \"https://drive.google.com/file/d/\" in url:\n        fuzzy = True\n\n    output = gdown.download(\n        url, output, quiet, proxy, speed, use_cookies, verify, id, fuzzy, resume\n    )\n\n    if unzip and output.endswith(\".zip\"):\n        with zipfile.ZipFile(output, \"r\") as zip_ref:\n            if not quiet:\n                print(\"Extracting files...\")\n            zip_ref.extractall(os.path.dirname(output))\n\n    return os.path.abspath(output)\n</code></pre>"},{"location":"common/#geemap.common.download_folder","title":"<code>download_folder(url=None, id=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, remaining_ok=False)</code>","text":"<p>Downloads the entire folder from URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the Google Drive folder. Must be of the format 'https://drive.google.com/drive/folders/{url}'. Defaults to None.</p> <code>None</code> <code>id</code> <code>str</code> <p>Google Drive's folder ID. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>String containing the path of the output folder. Defaults to current working directory.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Defaults to False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of files downloaded, or None if failed.</p> Source code in <code>geemap/common.py</code> <pre><code>def download_folder(\n    url=None,\n    id=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    remaining_ok=False,\n):\n\"\"\"Downloads the entire folder from URL.\n\n    Args:\n        url (str, optional): URL of the Google Drive folder. Must be of the format 'https://drive.google.com/drive/folders/{url}'. Defaults to None.\n        id (str, optional): Google Drive's folder ID. Defaults to None.\n        output (str, optional):  String containing the path of the output folder. Defaults to current working directory.\n        quiet (bool, optional): Suppress terminal output. Defaults to False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n\n    Returns:\n        list: List of files downloaded, or None if failed.\n    \"\"\"\n    import gdown\n\n    files = gdown.download_folder(\n        url, id, output, quiet, proxy, speed, use_cookies, remaining_ok\n    )\n    return files\n</code></pre>"},{"location":"common/#geemap.common.download_from_gdrive","title":"<code>download_from_gdrive(gfile_url, file_name, out_dir='.', unzip=True, verbose=True)</code>","text":"<p>Download a file shared via Google Drive    (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing)</p> <p>Parameters:</p> Name Type Description Default <code>gfile_url</code> <code>str</code> <p>The Google Drive shared file URL</p> required <code>file_name</code> <code>str</code> <p>The output file name to use.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the output file if it is a zip file. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to display or not the output of the function</p> <code>True</code> Source code in <code>geemap/common.py</code> <pre><code>def download_from_gdrive(gfile_url, file_name, out_dir=\".\", unzip=True, verbose=True):\n\"\"\"Download a file shared via Google Drive\n       (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing)\n\n    Args:\n        gfile_url (str): The Google Drive shared file URL\n        file_name (str): The output file name to use.\n        out_dir (str, optional): The output directory. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the output file if it is a zip file. Defaults to True.\n        verbose (bool, optional): Whether to display or not the output of the function\n    \"\"\"\n    try:\n        from google_drive_downloader import GoogleDriveDownloader as gdd\n    except ImportError:\n        raise Exception(\n            \"Please install the google_drive_downloader package using `pip install googledrivedownloader`\"\n        )\n\n    file_id = gfile_url.split(\"/\")[5]\n    if verbose:\n        print(f\"Google Drive file id: {file_id}\")\n\n    dest_path = os.path.join(out_dir, file_name)\n    gdd.download_file_from_google_drive(file_id, dest_path, True, unzip)\n\n    return\n</code></pre>"},{"location":"common/#geemap.common.download_from_url","title":"<code>download_from_url(url, out_file_name=None, out_dir='.', unzip=True, verbose=True)</code>","text":"<p>Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip)</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The HTTP URL to download.</p> required <code>out_file_name</code> <code>str</code> <p>The output file name to use. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The output directory to use. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the downloaded file if it is a zip file. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to display or not the output of the function</p> <code>True</code> Source code in <code>geemap/common.py</code> <pre><code>def download_from_url(url, out_file_name=None, out_dir=\".\", unzip=True, verbose=True):\n\"\"\"Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip)\n\n    Args:\n        url (str): The HTTP URL to download.\n        out_file_name (str, optional): The output file name to use. Defaults to None.\n        out_dir (str, optional): The output directory to use. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the downloaded file if it is a zip file. Defaults to True.\n        verbose (bool, optional): Whether to display or not the output of the function\n    \"\"\"\n    in_file_name = os.path.basename(url)\n\n    if out_file_name is None:\n        out_file_name = in_file_name\n    out_file_path = os.path.join(os.path.abspath(out_dir), out_file_name)\n\n    if verbose:\n        print(f\"Downloading {url} ...\")\n\n    try:\n        urllib.request.urlretrieve(url, out_file_path)\n    except Exception:\n        raise Exception(\"The URL is invalid. Please double check the URL.\")\n\n    final_path = out_file_path\n\n    if unzip:\n        # if it is a zip file\n        if \".zip\" in out_file_name:\n            if verbose:\n                print(f\"Unzipping {out_file_name} ...\")\n            with zipfile.ZipFile(out_file_path, \"r\") as zip_ref:\n                zip_ref.extractall(out_dir)\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".zip\", \"\")\n            )\n\n        # if it is a tar file\n        if \".tar\" in out_file_name:\n            if verbose:\n                print(f\"Unzipping {out_file_name} ...\")\n            with tarfile.open(out_file_path, \"r\") as tar_ref:\n                with tarfile.open(out_file_path, \"r\") as tar_ref:\n\n                    def is_within_directory(directory, target):\n                        abs_directory = os.path.abspath(directory)\n                        abs_target = os.path.abspath(target)\n\n                        prefix = os.path.commonprefix([abs_directory, abs_target])\n\n                        return prefix == abs_directory\n\n                    def safe_extract(\n                        tar, path=\".\", members=None, *, numeric_owner=False\n                    ):\n                        for member in tar.getmembers():\n                            member_path = os.path.join(path, member.name)\n                            if not is_within_directory(path, member_path):\n                                raise Exception(\"Attempted Path Traversal in Tar File\")\n\n                        tar.extractall(path, members, numeric_owner=numeric_owner)\n\n                    safe_extract(tar_ref, out_dir)\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".tar\", \"\")\n            )\n\n    if verbose:\n        print(f\"Data downloaded to: {final_path}\")\n\n    return\n</code></pre>"},{"location":"common/#geemap.common.download_ned","title":"<code>download_ned(region, out_dir=None, return_url=False, download_args={}, **kwargs)</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>A filepath to a vector dataset or a list of bounds in the form of [minx, miny, maxx, maxy].</p> required <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>return_url</code> <code>bool</code> <p>Whether to return the download URLs of the files. Defaults to False.</p> <code>False</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of the download URLs of the files if return_url is True.</p> Source code in <code>geemap/common.py</code> <pre><code>def download_ned(region, out_dir=None, return_url=False, download_args={}, **kwargs):\n\"\"\"Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list): A filepath to a vector dataset or a list of bounds in the form of [minx, miny, maxx, maxy].\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_url (bool, optional): Whether to return the download URLs of the files. Defaults to False.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n\n    Returns:\n        list: A list of the download URLs of the files if return_url is True.\n    \"\"\"\n    import geopandas as gpd\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n    else:\n        out_dir = os.path.abspath(out_dir)\n\n    if isinstance(region, str):\n        if region.startswith(\"http\"):\n            region = github_raw_url(region)\n            region = download_file(region)\n        elif not os.path.exists(region):\n            raise ValueError(\"region must be a path or a URL to a vector dataset.\")\n\n        roi = gpd.read_file(region, **kwargs)\n        roi = roi.to_crs(epsg=4326)\n        bounds = roi.total_bounds\n\n    elif isinstance(region, list):\n        bounds = region\n\n    else:\n        raise ValueError(\n            \"region must be a filepath or a list of bounds in the form of [minx, miny, maxx, maxy].\"\n        )\n    minx, miny, maxx, maxy = [float(x) for x in bounds]\n    tiles = []\n    left = abs(math.floor(minx))\n    right = abs(math.floor(maxx)) - 1\n    upper = math.ceil(maxy)\n    bottom = math.ceil(miny) - 1\n\n    for y in range(upper, bottom, -1):\n        for x in range(left, right, -1):\n            tile_id = \"n{}w{}\".format(str(y).zfill(2), str(x).zfill(3))\n            tiles.append(tile_id)\n\n    links = []\n    filepaths = []\n\n    for index, tile in enumerate(tiles):\n        tif_url = f\"https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/TIFF/current/{tile}/USGS_13_{tile}.tif\"\n\n        r = requests.head(tif_url)\n        if r.status_code == 200:\n            tif = os.path.join(out_dir, os.path.basename(tif_url))\n            links.append(tif_url)\n            filepaths.append(tif)\n        else:\n            print(f\"{tif_url} does not exist.\")\n\n    if return_url:\n        return links\n    else:\n        for index, link in enumerate(links):\n            print(f\"Downloading {index + 1} of {len(links)}: {os.path.basename(link)}\")\n            download_file(link, filepaths[index], **download_args)\n</code></pre>"},{"location":"common/#geemap.common.dynamic_world","title":"<code>dynamic_world(region=None, start_date='2020-01-01', end_date='2021-01-01', clip=False, reducer=None, projection='EPSG:3857', scale=10, return_type='hillshade')</code>","text":"<p>Create 10-m land cover composite based on Dynamic World. The source code is adapted from the following tutorial by Spatial Thoughts: https://developers.google.com/earth-engine/tutorials/community/introduction-to-dynamic-world-pt-1</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region of interest.</p> <code>None</code> <code>start_date</code> <code>str | ee.Date</code> <p>The start date of the query. Default to \"2020-01-01\".</p> <code>'2020-01-01'</code> <code>end_date</code> <code>str | ee.Date</code> <p>The end date of the query. Default to \"2021-01-01\".</p> <code>'2021-01-01'</code> <code>clip</code> <code>bool</code> <p>Whether to clip the image to the region. Default to False.</p> <code>False</code> <code>reducer</code> <code>ee.Reducer</code> <p>The reducer to be used. Default to None.</p> <code>None</code> <code>projection</code> <code>str</code> <p>The projection to be used for creating hillshade. Default to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>scale</code> <code>int</code> <p>The scale to be used for creating hillshade. Default to 10.</p> <code>10</code> <code>return_type</code> <code>str</code> <p>The type of image to be returned. Can be one of 'hillshade', 'visualize', 'class', or 'probability'. Default to \"hillshade\".</p> <code>'hillshade'</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The image with the specified return_type.</p> Source code in <code>geemap/common.py</code> <pre><code>def dynamic_world(\n    region=None,\n    start_date=\"2020-01-01\",\n    end_date=\"2021-01-01\",\n    clip=False,\n    reducer=None,\n    projection=\"EPSG:3857\",\n    scale=10,\n    return_type=\"hillshade\",\n):\n\"\"\"Create 10-m land cover composite based on Dynamic World. The source code is adapted from the following tutorial by Spatial Thoughts:\n    https://developers.google.com/earth-engine/tutorials/community/introduction-to-dynamic-world-pt-1\n\n    Args:\n        region (ee.Geometry | ee.FeatureCollection): The region of interest.\n        start_date (str | ee.Date): The start date of the query. Default to \"2020-01-01\".\n        end_date (str | ee.Date): The end date of the query. Default to \"2021-01-01\".\n        clip (bool, optional): Whether to clip the image to the region. Default to False.\n        reducer (ee.Reducer, optional): The reducer to be used. Default to None.\n        projection (str, optional): The projection to be used for creating hillshade. Default to \"EPSG:3857\".\n        scale (int, optional): The scale to be used for creating hillshade. Default to 10.\n        return_type (str, optional): The type of image to be returned. Can be one of 'hillshade', 'visualize', 'class', or 'probability'. Default to \"hillshade\".\n\n    Returns:\n        ee.Image: The image with the specified return_type.\n    \"\"\"\n\n    if return_type not in [\"hillshade\", \"visualize\", \"class\", \"probability\"]:\n        raise ValueError(\n            f\"{return_type} must be one of 'hillshade', 'visualize', 'class', or 'probability'.\"\n        )\n\n    if reducer is None:\n        reducer = ee.Reducer.mode()\n\n    dw = ee.ImageCollection(\"GOOGLE/DYNAMICWORLD/V1\").filter(\n        ee.Filter.date(start_date, end_date)\n    )\n\n    if isinstance(region, ee.FeatureCollection) or isinstance(region, ee.Geometry):\n        dw = dw.filterBounds(region)\n    else:\n        raise ValueError(\"region must be an ee.FeatureCollection or ee.Geometry.\")\n\n    # Create a Mode Composite\n    classification = dw.select(\"label\")\n    dwComposite = classification.reduce(reducer)\n    if clip and (region is not None):\n        if isinstance(region, ee.Geometry):\n            dwComposite = dwComposite.clip(region)\n        elif isinstance(region, ee.FeatureCollection):\n            dwComposite = dwComposite.clipToCollection(region)\n        elif isinstance(region, ee.Feature):\n            dwComposite = dwComposite.clip(region.geometry())\n\n    dwVisParams = {\n        \"min\": 0,\n        \"max\": 8,\n        \"palette\": [\n            \"#419BDF\",\n            \"#397D49\",\n            \"#88B053\",\n            \"#7A87C6\",\n            \"#E49635\",\n            \"#DFC35A\",\n            \"#C4281B\",\n            \"#A59B8F\",\n            \"#B39FE1\",\n        ],\n    }\n\n    if return_type == \"class\":\n        return dwComposite\n    elif return_type == \"visualize\":\n        return dwComposite.visualize(**dwVisParams)\n    else:\n        # Create a Top-1 Probability Hillshade Visualization\n        probabilityBands = [\n            \"water\",\n            \"trees\",\n            \"grass\",\n            \"flooded_vegetation\",\n            \"crops\",\n            \"shrub_and_scrub\",\n            \"built\",\n            \"bare\",\n            \"snow_and_ice\",\n        ]\n\n        # Select probability bands\n        probabilityCol = dw.select(probabilityBands)\n\n        # Create a multi-band image with the average pixel-wise probability\n        # for each band across the time-period\n        meanProbability = probabilityCol.reduce(ee.Reducer.mean())\n\n        # Composites have a default projection that is not suitable\n        # for hillshade computation.\n        # Set a EPSG:3857 projection with 10m scale\n        proj = ee.Projection(projection).atScale(scale)\n        meanProbability = meanProbability.setDefaultProjection(proj)\n\n        # Create the Top1 Probability Hillshade\n        top1Probability = meanProbability.reduce(ee.Reducer.max())\n\n        if clip and (region is not None):\n            if isinstance(region, ee.Geometry):\n                top1Probability = top1Probability.clip(region)\n            elif isinstance(region, ee.FeatureCollection):\n                top1Probability = top1Probability.clipToCollection(region)\n            elif isinstance(region, ee.Feature):\n                top1Probability = top1Probability.clip(region.geometry())\n\n        if return_type == \"probability\":\n            return top1Probability\n        else:\n            top1Confidence = top1Probability.multiply(100).int()\n            hillshade = ee.Terrain.hillshade(top1Confidence).divide(255)\n            rgbImage = dwComposite.visualize(**dwVisParams).divide(255)\n            probabilityHillshade = rgbImage.multiply(hillshade)\n\n            return probabilityHillshade\n</code></pre>"},{"location":"common/#geemap.common.dynamic_world_s2","title":"<code>dynamic_world_s2(region=None, start_date='2020-01-01', end_date='2021-01-01', clip=False, cloud_pct=0.35, reducer=None)</code>","text":"<p>Create Sentinel-2 composite for the Dynamic World Land Cover product.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region of interest. Default to None.</p> <code>None</code> <code>start_date</code> <code>str | ee.Date</code> <p>The start date of the query. Default to \"2020-01-01\".</p> <code>'2020-01-01'</code> <code>end_date</code> <code>str | ee.Date</code> <p>The end date of the query. Default to \"2021-01-01\".</p> <code>'2021-01-01'</code> <code>clip</code> <code>bool</code> <p>Whether to clip the image to the region. Default to False.</p> <code>False</code> <code>cloud_pct</code> <code>float</code> <p>The percentage of cloud cover to be used for filtering. Default to 0.35.</p> <code>0.35</code> <code>reducer</code> <code>ee.Reducer</code> <p>The reducer to be used for creating image composite. Default to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The Sentinel-2 composite.</p> Source code in <code>geemap/common.py</code> <pre><code>def dynamic_world_s2(\n    region=None,\n    start_date=\"2020-01-01\",\n    end_date=\"2021-01-01\",\n    clip=False,\n    cloud_pct=0.35,\n    reducer=None,\n):\n\"\"\"Create Sentinel-2 composite for the Dynamic World Land Cover product.\n\n    Args:\n        region (ee.Geometry | ee.FeatureCollection): The region of interest. Default to None.\n        start_date (str | ee.Date): The start date of the query. Default to \"2020-01-01\".\n        end_date (str | ee.Date): The end date of the query. Default to \"2021-01-01\".\n        clip (bool, optional): Whether to clip the image to the region. Default to False.\n        cloud_pct (float, optional): The percentage of cloud cover to be used for filtering. Default to 0.35.\n        reducer (ee.Reducer, optional): The reducer to be used for creating image composite. Default to None.\n\n    Returns:\n        ee.Image: The Sentinel-2 composite.\n    \"\"\"\n    s2 = (\n        ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\")\n        .filterDate(start_date, end_date)\n        .filter(ee.Filter.lt(\"CLOUDY_PIXEL_PERCENTAGE\", cloud_pct * 100))\n    )\n\n    if isinstance(region, ee.FeatureCollection) or isinstance(region, ee.Geometry):\n        s2 = s2.filterBounds(region)\n    else:\n        raise ValueError(\"region must be an ee.FeatureCollection or ee.Geometry.\")\n\n    if reducer is None:\n        reducer = ee.Reducer.median()\n\n    image = s2.reduce(reducer).rename(s2.first().bandNames())\n\n    if clip and (region is not None):\n        if isinstance(region, ee.Geometry):\n            image = image.clip(region)\n        elif isinstance(region, ee.FeatureCollection):\n            image = image.clipToCollection(region)\n\n    return image\n</code></pre>"},{"location":"common/#geemap.common.edit_download_html","title":"<code>edit_download_html(htmlWidget, filename, title='Click here to download: ')</code>","text":"<p>Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058</p> <p>Parameters:</p> Name Type Description Default <code>htmlWidget</code> <code>object</code> <p>The HTML widget to display the URL.</p> required <code>filename</code> <code>str</code> <p>File path to download.</p> required <code>title</code> <code>str</code> <p>Download description. Defaults to \"Click here to download: \".</p> <code>'Click here to download: '</code> Source code in <code>geemap/common.py</code> <pre><code>def edit_download_html(htmlWidget, filename, title=\"Click here to download: \"):\n\"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058\n\n    Args:\n        htmlWidget (object): The HTML widget to display the URL.\n        filename (str): File path to download.\n        title (str, optional): Download description. Defaults to \"Click here to download: \".\n    \"\"\"\n\n    # from IPython.display import HTML\n    # import ipywidgets as widgets\n    import base64\n\n    # Change widget html temporarily to a font-awesome spinner\n    htmlWidget.value = '&lt;i class=\"fa fa-spinner fa-spin fa-2x fa-fw\"&gt;&lt;/i&gt;&lt;span class=\"sr-only\"&gt;Loading...&lt;/span&gt;'\n\n    # Process raw data\n    data = open(filename, \"rb\").read()\n    b64 = base64.b64encode(data)\n    payload = b64.decode()\n\n    basename = os.path.basename(filename)\n\n    # Create and assign html to widget\n    html = '&lt;a download=\"{filename}\" href=\"data:text/csv;base64,{payload}\" target=\"_blank\"&gt;{title}&lt;/a&gt;'\n    htmlWidget.value = html.format(\n        payload=payload, title=title + basename, filename=basename\n    )\n\n    # htmlWidget = widgets.HTML(value = '')\n    # htmlWidget\n</code></pre>"},{"location":"common/#geemap.common.ee_api_to_csv","title":"<code>ee_api_to_csv(outfile=None, timeout=300, proxies=None)</code>","text":"<p>Extracts Earth Engine API documentation from https://developers.google.com/earth-engine/api_docs as a csv file.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The output file path to a csv file. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>Proxy settings. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_api_to_csv(outfile=None, timeout=300, proxies=None):\n\"\"\"Extracts Earth Engine API documentation from https://developers.google.com/earth-engine/api_docs as a csv file.\n\n    Args:\n        outfile (str, optional): The output file path to a csv file. Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n        proxies (dict, optional): Proxy settings. Defaults to None.\n    \"\"\"\n    import pkg_resources\n\n    from bs4 import BeautifulSoup\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    data_dir = os.path.join(pkg_dir, \"data\")\n    template_dir = os.path.join(data_dir, \"template\")\n    csv_file = os.path.join(template_dir, \"ee_api_docs.csv\")\n\n    if outfile is None:\n        outfile = csv_file\n    else:\n        if not outfile.endswith(\".csv\"):\n            print(\"The output file must end with .csv\")\n            return\n        else:\n            out_dir = os.path.dirname(outfile)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n    url = \"https://developers.google.com/earth-engine/api_docs\"\n\n    try:\n        r = requests.get(url, timeout=timeout, proxies=proxies)\n        soup = BeautifulSoup(r.content, \"html.parser\")\n\n        names = []\n        descriptions = []\n        functions = []\n        returns = []\n        arguments = []\n        types = []\n        details = []\n\n        names = [h2.text for h2 in soup.find_all(\"h2\")]\n        descriptions = [h2.next_sibling.next_sibling.text for h2 in soup.find_all(\"h2\")]\n        func_tables = soup.find_all(\"table\", class_=\"blue\")\n        functions = [func_table.find(\"code\").text for func_table in func_tables]\n        returns = [func_table.find_all(\"td\")[1].text for func_table in func_tables]\n\n        detail_tables = []\n        tables = soup.find_all(\"table\", class_=\"blue\")\n\n        for table in tables:\n            item = table.next_sibling\n            if item.attrs == {\"class\": [\"details\"]}:\n                detail_tables.append(item)\n            else:\n                detail_tables.append(\"\")\n\n        for detail_table in detail_tables:\n            if detail_table != \"\":\n                items = [item.text for item in detail_table.find_all(\"code\")]\n            else:\n                items = \"\"\n            arguments.append(items)\n\n        for detail_table in detail_tables:\n            if detail_table != \"\":\n                items = [item.text for item in detail_table.find_all(\"td\")]\n                items = items[1::3]\n            else:\n                items = \"\"\n            types.append(items)\n\n        for detail_table in detail_tables:\n            if detail_table != \"\":\n                items = [item.text for item in detail_table.find_all(\"p\")]\n            else:\n                items = \"\"\n            details.append(items)\n\n        with open(outfile, \"w\", encoding=\"utf-8\") as csv_file:\n            csv_writer = csv.writer(csv_file, delimiter=\"\\t\")\n\n            csv_writer.writerow(\n                [\n                    \"name\",\n                    \"description\",\n                    \"function\",\n                    \"returns\",\n                    \"argument\",\n                    \"type\",\n                    \"details\",\n                ]\n            )\n\n            for i in range(len(names)):\n                name = names[i]\n                description = descriptions[i]\n                function = functions[i]\n                return_type = returns[i]\n                argument = \"|\".join(arguments[i])\n                argu_type = \"|\".join(types[i])\n                detail = \"|\".join(details[i])\n\n                csv_writer.writerow(\n                    [\n                        name,\n                        description,\n                        function,\n                        return_type,\n                        argument,\n                        argu_type,\n                        detail,\n                    ]\n                )\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_data_html","title":"<code>ee_data_html(asset)</code>","text":"<p>Generates HTML from an asset to be used in the HTML widget.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>dict</code> <p>A dictionary containing an Earth Engine asset.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string containing HTML.</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_data_html(asset):\n\"\"\"Generates HTML from an asset to be used in the HTML widget.\n\n    Args:\n        asset (dict): A dictionary containing an Earth Engine asset.\n\n    Returns:\n        str: A string containing HTML.\n    \"\"\"\n    try:\n        asset_title = asset.get(\"title\", \"Unknown\")\n        asset_dates = asset.get(\"dates\", \"Unknown\")\n        ee_id_snippet = asset.get(\"id\", \"Unknown\")\n        asset_uid = asset.get(\"uid\", None)\n        asset_url = asset.get(\"asset_url\", \"\")\n        code_url = asset.get(\"sample_code\", None)\n        thumbnail_url = asset.get(\"thumbnail_url\", None)\n        asset_type = asset.get(\"type\", \"Unknown\")\n\n        if asset_type == \"image\":\n            ee_id_snippet = \"ee.Image('{}')\".format(ee_id_snippet)\n        elif asset_type == \"image_collection\":\n            ee_id_snippet = \"ee.ImageCollection('{}')\".format(ee_id_snippet)\n        elif asset_type == \"table\":\n            ee_id_snippet = \"ee.FeatureCollection('{}')\".format(ee_id_snippet)\n\n        if not code_url and asset_uid:\n            coder_url = f\"\"\"https://code.earthengine.google.com/?scriptPath=Examples%3ADatasets%2F{asset_uid}\"\"\"\n        else:\n            coder_url = code_url\n\n        ## ee datasets always have a asset_url, and should have a thumbnail\n        catalog = (\n            bool(asset_url)\n            * f\"\"\"\n                    &lt;h4&gt;Data Catalog&lt;/h4&gt;\n                        &lt;p style=\"margin-left: 40px\"&gt;&lt;a href=\"{asset_url.replace('terms-of-use','description')}\" target=\"_blank\"&gt;Description&lt;/a&gt;&lt;/p&gt;\n                        &lt;p style=\"margin-left: 40px\"&gt;&lt;a href=\"{asset_url.replace('terms-of-use','bands')}\" target=\"_blank\"&gt;Bands&lt;/a&gt;&lt;/p&gt;\n                        &lt;p style=\"margin-left: 40px\"&gt;&lt;a href=\"{asset_url.replace('terms-of-use','image-properties')}\" target=\"_blank\"&gt;Properties&lt;/a&gt;&lt;/p&gt;\n                        &lt;p style=\"margin-left: 40px\"&gt;&lt;a href=\"{coder_url}\" target=\"_blank\"&gt;Example&lt;/a&gt;&lt;/p&gt;\n                    \"\"\"\n        )\n        thumbnail = (\n            bool(thumbnail_url)\n            * f\"\"\"\n                    &lt;h4&gt;Dataset Thumbnail&lt;/h4&gt;\n                    &lt;img src=\"{thumbnail_url}\"&gt;  \n                    \"\"\"\n        )\n        ## only community datasets have a code_url\n        alternative = (\n            bool(code_url)\n            * f\"\"\"\n                    &lt;h4&gt;Community Catalog&lt;/h4&gt;\n                        &lt;p style=\"margin-left: 40px\"&gt;{asset.get('provider','Provider unknown')}&lt;/p&gt;\n                        &lt;p style=\"margin-left: 40px\"&gt;{asset.get('tags','Tags unknown')}&lt;/p&gt;\n                        &lt;p style=\"margin-left: 40px\"&gt;&lt;a href=\"{coder_url}\" target=\"_blank\"&gt;Example&lt;/a&gt;&lt;/p&gt;\n                    \"\"\"\n        )\n\n        template = f\"\"\"\n            &lt;html&gt;\n            &lt;body&gt;\n                &lt;h3&gt;{asset_title}&lt;/h3&gt;\n                &lt;h4&gt;Dataset Availability&lt;/h4&gt;\n                    &lt;p style=\"margin-left: 40px\"&gt;{asset_dates}&lt;/p&gt;\n                &lt;h4&gt;Earth Engine Snippet&lt;/h4&gt;\n                    &lt;p style=\"margin-left: 40px\"&gt;{ee_id_snippet}&lt;/p&gt;\n{catalog}\n{alternative}\n{thumbnail}\n            &lt;/body&gt;\n            &lt;/html&gt;\n        \"\"\"\n        return template\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_data_thumbnail","title":"<code>ee_data_thumbnail(asset_id, timeout=300, proxies=None)</code>","text":"<p>Retrieves the thumbnail URL of an Earth Engine asset.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>An Earth Engine asset id.</p> required <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>Proxy settings. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An http url of the thumbnail.</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_data_thumbnail(asset_id, timeout=300, proxies=None):\n\"\"\"Retrieves the thumbnail URL of an Earth Engine asset.\n\n    Args:\n        asset_id (str): An Earth Engine asset id.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n        proxies (dict, optional): Proxy settings. Defaults to None.\n\n    Returns:\n        str: An http url of the thumbnail.\n    \"\"\"\n    import urllib\n\n    from bs4 import BeautifulSoup\n\n    asset_uid = asset_id.replace(\"/\", \"_\")\n    asset_url = \"https://developers.google.com/earth-engine/datasets/catalog/{}\".format(\n        asset_uid\n    )\n    thumbnail_url = \"https://mw1.google.com/ges/dd/images/{}_sample.png\".format(\n        asset_uid\n    )\n\n    r = requests.get(thumbnail_url, timeout=timeout, proxies=proxies)\n\n    try:\n        if r.status_code != 200:\n            html_page = urllib.request.urlopen(asset_url)\n            soup = BeautifulSoup(html_page, features=\"html.parser\")\n\n            for img in soup.findAll(\"img\"):\n                if \"sample.png\" in img.get(\"src\"):\n                    thumbnail_url = img.get(\"src\")\n                    return thumbnail_url\n\n        return thumbnail_url\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_export_geojson","title":"<code>ee_export_geojson(ee_object, filename=None, selectors=None, timeout=300, proxies=None)</code>","text":"<p>Exports Earth Engine FeatureCollection to geojson.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>ee.FeatureCollection to export.</p> required <code>filename</code> <code>str</code> <p>Output file name. Defaults to None.</p> <code>None</code> <code>selectors</code> <code>list</code> <p>A list of attributes to export. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300 seconds.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>Proxy settings. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_geojson(\n    ee_object, filename=None, selectors=None, timeout=300, proxies=None\n):\n\"\"\"Exports Earth Engine FeatureCollection to geojson.\n\n    Args:\n        ee_object (object): ee.FeatureCollection to export.\n        filename (str): Output file name. Defaults to None.\n        selectors (list, optional): A list of attributes to export. Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300 seconds.\n        proxies (dict, optional): Proxy settings. Defaults to None.\n    \"\"\"\n\n    if not isinstance(ee_object, ee.FeatureCollection):\n        print(\"The ee_object must be an ee.FeatureCollection.\")\n        return\n\n    if filename is None:\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        filename = os.path.join(out_dir, random_string(6) + \".geojson\")\n\n    allowed_formats = [\"geojson\"]\n    filename = os.path.abspath(filename)\n    basename = os.path.basename(filename)\n    name = os.path.splitext(basename)[0]\n    filetype = os.path.splitext(basename)[1][1:].lower()\n\n    if not (filetype.lower() in allowed_formats):\n        print(\"The output file type must be geojson.\")\n        return\n\n    if selectors is None:\n        selectors = ee_object.first().propertyNames().getInfo()\n        selectors = [\".geo\"] + selectors\n\n    elif not isinstance(selectors, list):\n        print(\"selectors must be a list, such as ['attribute1', 'attribute2']\")\n        return\n    else:\n        allowed_attributes = ee_object.first().propertyNames().getInfo()\n        for attribute in selectors:\n            if not (attribute in allowed_attributes):\n                print(\n                    \"Attributes must be one chosen from: {} \".format(\n                        \", \".join(allowed_attributes)\n                    )\n                )\n                return\n\n    try:\n        # print('Generating URL ...')\n        url = ee_object.getDownloadURL(\n            filetype=filetype, selectors=selectors, filename=name\n        )\n        # print('Downloading data from {}\\nPlease wait ...'.format(url))\n        r = None\n        r = requests.get(url, stream=True, timeout=timeout, proxies=proxies)\n\n        if r.status_code != 200:\n            print(\"An error occurred while downloading. \\n Retrying ...\")\n            try:\n                new_ee_object = ee_object.map(filter_polygons)\n                print(\"Generating URL ...\")\n                url = new_ee_object.getDownloadURL(\n                    filetype=filetype, selectors=selectors, filename=name\n                )\n                print(f\"Downloading data from {url}\\nPlease wait ...\")\n                r = requests.get(url, stream=True, timeout=timeout, proxies=proxies)\n            except Exception as e:\n                print(e)\n\n        with open(filename, \"wb\") as fd:\n            for chunk in r.iter_content(chunk_size=1024):\n                fd.write(chunk)\n    except Exception as e:\n        print(\"An error occurred while downloading.\")\n        if r is not None:\n            print(r.json()[\"error\"][\"message\"])\n\n        return\n\n    with open(filename) as f:\n        geojson = f.read()\n\n    return geojson\n</code></pre>"},{"location":"common/#geemap.common.ee_export_image","title":"<code>ee_export_image(ee_object, filename, scale=None, crs=None, crs_transform=None, region=None, dimensions=None, file_per_band=False, format='ZIPPED_GEO_TIFF', unzip=True, unmask_value=None, timeout=300, proxies=None)</code>","text":"<p>Exports an ee.Image as a GeoTIFF.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>The ee.Image to download.</p> required <code>filename</code> <code>str</code> <p>Output filename for the exported image.</p> required <code>scale</code> <code>float</code> <p>A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>A default CRS string to use for any bands that do not explicitly specify one. Defaults to None.</p> <code>None</code> <code>crs_transform</code> <code>list</code> <p>a default affine transform to use for any bands that do not specify one, of the same format as the crs_transform of bands. Defaults to None.</p> <code>None</code> <code>region</code> <code>object</code> <p>A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None.</p> <code>None</code> <code>dimensions</code> <code>list</code> <p>An optional array of two integers defining the width and height to which the band is cropped. Defaults to None.</p> <code>None</code> <code>file_per_band</code> <code>bool</code> <p>Whether to produce a different GeoTIFF per band. Defaults to False.</p> <code>False</code> <code>format</code> <code>str</code> <p>One of: \"ZIPPED_GEO_TIFF\" (GeoTIFF file(s) wrapped in a zip file, default), \"GEO_TIFF\" (GeoTIFF file), \"NPY\" (NumPy binary format). If \"GEO_TIFF\" or \"NPY\", filePerBand and all band-level transformations will be ignored. Loading a NumPy output results in a structured array.</p> <code>'ZIPPED_GEO_TIFF'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the downloaded file. Defaults to True.</p> <code>True</code> <code>unmask_value</code> <code>float</code> <p>The value to use for pixels that are masked in the input image. If the exported image contains zero values, you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>The timeout in seconds for the request. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxy servers to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_image(\n    ee_object,\n    filename,\n    scale=None,\n    crs=None,\n    crs_transform=None,\n    region=None,\n    dimensions=None,\n    file_per_band=False,\n    format=\"ZIPPED_GEO_TIFF\",\n    unzip=True,\n    unmask_value=None,\n    timeout=300,\n    proxies=None,\n):\n\"\"\"Exports an ee.Image as a GeoTIFF.\n\n    Args:\n        ee_object (object): The ee.Image to download.\n        filename (str): Output filename for the exported image.\n        scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None.\n        crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None.\n        crs_transform (list, optional): a default affine transform to use for any bands that do not specify one, of the same format as the crs_transform of bands. Defaults to None.\n        region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None.\n        dimensions (list, optional): An optional array of two integers defining the width and height to which the band is cropped. Defaults to None.\n        file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False.\n        format (str, optional):  One of: \"ZIPPED_GEO_TIFF\" (GeoTIFF file(s) wrapped in a zip file, default), \"GEO_TIFF\" (GeoTIFF file), \"NPY\" (NumPy binary format). If \"GEO_TIFF\" or \"NPY\",\n            filePerBand and all band-level transformations will be ignored. Loading a NumPy output results in a structured array.\n        unzip (bool, optional): Whether to unzip the downloaded file. Defaults to True.\n        unmask_value (float, optional): The value to use for pixels that are masked in the input image.\n            If the exported image contains zero values, you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.\n        timeout (int, optional): The timeout in seconds for the request. Defaults to 300.\n        proxies (dict, optional): A dictionary of proxy servers to use. Defaults to None.\n    \"\"\"\n\n    if not isinstance(ee_object, ee.Image):\n        print(\"The ee_object must be an ee.Image.\")\n        return\n\n    if unmask_value is not None:\n        ee_object = ee_object.selfMask().unmask(unmask_value)\n        if isinstance(region, ee.Geometry):\n            ee_object = ee_object.clip(region)\n        elif isinstance(region, ee.FeatureCollection):\n            ee_object = ee_object.clipToCollection(region)\n\n    filename = os.path.abspath(filename)\n    basename = os.path.basename(filename)\n    name = os.path.splitext(basename)[0]\n    filetype = os.path.splitext(basename)[1][1:].lower()\n    filename_zip = filename.replace(\".tif\", \".zip\")\n\n    if filetype != \"tif\":\n        print(\"The filename must end with .tif\")\n        return\n\n    try:\n        print(\"Generating URL ...\")\n        params = {\"name\": name, \"filePerBand\": file_per_band}\n\n        params[\"scale\"] = scale\n        if region is None:\n            region = ee_object.geometry()\n        if dimensions is not None:\n            params[\"dimensions\"] = dimensions\n        if region is not None:\n            params[\"region\"] = region\n        if crs is not None:\n            params[\"crs\"] = crs\n        if crs_transform is not None:\n            params[\"crs_transform\"] = crs_transform\n        if format != \"ZIPPED_GEO_TIFF\":\n            params[\"format\"] = format\n\n        try:\n            url = ee_object.getDownloadURL(params)\n        except Exception as e:\n            print(\"An error occurred while downloading.\")\n            print(e)\n            return\n        print(f\"Downloading data from {url}\\nPlease wait ...\")\n        # Need to initialize r to something because of how we currently handle errors\n        # We should aim to refactor the code such that only one try block is needed\n        r = None\n        r = requests.get(url, stream=True, timeout=timeout, proxies=proxies)\n\n        if r.status_code != 200:\n            print(\"An error occurred while downloading.\")\n            return\n\n        with open(filename_zip, \"wb\") as fd:\n            for chunk in r.iter_content(chunk_size=1024):\n                fd.write(chunk)\n\n    except Exception as e:\n        print(\"An error occurred while downloading.\")\n        if r is not None:\n            print(r.json()[\"error\"][\"message\"])\n        return\n\n    try:\n        if unzip:\n            with zipfile.ZipFile(filename_zip) as z:\n                z.extractall(os.path.dirname(filename))\n            os.remove(filename_zip)\n\n        if file_per_band:\n            print(f\"Data downloaded to {os.path.dirname(filename)}\")\n        else:\n            print(f\"Data downloaded to {filename}\")\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_export_image_collection","title":"<code>ee_export_image_collection(ee_object, out_dir, scale=None, crs=None, crs_transform=None, region=None, dimensions=None, file_per_band=False, format='ZIPPED_GEO_TIFF', unmask_value=None, filenames=None, timeout=300, proxies=None)</code>","text":"<p>Exports an ImageCollection as GeoTIFFs.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>The ee.Image to download.</p> required <code>out_dir</code> <code>str</code> <p>The output directory for the exported images.</p> required <code>scale</code> <code>float</code> <p>A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>A default CRS string to use for any bands that do not explicitly specify one. Defaults to None.</p> <code>None</code> <code>crs_transform</code> <code>list</code> <p>a default affine transform to use for any bands that do not specify one, of the same format as the crs_transform of bands. Defaults to None.</p> <code>None</code> <code>region</code> <code>object</code> <p>A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None.</p> <code>None</code> <code>dimensions</code> <code>list</code> <p>An optional array of two integers defining the width and height to which the band is cropped. Defaults to None.</p> <code>None</code> <code>file_per_band</code> <code>bool</code> <p>Whether to produce a different GeoTIFF per band. Defaults to False.</p> <code>False</code> <code>format</code> <code>str</code> <p>One of: \"ZIPPED_GEO_TIFF\" (GeoTIFF file(s) wrapped in a zip file, default), \"GEO_TIFF\" (GeoTIFF file), \"NPY\" (NumPy binary format). If \"GEO_TIFF\" or \"NPY\", filePerBand and all band-level transformations will be ignored. Loading a NumPy output results in a structured array.</p> <code>'ZIPPED_GEO_TIFF'</code> <code>unmask_value</code> <code>float</code> <p>The value to use for pixels that are masked in the input image. If the exported image contains zero values, you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.</p> <code>None</code> <code>filenames</code> <code>list | int</code> <p>A list of filenames to use for the exported images. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>The timeout in seconds for the request. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxy servers to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_image_collection(\n    ee_object,\n    out_dir,\n    scale=None,\n    crs=None,\n    crs_transform=None,\n    region=None,\n    dimensions=None,\n    file_per_band=False,\n    format=\"ZIPPED_GEO_TIFF\",\n    unmask_value=None,\n    filenames=None,\n    timeout=300,\n    proxies=None,\n):\n\"\"\"Exports an ImageCollection as GeoTIFFs.\n\n    Args:\n        ee_object (object): The ee.Image to download.\n        out_dir (str): The output directory for the exported images.\n        scale (float, optional): A default scale to use for any bands that do not specify one; ignored if crs and crs_transform is specified. Defaults to None.\n        crs (str, optional): A default CRS string to use for any bands that do not explicitly specify one. Defaults to None.\n        crs_transform (list, optional): a default affine transform to use for any bands that do not specify one, of the same format as the crs_transform of bands. Defaults to None.\n        region (object, optional): A polygon specifying a region to download; ignored if crs and crs_transform is specified. Defaults to None.\n        dimensions (list, optional): An optional array of two integers defining the width and height to which the band is cropped. Defaults to None.\n        file_per_band (bool, optional): Whether to produce a different GeoTIFF per band. Defaults to False.\n        format (str, optional):  One of: \"ZIPPED_GEO_TIFF\" (GeoTIFF file(s) wrapped in a zip file, default), \"GEO_TIFF\" (GeoTIFF file), \"NPY\" (NumPy binary format). If \"GEO_TIFF\" or \"NPY\",\n            filePerBand and all band-level transformations will be ignored. Loading a NumPy output results in a structured array.\n        unmask_value (float, optional): The value to use for pixels that are masked in the input image.\n            If the exported image contains zero values, you should set the unmask value to a  non-zero value so that the zero values are not treated as missing data. Defaults to None.\n        filenames (list | int, optional): A list of filenames to use for the exported images. Defaults to None.\n        timeout (int, optional): The timeout in seconds for the request. Defaults to 300.\n        proxies (dict, optional): A dictionary of proxy servers to use. Defaults to None.\n    \"\"\"\n\n    if not isinstance(ee_object, ee.ImageCollection):\n        print(\"The ee_object must be an ee.ImageCollection.\")\n        return\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    try:\n        count = int(ee_object.size().getInfo())\n        print(f\"Total number of images: {count}\\n\")\n\n        if filenames is None:\n            filenames = ee_object.aggregate_array(\"system:index\").getInfo()\n        elif isinstance(filenames, int):\n            filenames = [str(f + filenames) for f in range(0, count)]\n\n        if len(filenames) != count:\n            raise Exception(\n                \"The number of filenames must be equal to the number of images.\"\n            )\n\n        filenames = [str(f) + \".tif\" for f in filenames if not str(f).endswith(\".tif\")]\n\n        for i in range(0, count):\n            image = ee.Image(ee_object.toList(count).get(i))\n            filename = os.path.join(out_dir, filenames[i])\n            print(f\"Exporting {i + 1}/{count}: {filename}\")\n            ee_export_image(\n                image,\n                filename=filename,\n                scale=scale,\n                crs=crs,\n                crs_transform=crs_transform,\n                region=region,\n                dimensions=dimensions,\n                file_per_band=file_per_band,\n                format=format,\n                unmask_value=unmask_value,\n                timeout=timeout,\n                proxies=proxies,\n            )\n            print(\"\\n\")\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_export_image_collection_to_asset","title":"<code>ee_export_image_collection_to_asset(ee_object, descriptions=None, assetIds=None, pyramidingPolicy=None, dimensions=None, region=None, scale=None, crs=None, crsTransform=None, maxPixels=None, **kwargs)</code>","text":"<p>Creates a batch task to export an ImageCollection as raster images to Google Drive.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <p>The image collection to export.</p> required <code>descriptions</code> <p>A list of human-readable names of the tasks.</p> <code>None</code> <code>assetIds</code> <p>The destination asset ID.</p> <code>None</code> <code>pyramidingPolicy</code> <p>The pyramiding policy to apply to each band in the image, a dictionary keyed by band name. Values must be one of: \"mean\", \"sample\", \"min\", \"max\", or \"mode\". Defaults to \"mean\". A special key, \".default\", may be used to change the default for all bands.</p> <code>None</code> <code>dimensions</code> <p>The dimensions of the exported image. Takes either a single positive integer as the maximum dimension or \"WIDTHxHEIGHT\" where WIDTH and HEIGHT are each positive integers.</p> <code>None</code> <code>region</code> <p>The lon,lat coordinates for a LinearRing or Polygon specifying the region to export. Can be specified as a nested lists of numbers or a serialized string. Defaults to the image's region.</p> <code>None</code> <code>scale</code> <p>The resolution in meters per pixel. Defaults to the native resolution of the image assset unless a crsTransform is specified.</p> <code>None</code> <code>crs</code> <p>The coordinate reference system of the exported image's projection. Defaults to the image's default projection.</p> <code>None</code> <code>crsTransform</code> <p>A comma-separated string of 6 numbers describing the affine transform of the coordinate reference system of the exported image's projection, in the order: xScale, xShearing, xTranslation, yShearing, yScale and yTranslation. Defaults to the image's native CRS transform.</p> <code>None</code> <code>maxPixels</code> <p>The maximum allowed number of pixels in the exported image. The task will fail if the exported region covers more pixels in the specified projection. Defaults to 100,000,000.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'crs_transform'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_image_collection_to_asset(\n    ee_object,\n    descriptions=None,\n    assetIds=None,\n    pyramidingPolicy=None,\n    dimensions=None,\n    region=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    maxPixels=None,\n    **kwargs,\n):\n\"\"\"Creates a batch task to export an ImageCollection as raster images to Google Drive.\n\n    Args:\n        ee_object: The image collection to export.\n        descriptions: A list of human-readable names of the tasks.\n        assetIds: The destination asset ID.\n        pyramidingPolicy: The pyramiding policy to apply to each band in the\n            image, a dictionary keyed by band name. Values must be\n            one of: \"mean\", \"sample\", \"min\", \"max\", or \"mode\".\n            Defaults to \"mean\". A special key, \".default\", may be used to\n            change the default for all bands.\n        dimensions: The dimensions of the exported image. Takes either a\n            single positive integer as the maximum dimension or \"WIDTHxHEIGHT\"\n            where WIDTH and HEIGHT are each positive integers.\n        region: The lon,lat coordinates for a LinearRing or Polygon\n            specifying the region to export. Can be specified as a nested\n            lists of numbers or a serialized string. Defaults to the image's\n            region.\n        scale: The resolution in meters per pixel. Defaults to the\n            native resolution of the image assset unless a crsTransform\n            is specified.\n        crs: The coordinate reference system of the exported image's\n            projection. Defaults to the image's default projection.\n        crsTransform: A comma-separated string of 6 numbers describing\n            the affine transform of the coordinate reference system of the\n            exported image's projection, in the order: xScale, xShearing,\n            xTranslation, yShearing, yScale and yTranslation. Defaults to\n            the image's native CRS transform.\n        maxPixels: The maximum allowed number of pixels in the exported\n            image. The task will fail if the exported region covers more\n            pixels in the specified projection. Defaults to 100,000,000.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'crs_transform'.\n    \"\"\"\n\n    if not isinstance(ee_object, ee.ImageCollection):\n        raise ValueError(\"The ee_object must be an ee.ImageCollection.\")\n\n    try:\n        count = int(ee_object.size().getInfo())\n        print(f\"Total number of images: {count}\\n\")\n\n        if (descriptions is not None) and (len(descriptions) != count):\n            print(\"The number of descriptions is not equal to the number of images.\")\n            return\n\n        if descriptions is None:\n            descriptions = ee_object.aggregate_array(\"system:index\").getInfo()\n\n        if assetIds is None:\n            assetIds = descriptions\n\n        images = ee_object.toList(count)\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n            return\n\n        for i in range(0, count):\n            image = ee.Image(images.get(i))\n            description = descriptions[i]\n            assetId = assetIds[i]\n            ee_export_image_to_asset(\n                image,\n                description,\n                assetId,\n                pyramidingPolicy,\n                dimensions,\n                region,\n                scale,\n                crs,\n                crsTransform,\n                maxPixels,\n                **kwargs,\n            )\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_export_image_collection_to_cloud_storage","title":"<code>ee_export_image_collection_to_cloud_storage(ee_object, descriptions=None, bucket=None, fileNamePrefix=None, dimensions=None, region=None, scale=None, crs=None, crsTransform=None, maxPixels=None, shardSize=None, fileDimensions=None, skipEmptyTiles=None, fileFormat=None, formatOptions=None, **kwargs)</code>","text":"<p>Creates a batch task to export an ImageCollection as raster images to Google Drive.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <p>The image collection to export.</p> required <code>descriptions</code> <p>A list of human-readable names of the tasks.</p> <code>None</code> <code>bucket</code> <p>The name of a Cloud Storage bucket for the export.</p> <code>None</code> <code>fileNamePrefix</code> <p>Cloud Storage object name prefix for the export. Defaults to the name of the task.</p> <code>None</code> <code>dimensions</code> <p>The dimensions of the exported image. Takes either a single positive integer as the maximum dimension or \"WIDTHxHEIGHT\" where WIDTH and HEIGHT are each positive integers.</p> <code>None</code> <code>region</code> <p>The lon,lat coordinates for a LinearRing or Polygon specifying the region to export. Can be specified as a nested lists of numbers or a serialized string. Defaults to the image's region.</p> <code>None</code> <code>scale</code> <p>The resolution in meters per pixel. Defaults to the native resolution of the image assset unless a crsTransform is specified.</p> <code>None</code> <code>crs</code> <p>The coordinate reference system of the exported image's projection. Defaults to the image's default projection.</p> <code>None</code> <code>crsTransform</code> <p>A comma-separated string of 6 numbers describing the affine transform of the coordinate reference system of the exported image's projection, in the order: xScale, xShearing, xTranslation, yShearing, yScale and yTranslation. Defaults to the image's native CRS transform.</p> <code>None</code> <code>maxPixels</code> <p>The maximum allowed number of pixels in the exported image. The task will fail if the exported region covers more pixels in the specified projection. Defaults to 100,000,000.</p> <code>None</code> <code>shardSize</code> <p>Size in pixels of the tiles in which this image will be computed. Defaults to 256.</p> <code>None</code> <code>fileDimensions</code> <p>The dimensions in pixels of each image file, if the image is too large to fit in a single file. May specify a single number to indicate a square shape, or a tuple of two dimensions to indicate (width,height). Note that the image will still be clipped to the overall image dimensions. Must be a multiple of shardSize.</p> <code>None</code> <code>skipEmptyTiles</code> <p>If true, skip writing empty (i.e. fully-masked) image tiles. Defaults to false.</p> <code>None</code> <code>fileFormat</code> <p>The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported, defaults to 'GeoTIFF'.</p> <code>None</code> <code>formatOptions</code> <p>A dictionary of string keys to format specific options.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'crs_transform'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_image_collection_to_cloud_storage(\n    ee_object,\n    descriptions=None,\n    bucket=None,\n    fileNamePrefix=None,\n    dimensions=None,\n    region=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    maxPixels=None,\n    shardSize=None,\n    fileDimensions=None,\n    skipEmptyTiles=None,\n    fileFormat=None,\n    formatOptions=None,\n    **kwargs,\n):\n\"\"\"Creates a batch task to export an ImageCollection as raster images to Google Drive.\n\n    Args:\n        ee_object: The image collection to export.\n        descriptions: A list of human-readable names of the tasks.\n        bucket: The name of a Cloud Storage bucket for the export.\n        fileNamePrefix: Cloud Storage object name prefix for the export.\n            Defaults to the name of the task.\n        dimensions: The dimensions of the exported image. Takes either a\n            single positive integer as the maximum dimension or \"WIDTHxHEIGHT\"\n            where WIDTH and HEIGHT are each positive integers.\n        region: The lon,lat coordinates for a LinearRing or Polygon\n            specifying the region to export. Can be specified as a nested\n            lists of numbers or a serialized string. Defaults to the image's\n            region.\n        scale: The resolution in meters per pixel. Defaults to the\n            native resolution of the image assset unless a crsTransform\n            is specified.\n        crs: The coordinate reference system of the exported image's\n            projection. Defaults to the image's default projection.\n        crsTransform: A comma-separated string of 6 numbers describing\n            the affine transform of the coordinate reference system of the\n            exported image's projection, in the order: xScale, xShearing,\n            xTranslation, yShearing, yScale and yTranslation. Defaults to\n            the image's native CRS transform.\n        maxPixels: The maximum allowed number of pixels in the exported\n            image. The task will fail if the exported region covers more\n            pixels in the specified projection. Defaults to 100,000,000.\n        shardSize: Size in pixels of the tiles in which this image will be\n            computed. Defaults to 256.\n        fileDimensions: The dimensions in pixels of each image file, if the\n            image is too large to fit in a single file. May specify a\n            single number to indicate a square shape, or a tuple of two\n            dimensions to indicate (width,height). Note that the image will\n            still be clipped to the overall image dimensions. Must be a\n            multiple of shardSize.\n        skipEmptyTiles: If true, skip writing empty (i.e. fully-masked)\n            image tiles. Defaults to false.\n        fileFormat: The string file format to which the image is exported.\n            Currently only 'GeoTIFF' and 'TFRecord' are supported, defaults to\n            'GeoTIFF'.\n        formatOptions: A dictionary of string keys to format specific options.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'crs_transform'.\n    \"\"\"\n\n    if not isinstance(ee_object, ee.ImageCollection):\n        raise ValueError(\"The ee_object must be an ee.ImageCollection.\")\n\n    try:\n        count = int(ee_object.size().getInfo())\n        print(f\"Total number of images: {count}\\n\")\n\n        if (descriptions is not None) and (len(descriptions) != count):\n            print(\"The number of descriptions is not equal to the number of images.\")\n            return\n\n        if descriptions is None:\n            descriptions = ee_object.aggregate_array(\"system:index\").getInfo()\n\n        images = ee_object.toList(count)\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n            return\n\n        for i in range(0, count):\n            image = ee.Image(images.get(i))\n            description = descriptions[i]\n            ee_export_image_to_cloud_storage(\n                image,\n                description,\n                bucket,\n                fileNamePrefix,\n                dimensions,\n                region,\n                scale,\n                crs,\n                crsTransform,\n                maxPixels,\n                shardSize,\n                fileDimensions,\n                skipEmptyTiles,\n                fileFormat,\n                formatOptions,\n                **kwargs,\n            )\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_export_image_collection_to_drive","title":"<code>ee_export_image_collection_to_drive(ee_object, descriptions=None, folder=None, fileNamePrefix=None, dimensions=None, region=None, scale=None, crs=None, crsTransform=None, maxPixels=None, shardSize=None, fileDimensions=None, skipEmptyTiles=None, fileFormat=None, formatOptions=None, **kwargs)</code>","text":"<p>Creates a batch task to export an ImageCollection as raster images to Google Drive.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <p>The image collection to export.</p> required <code>descriptions</code> <p>A list of human-readable names of the tasks.</p> <code>None</code> <code>folder</code> <p>The name of a unique folder in your Drive account to export into. Defaults to the root of the drive.</p> <code>None</code> <code>fileNamePrefix</code> <p>The Google Drive filename for the export. Defaults to the name of the task.</p> <code>None</code> <code>dimensions</code> <p>The dimensions of the exported image. Takes either a single positive integer as the maximum dimension or \"WIDTHxHEIGHT\" where WIDTH and HEIGHT are each positive integers.</p> <code>None</code> <code>region</code> <p>The lon,lat coordinates for a LinearRing or Polygon specifying the region to export. Can be specified as a nested lists of numbers or a serialized string. Defaults to the image's region.</p> <code>None</code> <code>scale</code> <p>The resolution in meters per pixel. Defaults to the native resolution of the image assset unless a crsTransform is specified.</p> <code>None</code> <code>crs</code> <p>The coordinate reference system of the exported image's projection. Defaults to the image's default projection.</p> <code>None</code> <code>crsTransform</code> <p>A comma-separated string of 6 numbers describing the affine transform of the coordinate reference system of the exported image's projection, in the order: xScale, xShearing, xTranslation, yShearing, yScale and yTranslation. Defaults to the image's native CRS transform.</p> <code>None</code> <code>maxPixels</code> <p>The maximum allowed number of pixels in the exported image. The task will fail if the exported region covers more pixels in the specified projection. Defaults to 100,000,000.</p> <code>None</code> <code>shardSize</code> <p>Size in pixels of the tiles in which this image will be computed. Defaults to 256.</p> <code>None</code> <code>fileDimensions</code> <p>The dimensions in pixels of each image file, if the image is too large to fit in a single file. May specify a single number to indicate a square shape, or a tuple of two dimensions to indicate (width,height). Note that the image will still be clipped to the overall image dimensions. Must be a multiple of shardSize.</p> <code>None</code> <code>skipEmptyTiles</code> <p>If true, skip writing empty (i.e. fully-masked) image tiles. Defaults to false.</p> <code>None</code> <code>fileFormat</code> <p>The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported, defaults to 'GeoTIFF'.</p> <code>None</code> <code>formatOptions</code> <p>A dictionary of string keys to format specific options.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'crs_transform', 'driveFolder', and 'driveFileNamePrefix'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_image_collection_to_drive(\n    ee_object,\n    descriptions=None,\n    folder=None,\n    fileNamePrefix=None,\n    dimensions=None,\n    region=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    maxPixels=None,\n    shardSize=None,\n    fileDimensions=None,\n    skipEmptyTiles=None,\n    fileFormat=None,\n    formatOptions=None,\n    **kwargs,\n):\n\"\"\"Creates a batch task to export an ImageCollection as raster images to Google Drive.\n\n    Args:\n        ee_object: The image collection to export.\n        descriptions: A list of human-readable names of the tasks.\n        folder: The name of a unique folder in your Drive account to\n            export into. Defaults to the root of the drive.\n        fileNamePrefix: The Google Drive filename for the export.\n            Defaults to the name of the task.\n        dimensions: The dimensions of the exported image. Takes either a\n            single positive integer as the maximum dimension or \"WIDTHxHEIGHT\"\n            where WIDTH and HEIGHT are each positive integers.\n        region: The lon,lat coordinates for a LinearRing or Polygon\n            specifying the region to export. Can be specified as a nested\n            lists of numbers or a serialized string. Defaults to the image's\n            region.\n        scale: The resolution in meters per pixel. Defaults to the\n            native resolution of the image assset unless a crsTransform\n            is specified.\n        crs: The coordinate reference system of the exported image's\n            projection. Defaults to the image's default projection.\n        crsTransform: A comma-separated string of 6 numbers describing\n            the affine transform of the coordinate reference system of the\n            exported image's projection, in the order: xScale, xShearing,\n            xTranslation, yShearing, yScale and yTranslation. Defaults to\n            the image's native CRS transform.\n        maxPixels: The maximum allowed number of pixels in the exported\n            image. The task will fail if the exported region covers more\n            pixels in the specified projection. Defaults to 100,000,000.\n        shardSize: Size in pixels of the tiles in which this image will be\n            computed. Defaults to 256.\n        fileDimensions: The dimensions in pixels of each image file, if the\n            image is too large to fit in a single file. May specify a\n            single number to indicate a square shape, or a tuple of two\n            dimensions to indicate (width,height). Note that the image will\n            still be clipped to the overall image dimensions. Must be a\n            multiple of shardSize.\n        skipEmptyTiles: If true, skip writing empty (i.e. fully-masked)\n            image tiles. Defaults to false.\n        fileFormat: The string file format to which the image is exported.\n            Currently only 'GeoTIFF' and 'TFRecord' are supported, defaults to\n            'GeoTIFF'.\n        formatOptions: A dictionary of string keys to format specific options.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'crs_transform', 'driveFolder', and 'driveFileNamePrefix'.\n    \"\"\"\n\n    if not isinstance(ee_object, ee.ImageCollection):\n        raise ValueError(\"The ee_object must be an ee.ImageCollection.\")\n\n    try:\n        count = int(ee_object.size().getInfo())\n        print(f\"Total number of images: {count}\\n\")\n\n        if (descriptions is not None) and (len(descriptions) != count):\n            raise ValueError(\n                \"The number of descriptions is not equal to the number of images.\"\n            )\n\n        if descriptions is None:\n            descriptions = ee_object.aggregate_array(\"system:index\").getInfo()\n\n        images = ee_object.toList(count)\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n            return\n\n        for i in range(0, count):\n            image = ee.Image(images.get(i))\n            description = descriptions[i]\n            ee_export_image_to_drive(\n                image,\n                description,\n                folder,\n                fileNamePrefix,\n                dimensions,\n                region,\n                scale,\n                crs,\n                crsTransform,\n                maxPixels,\n                shardSize,\n                fileDimensions,\n                skipEmptyTiles,\n                fileFormat,\n                formatOptions,\n                **kwargs,\n            )\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_export_image_to_asset","title":"<code>ee_export_image_to_asset(image, description='myExportImageTask', assetId=None, pyramidingPolicy=None, dimensions=None, region=None, scale=None, crs=None, crsTransform=None, maxPixels=None, **kwargs)</code>","text":"<p>Creates a task to export an EE Image to an EE Asset.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <p>The image to be exported.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportImageTask'</code> <code>assetId</code> <p>The destination asset ID.</p> <code>None</code> <code>pyramidingPolicy</code> <p>The pyramiding policy to apply to each band in the image, a dictionary keyed by band name. Values must be one of: \"mean\", \"sample\", \"min\", \"max\", or \"mode\". Defaults to \"mean\". A special key, \".default\", may be used to change the default for all bands.</p> <code>None</code> <code>dimensions</code> <p>The dimensions of the exported image. Takes either a single positive integer as the maximum dimension or \"WIDTHxHEIGHT\" where WIDTH and HEIGHT are each positive integers.</p> <code>None</code> <code>region</code> <p>The lon,lat coordinates for a LinearRing or Polygon specifying the region to export. Can be specified as a nested lists of numbers or a serialized string. Defaults to the image's region.</p> <code>None</code> <code>scale</code> <p>The resolution in meters per pixel. Defaults to the native resolution of the image assset unless a crsTransform is specified.</p> <code>None</code> <code>crs</code> <p>The coordinate reference system of the exported image's projection. Defaults to the image's default projection.</p> <code>None</code> <code>crsTransform</code> <p>A comma-separated string of 6 numbers describing the affine transform of the coordinate reference system of the exported image's projection, in the order: xScale, xShearing, xTranslation, yShearing, yScale and yTranslation. Defaults to the image's native CRS transform.</p> <code>None</code> <code>maxPixels</code> <p>The maximum allowed number of pixels in the exported image. The task will fail if the exported region covers more pixels in the specified projection. Defaults to 100,000,000.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'crs_transform'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_image_to_asset(\n    image,\n    description=\"myExportImageTask\",\n    assetId=None,\n    pyramidingPolicy=None,\n    dimensions=None,\n    region=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    maxPixels=None,\n    **kwargs,\n):\n\"\"\"Creates a task to export an EE Image to an EE Asset.\n\n    Args:\n        image: The image to be exported.\n        description: Human-readable name of the task.\n        assetId: The destination asset ID.\n        pyramidingPolicy: The pyramiding policy to apply to each band in the\n            image, a dictionary keyed by band name. Values must be\n            one of: \"mean\", \"sample\", \"min\", \"max\", or \"mode\".\n            Defaults to \"mean\". A special key, \".default\", may be used to\n            change the default for all bands.\n        dimensions: The dimensions of the exported image. Takes either a\n            single positive integer as the maximum dimension or \"WIDTHxHEIGHT\"\n            where WIDTH and HEIGHT are each positive integers.\n        region: The lon,lat coordinates for a LinearRing or Polygon\n            specifying the region to export. Can be specified as a nested\n            lists of numbers or a serialized string. Defaults to the image's\n            region.\n        scale: The resolution in meters per pixel. Defaults to the\n            native resolution of the image assset unless a crsTransform\n            is specified.\n        crs: The coordinate reference system of the exported image's\n            projection. Defaults to the image's default projection.\n        crsTransform: A comma-separated string of 6 numbers describing\n            the affine transform of the coordinate reference system of the\n            exported image's projection, in the order: xScale, xShearing,\n            xTranslation, yShearing, yScale and yTranslation. Defaults to\n            the image's native CRS transform.\n        maxPixels: The maximum allowed number of pixels in the exported\n            image. The task will fail if the exported region covers more\n            pixels in the specified projection. Defaults to 100,000,000.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'crs_transform'.\n    \"\"\"\n\n    if isinstance(image, ee.Image) or isinstance(image, ee.image.Image):\n        pass\n    else:\n        raise ValueError(\"Input image must be an instance of ee.Image\")\n\n    if isinstance(assetId, str):\n        if assetId.startswith(\"users/\") or assetId.startswith(\"projects/\"):\n            pass\n        else:\n            assetId = f\"{ee_user_id()}/{assetId}\"\n\n    task = ee.batch.Export.image.toAsset(\n        image,\n        description,\n        assetId,\n        pyramidingPolicy,\n        dimensions,\n        region,\n        scale,\n        crs,\n        crsTransform,\n        maxPixels,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_export_image_to_cloud_storage","title":"<code>ee_export_image_to_cloud_storage(image, description='myExportImageTask', bucket=None, fileNamePrefix=None, dimensions=None, region=None, scale=None, crs=None, crsTransform=None, maxPixels=None, shardSize=None, fileDimensions=None, skipEmptyTiles=None, fileFormat=None, formatOptions=None, **kwargs)</code>","text":"<p>Creates a task to export an EE Image to Google Cloud Storage.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <p>The image to be exported.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportImageTask'</code> <code>bucket</code> <p>The name of a Cloud Storage bucket for the export.</p> <code>None</code> <code>fileNamePrefix</code> <p>Cloud Storage object name prefix for the export. Defaults to the name of the task.</p> <code>None</code> <code>dimensions</code> <p>The dimensions of the exported image. Takes either a single positive integer as the maximum dimension or \"WIDTHxHEIGHT\" where WIDTH and HEIGHT are each positive integers.</p> <code>None</code> <code>region</code> <p>The lon,lat coordinates for a LinearRing or Polygon specifying the region to export. Can be specified as a nested lists of numbers or a serialized string. Defaults to the image's region.</p> <code>None</code> <code>scale</code> <p>The resolution in meters per pixel. Defaults to the native resolution of the image assset unless a crsTransform is specified.</p> <code>None</code> <code>crs</code> <p>The coordinate reference system of the exported image's projection. Defaults to the image's default projection.</p> <code>None</code> <code>crsTransform</code> <p>A comma-separated string of 6 numbers describing the affine transform of the coordinate reference system of the exported image's projection, in the order: xScale, xShearing, xTranslation, yShearing, yScale and yTranslation. Defaults to the image's native CRS transform.</p> <code>None</code> <code>maxPixels</code> <p>The maximum allowed number of pixels in the exported image. The task will fail if the exported region covers more pixels in the specified projection. Defaults to 100,000,000.</p> <code>None</code> <code>shardSize</code> <p>Size in pixels of the tiles in which this image will be computed. Defaults to 256.</p> <code>None</code> <code>fileDimensions</code> <p>The dimensions in pixels of each image file, if the image is too large to fit in a single file. May specify a single number to indicate a square shape, or a tuple of two dimensions to indicate (width,height). Note that the image will still be clipped to the overall image dimensions. Must be a multiple of shardSize.</p> <code>None</code> <code>skipEmptyTiles</code> <p>If true, skip writing empty (i.e. fully-masked) image tiles. Defaults to false.</p> <code>None</code> <code>fileFormat</code> <p>The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported, defaults to 'GeoTIFF'.</p> <code>None</code> <code>formatOptions</code> <p>A dictionary of string keys to format specific options.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'crs_transform'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_image_to_cloud_storage(\n    image,\n    description=\"myExportImageTask\",\n    bucket=None,\n    fileNamePrefix=None,\n    dimensions=None,\n    region=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    maxPixels=None,\n    shardSize=None,\n    fileDimensions=None,\n    skipEmptyTiles=None,\n    fileFormat=None,\n    formatOptions=None,\n    **kwargs,\n):\n\"\"\"Creates a task to export an EE Image to Google Cloud Storage.\n\n    Args:\n        image: The image to be exported.\n        description: Human-readable name of the task.\n        bucket: The name of a Cloud Storage bucket for the export.\n        fileNamePrefix: Cloud Storage object name prefix for the export.\n            Defaults to the name of the task.\n        dimensions: The dimensions of the exported image. Takes either a\n            single positive integer as the maximum dimension or \"WIDTHxHEIGHT\"\n            where WIDTH and HEIGHT are each positive integers.\n        region: The lon,lat coordinates for a LinearRing or Polygon\n            specifying the region to export. Can be specified as a nested\n            lists of numbers or a serialized string. Defaults to the image's\n            region.\n        scale: The resolution in meters per pixel. Defaults to the\n            native resolution of the image assset unless a crsTransform\n            is specified.\n        crs: The coordinate reference system of the exported image's\n            projection. Defaults to the image's default projection.\n        crsTransform: A comma-separated string of 6 numbers describing\n            the affine transform of the coordinate reference system of the\n            exported image's projection, in the order: xScale, xShearing,\n            xTranslation, yShearing, yScale and yTranslation. Defaults to\n            the image's native CRS transform.\n        maxPixels: The maximum allowed number of pixels in the exported\n            image. The task will fail if the exported region covers more\n            pixels in the specified projection. Defaults to 100,000,000.\n        shardSize: Size in pixels of the tiles in which this image will be\n            computed. Defaults to 256.\n        fileDimensions: The dimensions in pixels of each image file, if the\n            image is too large to fit in a single file. May specify a\n            single number to indicate a square shape, or a tuple of two\n            dimensions to indicate (width,height). Note that the image will\n            still be clipped to the overall image dimensions. Must be a\n            multiple of shardSize.\n        skipEmptyTiles: If true, skip writing empty (i.e. fully-masked)\n            image tiles. Defaults to false.\n        fileFormat: The string file format to which the image is exported.\n            Currently only 'GeoTIFF' and 'TFRecord' are supported, defaults to\n            'GeoTIFF'.\n        formatOptions: A dictionary of string keys to format specific options.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'crs_transform'.\n    \"\"\"\n\n    if not isinstance(image, ee.Image):\n        raise ValueError(\"Input image must be an instance of ee.Image\")\n\n    task = ee.batch.Export.image.toCloudStorage(\n        image,\n        description,\n        bucket,\n        fileNamePrefix,\n        dimensions,\n        region,\n        scale,\n        crs,\n        crsTransform,\n        maxPixels,\n        shardSize,\n        fileDimensions,\n        skipEmptyTiles,\n        fileFormat,\n        formatOptions,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_export_image_to_drive","title":"<code>ee_export_image_to_drive(image, description='myExportImageTask', folder=None, fileNamePrefix=None, dimensions=None, region=None, scale=None, crs=None, crsTransform=None, maxPixels=None, shardSize=None, fileDimensions=None, skipEmptyTiles=None, fileFormat=None, formatOptions=None, **kwargs)</code>","text":"<p>Creates a batch task to export an Image as a raster to Google Drive.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <p>The image to be exported.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportImageTask'</code> <code>folder</code> <p>The name of a unique folder in your Drive account to export into. Defaults to the root of the drive.</p> <code>None</code> <code>fileNamePrefix</code> <p>The Google Drive filename for the export. Defaults to the name of the task.</p> <code>None</code> <code>dimensions</code> <p>The dimensions of the exported image. Takes either a single positive integer as the maximum dimension or \"WIDTHxHEIGHT\" where WIDTH and HEIGHT are each positive integers.</p> <code>None</code> <code>region</code> <p>The lon,lat coordinates for a LinearRing or Polygon specifying the region to export. Can be specified as a nested lists of numbers or a serialized string. Defaults to the image's region.</p> <code>None</code> <code>scale</code> <p>The resolution in meters per pixel. Defaults to the native resolution of the image assset unless a crsTransform is specified.</p> <code>None</code> <code>crs</code> <p>The coordinate reference system of the exported image's projection. Defaults to the image's default projection.</p> <code>None</code> <code>crsTransform</code> <p>A comma-separated string of 6 numbers describing the affine transform of the coordinate reference system of the exported image's projection, in the order: xScale, xShearing, xTranslation, yShearing, yScale and yTranslation. Defaults to the image's native CRS transform.</p> <code>None</code> <code>maxPixels</code> <p>The maximum allowed number of pixels in the exported image. The task will fail if the exported region covers more pixels in the specified projection. Defaults to 100,000,000.</p> <code>None</code> <code>shardSize</code> <p>Size in pixels of the tiles in which this image will be computed. Defaults to 256.</p> <code>None</code> <code>fileDimensions</code> <p>The dimensions in pixels of each image file, if the image is too large to fit in a single file. May specify a single number to indicate a square shape, or a tuple of two dimensions to indicate (width,height). Note that the image will still be clipped to the overall image dimensions. Must be a multiple of shardSize.</p> <code>None</code> <code>skipEmptyTiles</code> <p>If true, skip writing empty (i.e. fully-masked) image tiles. Defaults to false.</p> <code>None</code> <code>fileFormat</code> <p>The string file format to which the image is exported. Currently only 'GeoTIFF' and 'TFRecord' are supported, defaults to 'GeoTIFF'.</p> <code>None</code> <code>formatOptions</code> <p>A dictionary of string keys to format specific options.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'crs_transform', 'driveFolder', and 'driveFileNamePrefix'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_image_to_drive(\n    image,\n    description=\"myExportImageTask\",\n    folder=None,\n    fileNamePrefix=None,\n    dimensions=None,\n    region=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    maxPixels=None,\n    shardSize=None,\n    fileDimensions=None,\n    skipEmptyTiles=None,\n    fileFormat=None,\n    formatOptions=None,\n    **kwargs,\n):\n\"\"\"Creates a batch task to export an Image as a raster to Google Drive.\n\n    Args:\n        image: The image to be exported.\n        description: Human-readable name of the task.\n        folder: The name of a unique folder in your Drive account to\n            export into. Defaults to the root of the drive.\n        fileNamePrefix: The Google Drive filename for the export.\n            Defaults to the name of the task.\n        dimensions: The dimensions of the exported image. Takes either a\n            single positive integer as the maximum dimension or \"WIDTHxHEIGHT\"\n            where WIDTH and HEIGHT are each positive integers.\n        region: The lon,lat coordinates for a LinearRing or Polygon\n            specifying the region to export. Can be specified as a nested\n            lists of numbers or a serialized string. Defaults to the image's\n            region.\n        scale: The resolution in meters per pixel. Defaults to the\n            native resolution of the image assset unless a crsTransform\n            is specified.\n        crs: The coordinate reference system of the exported image's\n            projection. Defaults to the image's default projection.\n        crsTransform: A comma-separated string of 6 numbers describing\n            the affine transform of the coordinate reference system of the\n            exported image's projection, in the order: xScale, xShearing,\n            xTranslation, yShearing, yScale and yTranslation. Defaults to\n            the image's native CRS transform.\n        maxPixels: The maximum allowed number of pixels in the exported\n            image. The task will fail if the exported region covers more\n            pixels in the specified projection. Defaults to 100,000,000.\n        shardSize: Size in pixels of the tiles in which this image will be\n            computed. Defaults to 256.\n        fileDimensions: The dimensions in pixels of each image file, if the\n            image is too large to fit in a single file. May specify a\n            single number to indicate a square shape, or a tuple of two\n            dimensions to indicate (width,height). Note that the image will\n            still be clipped to the overall image dimensions. Must be a\n            multiple of shardSize.\n        skipEmptyTiles: If true, skip writing empty (i.e. fully-masked)\n            image tiles. Defaults to false.\n        fileFormat: The string file format to which the image is exported.\n            Currently only 'GeoTIFF' and 'TFRecord' are supported, defaults to\n            'GeoTIFF'.\n        formatOptions: A dictionary of string keys to format specific options.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'crs_transform', 'driveFolder', and 'driveFileNamePrefix'.\n    \"\"\"\n\n    if not isinstance(image, ee.Image):\n        raise ValueError(\"Input image must be an instance of ee.Image\")\n\n    task = ee.batch.Export.image.toDrive(\n        image,\n        description,\n        folder,\n        fileNamePrefix,\n        dimensions,\n        region,\n        scale,\n        crs,\n        crsTransform,\n        maxPixels,\n        shardSize,\n        fileDimensions,\n        skipEmptyTiles,\n        fileFormat,\n        formatOptions,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_export_map_to_cloud_storage","title":"<code>ee_export_map_to_cloud_storage(image, description='myExportMapTask', bucket=None, fileFormat=None, path=None, writePublicTiles=None, maxZoom=None, scale=None, minZoom=None, region=None, skipEmptyTiles=None, mapsApiKey=None, **kwargs)</code>","text":"<p>Creates a task to export an Image as a pyramid of map tiles.</p> <p>Exports a rectangular pyramid of map tiles for use with web map viewers. The map tiles will be accompanied by a reference index.html file that displays them using the Google Maps API, and an earth.html file for opening the map on Google Earth.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <p>The image to export as tiles.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportMapTask'</code> <code>bucket</code> <p>The destination bucket to write to.</p> <code>None</code> <code>fileFormat</code> <p>The map tiles' file format, one of 'auto', 'png', or 'jpeg'. Defaults to 'auto', which means that opaque tiles will be encoded as 'jpg' and tiles with transparency will be encoded as 'png'.</p> <code>None</code> <code>path</code> <p>The string used as the output's path. A trailing '/' is optional. Defaults to the task's description.</p> <code>None</code> <code>writePublicTiles</code> <p>Whether to write public tiles instead of using the bucket's default object ACL. Defaults to True and requires the invoker to be an OWNER of bucket.</p> <code>None</code> <code>maxZoom</code> <p>The maximum zoom level of the map tiles to export.</p> <code>None</code> <code>scale</code> <p>The max image resolution in meters per pixel, as an alternative to 'maxZoom'. The scale will be converted to the most appropriate maximum zoom level at the equator.</p> <code>None</code> <code>minZoom</code> <p>The optional minimum zoom level of the map tiles to export.</p> <code>None</code> <code>region</code> <p>The lon,lat coordinates for a LinearRing or Polygon specifying the region to export. Can be specified as a nested lists of numbers or a serialized string. Map tiles will be produced in the rectangular region containing this geometry. Defaults to the image's region.</p> <code>None</code> <code>skipEmptyTiles</code> <p>If true, skip writing empty (i.e. fully-transparent) map tiles. Defaults to false.</p> <code>None</code> <code>mapsApiKey</code> <p>Used in index.html to initialize the Google Maps API. This removes the \"development purposes only\" message from the map.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'crs_transform'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_map_to_cloud_storage(\n    image,\n    description=\"myExportMapTask\",\n    bucket=None,\n    fileFormat=None,\n    path=None,\n    writePublicTiles=None,\n    maxZoom=None,\n    scale=None,\n    minZoom=None,\n    region=None,\n    skipEmptyTiles=None,\n    mapsApiKey=None,\n    **kwargs,\n):\n\"\"\"Creates a task to export an Image as a pyramid of map tiles.\n\n    Exports a rectangular pyramid of map tiles for use with web map\n    viewers. The map tiles will be accompanied by a reference\n    index.html file that displays them using the Google Maps API,\n    and an earth.html file for opening the map on Google Earth.\n\n    Args:\n        image: The image to export as tiles.\n        description: Human-readable name of the task.\n        bucket: The destination bucket to write to.\n        fileFormat: The map tiles' file format, one of 'auto', 'png',\n            or 'jpeg'. Defaults to 'auto', which means that opaque tiles\n            will be encoded as 'jpg' and tiles with transparency will be\n            encoded as 'png'.\n        path: The string used as the output's path. A trailing '/'\n            is optional. Defaults to the task's description.\n        writePublicTiles: Whether to write public tiles instead of using the\n            bucket's default object ACL. Defaults to True and requires the\n            invoker to be an OWNER of bucket.\n        maxZoom: The maximum zoom level of the map tiles to export.\n        scale: The max image resolution in meters per pixel, as an alternative\n            to 'maxZoom'. The scale will be converted to the most appropriate\n            maximum zoom level at the equator.\n        minZoom: The optional minimum zoom level of the map tiles to export.\n        region: The lon,lat coordinates for a LinearRing or Polygon\n            specifying the region to export. Can be specified as a nested\n            lists of numbers or a serialized string. Map tiles will be\n            produced in the rectangular region containing this geometry.\n            Defaults to the image's region.\n        skipEmptyTiles: If true, skip writing empty (i.e. fully-transparent)\n            map tiles. Defaults to false.\n        mapsApiKey: Used in index.html to initialize the Google Maps API. This\n            removes the \"development purposes only\" message from the map.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'crs_transform'.\n\n    \"\"\"\n    if not isinstance(image, ee.Image):\n        raise TypeError(\"image must be an ee.Image\")\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n        return\n\n    print(\n        f\"Exporting {description}... Please check the Task Manager from the JavaScript Code Editor.\"\n    )\n\n    task = ee.batch.Export.map.toCloudStorage(\n        image,\n        description,\n        bucket,\n        fileFormat,\n        path,\n        writePublicTiles,\n        maxZoom,\n        scale,\n        minZoom,\n        region,\n        skipEmptyTiles,\n        mapsApiKey,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_export_vector","title":"<code>ee_export_vector(ee_object, filename, selectors=None, verbose=True, keep_zip=False, timeout=300, proxies=None)</code>","text":"<p>Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>ee.FeatureCollection to export.</p> required <code>filename</code> <code>str</code> <p>Output file name.</p> required <code>selectors</code> <code>list</code> <p>A list of attributes to export. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive text.</p> <code>True</code> <code>keep_zip</code> <code>bool</code> <p>Whether to keep the downloaded shapefile as a zip file.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300 seconds.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxies to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_vector(\n    ee_object,\n    filename,\n    selectors=None,\n    verbose=True,\n    keep_zip=False,\n    timeout=300,\n    proxies=None,\n):\n\"\"\"Exports Earth Engine FeatureCollection to other formats, including shp, csv, json, kml, and kmz.\n\n    Args:\n        ee_object (object): ee.FeatureCollection to export.\n        filename (str): Output file name.\n        selectors (list, optional): A list of attributes to export. Defaults to None.\n        verbose (bool, optional): Whether to print out descriptive text.\n        keep_zip (bool, optional): Whether to keep the downloaded shapefile as a zip file.\n        timeout (int, optional): Timeout in seconds. Defaults to 300 seconds.\n        proxies (dict, optional): A dictionary of proxies to use. Defaults to None.\n    \"\"\"\n\n    if not isinstance(ee_object, ee.FeatureCollection):\n        raise ValueError(\"ee_object must be an ee.FeatureCollection\")\n\n    allowed_formats = [\"csv\", \"geojson\", \"json\", \"kml\", \"kmz\", \"shp\"]\n    # allowed_formats = ['csv', 'kml', 'kmz']\n    filename = os.path.abspath(filename)\n    basename = os.path.basename(filename)\n    name = os.path.splitext(basename)[0]\n    filetype = os.path.splitext(basename)[1][1:].lower()\n\n    if filetype == \"shp\":\n        filename = filename.replace(\".shp\", \".zip\")\n\n    if not (filetype.lower() in allowed_formats):\n        raise ValueError(\n            \"The file type must be one of the following: {}\".format(\n                \", \".join(allowed_formats)\n            )\n        )\n\n    if selectors is None:\n        selectors = ee_object.first().propertyNames().getInfo()\n        if filetype == \"csv\":\n            # remove .geo coordinate field\n            ee_object = ee_object.select([\".*\"], None, False)\n\n    if filetype == \"geojson\":\n        selectors = [\".geo\"] + selectors\n\n    elif not isinstance(selectors, list):\n        raise ValueError(\n            \"selectors must be a list, such as ['attribute1', 'attribute2']\"\n        )\n    else:\n        allowed_attributes = ee_object.first().propertyNames().getInfo()\n        for attribute in selectors:\n            if not (attribute in allowed_attributes):\n                raise ValueError(\n                    \"Attributes must be one chosen from: {} \".format(\n                        \", \".join(allowed_attributes)\n                    )\n                )\n\n    try:\n        if verbose:\n            print(\"Generating URL ...\")\n        url = ee_object.getDownloadURL(\n            filetype=filetype, selectors=selectors, filename=name\n        )\n        if verbose:\n            print(f\"Downloading data from {url}\\nPlease wait ...\")\n        r = None\n        r = requests.get(url, stream=True, timeout=timeout, proxies=proxies)\n\n        if r.status_code != 200:\n            print(\"An error occurred while downloading. \\n Retrying ...\")\n            try:\n                new_ee_object = ee_object.map(filter_polygons)\n                print(\"Generating URL ...\")\n                url = new_ee_object.getDownloadURL(\n                    filetype=filetype, selectors=selectors, filename=name\n                )\n                print(f\"Downloading data from {url}\\nPlease wait ...\")\n                r = requests.get(url, stream=True, timeout=timeout, proxies=proxies)\n            except Exception as e:\n                print(e)\n                raise ValueError\n\n        with open(filename, \"wb\") as fd:\n            for chunk in r.iter_content(chunk_size=1024):\n                fd.write(chunk)\n    except Exception as e:\n        print(\"An error occurred while downloading.\")\n        if r is not None:\n            print(r.json()[\"error\"][\"message\"])\n        raise ValueError(e)\n\n    try:\n        if filetype == \"shp\":\n            with zipfile.ZipFile(filename) as z:\n                z.extractall(os.path.dirname(filename))\n            if not keep_zip:\n                os.remove(filename)\n            filename = filename.replace(\".zip\", \".shp\")\n        if verbose:\n            print(f\"Data downloaded to {filename}\")\n    except Exception as e:\n        raise ValueError(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_export_vector_to_asset","title":"<code>ee_export_vector_to_asset(collection, description='myExportTableTask', assetId=None, maxVertices=None, **kwargs)</code>","text":"<p>Creates a task to export a FeatureCollection to Asset.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <p>The feature collection to be exported.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportTableTask'</code> <code>assetId</code> <p>The destination asset ID.</p> <code>None</code> <code>maxVertices</code> <p>Max number of uncut vertices per geometry; geometries with more vertices will be cut into pieces smaller than this size.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_vector_to_asset(\n    collection,\n    description=\"myExportTableTask\",\n    assetId=None,\n    maxVertices=None,\n    **kwargs,\n):\n\"\"\"Creates a task to export a FeatureCollection to Asset.\n\n    Args:\n        collection: The feature collection to be exported.\n        description: Human-readable name of the task.\n        assetId: The destination asset ID.\n        maxVertices:\n            Max number of uncut vertices per geometry; geometries with more\n            vertices will be cut into pieces smaller than this size.\n        **kwargs: Holds other keyword arguments that may have been deprecated.\n    \"\"\"\n    if not isinstance(collection, ee.FeatureCollection):\n        raise ValueError(\"The collection must be an ee.FeatureCollection.\")\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n        return\n\n    if isinstance(assetId, str):\n        if assetId.startswith(\"users/\") or assetId.startswith(\"projects/\"):\n            pass\n        else:\n            assetId = f\"{ee_user_id()}/{assetId}\"\n\n    print(assetId)\n    print(\n        f\"Exporting {description}... Please check the Task Manager from the JavaScript Code Editor.\"\n    )\n\n    task = ee.batch.Export.table.toAsset(\n        collection,\n        description,\n        assetId,\n        maxVertices,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_export_vector_to_cloud_storage","title":"<code>ee_export_vector_to_cloud_storage(collection, description='myExportTableTask', bucket=None, fileNamePrefix=None, fileFormat=None, selectors=None, maxVertices=None, **kwargs)</code>","text":"<p>Creates a task to export a FeatureCollection to Google Cloud Storage.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <p>The feature collection to be exported.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportTableTask'</code> <code>bucket</code> <p>The name of a Cloud Storage bucket for the export.</p> <code>None</code> <code>fileNamePrefix</code> <p>Cloud Storage object name prefix for the export. Defaults to the name of the task.</p> <code>None</code> <code>fileFormat</code> <p>The output format: \"CSV\" (default), \"GeoJSON\", \"KML\", \"KMZ\", \"SHP\", or \"TFRecord\".</p> <code>None</code> <code>selectors</code> <p>The list of properties to include in the output, as a list of strings or a comma-separated string. By default, all properties are included.</p> <code>None</code> <code>maxVertices</code> <p>Max number of uncut vertices per geometry; geometries with more vertices will be cut into pieces smaller than this size.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'outputBucket'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_vector_to_cloud_storage(\n    collection,\n    description=\"myExportTableTask\",\n    bucket=None,\n    fileNamePrefix=None,\n    fileFormat=None,\n    selectors=None,\n    maxVertices=None,\n    **kwargs,\n):\n\"\"\"Creates a task to export a FeatureCollection to Google Cloud Storage.\n\n    Args:\n        collection: The feature collection to be exported.\n        description: Human-readable name of the task.\n        bucket: The name of a Cloud Storage bucket for the export.\n        fileNamePrefix: Cloud Storage object name prefix for the export.\n            Defaults to the name of the task.\n        fileFormat: The output format: \"CSV\" (default), \"GeoJSON\", \"KML\", \"KMZ\",\n            \"SHP\", or \"TFRecord\".\n        selectors: The list of properties to include in the output, as a list\n            of strings or a comma-separated string. By default, all properties\n            are included.\n        maxVertices:\n            Max number of uncut vertices per geometry; geometries with more\n            vertices will be cut into pieces smaller than this size.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'outputBucket'.\n    \"\"\"\n    if not isinstance(collection, ee.FeatureCollection):\n        raise ValueError(\"The collection must be an ee.FeatureCollection.\")\n\n    allowed_formats = [\"csv\", \"geojson\", \"kml\", \"kmz\", \"shp\", \"tfrecord\"]\n    if not (fileFormat.lower() in allowed_formats):\n        raise ValueError(\n            \"The file type must be one of the following: {}\".format(\n                \", \".join(allowed_formats)\n            )\n        )\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n        return\n\n    print(\n        f\"Exporting {description}... Please check the Task Manager from the JavaScript Code Editor.\"\n    )\n\n    task = ee.batch.Export.table.toCloudStorage(\n        collection,\n        description,\n        bucket,\n        fileNamePrefix,\n        fileFormat,\n        selectors,\n        maxVertices,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_export_vector_to_drive","title":"<code>ee_export_vector_to_drive(collection, description='myExportTableTask', folder=None, fileNamePrefix=None, fileFormat=None, selectors=None, maxVertices=None, **kwargs)</code>","text":"<p>Creates a task to export a FeatureCollection to Drive.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <p>The feature collection to be exported.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportTableTask'</code> <code>folder</code> <p>The name of a unique folder in your Drive account to export into. Defaults to the root of the drive.</p> <code>None</code> <code>fileNamePrefix</code> <p>The Google Drive filename for the export. Defaults to the name of the task.</p> <code>None</code> <code>fileFormat</code> <p>The output format: \"CSV\" (default), \"GeoJSON\", \"KML\", \"KMZ\", \"SHP\", or \"TFRecord\".</p> <code>None</code> <code>selectors</code> <p>The list of properties to include in the output, as a list of strings or a comma-separated string. By default, all properties are included.</p> <code>None</code> <code>maxVertices</code> <p>Max number of uncut vertices per geometry; geometries with more vertices will be cut into pieces smaller than this size.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'driveFolder' and 'driveFileNamePrefix'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_vector_to_drive(\n    collection,\n    description=\"myExportTableTask\",\n    folder=None,\n    fileNamePrefix=None,\n    fileFormat=None,\n    selectors=None,\n    maxVertices=None,\n    **kwargs,\n):\n\"\"\"Creates a task to export a FeatureCollection to Drive.\n\n    Args:\n        collection: The feature collection to be exported.\n        description: Human-readable name of the task.\n        folder: The name of a unique folder in your Drive account to\n            export into. Defaults to the root of the drive.\n        fileNamePrefix: The Google Drive filename for the export.\n            Defaults to the name of the task.\n        fileFormat: The output format: \"CSV\" (default), \"GeoJSON\", \"KML\",\n            \"KMZ\", \"SHP\", or \"TFRecord\".\n        selectors: The list of properties to include in the output, as a list\n            of strings or a comma-separated string. By default, all properties\n            are included.\n        maxVertices:\n            Max number of uncut vertices per geometry; geometries with more\n            vertices will be cut into pieces smaller than this size.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'driveFolder' and 'driveFileNamePrefix'.\n    \"\"\"\n    if not isinstance(collection, ee.FeatureCollection):\n        raise ValueError(\"The collection must be an ee.FeatureCollection.\")\n\n    allowed_formats = [\"csv\", \"geojson\", \"kml\", \"kmz\", \"shp\", \"tfrecord\"]\n    if not (fileFormat.lower() in allowed_formats):\n        raise ValueError(\n            \"The file type must be one of the following: {}\".format(\n                \", \".join(allowed_formats)\n            )\n        )\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n        return\n\n    print(\n        f\"Exporting {description}... Please check the Task Manager from the JavaScript Code Editor.\"\n    )\n\n    task = ee.batch.Export.table.toDrive(\n        collection,\n        description,\n        folder,\n        fileNamePrefix,\n        fileFormat,\n        selectors,\n        maxVertices,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_export_vector_to_feature_view","title":"<code>ee_export_vector_to_feature_view(collection, description='myExportTableTask', assetId=None, ingestionTimeParameters=None, **kwargs)</code>","text":"<p>Creates a task to export a FeatureCollection to a FeatureView.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <p>The feature collection to be exported.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportTableTask'</code> <code>assetId</code> <p>The destination asset ID.</p> <code>None</code> <code>ingestionTimeParameters</code> <p>The FeatureView ingestion time parameters.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_vector_to_feature_view(\n    collection,\n    description=\"myExportTableTask\",\n    assetId=None,\n    ingestionTimeParameters=None,\n    **kwargs,\n):\n\"\"\"Creates a task to export a FeatureCollection to a FeatureView.\n\n    Args:\n        collection: The feature collection to be exported.\n        description: Human-readable name of the task.\n        assetId: The destination asset ID.\n        ingestionTimeParameters: The FeatureView ingestion time parameters.\n        **kwargs: Holds other keyword arguments that may have been deprecated.\n    \"\"\"\n    if not isinstance(collection, ee.FeatureCollection):\n        raise ValueError(\"The collection must be an ee.FeatureCollection.\")\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n        return\n\n    print(\n        f\"Exporting {description}... Please check the Task Manager from the JavaScript Code Editor.\"\n    )\n\n    task = ee.batch.Export.table.toFeatureView(\n        collection,\n        description,\n        assetId,\n        ingestionTimeParameters,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_export_video_to_cloud_storage","title":"<code>ee_export_video_to_cloud_storage(collection, description='myExportVideoTask', bucket=None, fileNamePrefix=None, framesPerSecond=None, dimensions=None, region=None, scale=None, crs=None, crsTransform=None, maxPixels=None, maxFrames=None, **kwargs)</code>","text":"<p>Creates a task to export an ImageCollection as a video to Cloud Storage.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <p>The image collection to be exported. The collection must only contain RGB images.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportVideoTask'</code> <code>bucket</code> <p>The name of a Cloud Storage bucket for the export.</p> <code>None</code> <code>fileNamePrefix</code> <p>Cloud Storage object name prefix for the export. Defaults to the task's description.</p> <code>None</code> <code>framesPerSecond</code> <p>A number between .1 and 120 describing the framerate of the exported video.</p> <code>None</code> <code>dimensions</code> <p>The dimensions of the exported video. Takes either a single positive integer as the maximum dimension or \"WIDTHxHEIGHT\" where WIDTH and HEIGHT are each positive integers.</p> <code>None</code> <code>region</code> <p>The lon,lat coordinates for a LinearRing or Polygon specifying the region to export. Can be specified as a nested lists of numbers or a serialized string. Defaults to the first image's region.</p> <code>None</code> <code>scale</code> <p>The resolution in meters per pixel.</p> <code>None</code> <code>crs</code> <p>The coordinate reference system of the exported video's projection. Defaults to SR-ORG:6627.</p> <code>None</code> <code>crsTransform</code> <p>A comma-separated string of 6 numbers describing the affine transform of the coordinate reference system of the exported video's projection, in the order: xScale, xShearing, xTranslation, yShearing, yScale and yTranslation. Defaults to the image collection's native CRS transform.</p> <code>None</code> <code>maxPixels</code> <p>The maximum number of pixels per frame. Defaults to 1e8 pixels per frame. By setting this explicitly, you may raise or lower the limit.</p> <code>None</code> <code>maxFrames</code> <p>The maximum number of frames to export. Defaults to 1000 frames. By setting this explicitly, you may raise or lower the limit.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'crs_transform'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_video_to_cloud_storage(\n    collection,\n    description=\"myExportVideoTask\",\n    bucket=None,\n    fileNamePrefix=None,\n    framesPerSecond=None,\n    dimensions=None,\n    region=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    maxPixels=None,\n    maxFrames=None,\n    **kwargs,\n):\n\"\"\"Creates a task to export an ImageCollection as a video to Cloud Storage.\n\n    Args:\n        collection: The image collection to be exported. The collection must\n            only contain RGB images.\n        description: Human-readable name of the task.\n        bucket: The name of a Cloud Storage bucket for the export.\n        fileNamePrefix: Cloud Storage object name prefix for the export.\n            Defaults to the task's description.\n        framesPerSecond: A number between .1 and 120 describing the\n            framerate of the exported video.\n        dimensions: The dimensions of the exported video. Takes either a\n            single positive integer as the maximum dimension or \"WIDTHxHEIGHT\"\n            where WIDTH and HEIGHT are each positive integers.\n        region: The lon,lat coordinates for a LinearRing or Polygon\n            specifying the region to export. Can be specified as a nested\n            lists of numbers or a serialized string. Defaults to the first\n            image's region.\n        scale: The resolution in meters per pixel.\n        crs: The coordinate reference system of the exported video's\n            projection. Defaults to SR-ORG:6627.\n        crsTransform: A comma-separated string of 6 numbers describing\n            the affine transform of the coordinate reference system of the\n            exported video's projection, in the order: xScale, xShearing,\n            xTranslation, yShearing, yScale and yTranslation. Defaults to\n            the image collection's native CRS transform.\n        maxPixels: The maximum number of pixels per frame.\n            Defaults to 1e8 pixels per frame. By setting this explicitly,\n            you may raise or lower the limit.\n        maxFrames: The maximum number of frames to export.\n            Defaults to 1000 frames. By setting this explicitly, you may\n            raise or lower the limit.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'crs_transform'.\n\n    \"\"\"\n    if not isinstance(collection, ee.ImageCollection):\n        raise TypeError(\"collection must be an ee.ImageCollection\")\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n        return\n\n    print(\n        f\"Exporting {description}... Please check the Task Manager from the JavaScript Code Editor.\"\n    )\n\n    task = ee.batch.Export.video.toCloudStorage(\n        collection,\n        description,\n        bucket,\n        fileNamePrefix,\n        framesPerSecond,\n        dimensions,\n        region,\n        scale,\n        crs,\n        crsTransform,\n        maxPixels,\n        maxFrames,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_export_video_to_dirve","title":"<code>ee_export_video_to_dirve(collection, description='myExportVideoTask', folder=None, fileNamePrefix=None, framesPerSecond=None, dimensions=None, region=None, scale=None, crs=None, crsTransform=None, maxPixels=None, maxFrames=None, **kwargs)</code>","text":"<p>Creates a task to export an ImageCollection as a video to Drive.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <p>The image collection to be exported. The collection must only contain RGB images.</p> required <code>description</code> <p>Human-readable name of the task.</p> <code>'myExportVideoTask'</code> <code>folder</code> <p>The name of a unique folder in your Drive account to export into. Defaults to the root of the drive.</p> <code>None</code> <code>fileNamePrefix</code> <p>The Google Drive filename for the export. Defaults to the name of the task.</p> <code>None</code> <code>framesPerSecond</code> <p>A number between .1 and 120 describing the framerate of the exported video.</p> <code>None</code> <code>dimensions</code> <p>The dimensions of the exported video. Takes either a single positive integer as the maximum dimension or \"WIDTHxHEIGHT\" where WIDTH and HEIGHT are each positive integers.</p> <code>None</code> <code>region</code> <p>The lon,lat coordinates for a LinearRing or Polygon specifying the region to export. Can be specified as a nested lists of numbers or a serialized string. Defaults to the first image's region.</p> <code>None</code> <code>scale</code> <p>The resolution in meters per pixel.</p> <code>None</code> <code>crs</code> <p>The coordinate reference system of the exported video's projection. Defaults to SR-ORG:6627.</p> <code>None</code> <code>crsTransform</code> <p>A comma-separated string of 6 numbers describing the affine transform of the coordinate reference system of the exported video's projection, in the order: xScale, xShearing, xTranslation, yShearing, yScale and yTranslation. Defaults to the image collection's native CRS transform.</p> <code>None</code> <code>maxPixels</code> <p>The maximum number of pixels per frame. Defaults to 1e8 pixels per frame. By setting this explicitly, you may raise or lower the limit.</p> <code>None</code> <code>maxFrames</code> <p>The maximum number of frames to export. Defaults to 1000 frames. By setting this explicitly, you may raise or lower the limit.</p> <code>None</code> <code>**kwargs</code> <p>Holds other keyword arguments that may have been deprecated such as 'crs_transform'.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_export_video_to_dirve(\n    collection,\n    description=\"myExportVideoTask\",\n    folder=None,\n    fileNamePrefix=None,\n    framesPerSecond=None,\n    dimensions=None,\n    region=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    maxPixels=None,\n    maxFrames=None,\n    **kwargs,\n):\n\"\"\"Creates a task to export an ImageCollection as a video to Drive.\n\n    Args:\n        collection: The image collection to be exported. The collection must\n            only contain RGB images.\n        description: Human-readable name of the task.\n        folder: The name of a unique folder in your Drive account to\n            export into. Defaults to the root of the drive.\n        fileNamePrefix: The Google Drive filename for the export.\n            Defaults to the name of the task.\n        framesPerSecond: A number between .1 and 120 describing the\n            framerate of the exported video.\n        dimensions: The dimensions of the exported video. Takes either a\n            single positive integer as the maximum dimension or \"WIDTHxHEIGHT\"\n            where WIDTH and HEIGHT are each positive integers.\n        region: The lon,lat coordinates for a LinearRing or Polygon\n            specifying the region to export. Can be specified as a nested\n            lists of numbers or a serialized string. Defaults to the first\n            image's region.\n        scale: The resolution in meters per pixel.\n        crs: The coordinate reference system of the exported video's\n            projection. Defaults to SR-ORG:6627.\n        crsTransform: A comma-separated string of 6 numbers describing\n            the affine transform of the coordinate reference system of the\n            exported video's projection, in the order: xScale, xShearing,\n            xTranslation, yShearing, yScale and yTranslation. Defaults to\n            the image collection's native CRS transform.\n        maxPixels: The maximum number of pixels per frame.\n            Defaults to 1e8 pixels per frame. By setting this explicitly,\n            you may raise or lower the limit.\n        maxFrames: The maximum number of frames to export.\n            Defaults to 1000 frames. By setting this explicitly, you may\n            raise or lower the limit.\n        **kwargs: Holds other keyword arguments that may have been deprecated\n            such as 'crs_transform'.\n\n    \"\"\"\n    if not isinstance(collection, ee.ImageCollection):\n        raise TypeError(\"collection must be an ee.ImageCollection\")\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:  # skip if running GitHub CI.\n        return\n\n    print(\n        f\"Exporting {description}... Please check the Task Manager from the JavaScript Code Editor.\"\n    )\n\n    task = ee.batch.Export.video.toDrive(\n        collection,\n        description,\n        folder,\n        fileNamePrefix,\n        framesPerSecond,\n        dimensions,\n        region,\n        scale,\n        crs,\n        crsTransform,\n        maxPixels,\n        maxFrames,\n        **kwargs,\n    )\n    task.start()\n</code></pre>"},{"location":"common/#geemap.common.ee_function_tree","title":"<code>ee_function_tree(name)</code>","text":"<p>Construct the tree structure based on an Earth Engine function. For example, the function \"ee.Algorithms.FMask.matchClouds\" will return a list [\"ee.Algorithms\", \"ee.Algorithms.FMask\", \"ee.Algorithms.FMask.matchClouds\"]</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Earth Engine function</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list for parent functions.</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_function_tree(name):\n\"\"\"Construct the tree structure based on an Earth Engine function. For example, the function \"ee.Algorithms.FMask.matchClouds\" will return a list [\"ee.Algorithms\", \"ee.Algorithms.FMask\", \"ee.Algorithms.FMask.matchClouds\"]\n\n    Args:\n        name (str): The name of the Earth Engine function\n\n    Returns:\n        list: The list for parent functions.\n    \"\"\"\n    func_list = []\n    try:\n        items = name.split(\".\")\n        if items[0] == \"ee\":\n            for i in range(2, len(items) + 1):\n                func_list.append(\".\".join(items[0:i]))\n        else:\n            for i in range(1, len(items) + 1):\n                func_list.append(\".\".join(items[0:i]))\n\n        return func_list\n    except Exception as e:\n        print(e)\n        print(\"The provided function name is invalid.\")\n</code></pre>"},{"location":"common/#geemap.common.ee_initialize","title":"<code>ee_initialize(token_name='EARTHENGINE_TOKEN', auth_mode='notebook', service_account=False)</code>","text":"<p>Authenticates Earth Engine and initialize an Earth Engine session</p> <p>Parameters:</p> Name Type Description Default <code>token_name</code> <code>str</code> <p>The name of the Earth Engine token. Defaults to \"EARTHENGINE_TOKEN\".</p> <code>'EARTHENGINE_TOKEN'</code> <code>auth_mode</code> <code>str</code> <p>The authentication mode, can be one of paste,notebook,gcloud,appdefault. Defaults to \"notebook\".</p> <code>'notebook'</code> <code>service_account</code> <code>bool</code> <p>If True, use a service account. Defaults to False.</p> <code>False</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_initialize(\n    token_name=\"EARTHENGINE_TOKEN\", auth_mode=\"notebook\", service_account=False\n):\n\"\"\"Authenticates Earth Engine and initialize an Earth Engine session\n\n    Args:\n        token_name (str, optional): The name of the Earth Engine token. Defaults to \"EARTHENGINE_TOKEN\".\n        auth_mode (str, optional): The authentication mode, can be one of paste,notebook,gcloud,appdefault. Defaults to \"notebook\".\n        service_account (bool, optional): If True, use a service account. Defaults to False.\n    \"\"\"\n    import httplib2\n    from .__init__ import __version__\n\n    user_agent = f\"geemap/{__version__}\"\n\n    if ee.data._credentials is None:\n        ee_token = os.environ.get(token_name)\n        if service_account:\n            try:\n                credential_file_path = os.path.expanduser(\n                    \"~/.config/earthengine/private-key.json\"\n                )\n\n                if os.path.exists(credential_file_path):\n                    with open(credential_file_path) as f:\n                        token_dict = json.load(f)\n                else:\n                    token_name = \"EARTHENGINE_TOKEN\"\n                    ee_token = os.environ.get(token_name)\n                    token_dict = json.loads(ee_token, strict=False)\n                service_account = token_dict[\"client_email\"]\n                private_key = token_dict[\"private_key\"]\n\n                credentials = ee.ServiceAccountCredentials(\n                    service_account, key_data=private_key\n                )\n                ee.Initialize(credentials)\n\n            except Exception as e:\n                raise Exception(e)\n\n        else:\n            try:\n                if ee_token is not None:\n                    credential_file_path = os.path.expanduser(\n                        \"~/.config/earthengine/credentials\"\n                    )\n                    if not os.path.exists(credential_file_path):\n                        os.makedirs(\n                            os.path.dirname(credential_file_path), exist_ok=True\n                        )\n                        if ee_token.startswith(\"{\") and ee_token.endswith(\n                            \"}\"\n                        ):  # deals with token generated by new auth method (earthengine-api&gt;=0.1.304).\n                            token_dict = json.loads(ee_token)\n                            with open(credential_file_path, \"w\") as f:\n                                f.write(json.dumps(token_dict))\n                        else:\n                            credential = (\n                                '{\"refresh_token\":\"%s\"}' % ee_token\n                            )  # deals with token generated by old auth method.\n                            with open(credential_file_path, \"w\") as f:\n                                f.write(credential)\n                elif in_colab_shell():\n                    if credentials_in_drive() and (not credentials_in_colab()):\n                        copy_credentials_to_colab()\n                    elif not credentials_in_colab:\n                        ee.Authenticate(auth_mode=auth_mode)\n                        if is_drive_mounted() and (not credentials_in_drive()):\n                            copy_credentials_to_drive()\n                    else:\n                        if is_drive_mounted():\n                            copy_credentials_to_drive()\n\n                ee.Initialize(http_transport=httplib2.Http())\n\n            except Exception:\n                ee.Authenticate(auth_mode=auth_mode)\n                ee.Initialize(http_transport=httplib2.Http())\n\n        ee.data.setUserAgent(user_agent)\n</code></pre>"},{"location":"common/#geemap.common.ee_join_table","title":"<code>ee_join_table(ee_object, data, src_key, dst_key=None)</code>","text":"<p>Join a table to an ee.FeatureCollection attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.FeatureCollection</code> <p>The ee.FeatureCollection to be joined by a table.</p> required <code>data</code> <code>str | pd.DataFraem | gpd.GeoDataFrame</code> <p>The table to join to the ee.FeatureCollection.</p> required <code>src_key</code> <code>str</code> <p>The key of ee.FeatureCollection attribute table to join.</p> required <code>dst_key</code> <code>str</code> <p>The key of the table to be joined to the ee.FeatureCollection. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>The joined ee.FeatureCollection.</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_join_table(ee_object, data, src_key, dst_key=None):\n\"\"\"Join a table to an ee.FeatureCollection attribute table.\n\n    Args:\n        ee_object (ee.FeatureCollection): The ee.FeatureCollection to be joined by a table.\n        data (str | pd.DataFraem | gpd.GeoDataFrame): The table to join to the ee.FeatureCollection.\n        src_key (str): The key of ee.FeatureCollection attribute table to join.\n        dst_key (str, optional): The key of the table to be joined to the ee.FeatureCollection. Defaults to None.\n\n    Returns:\n        ee.FeatureCollection: The joined ee.FeatureCollection.\n    \"\"\"\n    import pandas as pd\n\n    if not isinstance(ee_object, ee.FeatureCollection):\n        raise TypeError(\"The input ee_object must be of type ee.FeatureCollection.\")\n\n    if not isinstance(src_key, str):\n        raise TypeError(\"The input src_key must be of type str.\")\n\n    if dst_key is None:\n        dst_key = src_key\n\n    if isinstance(data, str):\n        data = github_raw_url(data)\n        if data.endswith(\".csv\"):\n            df = pd.read_csv(data)\n        elif data.endswith(\".geojson\"):\n            df = geojson_to_df(data)\n        else:\n            import geopandas as gpd\n\n            gdf = gpd.read_file(data)\n            df = gdf_to_df(gdf)\n    elif isinstance(data, pd.DataFrame):\n        if \"geometry\" in data.columns:\n            df = data.drop(columns=[\"geometry\"])\n        elif \"geom\" in data.columns:\n            df = data.drop(columns=[\"geom\"])\n        else:\n            df = data\n    else:\n        raise TypeError(\"The input data must be of type str or pandas.DataFrame.\")\n\n    df[dst_key] = df[dst_key].astype(str)\n    df.set_index(dst_key, inplace=True)\n    df = df[~df.index.duplicated(keep=\"first\")]\n    table = ee.Dictionary(df.to_dict(\"index\"))\n\n    fc = ee_object.map(lambda f: f.set(table.get(f.get(src_key), ee.Dictionary())))\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.ee_num_round","title":"<code>ee_num_round(num, decimal=2)</code>","text":"<p>Rounds a number to a specified number of decimal places.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>ee.Number</code> <p>The number to round.</p> required <code>decimal</code> <code>int</code> <p>The number of decimal places to round. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>ee.Number</code> <p>The number with the specified decimal places rounded.</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_num_round(num, decimal=2):\n\"\"\"Rounds a number to a specified number of decimal places.\n\n    Args:\n        num (ee.Number): The number to round.\n        decimal (int, optional): The number of decimal places to round. Defaults to 2.\n\n    Returns:\n        ee.Number: The number with the specified decimal places rounded.\n    \"\"\"\n    format_str = \"%.{}f\".format(decimal)\n    return ee.Number.parse(ee.Number(num).format(format_str))\n</code></pre>"},{"location":"common/#geemap.common.ee_search","title":"<code>ee_search(asset_limit=100)</code>","text":"<p>Search Earth Engine API and user assets. If you received a warning (IOPub message rate exceeded) in Jupyter notebook, you can relaunch Jupyter notebook using the following command:     jupyter notebook --NotebookApp.iopub_msg_rate_limit=10000</p> <p>Parameters:</p> Name Type Description Default <code>asset_limit</code> <code>int</code> <p>The number of assets to display for each asset type, i.e., Image, ImageCollection, and FeatureCollection. Defaults to 100.</p> <code>100</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_search(asset_limit=100):\n\"\"\"Search Earth Engine API and user assets. If you received a warning (IOPub message rate exceeded) in Jupyter notebook, you can relaunch Jupyter notebook using the following command:\n        jupyter notebook --NotebookApp.iopub_msg_rate_limit=10000\n\n    Args:\n        asset_limit (int, optional): The number of assets to display for each asset type, i.e., Image, ImageCollection, and FeatureCollection. Defaults to 100.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    class Flags:\n        def __init__(\n            self,\n            repos=None,\n            docs=None,\n            assets=None,\n            docs_dict=None,\n            asset_dict=None,\n            asset_import=None,\n        ):\n            self.repos = repos\n            self.docs = docs\n            self.assets = assets\n            self.docs_dict = docs_dict\n            self.asset_dict = asset_dict\n            self.asset_import = asset_import\n\n    flags = Flags()\n\n    search_type = widgets.ToggleButtons(\n        options=[\"Scripts\", \"Docs\", \"Assets\"],\n        tooltips=[\n            \"Search Earth Engine Scripts\",\n            \"Search Earth Engine API\",\n            \"Search Earth Engine Assets\",\n        ],\n        button_style=\"primary\",\n    )\n    search_type.style.button_width = \"100px\"\n\n    search_box = widgets.Text(placeholder=\"Filter scripts...\", value=\"Loading...\")\n    search_box.layout.width = \"310px\"\n\n    tree_widget = widgets.Output()\n\n    left_widget = widgets.VBox()\n    right_widget = widgets.VBox()\n    output_widget = widgets.Output()\n    output_widget.layout.max_width = \"650px\"\n\n    search_widget = widgets.HBox()\n    search_widget.children = [left_widget, right_widget]\n    display(search_widget)\n\n    repo_tree, repo_output, _ = build_repo_tree()\n    left_widget.children = [search_type, repo_tree]\n    right_widget.children = [repo_output]\n\n    flags.repos = repo_tree\n    search_box.value = \"\"\n\n    def search_type_changed(change):\n        search_box.value = \"\"\n\n        output_widget.clear_output()\n        tree_widget.clear_output()\n        if change[\"new\"] == \"Scripts\":\n            search_box.placeholder = \"Filter scripts...\"\n            left_widget.children = [search_type, repo_tree]\n            right_widget.children = [repo_output]\n        elif change[\"new\"] == \"Docs\":\n            search_box.placeholder = \"Filter methods...\"\n            search_box.value = \"Loading...\"\n            left_widget.children = [search_type, search_box, tree_widget]\n            right_widget.children = [output_widget]\n            if flags.docs is None:\n                api_dict = read_api_csv()\n                ee_api_tree, tree_dict = build_api_tree(api_dict, output_widget)\n                flags.docs = ee_api_tree\n                flags.docs_dict = tree_dict\n            else:\n                ee_api_tree = flags.docs\n            with tree_widget:\n                tree_widget.clear_output()\n                display(ee_api_tree)\n                right_widget.children = [output_widget]\n            search_box.value = \"\"\n        elif change[\"new\"] == \"Assets\":\n            search_box.placeholder = \"Filter assets...\"\n            left_widget.children = [search_type, search_box, tree_widget]\n            right_widget.children = [output_widget]\n            search_box.value = \"Loading...\"\n            if flags.assets is None:\n                asset_tree, asset_widget, asset_dict = build_asset_tree(\n                    limit=asset_limit\n                )\n                flags.assets = asset_tree\n                flags.asset_dict = asset_dict\n                flags.asset_import = asset_widget\n\n            with tree_widget:\n                tree_widget.clear_output()\n                display(flags.assets)\n            right_widget.children = [flags.asset_import]\n            search_box.value = \"\"\n\n    search_type.observe(search_type_changed, names=\"value\")\n\n    def search_box_callback(text):\n        if search_type.value == \"Docs\":\n            with tree_widget:\n                if text.value == \"\":\n                    print(\"Loading...\")\n                    tree_widget.clear_output(wait=True)\n                    display(flags.docs)\n                else:\n                    tree_widget.clear_output()\n                    print(\"Searching...\")\n                    tree_widget.clear_output(wait=True)\n                    sub_tree = search_api_tree(text.value, flags.docs_dict)\n                    display(sub_tree)\n        elif search_type.value == \"Assets\":\n            with tree_widget:\n                if text.value == \"\":\n                    print(\"Loading...\")\n                    tree_widget.clear_output(wait=True)\n                    display(flags.assets)\n                else:\n                    tree_widget.clear_output()\n                    print(\"Searching...\")\n                    tree_widget.clear_output(wait=True)\n                    sub_tree = search_api_tree(text.value, flags.asset_dict)\n                    display(sub_tree)\n\n    search_box.on_submit(search_box_callback)\n</code></pre>"},{"location":"common/#geemap.common.ee_to_bbox","title":"<code>ee_to_bbox(ee_object)</code>","text":"<p>Get the bounding box of an Earth Engine object as a list in the format [xmin, ymin, xmax, ymax].</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.Image | ee.Geometry | ee.Feature | ee.FeatureCollection</code> <p>The input Earth Engine object.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The bounding box of the Earth Engine object in the format [xmin, ymin, xmax, ymax].</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_bbox(ee_object):\n\"\"\"Get the bounding box of an Earth Engine object as a list in the format [xmin, ymin, xmax, ymax].\n\n    Args:\n        ee_object (ee.Image | ee.Geometry | ee.Feature | ee.FeatureCollection): The input Earth Engine object.\n\n    Returns:\n        list: The bounding box of the Earth Engine object in the format [xmin, ymin, xmax, ymax].\n    \"\"\"\n    if (\n        isinstance(ee_object, ee.Image)\n        or isinstance(ee_object, ee.Feature)\n        or isinstance(ee_object, ee.FeatureCollection)\n    ):\n        geometry = ee_object.geometry()\n    elif isinstance(ee_object, ee.Geometry):\n        geometry = ee_object\n    else:\n        raise Exception(\n            \"The ee_object must be an ee.Image, ee.Feature, ee.FeatureCollection or ee.Geometry object.\"\n        )\n\n    bounds = geometry.bounds().getInfo()[\"coordinates\"][0]\n    xmin = bounds[0][0]\n    ymin = bounds[0][1]\n    xmax = bounds[1][0]\n    ymax = bounds[2][1]\n    bbox = [xmin, ymin, xmax, ymax]\n    return bbox\n</code></pre>"},{"location":"common/#geemap.common.ee_to_csv","title":"<code>ee_to_csv(ee_object, filename, selectors=None, verbose=True, timeout=300, proxies=None)</code>","text":"<p>Downloads an ee.FeatureCollection as a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>ee.FeatureCollection</p> required <code>filename</code> <code>str</code> <p>The output filepath of the CSV file.</p> required <code>selectors</code> <code>list</code> <p>A list of attributes to export. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive text.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300 seconds.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>Proxy settings. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_csv(\n    ee_object, filename, selectors=None, verbose=True, timeout=300, proxies=None\n):\n\"\"\"Downloads an ee.FeatureCollection as a CSV file.\n\n    Args:\n        ee_object (object): ee.FeatureCollection\n        filename (str): The output filepath of the CSV file.\n        selectors (list, optional): A list of attributes to export. Defaults to None.\n        verbose (bool, optional): Whether to print out descriptive text.\n        timeout (int, optional): Timeout in seconds. Defaults to 300 seconds.\n        proxies (dict, optional): Proxy settings. Defaults to None.\n\n    \"\"\"\n    # ee_initialize()\n    try:\n        if filename.lower().endswith(\".csv\"):\n            ee_export_vector(\n                ee_object=ee_object,\n                filename=filename,\n                selectors=selectors,\n                verbose=verbose,\n                timeout=timeout,\n                proxies=proxies,\n            )\n        else:\n            print(\"The filename must end with .csv\")\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_to_df","title":"<code>ee_to_df(ee_object, col_names=None, sort_columns=False, **kwargs)</code>","text":"<p>Converts an ee.FeatureCollection to pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.FeatureCollection</code> <p>ee.FeatureCollection.</p> required <code>col_names</code> <code>list</code> <p>List of column names. Defaults to None.</p> <code>None</code> <code>sort_columns</code> <code>bool</code> <p>Whether to sort the column names. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>ee_object must be an ee.FeatureCollection</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pandas DataFrame</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_df(ee_object, col_names=None, sort_columns=False, **kwargs):\n\"\"\"Converts an ee.FeatureCollection to pandas dataframe.\n\n    Args:\n        ee_object (ee.FeatureCollection): ee.FeatureCollection.\n        col_names (list): List of column names. Defaults to None.\n        sort_columns (bool): Whether to sort the column names. Defaults to False.\n\n    Raises:\n        TypeError: ee_object must be an ee.FeatureCollection\n\n    Returns:\n        pd.DataFrame: pandas DataFrame\n    \"\"\"\n    import pandas as pd\n\n    if isinstance(ee_object, ee.Feature):\n        ee_object = ee.FeatureCollection([ee_object])\n\n    if not isinstance(ee_object, ee.FeatureCollection):\n        raise TypeError(\"ee_object must be an ee.FeatureCollection\")\n\n    try:\n        data = ee_object.map(lambda f: ee.Feature(None, f.toDictionary()))\n        data = [x[\"properties\"] for x in data.getInfo()[\"features\"]]\n        df = pd.DataFrame(data)\n\n        if col_names is None:\n            col_names = ee_object.first().propertyNames().getInfo()\n            col_names.remove(\"system:index\")\n        elif not isinstance(col_names, list):\n            raise TypeError(\"col_names must be a list\")\n\n        df = df[col_names]\n\n        if sort_columns:\n            df = df.reindex(sorted(df.columns), axis=1)\n\n        return df\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_to_gdf","title":"<code>ee_to_gdf(ee_object, selectors=None, verbose=False)</code>","text":"<p>Converts an ee.FeatureCollection to Geopandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.FeatureCollection</code> <p>ee.FeatureCollection.</p> required <code>selectors</code> <code>list</code> <p>A list of attributes to export. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive text. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>ee_object must be an ee.FeatureCollection.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_gdf(ee_object, selectors=None, verbose=False):\n\"\"\"Converts an ee.FeatureCollection to Geopandas dataframe.\n\n    Args:\n        ee_object (ee.FeatureCollection): ee.FeatureCollection.\n        selectors (list, optional): A list of attributes to export. Defaults to None.\n        verbose (bool, optional): Whether to print out descriptive text. Defaults to False.\n\n    Raises:\n        TypeError: ee_object must be an ee.FeatureCollection.\n\n    Returns:\n        gpd.GeoDataFrame: geopandas.GeoDataFrame\n    \"\"\"\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    if not isinstance(ee_object, ee.FeatureCollection):\n        raise TypeError(\"ee_object must be an ee.FeatureCollection\")\n\n    collection = ee_to_geojson(ee_object)\n    gdf = gpd.GeoDataFrame.from_features(collection[\"features\"])\n\n    return gdf\n</code></pre>"},{"location":"common/#geemap.common.ee_to_geojson","title":"<code>ee_to_geojson(ee_object, filename=None, indent=2, **kwargs)</code>","text":"<p>Converts Earth Engine object to geojson.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>An Earth Engine object.</p> required <code>filename</code> <code>str</code> <p>The file path to save the geojson. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>GeoJSON object.</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_geojson(ee_object, filename=None, indent=2, **kwargs):\n\"\"\"Converts Earth Engine object to geojson.\n\n    Args:\n        ee_object (object): An Earth Engine object.\n        filename (str, optional): The file path to save the geojson. Defaults to None.\n\n    Returns:\n        object: GeoJSON object.\n    \"\"\"\n    # from json import dumps\n\n    # ee_initialize()\n\n    try:\n        if (\n            isinstance(ee_object, ee.geometry.Geometry)\n            or isinstance(ee_object, ee.feature.Feature)\n            or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n        ):\n            json_object = ee_object.getInfo()\n            if filename is not None:\n                filename = os.path.abspath(filename)\n                if not os.path.exists(os.path.dirname(filename)):\n                    os.makedirs(os.path.dirname(filename))\n                with open(filename, \"w\") as geojson:\n                    geojson.write(\n                        json.dumps(json_object, indent=indent, **kwargs) + \"\\n\"\n                    )\n            else:\n                return json_object\n        else:\n            print(\"Could not convert the Earth Engine object to geojson\")\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_to_geopandas","title":"<code>ee_to_geopandas(ee_object, selectors=None, verbose=False)</code>","text":"<p>Converts an ee.FeatureCollection to Geopandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.FeatureCollection</code> <p>ee.FeatureCollection.</p> required <code>selectors</code> <code>list</code> <p>A list of attributes to export. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive text. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>ee_object must be an ee.FeatureCollection.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_gdf(ee_object, selectors=None, verbose=False):\n\"\"\"Converts an ee.FeatureCollection to Geopandas dataframe.\n\n    Args:\n        ee_object (ee.FeatureCollection): ee.FeatureCollection.\n        selectors (list, optional): A list of attributes to export. Defaults to None.\n        verbose (bool, optional): Whether to print out descriptive text. Defaults to False.\n\n    Raises:\n        TypeError: ee_object must be an ee.FeatureCollection.\n\n    Returns:\n        gpd.GeoDataFrame: geopandas.GeoDataFrame\n    \"\"\"\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    if not isinstance(ee_object, ee.FeatureCollection):\n        raise TypeError(\"ee_object must be an ee.FeatureCollection\")\n\n    collection = ee_to_geojson(ee_object)\n    gdf = gpd.GeoDataFrame.from_features(collection[\"features\"])\n\n    return gdf\n</code></pre>"},{"location":"common/#geemap.common.ee_to_geotiff","title":"<code>ee_to_geotiff(ee_object, output, bbox=None, vis_params={}, zoom=None, resolution=None, crs='EPSG:3857', to_cog=False, quiet=False, **kwargs)</code>","text":"<p>Downloads an Earth Engine object as GeoTIFF.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.Image | ee.FeatureCollection</code> <p>The Earth Engine object to download.</p> required <code>output</code> <code>str</code> <p>The output path for the GeoTIFF.</p> required <code>bbox</code> <code>str</code> <p>The bounding box in the format [xmin, ymin, xmax, ymax]. Defaults to None, which is the bounding box of the Earth Engine object.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters. Defaults to {}.</p> <code>{}</code> <code>zoom</code> <code>int</code> <p>The zoom level to download the image at. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>float</code> <p>The resolution in meters to download the image at. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS of the output image. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the image to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Whether to hide the download progress bar. Defaults to False.</p> <code>False</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_geotiff(\n    ee_object,\n    output,\n    bbox=None,\n    vis_params={},\n    zoom=None,\n    resolution=None,\n    crs=\"EPSG:3857\",\n    to_cog=False,\n    quiet=False,\n    **kwargs,\n):\n\"\"\"Downloads an Earth Engine object as GeoTIFF.\n\n    Args:\n        ee_object (ee.Image | ee.FeatureCollection): The Earth Engine object to download.\n        output (str): The output path for the GeoTIFF.\n        bbox (str, optional): The bounding box in the format [xmin, ymin, xmax, ymax]. Defaults to None,\n            which is the bounding box of the Earth Engine object.\n        vis_params (dict, optional): Visualization parameters. Defaults to {}.\n        zoom (int, optional): The zoom level to download the image at. Defaults to None.\n        resolution (float, optional): The resolution in meters to download the image at. Defaults to None.\n        crs (str, optional): The CRS of the output image. Defaults to \"EPSG:3857\".\n        to_cog (bool, optional): Whether to convert the image to Cloud Optimized GeoTIFF. Defaults to False.\n        quiet (bool, optional): Whether to hide the download progress bar. Defaults to False.\n\n    \"\"\"\n\n    from box import Box\n\n    image = None\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n    url = map_id_dict[\"tile_fetcher\"].url_format\n\n    if bbox is None:\n        bbox = ee_to_bbox(image)\n\n    if zoom is None and resolution is None:\n        raise ValueError(\"Either zoom level or resolution must be specified.\")\n\n    tms_to_geotiff(output, bbox, zoom, resolution, url, crs, to_cog, quiet, **kwargs)\n</code></pre>"},{"location":"common/#geemap.common.ee_to_numpy","title":"<code>ee_to_numpy(ee_object, bands=None, region=None, properties=None, default_value=None)</code>","text":"<p>Extracts a rectangular region of pixels from an image into a 2D numpy array per band.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>The image to sample.</p> required <code>bands</code> <code>list</code> <p>The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None.</p> <code>None</code> <code>region</code> <code>object</code> <p>The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band.</p> <code>None</code> <code>properties</code> <code>list</code> <p>The properties to copy over from the sampled image. Defaults to all non-system properties.</p> <code>None</code> <code>default_value</code> <code>float</code> <p>A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>array</code> <p>A 3D numpy array.</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_numpy(\n    ee_object, bands=None, region=None, properties=None, default_value=None\n):\n\"\"\"Extracts a rectangular region of pixels from an image into a 2D numpy array per band.\n\n    Args:\n        ee_object (object): The image to sample.\n        bands (list, optional): The list of band names to extract. Please make sure that all bands have the same spatial resolution. Defaults to None.\n        region (object, optional): The region whose projected bounding box is used to sample the image. The maximum number of pixels you can export is 262,144. Resampling and reprojecting all bands to a fixed scale can be useful. Defaults to the footprint in each band.\n        properties (list, optional): The properties to copy over from the sampled image. Defaults to all non-system properties.\n        default_value (float, optional): A default value used when a sampled pixel is masked or outside a band's footprint. Defaults to None.\n\n    Returns:\n        array: A 3D numpy array.\n    \"\"\"\n    import numpy as np\n\n    if not isinstance(ee_object, ee.Image):\n        print(\"The input must be an ee.Image.\")\n        return\n\n    if region is None:\n        region = ee_object.geometry()\n\n    try:\n        if bands is not None:\n            ee_object = ee_object.select(bands)\n        else:\n            bands = ee_object.bandNames().getInfo()\n\n        band_arrs = ee_object.sampleRectangle(\n            region=region, properties=properties, defaultValue=default_value\n        )\n        band_values = []\n\n        for band in bands:\n            band_arr = band_arrs.get(band).getInfo()\n            band_value = np.array(band_arr)\n            band_values.append(band_value)\n\n        image = np.dstack(band_values)\n        return image\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_to_pandas","title":"<code>ee_to_pandas(ee_object, col_names=None, sort_columns=False, **kwargs)</code>","text":"<p>Converts an ee.FeatureCollection to pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.FeatureCollection</code> <p>ee.FeatureCollection.</p> required <code>col_names</code> <code>list</code> <p>List of column names. Defaults to None.</p> <code>None</code> <code>sort_columns</code> <code>bool</code> <p>Whether to sort the column names. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>ee_object must be an ee.FeatureCollection</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pandas DataFrame</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_df(ee_object, col_names=None, sort_columns=False, **kwargs):\n\"\"\"Converts an ee.FeatureCollection to pandas dataframe.\n\n    Args:\n        ee_object (ee.FeatureCollection): ee.FeatureCollection.\n        col_names (list): List of column names. Defaults to None.\n        sort_columns (bool): Whether to sort the column names. Defaults to False.\n\n    Raises:\n        TypeError: ee_object must be an ee.FeatureCollection\n\n    Returns:\n        pd.DataFrame: pandas DataFrame\n    \"\"\"\n    import pandas as pd\n\n    if isinstance(ee_object, ee.Feature):\n        ee_object = ee.FeatureCollection([ee_object])\n\n    if not isinstance(ee_object, ee.FeatureCollection):\n        raise TypeError(\"ee_object must be an ee.FeatureCollection\")\n\n    try:\n        data = ee_object.map(lambda f: ee.Feature(None, f.toDictionary()))\n        data = [x[\"properties\"] for x in data.getInfo()[\"features\"]]\n        df = pd.DataFrame(data)\n\n        if col_names is None:\n            col_names = ee_object.first().propertyNames().getInfo()\n            col_names.remove(\"system:index\")\n        elif not isinstance(col_names, list):\n            raise TypeError(\"col_names must be a list\")\n\n        df = df[col_names]\n\n        if sort_columns:\n            df = df.reindex(sorted(df.columns), axis=1)\n\n        return df\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_to_shp","title":"<code>ee_to_shp(ee_object, filename, selectors=None, verbose=True, keep_zip=False, timeout=300, proxies=None)</code>","text":"<p>Downloads an ee.FeatureCollection as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>ee.FeatureCollection</p> required <code>filename</code> <code>str</code> <p>The output filepath of the shapefile.</p> required <code>selectors</code> <code>list</code> <p>A list of attributes to export. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive text.</p> <code>True</code> <code>keep_zip</code> <code>bool</code> <p>Whether to keep the downloaded shapefile as a zip file.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300 seconds.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>Proxy settings. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def ee_to_shp(\n    ee_object,\n    filename,\n    selectors=None,\n    verbose=True,\n    keep_zip=False,\n    timeout=300,\n    proxies=None,\n):\n\"\"\"Downloads an ee.FeatureCollection as a shapefile.\n\n    Args:\n        ee_object (object): ee.FeatureCollection\n        filename (str): The output filepath of the shapefile.\n        selectors (list, optional): A list of attributes to export. Defaults to None.\n        verbose (bool, optional): Whether to print out descriptive text.\n        keep_zip (bool, optional): Whether to keep the downloaded shapefile as a zip file.\n        timeout (int, optional): Timeout in seconds. Defaults to 300 seconds.\n        proxies (dict, optional): Proxy settings. Defaults to None.\n    \"\"\"\n    # ee_initialize()\n    try:\n        if filename.lower().endswith(\".shp\"):\n            ee_export_vector(\n                ee_object=ee_object,\n                filename=filename,\n                selectors=selectors,\n                verbose=verbose,\n                keep_zip=keep_zip,\n                timeout=timeout,\n                proxies=proxies,\n            )\n        else:\n            print(\"The filename must end with .shp\")\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.ee_user_id","title":"<code>ee_user_id()</code>","text":"<p>Gets Earth Engine account user id.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the user id.</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_user_id():\n\"\"\"Gets Earth Engine account user id.\n\n    Returns:\n        str: A string containing the user id.\n    \"\"\"\n    # ee_initialize()\n    roots = ee.data.getAssetRoots()\n    if len(roots) == 0:\n        return None\n    else:\n        root = ee.data.getAssetRoots()[0]\n        user_id = root[\"id\"].replace(\"projects/earthengine-legacy/assets/\", \"\")\n        return user_id\n</code></pre>"},{"location":"common/#geemap.common.ee_vector_style","title":"<code>ee_vector_style(collection, column, labels=None, color='black', pointSize=3, pointShape='circle', width=2, fillColor=None, lineType='solid', neighborhood=5, return_fc=False)</code>","text":"<p>Create a vector style for a feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>ee.FeatureCollection</code> <p>The input feature collection.</p> required <code>column</code> <code>str</code> <p>The name of the column to use for styling.</p> required <code>labels</code> <code>list</code> <p>A list of labels to use for styling. Defaults to None.</p> <code>None</code> <code>color</code> <code>str | list</code> <p>A default color (CSS 3.0 color value e.g. 'FF0000' or 'red') to use for drawing the features. Supports opacity (e.g.: 'FF000088' for 50% transparent red). Defaults to \"black\".</p> <code>'black'</code> <code>pointSize</code> <code>int | list</code> <p>The default size in pixels of the point markers. Defaults to 3.</p> <code>3</code> <code>pointShape</code> <code>str | list</code> <p>The default shape of the marker to draw at each point location. One of: circle, square, diamond, cross, plus, pentagram, hexagram, triangle, triangle_up, triangle_down, triangle_left, triangle_right, pentagon, hexagon, star5, star6. This argument also supports the following Matlab marker abbreviations: o, s, d, x, +, p, h, ^, v, &lt;, &gt;. Defaults to \"circle\".</p> <code>'circle'</code> <code>width</code> <code>int | list</code> <p>The default line width for lines and outlines for polygons and point shapes. Defaults to 2.</p> <code>2</code> <code>fillColor</code> <code>str | list</code> <p>The color for filling polygons and point shapes. Defaults to 'color' at 0.66 opacity. Defaults to None.</p> <code>None</code> <code>lineType</code> <code>str | list</code> <p>The default line style for lines and outlines of polygons and point shapes. Defaults to 'solid'. One of: solid, dotted, dashed. Defaults to \"solid\".</p> <code>'solid'</code> <code>neighborhood</code> <code>int</code> <p>If styleProperty is used and any feature has a pointSize or width larger than the defaults, tiling artifacts can occur. Specifies the maximum neighborhood (pointSize + width) needed for any feature. Defaults to 5.</p> <code>5</code> <code>return_fc</code> <code>bool</code> <p>If True, return an ee.FeatureCollection with a style property. Otherwise, return a styled ee.Image. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ee.FeatureCollection | ee.Image</code> <p>The styled Earth Engine FeatureCollection or Image.</p> Source code in <code>geemap/common.py</code> <pre><code>def ee_vector_style(\n    collection,\n    column,\n    labels=None,\n    color=\"black\",\n    pointSize=3,\n    pointShape=\"circle\",\n    width=2,\n    fillColor=None,\n    lineType=\"solid\",\n    neighborhood=5,\n    return_fc=False,\n):\n\"\"\"Create a vector style for a feature collection.\n\n    Args:\n        collection (ee.FeatureCollection): The input feature collection.\n        column (str): The name of the column to use for styling.\n        labels (list, optional): A list of labels to use for styling. Defaults to None.\n        color (str | list, optional): A default color (CSS 3.0 color value e.g. 'FF0000' or 'red') to use for drawing the features. Supports opacity (e.g.: 'FF000088' for 50% transparent red). Defaults to \"black\".\n        pointSize (int | list, optional): The default size in pixels of the point markers. Defaults to 3.\n        pointShape (str | list, optional): The default shape of the marker to draw at each point location. One of: circle, square, diamond, cross, plus, pentagram, hexagram, triangle, triangle_up, triangle_down, triangle_left, triangle_right, pentagon, hexagon, star5, star6. This argument also supports the following Matlab marker abbreviations: o, s, d, x, +, p, h, ^, v, &lt;, &gt;. Defaults to \"circle\".\n        width (int | list, optional): The default line width for lines and outlines for polygons and point shapes. Defaults to 2.\n        fillColor (str | list, optional): The color for filling polygons and point shapes. Defaults to 'color' at 0.66 opacity. Defaults to None.\n        lineType (str | list, optional): The default line style for lines and outlines of polygons and point shapes. Defaults to 'solid'. One of: solid, dotted, dashed. Defaults to \"solid\".\n        neighborhood (int, optional): If styleProperty is used and any feature has a pointSize or width larger than the defaults, tiling artifacts can occur. Specifies the maximum neighborhood (pointSize + width) needed for any feature. Defaults to 5.\n        return_fc (bool, optional): If True, return an ee.FeatureCollection with a style property. Otherwise, return a styled ee.Image. Defaults to False.\n\n    Returns:\n        ee.FeatureCollection | ee.Image: The styled Earth Engine FeatureCollection or Image.\n    \"\"\"\n    if not isinstance(collection, ee.FeatureCollection):\n        raise ValueError(\"collection must be an ee.FeatureCollection.\")\n\n    if not isinstance(column, str):\n        raise ValueError(\"column must be a string.\")\n\n    prop_names = ee.Feature(collection.first()).propertyNames().getInfo()\n    if column not in prop_names:\n        raise ValueError(\n            f\"{column} is not a property name of the collection. It must be one of {','.join(prop_names)}.\"\n        )\n\n    if labels is None:\n        labels = collection.aggregate_array(column).distinct().sort().getInfo()\n    elif isinstance(labels, list):\n        collection = collection.filter(ee.Filter.inList(column, labels))\n    elif not isinstance(labels, list):\n        raise ValueError(\"labels must be a list.\")\n\n    size = len(labels)\n    if isinstance(color, str):\n        color = [color] * size\n    elif size != len(color):\n        raise ValueError(\"labels and color must be the same length.\")\n    elif not isinstance(color, list):\n        raise ValueError(\"color must be a string or a list.\")\n\n    if isinstance(pointSize, int):\n        pointSize = [pointSize] * size\n    elif not isinstance(pointSize, list):\n        raise ValueError(\"pointSize must be an integer or a list.\")\n\n    if isinstance(pointShape, str):\n        pointShape = [pointShape] * size\n    elif not isinstance(pointShape, list):\n        raise ValueError(\"pointShape must be a string or a list.\")\n\n    if isinstance(width, int):\n        width = [width] * size\n    elif not isinstance(width, list):\n        raise ValueError(\"width must be an integer or a list.\")\n\n    if fillColor is None:\n        fillColor = color\n    elif isinstance(fillColor, str):\n        fillColor = [fillColor] * size\n    elif not isinstance(fillColor, list):\n        raise ValueError(\"fillColor must be a list.\")\n\n    if not isinstance(neighborhood, int):\n        raise ValueError(\"neighborhood must be an integer.\")\n\n    if isinstance(lineType, str):\n        lineType = [lineType] * size\n    elif not isinstance(lineType, list):\n        raise ValueError(\"lineType must be a string or list.\")\n\n    style_dict = {}\n\n    for i, label in enumerate(labels):\n        style_dict[label] = {\n            \"color\": color[i],\n            \"pointSize\": pointSize[i],\n            \"pointShape\": pointShape[i],\n            \"width\": width[i],\n            \"fillColor\": fillColor[i],\n            \"lineType\": lineType[i],\n        }\n\n    style = ee.Dictionary(style_dict)\n\n    result = collection.map(lambda f: f.set(\"style\", style.get(f.get(column))))\n\n    if return_fc:\n        return result\n    else:\n        return result.style(**{\"styleProperty\": \"style\", \"neighborhood\": neighborhood})\n</code></pre>"},{"location":"common/#geemap.common.explode","title":"<code>explode(coords)</code>","text":"<p>Explode a GeoJSON geometry's coordinates object and yield coordinate tuples. As long as the input is conforming, the type of the geometry doesn't matter.  From Fiona 1.4.8</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of coordinates.</p> required <p>Yields:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>geemap/common.py</code> <pre><code>def explode(coords):\n\"\"\"Explode a GeoJSON geometry's coordinates object and yield\n    coordinate tuples. As long as the input is conforming, the type of\n    the geometry doesn't matter.  From Fiona 1.4.8\n\n    Args:\n        coords (list): A list of coordinates.\n\n    Yields:\n        [type]: [description]\n    \"\"\"\n\n    for e in coords:\n        if isinstance(e, (float, int)):\n            yield coords\n            break\n        else:\n            for f in explode(e):\n                yield f\n</code></pre>"},{"location":"common/#geemap.common.extract_pixel_values","title":"<code>extract_pixel_values(ee_object, region, scale=None, projection=None, tileScale=1, getInfo=False)</code>","text":"<p>Samples the pixels of an image, returning them as a ee.Dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.Image | ee.ImageCollection</code> <p>The ee.Image or ee.ImageCollection to sample.</p> required <code>region</code> <code>ee.Geometry</code> <p>The region to sample from. If unspecified, uses the image's whole footprint.</p> required <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to sample in. Defaults to None.</p> <code>None</code> <code>projection</code> <code>str</code> <p>The projection in which to sample. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.</p> <code>None</code> <code>tileScale</code> <code>int</code> <p>A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.</p> <code>1</code> <code>getInfo</code> <code>bool</code> <p>Whether to use getInfo with the results, i.e., returning the values a list. Default to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>The image must be an instance of ee.Image.</p> <code>TypeError</code> <p>Region must be an instance of ee.Geometry.</p> <p>Returns:</p> Type Description <code>ee.Dictionary</code> <p>The dictionary containing band names and pixel values.</p> Source code in <code>geemap/common.py</code> <pre><code>def extract_pixel_values(\n    ee_object, region, scale=None, projection=None, tileScale=1, getInfo=False\n):\n\"\"\"Samples the pixels of an image, returning them as a ee.Dictionary.\n\n    Args:\n        ee_object (ee.Image | ee.ImageCollection): The ee.Image or ee.ImageCollection to sample.\n        region (ee.Geometry): The region to sample from. If unspecified, uses the image's whole footprint.\n        scale (float, optional): A nominal scale in meters of the projection to sample in. Defaults to None.\n        projection (str, optional): The projection in which to sample. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.\n        tileScale (int, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.\n        getInfo (bool, optional): Whether to use getInfo with the results, i.e., returning the values a list. Default to False.\n\n    Raises:\n        TypeError: The image must be an instance of ee.Image.\n        TypeError: Region must be an instance of ee.Geometry.\n\n    Returns:\n        ee.Dictionary: The dictionary containing band names and pixel values.\n    \"\"\"\n    if isinstance(ee_object, ee.ImageCollection):\n        ee_object = ee_object.toBands()\n\n    if not isinstance(ee_object, ee.Image):\n        raise TypeError(\"The image must be an instance of ee.Image.\")\n\n    if not isinstance(region, ee.Geometry):\n        raise TypeError(\"Region must be an instance of ee.Geometry.\")\n\n    dict_values = (\n        ee_object.sample(region, scale, projection, tileScale=tileScale)\n        .first()\n        .toDictionary()\n    )\n\n    if getInfo:\n        band_names = ee_object.bandNames().getInfo()\n        values_tmp = dict_values.getInfo()\n        values = [values_tmp[i] for i in band_names]\n        return dict(zip(band_names, values))\n    else:\n        return dict_values\n</code></pre>"},{"location":"common/#geemap.common.extract_transect","title":"<code>extract_transect(image, line, reducer='mean', n_segments=100, dist_interval=None, scale=None, crs=None, crsTransform=None, tileScale=1.0, to_pandas=False, **kwargs)</code>","text":"<p>Extracts transect from an image. Credits to Gena for providing the JavaScript example https://code.earthengine.google.com/b09759b8ac60366ee2ae4eccdd19e615.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The image to extract transect from.</p> required <code>line</code> <code>ee.Geometry.LineString</code> <p>The LineString used to extract transect from an image.</p> required <code>reducer</code> <code>str</code> <p>The ee.Reducer to use, e.g., 'mean', 'median', 'min', 'max', 'stdDev'. Defaults to \"mean\".</p> <code>'mean'</code> <code>n_segments</code> <code>int</code> <p>The number of segments that the LineString will be split into. Defaults to 100.</p> <code>100</code> <code>dist_interval</code> <code>float</code> <p>The distance interval used for splitting the LineString. If specified, the n_segments parameter will be ignored. Defaults to None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>crs</code> <code>ee.Projection</code> <p>The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.</p> <code>None</code> <code>crsTransform</code> <code>list</code> <p>The list of CRS transform values. This is a row-major ordering of the 3x2 transform matrix. This option is mutually exclusive with 'scale', and will replace any transform already set on the projection. Defaults to None.</p> <code>None</code> <code>tileScale</code> <code>float</code> <p>A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.</p> <code>1.0</code> <code>to_pandas</code> <code>bool</code> <p>Whether to convert the result to a pandas dataframe. Default to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the geometry type is not LineString.</p> <code>Exception</code> <p>If the program fails to compute.</p> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>The FeatureCollection containing the transect with distance and reducer values.</p> Source code in <code>geemap/common.py</code> <pre><code>def extract_transect(\n    image,\n    line,\n    reducer=\"mean\",\n    n_segments=100,\n    dist_interval=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    tileScale=1.0,\n    to_pandas=False,\n    **kwargs,\n):\n\"\"\"Extracts transect from an image. Credits to Gena for providing the JavaScript example https://code.earthengine.google.com/b09759b8ac60366ee2ae4eccdd19e615.\n\n    Args:\n        image (ee.Image): The image to extract transect from.\n        line (ee.Geometry.LineString): The LineString used to extract transect from an image.\n        reducer (str, optional): The ee.Reducer to use, e.g., 'mean', 'median', 'min', 'max', 'stdDev'. Defaults to \"mean\".\n        n_segments (int, optional): The number of segments that the LineString will be split into. Defaults to 100.\n        dist_interval (float, optional): The distance interval used for splitting the LineString. If specified, the n_segments parameter will be ignored. Defaults to None.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        crs (ee.Projection, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.\n        crsTransform (list, optional): The list of CRS transform values. This is a row-major ordering of the 3x2 transform matrix. This option is mutually exclusive with 'scale', and will replace any transform already set on the projection. Defaults to None.\n        tileScale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.\n        to_pandas (bool, optional): Whether to convert the result to a pandas dataframe. Default to False.\n\n    Raises:\n        TypeError: If the geometry type is not LineString.\n        Exception: If the program fails to compute.\n\n    Returns:\n        ee.FeatureCollection: The FeatureCollection containing the transect with distance and reducer values.\n    \"\"\"\n    try:\n        geom_type = line.type().getInfo()\n        if geom_type != \"LineString\":\n            raise TypeError(\"The geometry type must be LineString.\")\n\n        reducer = eval(\"ee.Reducer.\" + reducer + \"()\")\n        maxError = image.projection().nominalScale().divide(5)\n\n        length = line.length(maxError)\n        if dist_interval is None:\n            dist_interval = length.divide(n_segments)\n\n        distances = ee.List.sequence(0, length, dist_interval)\n        lines = line.cutLines(distances, maxError).geometries()\n\n        def set_dist_attr(l):\n            l = ee.List(l)\n            geom = ee.Geometry(l.get(0))\n            distance = ee.Number(l.get(1))\n            geom = ee.Geometry.LineString(geom.coordinates())\n            return ee.Feature(geom, {\"distance\": distance})\n\n        lines = lines.zip(distances).map(set_dist_attr)\n        lines = ee.FeatureCollection(lines)\n\n        transect = image.reduceRegions(\n            **{\n                \"collection\": ee.FeatureCollection(lines),\n                \"reducer\": reducer,\n                \"scale\": scale,\n                \"crs\": crs,\n                \"crsTransform\": crsTransform,\n                \"tileScale\": tileScale,\n            }\n        )\n\n        if to_pandas:\n            return ee_to_df(transect)\n        return transect\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.extract_values_to_points","title":"<code>extract_values_to_points(in_fc, image, out_fc=None, scale=None, crs=None, crsTransform=None, tileScale=1, stats_type='FIRST', timeout=300, proxies=None, **kwargs)</code>","text":"<p>Extracts image values to points.</p> <p>Parameters:</p> Name Type Description Default <code>in_fc</code> <code>object</code> <p>ee.FeatureCollection.</p> required <code>image</code> <code>object</code> <p>The ee.Image to extract pixel values.</p> required <code>out_fc</code> <code>object</code> <p>The output feature collection. Defaults to None.</p> <code>None</code> <code>scale</code> <code>ee.Projectoin</code> <p>A nominal scale in meters of the projection to sample in. If unspecified,the scale of the image's first band is used.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.</p> <code>None</code> <code>crsTransform</code> <code>list</code> <p>The list of CRS transform values. This is a row-major ordering of the 3x2 transform matrix. This option is mutually exclusive with 'scale', and will replace any transform already set on the projection.</p> <code>None</code> <code>tile_scale</code> <code>float</code> <p>A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default.</p> required <code>stats_type</code> <code>str</code> <p>Statistic type to be calculated. Defaults to 'FIRST'.</p> <code>'FIRST'</code> <code>timeout</code> <code>int</code> <p>The number of seconds after which the request will be terminated. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxy servers to use for each request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def extract_values_to_points(\n    in_fc,\n    image,\n    out_fc=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    tileScale=1,\n    stats_type=\"FIRST\",\n    timeout=300,\n    proxies=None,\n    **kwargs,\n):\n\"\"\"Extracts image values to points.\n\n    Args:\n        in_fc (object): ee.FeatureCollection.\n        image (object): The ee.Image to extract pixel values.\n        out_fc (object, optional): The output feature collection. Defaults to None.\n        scale (ee.Projectoin, optional): A nominal scale in meters of the projection to sample in. If unspecified,the scale of the image's first band is used.\n        crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.\n        crsTransform (list, optional): The list of CRS transform values. This is a row-major ordering of the 3x2 transform matrix. This option is mutually exclusive with 'scale', and will replace any transform already set on the projection.\n        tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default.\n        stats_type (str, optional): Statistic type to be calculated. Defaults to 'FIRST'.\n        timeout (int, optional): The number of seconds after which the request will be terminated. Defaults to 300.\n        proxies (dict, optional): A dictionary of proxy servers to use for each request. Defaults to None.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n\n    if \"tile_scale\" in kwargs:\n        tileScale = kwargs[\"tile_scale\"]\n    if \"crs_transform\" in kwargs:\n        crsTransform = kwargs[\"crs_transform\"]\n\n    allowed_stats = {\n        \"FIRST\": ee.Reducer.first(),\n        \"MEAN\": ee.Reducer.mean(),\n        \"MAXIMUM\": ee.Reducer.max(),\n        \"MEDIAN\": ee.Reducer.median(),\n        \"MINIMUM\": ee.Reducer.min(),\n        \"STD\": ee.Reducer.stdDev(),\n        \"MIN_MAX\": ee.Reducer.minMax(),\n        \"SUM\": ee.Reducer.sum(),\n        \"VARIANCE\": ee.Reducer.variance(),\n    }\n\n    if stats_type.upper() not in allowed_stats:\n        raise ValueError(\n            f\"The statistics_type must be one of the following {', '.join(allowed_stats.keys())}\"\n        )\n\n    if not isinstance(in_fc, ee.FeatureCollection):\n        try:\n            in_fc = shp_to_ee(in_fc)\n        except Exception as e:\n            print(e)\n            return\n\n    if not isinstance(image, ee.Image):\n        print(\"The image must be an instance of ee.Image.\")\n        return\n\n    result = image.reduceRegions(\n        collection=in_fc,\n        reducer=allowed_stats[stats_type.upper()],\n        scale=scale,\n        crs=crs,\n        crsTransform=crsTransform,\n        tileScale=tileScale,\n    )\n\n    if out_fc is not None:\n        ee_export_vector(result, out_fc, timeout=timeout, proxies=proxies)\n    else:\n        return result\n</code></pre>"},{"location":"common/#geemap.common.file_browser","title":"<code>file_browser(in_dir=None, show_hidden=False, add_root_node=True, search_description=None, use_import=False, return_sep_widgets=False, node_icon='file')</code>","text":"<p>Creates a simple file browser and text editor.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>The input directory. Defaults to None, which will use the current working directory.</p> <code>None</code> <code>show_hidden</code> <code>bool</code> <p>Whether to show hidden files/folders. Defaults to False.</p> <code>False</code> <code>add_root_node</code> <code>bool</code> <p>Whether to add the input directory as a root node. Defaults to True.</p> <code>True</code> <code>search_description</code> <code>str</code> <p>The description of the search box. Defaults to None.</p> <code>None</code> <code>use_import</code> <code>bool</code> <p>Whether to show the import button. Defaults to False.</p> <code>False</code> <code>return_sep_widgets</code> <code>bool</code> <p>Whether to return the results as separate widgets. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>object</code> <p>An ipywidget.</p> Source code in <code>geemap/common.py</code> <pre><code>def file_browser(\n    in_dir=None,\n    show_hidden=False,\n    add_root_node=True,\n    search_description=None,\n    use_import=False,\n    return_sep_widgets=False,\n    node_icon=\"file\",\n):\n\"\"\"Creates a simple file browser and text editor.\n\n    Args:\n        in_dir (str, optional): The input directory. Defaults to None, which will use the current working directory.\n        show_hidden (bool, optional): Whether to show hidden files/folders. Defaults to False.\n        add_root_node (bool, optional): Whether to add the input directory as a root node. Defaults to True.\n        search_description (str, optional): The description of the search box. Defaults to None.\n        use_import (bool, optional): Whether to show the import button. Defaults to False.\n        return_sep_widgets (bool, optional): Whether to return the results as separate widgets. Defaults to False.\n\n    Returns:\n        object: An ipywidget.\n    \"\"\"\n    import platform\n\n    if in_dir is None:\n        in_dir = os.getcwd()\n\n    if not os.path.exists(in_dir):\n        print(\"The provided directory does not exist.\")\n        return\n    elif not os.path.isdir(in_dir):\n        print(\"The provided path is not a valid directory.\")\n        return\n\n    sep = \"/\"\n    if platform.system() == \"Windows\":\n        sep = \"\\\\\"\n\n    if in_dir.endswith(sep):\n        in_dir = in_dir[:-1]\n\n    full_widget = widgets.HBox()\n    left_widget = widgets.VBox()\n\n    right_widget = widgets.VBox()\n\n    import_btn = widgets.Button(\n        description=\"import\",\n        button_style=\"primary\",\n        tooltip=\"import the content to a new cell\",\n        disabled=True,\n    )\n    import_btn.layout.width = \"70px\"\n    path_widget = widgets.Text()\n    path_widget.layout.min_width = \"400px\"\n    # path_widget.layout.max_width = '400px'\n    save_widget = widgets.Button(\n        description=\"Save\",\n        button_style=\"primary\",\n        tooltip=\"Save edits to file.\",\n        disabled=True,\n    )\n    info_widget = widgets.HBox()\n    info_widget.children = [path_widget, save_widget]\n    if use_import:\n        info_widget.children = [import_btn, path_widget, save_widget]\n\n    text_widget = widgets.Textarea()\n    text_widget.layout.width = \"630px\"\n    text_widget.layout.height = \"600px\"\n\n    right_widget.children = [info_widget, text_widget]\n    full_widget.children = [left_widget]\n\n    if search_description is None:\n        search_description = \"Search files/folders...\"\n    search_box = widgets.Text(placeholder=search_description)\n    search_box.layout.width = \"310px\"\n    tree_widget = widgets.Output()\n    tree_widget.layout.max_width = \"310px\"\n    tree_widget.overflow = \"auto\"\n\n    left_widget.children = [search_box, tree_widget]\n\n    tree = Tree(multiple_selection=False)\n    tree_dict = {}\n\n    def on_button_clicked(b):\n        content = text_widget.value\n        out_file = path_widget.value\n\n        out_dir = os.path.dirname(out_file)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        with open(out_file, \"w\") as f:\n            f.write(content)\n\n        text_widget.disabled = True\n        text_widget.value = \"The content has been saved successfully.\"\n        save_widget.disabled = True\n        path_widget.disabled = True\n\n        if (out_file not in tree_dict.keys()) and (out_dir in tree_dict.keys()):\n            node = Node(os.path.basename(out_file))\n            tree_dict[out_file] = node\n            parent_node = tree_dict[out_dir]\n            parent_node.add_node(node)\n\n    save_widget.on_click(on_button_clicked)\n\n    def import_btn_clicked(b):\n        if (text_widget.value != \"\") and (path_widget.value.endswith(\".py\")):\n            create_code_cell(text_widget.value)\n\n    import_btn.on_click(import_btn_clicked)\n\n    def search_box_callback(text):\n        with tree_widget:\n            if text.value == \"\":\n                print(\"Loading...\")\n                tree_widget.clear_output(wait=True)\n                display(tree)\n            else:\n                tree_widget.clear_output()\n                print(\"Searching...\")\n                tree_widget.clear_output(wait=True)\n                sub_tree = search_api_tree(text.value, tree_dict)\n                display(sub_tree)\n\n    search_box.on_submit(search_box_callback)\n\n    def handle_file_click(event):\n        if event[\"new\"]:\n            cur_node = event[\"owner\"]\n            for key in tree_dict.keys():\n                if (cur_node is tree_dict[key]) and (os.path.isfile(key)):\n                    if key.endswith(\".py\"):\n                        import_btn.disabled = False\n                    else:\n                        import_btn.disabled = True\n                    try:\n                        with open(key) as f:\n                            content = f.read()\n                            text_widget.value = content\n                            text_widget.disabled = False\n                            path_widget.value = key\n                            path_widget.disabled = False\n                            save_widget.disabled = False\n                            full_widget.children = [left_widget, right_widget]\n                    except Exception as e:\n                        path_widget.value = key\n                        path_widget.disabled = True\n                        save_widget.disabled = True\n                        text_widget.disabled = True\n                        text_widget.value = (\n                            \"Failed to open {}.\".format(cur_node.name) + \"\\n\\n\" + str(e)\n                        )\n                        full_widget.children = [left_widget, right_widget]\n                        return\n                    break\n\n    def handle_folder_click(event):\n        if event[\"new\"]:\n            full_widget.children = [left_widget]\n            text_widget.value = \"\"\n\n    if add_root_node:\n        root_name = in_dir.split(sep)[-1]\n        root_node = Node(root_name)\n        tree_dict[in_dir] = root_node\n        tree.add_node(root_node)\n        root_node.observe(handle_folder_click, \"selected\")\n\n    for root, d_names, f_names in os.walk(in_dir):\n        if not show_hidden:\n            folders = root.split(sep)\n            for folder in folders:\n                if folder.startswith(\".\"):\n                    continue\n            for d_name in d_names:\n                if d_name.startswith(\".\"):\n                    d_names.remove(d_name)\n            for f_name in f_names:\n                if f_name.startswith(\".\"):\n                    f_names.remove(f_name)\n\n        d_names.sort()\n        f_names.sort()\n\n        if (not add_root_node) and (root == in_dir):\n            for d_name in d_names:\n                node = Node(d_name)\n                tree_dict[os.path.join(in_dir, d_name)] = node\n                tree.add_node(node)\n                node.opened = False\n                node.observe(handle_folder_click, \"selected\")\n\n        if (root != in_dir) and (root not in tree_dict.keys()):\n            name = root.split(sep)[-1]\n            dir_name = os.path.dirname(root)\n            parent_node = tree_dict[dir_name]\n            node = Node(name)\n            tree_dict[root] = node\n            parent_node.add_node(node)\n            node.observe(handle_folder_click, \"selected\")\n\n        if len(f_names) &gt; 0:\n            parent_node = tree_dict[root]\n            parent_node.opened = False\n            for f_name in f_names:\n                node = Node(f_name)\n                node.icon = node_icon\n                full_path = os.path.join(root, f_name)\n                tree_dict[full_path] = node\n                parent_node.add_node(node)\n                node.observe(handle_file_click, \"selected\")\n\n    with tree_widget:\n        tree_widget.clear_output()\n        display(tree)\n\n    if return_sep_widgets:\n        return left_widget, right_widget, tree_dict\n    else:\n        return full_widget\n</code></pre>"},{"location":"common/#geemap.common.filter_HUC08","title":"<code>filter_HUC08(region)</code>","text":"<p>Filters HUC08 watersheds intersecting a given region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>object</code> <p>ee.Geometry</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def filter_HUC08(region):\n\"\"\"Filters HUC08 watersheds intersecting a given region.\n\n    Args:\n        region (object): ee.Geometry\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n\n    USGS_HUC08 = ee.FeatureCollection(\"USGS/WBD/2017/HUC08\")  # Subbasins\n    HUC08 = USGS_HUC08.filterBounds(region)\n    return HUC08\n</code></pre>"},{"location":"common/#geemap.common.filter_HUC10","title":"<code>filter_HUC10(region)</code>","text":"<p>Filters HUC10 watersheds intersecting a given region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>object</code> <p>ee.Geometry</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def filter_HUC10(region):\n\"\"\"Filters HUC10 watersheds intersecting a given region.\n\n    Args:\n        region (object): ee.Geometry\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n\n    USGS_HUC10 = ee.FeatureCollection(\"USGS/WBD/2017/HUC10\")  # Watersheds\n    HUC10 = USGS_HUC10.filterBounds(region)\n    return HUC10\n</code></pre>"},{"location":"common/#geemap.common.filter_NWI","title":"<code>filter_NWI(HUC08_Id, region, exclude_riverine=True)</code>","text":"<p>Retrieves NWI dataset for a given HUC8 watershed.</p> <p>Parameters:</p> Name Type Description Default <code>HUC08_Id</code> <code>str</code> <p>The HUC8 watershed id.</p> required <code>region</code> <code>object</code> <p>ee.Geometry</p> required <code>exclude_riverine</code> <code>bool</code> <p>Whether to exclude riverine wetlands. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def filter_NWI(HUC08_Id, region, exclude_riverine=True):\n\"\"\"Retrieves NWI dataset for a given HUC8 watershed.\n\n    Args:\n        HUC08_Id (str): The HUC8 watershed id.\n        region (object): ee.Geometry\n        exclude_riverine (bool, optional): Whether to exclude riverine wetlands. Defaults to True.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n    nwi_asset_prefix = \"users/wqs/NWI-HU8/HU8_\"\n    nwi_asset_suffix = \"_Wetlands\"\n    nwi_asset_path = nwi_asset_prefix + HUC08_Id + nwi_asset_suffix\n    nwi_huc = ee.FeatureCollection(nwi_asset_path).filterBounds(region)\n\n    if exclude_riverine:\n        nwi_huc = nwi_huc.filter(\n            ee.Filter.notEquals(**{\"leftField\": \"WETLAND_TY\", \"rightValue\": \"Riverine\"})\n        )\n    return nwi_huc\n</code></pre>"},{"location":"common/#geemap.common.filter_polygons","title":"<code>filter_polygons(ftr)</code>","text":"<p>Converts GeometryCollection to Polygon/MultiPolygon</p> <p>Parameters:</p> Name Type Description Default <code>ftr</code> <code>object</code> <p>ee.Feature</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.Feature</p> Source code in <code>geemap/common.py</code> <pre><code>def filter_polygons(ftr):\n\"\"\"Converts GeometryCollection to Polygon/MultiPolygon\n\n    Args:\n        ftr (object): ee.Feature\n\n    Returns:\n        object: ee.Feature\n    \"\"\"\n    # ee_initialize()\n    geometries = ftr.geometry().geometries()\n    geometries = geometries.map(\n        lambda geo: ee.Feature(ee.Geometry(geo)).set(\"geoType\", ee.Geometry(geo).type())\n    )\n\n    polygons = (\n        ee.FeatureCollection(geometries)\n        .filter(ee.Filter.eq(\"geoType\", \"Polygon\"))\n        .geometry()\n    )\n    return ee.Feature(polygons).copyProperties(ftr)\n</code></pre>"},{"location":"common/#geemap.common.find_HUC08","title":"<code>find_HUC08(HUC08_Id)</code>","text":"<p>Finds a HUC08 watershed based on a given HUC08 ID</p> <p>Parameters:</p> Name Type Description Default <code>HUC08_Id</code> <code>str</code> <p>The HUC08 ID.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def find_HUC08(HUC08_Id):\n\"\"\"Finds a HUC08 watershed based on a given HUC08 ID\n\n    Args:\n        HUC08_Id (str): The HUC08 ID.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n\n    USGS_HUC08 = ee.FeatureCollection(\"USGS/WBD/2017/HUC08\")  # Subbasins\n    HUC08 = USGS_HUC08.filter(ee.Filter.eq(\"huc8\", HUC08_Id))\n    return HUC08\n</code></pre>"},{"location":"common/#geemap.common.find_HUC10","title":"<code>find_HUC10(HUC10_Id)</code>","text":"<p>Finds a HUC10 watershed based on a given HUC08 ID</p> <p>Parameters:</p> Name Type Description Default <code>HUC10_Id</code> <code>str</code> <p>The HUC10 ID.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def find_HUC10(HUC10_Id):\n\"\"\"Finds a HUC10 watershed based on a given HUC08 ID\n\n    Args:\n        HUC10_Id (str): The HUC10 ID.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n\n    USGS_HUC10 = ee.FeatureCollection(\"USGS/WBD/2017/HUC10\")  # Watersheds\n    HUC10 = USGS_HUC10.filter(ee.Filter.eq(\"huc10\", HUC10_Id))\n    return HUC10\n</code></pre>"},{"location":"common/#geemap.common.find_NAIP","title":"<code>find_NAIP(region, add_NDVI=True, add_NDWI=True)</code>","text":"<p>Create annual NAIP mosaic for a given region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>object</code> <p>ee.Geometry</p> required <code>add_NDVI</code> <code>bool</code> <p>Whether to add the NDVI band. Defaults to True.</p> <code>True</code> <code>add_NDWI</code> <code>bool</code> <p>Whether to add the NDWI band. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.ImageCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def find_NAIP(region, add_NDVI=True, add_NDWI=True):\n\"\"\"Create annual NAIP mosaic for a given region.\n\n    Args:\n        region (object): ee.Geometry\n        add_NDVI (bool, optional): Whether to add the NDVI band. Defaults to True.\n        add_NDWI (bool, optional): Whether to add the NDWI band. Defaults to True.\n\n    Returns:\n        object: ee.ImageCollection\n    \"\"\"\n\n    init_collection = (\n        ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n        .filterBounds(region)\n        .filterDate(\"2009-01-01\", \"2019-12-31\")\n        .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n    )\n\n    yearList = ee.List(\n        init_collection.distinct([\"system:time_start\"]).aggregate_array(\n            \"system:time_start\"\n        )\n    )\n    init_years = yearList.map(lambda y: ee.Date(y).get(\"year\"))\n\n    # remove duplicates\n    init_years = ee.Dictionary(\n        init_years.reduce(ee.Reducer.frequencyHistogram())\n    ).keys()\n    years = init_years.map(lambda x: ee.Number.parse(x))\n    # years = init_years.map(lambda x: x)\n\n    # Available NAIP years with NIR band\n    def NAIPAnnual(year):\n        start_date = ee.Date.fromYMD(year, 1, 1)\n        end_date = ee.Date.fromYMD(year, 12, 31)\n        collection = init_collection.filterDate(start_date, end_date)\n        # .filterBounds(geometry)\n        # .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n        time_start = ee.Date(\n            ee.List(collection.aggregate_array(\"system:time_start\")).sort().get(0)\n        ).format(\"YYYY-MM-dd\")\n        time_end = ee.Date(\n            ee.List(collection.aggregate_array(\"system:time_end\")).sort().get(-1)\n        ).format(\"YYYY-MM-dd\")\n        col_size = collection.size()\n        image = ee.Image(collection.mosaic().clip(region))\n\n        if add_NDVI:\n            NDVI = (\n                ee.Image(image)\n                .normalizedDifference([\"N\", \"R\"])\n                .select([\"nd\"], [\"ndvi\"])\n            )\n            image = image.addBands(NDVI)\n\n        if add_NDWI:\n            NDWI = (\n                ee.Image(image)\n                .normalizedDifference([\"G\", \"N\"])\n                .select([\"nd\"], [\"ndwi\"])\n            )\n            image = image.addBands(NDWI)\n\n        return image.set(\n            {\n                \"system:time_start\": time_start,\n                \"system:time_end\": time_end,\n                \"tiles\": col_size,\n            }\n        )\n\n    # remove years with incomplete coverage\n    naip = ee.ImageCollection(years.map(NAIPAnnual))\n    mean_size = ee.Number(naip.aggregate_mean(\"tiles\"))\n    total_sd = ee.Number(naip.aggregate_total_sd(\"tiles\"))\n    threshold = mean_size.subtract(total_sd.multiply(1))\n    naip = naip.filter(\n        ee.Filter.Or(ee.Filter.gte(\"tiles\", threshold), ee.Filter.gte(\"tiles\", 15))\n    )\n    naip = naip.filter(ee.Filter.gte(\"tiles\", 7))\n\n    naip_count = naip.size()\n    naip_seq = ee.List.sequence(0, naip_count.subtract(1))\n\n    def set_index(index):\n        img = ee.Image(naip.toList(naip_count).get(index))\n        return img.set({\"system:uid\": ee.Number(index).toUint8()})\n\n    naip = naip_seq.map(set_index)\n\n    return ee.ImageCollection(naip)\n</code></pre>"},{"location":"common/#geemap.common.find_NWI","title":"<code>find_NWI(HUC08_Id, exclude_riverine=True)</code>","text":"<p>Finds NWI dataset for a given HUC08 watershed.</p> <p>Parameters:</p> Name Type Description Default <code>HUC08_Id</code> <code>str</code> <p>The HUC08 watershed ID.</p> required <code>exclude_riverine</code> <code>bool</code> <p>Whether to exclude riverine wetlands. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def find_NWI(HUC08_Id, exclude_riverine=True):\n\"\"\"Finds NWI dataset for a given HUC08 watershed.\n\n    Args:\n        HUC08_Id (str): The HUC08 watershed ID.\n        exclude_riverine (bool, optional): Whether to exclude riverine wetlands. Defaults to True.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n\n    nwi_asset_prefix = \"users/wqs/NWI-HU8/HU8_\"\n    nwi_asset_suffix = \"_Wetlands\"\n    nwi_asset_path = nwi_asset_prefix + HUC08_Id + nwi_asset_suffix\n    nwi_huc = ee.FeatureCollection(nwi_asset_path)\n    if exclude_riverine:\n        nwi_huc = nwi_huc.filter(\n            ee.Filter.notEquals(**{\"leftField\": \"WETLAND_TY\", \"rightValue\": \"Riverine\"})\n        )\n    return nwi_huc\n</code></pre>"},{"location":"common/#geemap.common.find_files","title":"<code>find_files(input_dir, ext=None, fullpath=True, recursive=True)</code>","text":"<p>Find files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The input directory.</p> required <code>ext</code> <code>str</code> <p>The file extension to match. Defaults to None.</p> <code>None</code> <code>fullpath</code> <code>bool</code> <p>Whether to return the full path. Defaults to True.</p> <code>True</code> <code>recursive</code> <code>bool</code> <p>Whether to search recursively. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of matching files.</p> Source code in <code>geemap/common.py</code> <pre><code>def find_files(input_dir, ext=None, fullpath=True, recursive=True):\n\"\"\"Find files in a directory.\n\n    Args:\n        input_dir (str): The input directory.\n        ext (str, optional): The file extension to match. Defaults to None.\n        fullpath (bool, optional): Whether to return the full path. Defaults to True.\n        recursive (bool, optional): Whether to search recursively. Defaults to True.\n\n    Returns:\n        list: A list of matching files.\n    \"\"\"\n\n    from pathlib import Path\n\n    files = []\n\n    if ext is None:\n        ext = \"*\"\n    else:\n        ext = ext.replace(\".\", \"\")\n\n    ext = f\"*.{ext}\"\n\n    if recursive:\n        if fullpath:\n            files = [str(path.joinpath()) for path in Path(input_dir).rglob(ext)]\n        else:\n            files = [str(path.name) for path in Path(input_dir).rglob(ext)]\n    else:\n        if fullpath:\n            files = [str(path.joinpath()) for path in Path(input_dir).glob(ext)]\n        else:\n            files = [path.name for path in Path(input_dir).glob(ext)]\n\n    return files\n</code></pre>"},{"location":"common/#geemap.common.find_landsat_by_path_row","title":"<code>find_landsat_by_path_row(landsat_col, path_num, row_num)</code>","text":"<p>Finds Landsat images by WRS path number and row number.</p> <p>Parameters:</p> Name Type Description Default <code>landsat_col</code> <code>str</code> <p>The image collection id of Landsat.</p> required <code>path_num</code> <code>int</code> <p>The WRS path number.</p> required <code>row_num</code> <code>int</code> <p>the WRS row number.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.ImageCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def find_landsat_by_path_row(landsat_col, path_num, row_num):\n\"\"\"Finds Landsat images by WRS path number and row number.\n\n    Args:\n        landsat_col (str): The image collection id of Landsat.\n        path_num (int): The WRS path number.\n        row_num (int): the WRS row number.\n\n    Returns:\n        object: ee.ImageCollection\n    \"\"\"\n    try:\n        if isinstance(landsat_col, str):\n            landsat_col = ee.ImageCollection(landsat_col)\n            collection = landsat_col.filter(ee.Filter.eq(\"WRS_PATH\", path_num)).filter(\n                ee.Filter.eq(\"WRS_ROW\", row_num)\n            )\n            return collection\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.fishnet","title":"<code>fishnet(data, h_interval=1.0, v_interval=1.0, rows=None, cols=None, delta=1.0, intersect=True, output=None, **kwargs)</code>","text":"<p>Create a fishnet (i.e., rectangular grid) based on an input vector dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | ee.Geometry | ee.Feature | ee.FeatureCollection</code> <p>The input vector dataset. It can be a file path, HTTP URL, ee.Geometry, ee.Feature, or ee.FeatureCollection.</p> required <code>h_interval</code> <code>float</code> <p>The horizontal interval in degrees. It will be ignored if rows and cols are specified. Defaults to 1.0.</p> <code>1.0</code> <code>v_interval</code> <code>float</code> <p>The vertical interval in degrees. It will be ignored if rows and cols are specified. Defaults to 1.0.</p> <code>1.0</code> <code>rows</code> <code>int</code> <p>The number of rows. Defaults to None.</p> <code>None</code> <code>cols</code> <code>int</code> <p>The number of columns. Defaults to None.</p> <code>None</code> <code>delta</code> <code>float</code> <p>The buffer distance in degrees. Defaults to 1.0.</p> <code>1.0</code> <code>intersect</code> <code>bool</code> <p>If True, the output will be a feature collection of intersecting polygons. Defaults to True.</p> <code>True</code> <code>output</code> <code>str</code> <p>The output file path. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>The fishnet as an ee.FeatureCollection.</p> Source code in <code>geemap/common.py</code> <pre><code>def fishnet(\n    data,\n    h_interval=1.0,\n    v_interval=1.0,\n    rows=None,\n    cols=None,\n    delta=1.0,\n    intersect=True,\n    output=None,\n    **kwargs,\n):\n\"\"\"Create a fishnet (i.e., rectangular grid) based on an input vector dataset.\n\n    Args:\n        data (str | ee.Geometry | ee.Feature | ee.FeatureCollection): The input vector dataset. It can be a file path, HTTP URL, ee.Geometry, ee.Feature, or ee.FeatureCollection.\n        h_interval (float, optional): The horizontal interval in degrees. It will be ignored if rows and cols are specified. Defaults to 1.0.\n        v_interval (float, optional): The vertical interval in degrees. It will be ignored if rows and cols are specified. Defaults to 1.0.\n        rows (int, optional): The number of rows. Defaults to None.\n        cols (int, optional): The number of columns. Defaults to None.\n        delta (float, optional): The buffer distance in degrees. Defaults to 1.0.\n        intersect (bool, optional): If True, the output will be a feature collection of intersecting polygons. Defaults to True.\n        output (str, optional): The output file path. Defaults to None.\n\n\n    Returns:\n        ee.FeatureCollection: The fishnet as an ee.FeatureCollection.\n    \"\"\"\n    if isinstance(data, str):\n        data = vector_to_ee(data, **kwargs)\n\n    if isinstance(data, ee.FeatureCollection) or isinstance(data, ee.Feature):\n        data = data.geometry()\n    elif isinstance(data, ee.Geometry):\n        pass\n    else:\n        raise ValueError(\n            \"data must be a string, ee.FeatureCollection, ee.Feature, or ee.Geometry.\"\n        )\n\n    coords = data.bounds().coordinates().getInfo()\n\n    west = coords[0][0][0]\n    east = coords[0][1][0]\n    south = coords[0][0][1]\n    north = coords[0][2][1]\n\n    if rows is not None and cols is not None:\n        v_interval = (north - south) / rows\n        h_interval = (east - west) / cols\n\n    # west = west - delta * h_interval\n    east = east + delta * h_interval\n    # south = south - delta * v_interval\n    north = north + delta * v_interval\n\n    grids = latlon_grid(v_interval, h_interval, west, east, south, north)\n\n    if intersect:\n        grids = grids.filterBounds(data)\n\n    if output is not None:\n        ee_export_vector(grids, output)\n\n    else:\n        return grids\n</code></pre>"},{"location":"common/#geemap.common.gdf_bounds","title":"<code>gdf_bounds(gdf, return_geom=False)</code>","text":"<p>Returns the bounding box of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>return_geom</code> <code>bool</code> <p>Whether to return the bounding box as a GeoDataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | gpd.GeoDataFrame</code> <p>A bounding box in the form of a list (minx, miny, maxx, maxy) or GeoDataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def gdf_bounds(gdf, return_geom=False):\n\"\"\"Returns the bounding box of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        return_geom (bool, optional): Whether to return the bounding box as a GeoDataFrame. Defaults to False.\n\n    Returns:\n        list | gpd.GeoDataFrame: A bounding box in the form of a list (minx, miny, maxx, maxy) or GeoDataFrame.\n    \"\"\"\n    bounds = gdf.total_bounds\n    if return_geom:\n        return bbox_to_gdf(bbox=bounds)\n    else:\n        return bounds\n</code></pre>"},{"location":"common/#geemap.common.gdf_centroid","title":"<code>gdf_centroid(gdf, return_geom=False)</code>","text":"<p>Returns the centroid of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>return_geom</code> <code>bool</code> <p>Whether to return the bounding box as a GeoDataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | gpd.GeoDataFrame</code> <p>A bounding box in the form of a list (lon, lat) or GeoDataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def gdf_centroid(gdf, return_geom=False):\n\"\"\"Returns the centroid of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        return_geom (bool, optional): Whether to return the bounding box as a GeoDataFrame. Defaults to False.\n\n    Returns:\n        list | gpd.GeoDataFrame: A bounding box in the form of a list (lon, lat) or GeoDataFrame.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    centroid = gdf_bounds(gdf, return_geom=True).centroid\n    if return_geom:\n        return centroid\n    else:\n        return centroid.x[0], centroid.y[0]\n</code></pre>"},{"location":"common/#geemap.common.gdf_geom_type","title":"<code>gdf_geom_type(gdf, first_only=True)</code>","text":"<p>Returns the geometry type of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>first_only</code> <code>bool</code> <p>Whether to return the geometry type of the first feature in the GeoDataFrame. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The geometry type of the GeoDataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def gdf_geom_type(gdf, first_only=True):\n\"\"\"Returns the geometry type of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        first_only (bool, optional): Whether to return the geometry type of the first feature in the GeoDataFrame. Defaults to True.\n\n    Returns:\n        str: The geometry type of the GeoDataFrame.\n    \"\"\"\n\n    if first_only:\n        return gdf.geometry.type[0]\n    else:\n        return gdf.geometry.type\n</code></pre>"},{"location":"common/#geemap.common.gdf_to_df","title":"<code>gdf_to_df(gdf, drop_geom=True)</code>","text":"<p>Converts a GeoDataFrame to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>drop_geom</code> <code>bool</code> <p>Whether to drop the geometry column. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas DataFrame containing the GeoDataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def gdf_to_df(gdf, drop_geom=True):\n\"\"\"Converts a GeoDataFrame to a pandas DataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        drop_geom (bool, optional): Whether to drop the geometry column. Defaults to True.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the GeoDataFrame.\n    \"\"\"\n    import pandas as pd\n\n    if drop_geom:\n        df = pd.DataFrame(gdf.drop(columns=[\"geometry\"]))\n    else:\n        df = pd.DataFrame(gdf)\n\n    return df\n</code></pre>"},{"location":"common/#geemap.common.gdf_to_ee","title":"<code>gdf_to_ee(gdf, geodesic=True, date=None, date_format='YYYY-MM-dd')</code>","text":"<p>Converts a GeoPandas GeoDataFrame to ee.FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The input geopandas.GeoDataFrame to be converted ee.FeatureCollection.</p> required <code>geodesic</code> <code>bool</code> <p>Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected. Defaults to True.</p> <code>True</code> <code>date</code> <code>str</code> <p>Column name for the date column. Defaults to None.</p> <code>None</code> <code>date_format</code> <code>str</code> <p>Date format. A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.</p> <code>'YYYY-MM-dd'</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>The input data type must be geopandas.GeoDataFrame.</p> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>The output ee.FeatureCollection converted from the input geopandas.GeoDataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def gdf_to_ee(gdf, geodesic=True, date=None, date_format=\"YYYY-MM-dd\"):\n\"\"\"Converts a GeoPandas GeoDataFrame to ee.FeatureCollection.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The input geopandas.GeoDataFrame to be converted ee.FeatureCollection.\n        geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected. Defaults to True.\n        date (str, optional): Column name for the date column. Defaults to None.\n        date_format (str, optional): Date format. A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.\n\n    Raises:\n        TypeError: The input data type must be geopandas.GeoDataFrame.\n\n    Returns:\n        ee.FeatureCollection: The output ee.FeatureCollection converted from the input geopandas.GeoDataFrame.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    if not isinstance(gdf, gpd.GeoDataFrame):\n        raise TypeError(\"The input data type must be geopandas.GeoDataFrame.\")\n\n    out_json = os.path.join(os.getcwd(), random_string(6) + \".geojson\")\n    gdf = gdf.to_crs(4326)\n    gdf.to_file(out_json, driver=\"GeoJSON\")\n\n    fc = geojson_to_ee(out_json, geodesic=geodesic)\n\n    if date is not None:\n        try:\n            fc = fc.map(\n                lambda x: x.set(\n                    \"system:time_start\",\n                    ee.Date.parse(date_format, x.get(date)).millis(),\n                )\n            )\n        except Exception as e:\n            raise Exception(e)\n\n    os.remove(out_json)\n\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.gdf_to_geojson","title":"<code>gdf_to_geojson(gdf, out_geojson=None, epsg=None)</code>","text":"<p>Converts a GeoDataFame to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>out_geojson</code> <code>str</code> <p>File path to he output GeoJSON. Defaults to None.</p> <code>None</code> <code>epsg</code> <code>str</code> <p>An EPSG string, e.g., \"4326\". Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>When the output file extension is incorrect.</p> <code>Exception</code> <p>When the conversion fails.</p> <p>Returns:</p> Type Description <code>dict</code> <p>When the out_json is None returns a dict.</p> Source code in <code>geemap/common.py</code> <pre><code>def gdf_to_geojson(gdf, out_geojson=None, epsg=None):\n\"\"\"Converts a GeoDataFame to GeoJSON.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        out_geojson (str, optional): File path to he output GeoJSON. Defaults to None.\n        epsg (str, optional): An EPSG string, e.g., \"4326\". Defaults to None.\n\n    Raises:\n        TypeError: When the output file extension is incorrect.\n        Exception: When the conversion fails.\n\n    Returns:\n        dict: When the out_json is None returns a dict.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    try:\n        if epsg is not None:\n            gdf = gdf.to_crs(epsg=epsg)\n        geojson = gdf.__geo_interface__\n\n        if out_geojson is None:\n            return geojson\n        else:\n            ext = os.path.splitext(out_geojson)[1]\n            if ext.lower() not in [\".json\", \".geojson\"]:\n                raise TypeError(\n                    \"The output file extension must be either .json or .geojson\"\n                )\n            out_dir = os.path.dirname(out_geojson)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            gdf.to_file(out_geojson, driver=\"GeoJSON\")\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.geocode","title":"<code>geocode(location, max_rows=10, reverse=False)</code>","text":"<p>Search location by address and lat/lon coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>Place name or address</p> required <code>max_rows</code> <code>int</code> <p>Maximum number of records to return. Defaults to 10.</p> <code>10</code> <code>reverse</code> <code>bool</code> <p>Search place based on coordinates. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>Returns a list of locations.</p> Source code in <code>geemap/common.py</code> <pre><code>def geocode(location, max_rows=10, reverse=False):\n\"\"\"Search location by address and lat/lon coordinates.\n\n    Args:\n        location (str): Place name or address\n        max_rows (int, optional): Maximum number of records to return. Defaults to 10.\n        reverse (bool, optional): Search place based on coordinates. Defaults to False.\n\n    Returns:\n        list: Returns a list of locations.\n    \"\"\"\n    import geocoder\n\n    if not isinstance(location, str):\n        print(\"The location must be a string.\")\n        return None\n\n    if not reverse:\n        locations = []\n        addresses = set()\n        g = geocoder.arcgis(location, maxRows=max_rows)\n\n        for result in g:\n            address = result.address\n            if address not in addresses:\n                addresses.add(address)\n                locations.append(result)\n\n        if len(locations) &gt; 0:\n            return locations\n        else:\n            return None\n\n    else:\n        try:\n            if \",\" in location:\n                latlon = [float(x) for x in location.split(\",\")]\n            elif \" \" in location:\n                latlon = [float(x) for x in location.split(\" \")]\n            else:\n                print(\n                    \"The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3\"\n                )\n                return\n            g = geocoder.arcgis(latlon, method=\"reverse\")\n            locations = []\n            addresses = set()\n\n            for result in g:\n                address = result.address\n                if address not in addresses:\n                    addresses.add(address)\n                    locations.append(result)\n\n            if len(locations) &gt; 0:\n                return locations\n            else:\n                return None\n\n        except Exception as e:\n            print(e)\n            return None\n</code></pre>"},{"location":"common/#geemap.common.geojson_to_df","title":"<code>geojson_to_df(in_geojson, encoding='utf-8', drop_geometry=True)</code>","text":"<p>Converts a GeoJSON object to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>drop_geometry</code> <code>bool</code> <p>Whether to drop the geometry column. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the input GeoJSON file could not be found.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas DataFrame containing the GeoJSON object.</p> Source code in <code>geemap/common.py</code> <pre><code>def geojson_to_df(in_geojson, encoding=\"utf-8\", drop_geometry=True):\n\"\"\"Converts a GeoJSON object to a pandas DataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n        drop_geometry (bool, optional): Whether to drop the geometry column. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the input GeoJSON file could not be found.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the GeoJSON object.\n    \"\"\"\n\n    import pandas as pd\n    from urllib.request import urlopen\n\n    if isinstance(in_geojson, str):\n        if in_geojson.startswith(\"http\"):\n            in_geojson = github_raw_url(in_geojson)\n            with urlopen(in_geojson) as f:\n                data = json.load(f)\n        else:\n            in_geojson = os.path.abspath(in_geojson)\n            if not os.path.exists(in_geojson):\n                raise FileNotFoundError(\"The provided GeoJSON file could not be found.\")\n\n            with open(in_geojson, encoding=encoding) as f:\n                data = json.load(f)\n\n    elif isinstance(in_geojson, dict):\n        data = in_geojson\n\n    df = pd.json_normalize(data[\"features\"])\n    df.columns = [col.replace(\"properties.\", \"\") for col in df.columns]\n    if drop_geometry:\n        df = df[df.columns.drop(list(df.filter(regex=\"geometry\")))]\n    return df\n</code></pre>"},{"location":"common/#geemap.common.geojson_to_ee","title":"<code>geojson_to_ee(geo_json, geodesic=False, encoding='utf-8')</code>","text":"<p>Converts a geojson to ee.Geometry()</p> <p>Parameters:</p> Name Type Description Default <code>geo_json</code> <code>dict</code> <p>A geojson geometry dictionary or file path.</p> required <code>geodesic</code> <code>bool</code> <p>Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected. Defaults to False.</p> <code>False</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>ee_object</code> <p>An ee.Geometry object</p> Source code in <code>geemap/common.py</code> <pre><code>def geojson_to_ee(geo_json, geodesic=False, encoding=\"utf-8\"):\n\"\"\"Converts a geojson to ee.Geometry()\n\n    Args:\n        geo_json (dict): A geojson geometry dictionary or file path.\n        geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected. Defaults to False.\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    Returns:\n        ee_object: An ee.Geometry object\n    \"\"\"\n\n    try:\n        if isinstance(geo_json, str):\n            if geo_json.startswith(\"http\") and geo_json.endswith(\".geojson\"):\n                geo_json = github_raw_url(geo_json)\n                out_geojson = temp_file_path(extension=\".geojson\")\n                download_file(geo_json, out_geojson)\n                with open(out_geojson, \"r\", encoding=encoding) as f:\n                    geo_json = json.loads(f.read())\n                os.remove(out_geojson)\n\n            elif os.path.isfile(geo_json):\n                with open(os.path.abspath(geo_json), encoding=encoding) as f:\n                    geo_json = json.load(f)\n\n        # geo_json[\"geodesic\"] = geodesic\n        if geo_json[\"type\"] == \"FeatureCollection\":\n            for feature in geo_json[\"features\"]:\n                if feature[\"geometry\"][\"type\"] != \"Point\":\n                    feature[\"geometry\"][\"geodesic\"] = geodesic\n            features = ee.FeatureCollection(geo_json)\n            return features\n        elif geo_json[\"type\"] == \"Feature\":\n            geom = None\n            if \"style\" in geo_json[\"properties\"]:\n                keys = geo_json[\"properties\"][\"style\"].keys()\n                if \"radius\" in keys:  # Checks whether it is a circle\n                    geom = ee.Geometry(geo_json[\"geometry\"])\n                    radius = geo_json[\"properties\"][\"style\"][\"radius\"]\n                    geom = geom.buffer(radius)\n                else:\n                    geom = ee.Geometry(geo_json[\"geometry\"])\n            elif (\n                geo_json[\"geometry\"][\"type\"] == \"Point\"\n            ):  # Checks whether it is a point\n                coordinates = geo_json[\"geometry\"][\"coordinates\"]\n                longitude = coordinates[0]\n                latitude = coordinates[1]\n                geom = ee.Geometry.Point(longitude, latitude)\n            else:\n                geom = ee.Geometry(geo_json[\"geometry\"], \"\", geodesic)\n            return geom\n        else:\n            raise Exception(\"Could not convert the geojson to ee.Geometry()\")\n\n    except Exception as e:\n        print(\"Could not convert the geojson to ee.Geometry()\")\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.geometry_type","title":"<code>geometry_type(ee_object)</code>","text":"<p>Get geometry type of an Earth Engine object.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>An Earth Engine object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Returns geometry type. One of Point, MultiPoint, LineString, LinearRing, MultiLineString, BBox, Rectangle, Polygon, MultiPolygon.</p> Source code in <code>geemap/common.py</code> <pre><code>def geometry_type(ee_object):\n\"\"\"Get geometry type of an Earth Engine object.\n\n    Args:\n        ee_object (object): An Earth Engine object.\n\n    Returns:\n        str: Returns geometry type. One of Point, MultiPoint, LineString, LinearRing, MultiLineString, BBox, Rectangle, Polygon, MultiPolygon.\n    \"\"\"\n    if isinstance(ee_object, ee.Geometry):\n        return ee_object.type().getInfo()\n    elif isinstance(ee_object, ee.Feature):\n        return ee_object.geometry().type().getInfo()\n    elif isinstance(ee_object, ee.FeatureCollection):\n        return ee.Feature(ee_object.first()).geometry().type().getInfo()\n    else:\n        raise TypeError(\n            \"The ee_object must be one of ee.Geometry, ee.Feature, ee.FeatureCollection.\"\n        )\n</code></pre>"},{"location":"common/#geemap.common.geopandas_to_ee","title":"<code>geopandas_to_ee(gdf, geodesic=True, date=None, date_format='YYYY-MM-dd')</code>","text":"<p>Converts a GeoPandas GeoDataFrame to ee.FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The input geopandas.GeoDataFrame to be converted ee.FeatureCollection.</p> required <code>geodesic</code> <code>bool</code> <p>Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected. Defaults to True.</p> <code>True</code> <code>date</code> <code>str</code> <p>Column name for the date column. Defaults to None.</p> <code>None</code> <code>date_format</code> <code>str</code> <p>Date format. A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.</p> <code>'YYYY-MM-dd'</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>The input data type must be geopandas.GeoDataFrame.</p> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>The output ee.FeatureCollection converted from the input geopandas.GeoDataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def gdf_to_ee(gdf, geodesic=True, date=None, date_format=\"YYYY-MM-dd\"):\n\"\"\"Converts a GeoPandas GeoDataFrame to ee.FeatureCollection.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The input geopandas.GeoDataFrame to be converted ee.FeatureCollection.\n        geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected. Defaults to True.\n        date (str, optional): Column name for the date column. Defaults to None.\n        date_format (str, optional): Date format. A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.\n\n    Raises:\n        TypeError: The input data type must be geopandas.GeoDataFrame.\n\n    Returns:\n        ee.FeatureCollection: The output ee.FeatureCollection converted from the input geopandas.GeoDataFrame.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    if not isinstance(gdf, gpd.GeoDataFrame):\n        raise TypeError(\"The input data type must be geopandas.GeoDataFrame.\")\n\n    out_json = os.path.join(os.getcwd(), random_string(6) + \".geojson\")\n    gdf = gdf.to_crs(4326)\n    gdf.to_file(out_json, driver=\"GeoJSON\")\n\n    fc = geojson_to_ee(out_json, geodesic=geodesic)\n\n    if date is not None:\n        try:\n            fc = fc.map(\n                lambda x: x.set(\n                    \"system:time_start\",\n                    ee.Date.parse(date_format, x.get(date)).millis(),\n                )\n            )\n        except Exception as e:\n            raise Exception(e)\n\n    os.remove(out_json)\n\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.get_all_NAIP","title":"<code>get_all_NAIP(start_year=2009, end_year=2019)</code>","text":"<p>Creates annual NAIP imagery mosaic.</p> <p>Parameters:</p> Name Type Description Default <code>start_year</code> <code>int</code> <p>The starting year. Defaults to 2009.</p> <code>2009</code> <code>end_year</code> <code>int</code> <p>The ending year. Defaults to 2019.</p> <code>2019</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.ImageCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def get_all_NAIP(start_year=2009, end_year=2019):\n\"\"\"Creates annual NAIP imagery mosaic.\n\n    Args:\n        start_year (int, optional): The starting year. Defaults to 2009.\n        end_year (int, optional): The ending year. Defaults to 2019.\n\n    Returns:\n        object: ee.ImageCollection\n    \"\"\"\n    try:\n\n        def get_annual_NAIP(year):\n            try:\n                collection = ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n                start_date = ee.Date.fromYMD(year, 1, 1)\n                end_date = ee.Date.fromYMD(year, 12, 31)\n                naip = collection.filterDate(start_date, end_date).filter(\n                    ee.Filter.listContains(\"system:band_names\", \"N\")\n                )\n                return ee.ImageCollection(naip)\n            except Exception as e:\n                print(e)\n\n        years = ee.List.sequence(start_year, end_year)\n        collection = years.map(get_annual_NAIP)\n        return collection\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.get_annual_NAIP","title":"<code>get_annual_NAIP(year, RGBN=True)</code>","text":"<p>Filters NAIP ImageCollection by year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year to filter the NAIP ImageCollection.</p> required <code>RGBN</code> <code>bool</code> <p>Whether to retrieve 4-band NAIP imagery only. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.ImageCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def get_annual_NAIP(year, RGBN=True):\n\"\"\"Filters NAIP ImageCollection by year.\n\n    Args:\n        year (int): The year to filter the NAIP ImageCollection.\n        RGBN (bool, optional): Whether to retrieve 4-band NAIP imagery only. Defaults to True.\n\n    Returns:\n        object: ee.ImageCollection\n    \"\"\"\n    try:\n        collection = ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n        start_date = str(year) + \"-01-01\"\n        end_date = str(year) + \"-12-31\"\n        naip = collection.filterDate(start_date, end_date)\n        if RGBN:\n            naip = naip.filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n        return naip\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.get_api_key","title":"<code>get_api_key(token_name, m=None)</code>","text":"<p>Retrieves an API key based on a system environmen variable.</p> <p>Parameters:</p> Name Type Description Default <code>token_name</code> <code>str</code> <p>The token name.</p> required <code>m</code> <code>ipyleaflet.Map | folium.Map</code> <p>A Map instance. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The API key.</p> Source code in <code>geemap/common.py</code> <pre><code>def get_api_key(token_name, m=None):\n\"\"\"Retrieves an API key based on a system environmen variable.\n\n    Args:\n        token_name (str): The token name.\n        m (ipyleaflet.Map | folium.Map, optional): A Map instance. Defaults to None.\n\n    Returns:\n        str: The API key.\n    \"\"\"\n    api_key = os.environ.get(token_name)\n    if m is not None and token_name in m.api_keys:\n        api_key = m.api_keys[token_name]\n\n    return api_key\n</code></pre>"},{"location":"common/#geemap.common.get_bounds","title":"<code>get_bounds(geometry, north_up=True, transform=None)</code>","text":"<p>Bounding box of a GeoJSON geometry, GeometryCollection, or FeatureCollection. left, bottom, right, top not xmin, ymin, xmax, ymax If not north_up, y will be switched to guarantee the above. Source code adapted from https://github.com/mapbox/rasterio/blob/master/rasterio/features.py#L361</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON dict.</p> required <code>north_up</code> <code>bool</code> <p>. Defaults to True.</p> <code>True</code> <code>transform</code> <code>[type]</code> <p>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of coordinates representing [left, bottom, right, top]</p> Source code in <code>geemap/common.py</code> <pre><code>def get_bounds(geometry, north_up=True, transform=None):\n\"\"\"Bounding box of a GeoJSON geometry, GeometryCollection, or FeatureCollection.\n    left, bottom, right, top\n    *not* xmin, ymin, xmax, ymax\n    If not north_up, y will be switched to guarantee the above.\n    Source code adapted from https://github.com/mapbox/rasterio/blob/master/rasterio/features.py#L361\n\n    Args:\n        geometry (dict): A GeoJSON dict.\n        north_up (bool, optional): . Defaults to True.\n        transform ([type], optional): . Defaults to None.\n\n    Returns:\n        list: A list of coordinates representing [left, bottom, right, top]\n    \"\"\"\n\n    if \"bbox\" in geometry:\n        return tuple(geometry[\"bbox\"])\n\n    geometry = geometry.get(\"geometry\") or geometry\n\n    # geometry must be a geometry, GeometryCollection, or FeatureCollection\n    if not (\n        \"coordinates\" in geometry or \"geometries\" in geometry or \"features\" in geometry\n    ):\n        raise ValueError(\n            \"geometry must be a GeoJSON-like geometry, GeometryCollection, \"\n            \"or FeatureCollection\"\n        )\n\n    if \"features\" in geometry:\n        # Input is a FeatureCollection\n        xmins = []\n        ymins = []\n        xmaxs = []\n        ymaxs = []\n        for feature in geometry[\"features\"]:\n            xmin, ymin, xmax, ymax = get_bounds(feature[\"geometry\"])\n            xmins.append(xmin)\n            ymins.append(ymin)\n            xmaxs.append(xmax)\n            ymaxs.append(ymax)\n        if north_up:\n            return min(xmins), min(ymins), max(xmaxs), max(ymaxs)\n        else:\n            return min(xmins), max(ymaxs), max(xmaxs), min(ymins)\n\n    elif \"geometries\" in geometry:\n        # Input is a geometry collection\n        xmins = []\n        ymins = []\n        xmaxs = []\n        ymaxs = []\n        for geometry in geometry[\"geometries\"]:\n            xmin, ymin, xmax, ymax = get_bounds(geometry)\n            xmins.append(xmin)\n            ymins.append(ymin)\n            xmaxs.append(xmax)\n            ymaxs.append(ymax)\n        if north_up:\n            return min(xmins), min(ymins), max(xmaxs), max(ymaxs)\n        else:\n            return min(xmins), max(ymaxs), max(xmaxs), min(ymins)\n\n    elif \"coordinates\" in geometry:\n        # Input is a singular geometry object\n        if transform is not None:\n            xyz = list(explode(geometry[\"coordinates\"]))\n            xyz_px = [transform * point for point in xyz]\n            xyz = tuple(zip(*xyz_px))\n            return min(xyz[0]), max(xyz[1]), max(xyz[0]), min(xyz[1])\n        else:\n            xyz = tuple(zip(*list(explode(geometry[\"coordinates\"]))))\n            if north_up:\n                return min(xyz[0]), min(xyz[1]), max(xyz[0]), max(xyz[1])\n            else:\n                return min(xyz[0]), max(xyz[1]), max(xyz[0]), min(xyz[1])\n\n    # all valid inputs returned above, so whatever falls through is an error\n    raise ValueError(\n        \"geometry must be a GeoJSON-like geometry, GeometryCollection, \"\n        \"or FeatureCollection\"\n    )\n</code></pre>"},{"location":"common/#geemap.common.get_census_dict","title":"<code>get_census_dict(reset=False)</code>","text":"<p>Returns a dictionary of Census data.</p> <p>Parameters:</p> Name Type Description Default <code>reset</code> <code>bool</code> <p>Reset the dictionary. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of Census data.</p> Source code in <code>geemap/common.py</code> <pre><code>def get_census_dict(reset=False):\n\"\"\"Returns a dictionary of Census data.\n\n    Args:\n        reset (bool, optional): Reset the dictionary. Defaults to False.\n\n    Returns:\n        dict: A dictionary of Census data.\n    \"\"\"\n    import pkg_resources\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    census_data = os.path.join(pkg_dir, \"data/census_data.json\")\n\n    if reset:\n        try:\n            from owslib.wms import WebMapService\n        except ImportError:\n            raise ImportError(\n                'The owslib package must be installed to use this function. Install with \"pip install owslib\"'\n            )\n\n        census_dict = {}\n\n        names = [\n            \"Current\",\n            \"ACS 2021\",\n            \"ACS 2019\",\n            \"ACS 2018\",\n            \"ACS 2017\",\n            \"ACS 2016\",\n            \"ACS 2015\",\n            \"ACS 2014\",\n            \"ACS 2013\",\n            \"ACS 2012\",\n            \"ECON 2012\",\n            \"Census 2020\",\n            \"Census 2010\",\n            \"Physical Features\",\n            \"Decennial Census 2020\",\n            \"Decennial Census 2010\",\n            \"Decennial Census 2000\",\n            \"Decennial Physical Features\",\n        ]\n\n        links = {}\n\n        print(\"Retrieving data. Please wait ...\")\n        for name in names:\n            if \"Decennial\" not in name:\n                links[\n                    name\n                ] = f\"https://tigerweb.geo.census.gov/arcgis/services/TIGERweb/tigerWMS_{name.replace(' ', '')}/MapServer/WMSServer\"\n            else:\n                links[\n                    name\n                ] = f\"https://tigerweb.geo.census.gov/arcgis/services/Census2020/tigerWMS_{name.replace('Decennial', '').replace(' ', '')}/MapServer/WMSServer\"\n\n            wms = WebMapService(links[name], timeout=300)\n            layers = list(wms.contents)\n            layers.sort()\n            census_dict[name] = {\n                \"url\": links[name],\n                \"layers\": layers,\n                # \"title\": wms.identification.title,\n                # \"abstract\": wms.identification.abstract,\n            }\n\n        with open(census_data, \"w\") as f:\n            json.dump(census_dict, f, indent=4)\n\n    else:\n        with open(census_data, \"r\") as f:\n            census_dict = json.load(f)\n\n    return census_dict\n</code></pre>"},{"location":"common/#geemap.common.get_center","title":"<code>get_center(geometry, north_up=True, transform=None)</code>","text":"<p>Get the centroid of a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON dict.</p> required <code>north_up</code> <code>bool</code> <p>. Defaults to True.</p> <code>True</code> <code>transform</code> <code>[type]</code> <p>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>[lon, lat]</p> Source code in <code>geemap/common.py</code> <pre><code>def get_center(geometry, north_up=True, transform=None):\n\"\"\"Get the centroid of a GeoJSON.\n\n    Args:\n        geometry (dict): A GeoJSON dict.\n        north_up (bool, optional): . Defaults to True.\n        transform ([type], optional): . Defaults to None.\n\n    Returns:\n        list: [lon, lat]\n    \"\"\"\n    bounds = get_bounds(geometry, north_up, transform)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lat, lon)\n    return center\n</code></pre>"},{"location":"common/#geemap.common.get_current_latlon","title":"<code>get_current_latlon()</code>","text":"<p>Get the current latitude and longitude based on the user's location.</p> Source code in <code>geemap/common.py</code> <pre><code>def get_current_latlon():\n\"\"\"Get the current latitude and longitude based on the user's location.\"\"\"\n    import geocoder\n\n    g = geocoder.ip(\"me\")\n    props = g.geojson[\"features\"][0][\"properties\"]\n    lat = props[\"lat\"]\n    lon = props[\"lng\"]\n    return lat, lon\n</code></pre>"},{"location":"common/#geemap.common.get_current_year","title":"<code>get_current_year()</code>","text":"<p>Get the current year.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current year.</p> Source code in <code>geemap/common.py</code> <pre><code>def get_current_year():\n\"\"\"Get the current year.\n\n    Returns:\n        int: The current year.\n    \"\"\"\n    today = datetime.date.today()\n    return today.year\n</code></pre>"},{"location":"common/#geemap.common.get_direct_url","title":"<code>get_direct_url(url)</code>","text":"<p>Get the direct URL for a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to get the direct URL for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The direct URL.</p> Source code in <code>geemap/common.py</code> <pre><code>def get_direct_url(url):\n\"\"\"Get the direct URL for a given URL.\n\n    Args:\n        url (str): The URL to get the direct URL for.\n\n    Returns:\n        str: The direct URL.\n    \"\"\"\n\n    if not isinstance(url, str):\n        raise ValueError(\"url must be a string.\")\n\n    if not url.startswith(\"http\"):\n        raise ValueError(\"url must start with http.\")\n\n    r = requests.head(url, allow_redirects=True)\n    return r.url\n</code></pre>"},{"location":"common/#geemap.common.get_geometry_coords","title":"<code>get_geometry_coords(row, geom, coord_type, shape_type, mercator=False)</code>","text":"<p>Returns the coordinates ('x' or 'y') of edges of a Polygon exterior.</p> <p>:param: (GeoPandas Series) row : The row of each of the GeoPandas DataFrame. :param: (str) geom : The column name. :param: (str) coord_type : Whether it's 'x' or 'y' coordinate. :param: (str) shape_type</p> Source code in <code>geemap/common.py</code> <pre><code>def get_geometry_coords(row, geom, coord_type, shape_type, mercator=False):\n\"\"\"\n    Returns the coordinates ('x' or 'y') of edges of a Polygon exterior.\n\n    :param: (GeoPandas Series) row : The row of each of the GeoPandas DataFrame.\n    :param: (str) geom : The column name.\n    :param: (str) coord_type : Whether it's 'x' or 'y' coordinate.\n    :param: (str) shape_type\n    \"\"\"\n\n    # Parse the exterior of the coordinate\n    if shape_type.lower() in [\"polygon\", \"multipolygon\"]:\n        exterior = row[geom].geoms[0].exterior\n        if coord_type == \"x\":\n            # Get the x coordinates of the exterior\n            coords = list(exterior.coords.xy[0])\n            if mercator:\n                coords = [lnglat_to_meters(x, 0)[0] for x in coords]\n            return coords\n\n        elif coord_type == \"y\":\n            # Get the y coordinates of the exterior\n            coords = list(exterior.coords.xy[1])\n            if mercator:\n                coords = [lnglat_to_meters(0, y)[1] for y in coords]\n            return coords\n\n    elif shape_type.lower() in [\"linestring\", \"multilinestring\"]:\n        if coord_type == \"x\":\n            coords = list(row[geom].coords.xy[0])\n            if mercator:\n                coords = [lnglat_to_meters(x, 0)[0] for x in coords]\n            return coords\n        elif coord_type == \"y\":\n            coords = list(row[geom].coords.xy[1])\n            if mercator:\n                coords = [lnglat_to_meters(0, y)[1] for y in coords]\n            return coords\n\n    elif shape_type.lower() in [\"point\", \"multipoint\"]:\n        exterior = row[geom]\n\n        if coord_type == \"x\":\n            # Get the x coordinates of the exterior\n            coords = exterior.coords.xy[0][0]\n            if mercator:\n                coords = lnglat_to_meters(coords, 0)[0]\n            return coords\n\n        elif coord_type == \"y\":\n            # Get the y coordinates of the exterior\n            coords = exterior.coords.xy[1][0]\n            if mercator:\n                coords = lnglat_to_meters(0, coords)[1]\n            return coords\n</code></pre>"},{"location":"common/#geemap.common.get_image_collection_thumbnails","title":"<code>get_image_collection_thumbnails(ee_object, out_dir, vis_params, dimensions=500, region=None, format='jpg', names=None, verbose=True, timeout=300, proxies=None)</code>","text":"<p>Download thumbnails for all images in an ImageCollection.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>The ee.ImageCollection instance.</p> required <code>out_dir</code> <code>[str</code> <p>The output directory to store thumbnails.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters.</p> required <code>dimensions</code> <code>int</code> <p>(a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 500.</p> <code>500</code> <code>region</code> <code>object</code> <p>Geospatial region of the image to render, it may be an ee.Geometry, GeoJSON, or an array of lat/lon points (E,S,W,N). If not set the default is the bounds image. Defaults to None.</p> <code>None</code> <code>format</code> <code>str</code> <p>Either 'png' or 'jpg'. Default to 'jpg'.</p> <code>'jpg'</code> <code>names</code> <code>list</code> <p>The list of output file names. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether or not to print hints. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>The number of seconds after which the request will be terminated. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxy servers to use for the request. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def get_image_collection_thumbnails(\n    ee_object,\n    out_dir,\n    vis_params,\n    dimensions=500,\n    region=None,\n    format=\"jpg\",\n    names=None,\n    verbose=True,\n    timeout=300,\n    proxies=None,\n):\n\"\"\"Download thumbnails for all images in an ImageCollection.\n\n    Args:\n        ee_object (object): The ee.ImageCollection instance.\n        out_dir ([str): The output directory to store thumbnails.\n        vis_params (dict): The visualization parameters.\n        dimensions (int, optional):(a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 500.\n        region (object, optional): Geospatial region of the image to render, it may be an ee.Geometry, GeoJSON, or an array of lat/lon points (E,S,W,N). If not set the default is the bounds image. Defaults to None.\n        format (str, optional): Either 'png' or 'jpg'. Default to 'jpg'.\n        names (list, optional): The list of output file names. Defaults to None.\n        verbose (bool, optional): Whether or not to print hints. Defaults to True.\n        timeout (int, optional): The number of seconds after which the request will be terminated. Defaults to 300.\n        proxies (dict, optional): A dictionary of proxy servers to use for the request. Defaults to None.\n    \"\"\"\n    if not isinstance(ee_object, ee.ImageCollection):\n        print(\"The ee_object must be an ee.ImageCollection.\")\n        raise TypeError(\"The ee_object must be an ee.Image.\")\n\n    if format not in [\"png\", \"jpg\"]:\n        raise ValueError(\"The output image format must be png or jpg.\")\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    try:\n        count = int(ee_object.size().getInfo())\n        if verbose:\n            print(f\"Total number of images: {count}\\n\")\n\n        if (names is not None) and (len(names) != count):\n            print(\"The number of names is not equal to the number of images.\")\n            return\n\n        if names is None:\n            names = ee_object.aggregate_array(\"system:index\").getInfo()\n\n        images = ee_object.toList(count)\n\n        for i in range(0, count):\n            image = ee.Image(images.get(i))\n            name = str(names[i])\n            ext = os.path.splitext(name)[1][1:]\n            if ext != format:\n                name = name + \".\" + format\n            out_img = os.path.join(out_dir, name)\n            if verbose:\n                print(f\"Downloading {i+1}/{count}: {name} ...\")\n\n            get_image_thumbnail(\n                image,\n                out_img,\n                vis_params,\n                dimensions,\n                region,\n                format,\n                timeout=timeout,\n                proxies=proxies,\n            )\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.get_image_thumbnail","title":"<code>get_image_thumbnail(ee_object, out_img, vis_params, dimensions=500, region=None, format='jpg', crs='EPSG:3857', timeout=300, proxies=None)</code>","text":"<p>Download a thumbnail for an ee.Image.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>The ee.Image instance.</p> required <code>out_img</code> <code>str</code> <p>The output file path to the png thumbnail.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters.</p> required <code>dimensions</code> <code>int</code> <p>(a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 500.</p> <code>500</code> <code>region</code> <code>object</code> <p>Geospatial region of the image to render, it may be an ee.Geometry, GeoJSON, or an array of lat/lon points (E,S,W,N). If not set the default is the bounds image. Defaults to None.</p> <code>None</code> <code>format</code> <code>str</code> <p>Either 'png' or 'jpg'. Default to 'jpg'.</p> <code>'jpg'</code> <code>timeout</code> <code>int</code> <p>The number of seconds after which the request will be terminated. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxy servers to use for the request. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def get_image_thumbnail(\n    ee_object,\n    out_img,\n    vis_params,\n    dimensions=500,\n    region=None,\n    format=\"jpg\",\n    crs=\"EPSG:3857\",\n    timeout=300,\n    proxies=None,\n):\n\"\"\"Download a thumbnail for an ee.Image.\n\n    Args:\n        ee_object (object): The ee.Image instance.\n        out_img (str): The output file path to the png thumbnail.\n        vis_params (dict): The visualization parameters.\n        dimensions (int, optional):(a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 500.\n        region (object, optional): Geospatial region of the image to render, it may be an ee.Geometry, GeoJSON, or an array of lat/lon points (E,S,W,N). If not set the default is the bounds image. Defaults to None.\n        format (str, optional): Either 'png' or 'jpg'. Default to 'jpg'.\n        timeout (int, optional): The number of seconds after which the request will be terminated. Defaults to 300.\n        proxies (dict, optional): A dictionary of proxy servers to use for the request. Defaults to None.\n    \"\"\"\n\n    if not isinstance(ee_object, ee.Image):\n        raise TypeError(\"The ee_object must be an ee.Image.\")\n\n    ext = os.path.splitext(out_img)[1][1:]\n    if ext not in [\"png\", \"jpg\"]:\n        raise ValueError(\"The output image format must be png or jpg.\")\n    else:\n        format = ext\n\n    out_image = os.path.abspath(out_img)\n    out_dir = os.path.dirname(out_image)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if region is not None:\n        vis_params[\"region\"] = region\n\n    vis_params[\"dimensions\"] = dimensions\n    vis_params[\"format\"] = format\n    vis_params[\"crs\"] = crs\n    url = ee_object.getThumbURL(vis_params)\n\n    try:\n        r = requests.get(url, stream=True, timeout=timeout, proxies=proxies)\n    except Exception as e:\n        print(\"An error occurred while downloading.\")\n        print(e)\n\n    if r.status_code != 200:\n        print(\"An error occurred while downloading.\")\n        print(r.json()[\"error\"][\"message\"])\n\n    else:\n        with open(out_img, \"wb\") as fd:\n            for chunk in r.iter_content(chunk_size=1024):\n                fd.write(chunk)\n</code></pre>"},{"location":"common/#geemap.common.get_info","title":"<code>get_info(ee_object, layer_name='', opened=False, return_node=False)</code>","text":"<p>Print out the information for an Earth Engine object using a tree structure. The source code     was adapted from https://github.com/google/earthengine-jupyter. Credits to Tyler Erickson.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>The Earth Engine object.</p> required <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"\".</p> <code>''</code> <code>opened</code> <code>bool</code> <p>Whether to expand the tree. Defaults to False.</p> <code>False</code> <code>return_node</code> <code>bool</code> <p>Whether to return the widget as ipytree.Node. If False, returns the widget as ipytree.Tree. Defaults to False.</p> <code>False</code> Source code in <code>geemap/common.py</code> <pre><code>def get_info(ee_object, layer_name=\"\", opened=False, return_node=False):\n\"\"\"Print out the information for an Earth Engine object using a tree structure. The source code\n        was adapted from https://github.com/google/earthengine-jupyter. Credits to Tyler Erickson.\n\n    Args:\n        ee_object (object): The Earth Engine object.\n        layer_name (str, optional): The name of the layer. Defaults to \"\".\n        opened (bool, optional): Whether to expand the tree. Defaults to False.\n        return_node (bool, optional): Whether to return the widget as ipytree.Node.\n            If False, returns the widget as ipytree.Tree. Defaults to False.\n    \"\"\"\n\n    def _order_items(item_dict, ordering_list):\n\"\"\"Orders dictionary items in a specified order.\n        Adapted from https://github.com/google/earthengine-jupyter.\n        \"\"\"\n        list_of_tuples = [\n            (key, item_dict[key])\n            for key in [x for x in ordering_list if x in item_dict.keys()]\n        ]\n\n        return dict(list_of_tuples)\n\n    def _process_info(info):\n        node_list = []\n        if isinstance(info, list):\n            for count, item in enumerate(info):\n                if isinstance(item, (list, dict)):\n                    if \"id\" in item:\n                        count = f\"{count}: \\\"{item['id']}\\\"\"\n                    if \"data_type\" in item:\n                        count = f\"{count}, {item['data_type']['precision']}\"\n                    if \"crs\" in item:\n                        count = f\"{count}, {item['crs']}\"\n                    if \"dimensions\" in item:\n                        dimensions = item[\"dimensions\"]\n                        count = f\"{count}, {dimensions[0]}x{dimensions[1]} px\"\n                    node_list.append(\n                        Node(f\"{count}\", nodes=_process_info(item), opened=opened)\n                    )\n                else:\n                    node_list.append(Node(f\"{count}: {item}\", icon=\"file\"))\n        elif isinstance(info, dict):\n            for k, v in info.items():\n                if isinstance(v, (list, dict)):\n                    if k == \"properties\":\n                        k = f\"properties: Object ({len(v)} properties)\"\n                    elif k == \"bands\":\n                        k = f\"bands: List ({len(v)} elements)\"\n                    node_list.append(\n                        Node(f\"{k}\", nodes=_process_info(v), opened=opened)\n                    )\n                else:\n                    node_list.append(Node(f\"{k}: {v}\", icon=\"file\"))\n        else:\n            node_list.append(Node(f\"{info}\", icon=\"file\"))\n        return node_list\n\n    if isinstance(ee_object, ee.FeatureCollection):\n        ee_object = ee_object.map(lambda f: ee.Feature(None, f.toDictionary()))\n    layer_info = ee_object.getInfo()\n    props = layer_info.get(\"properties\", {})\n    layer_info[\"properties\"] = dict(sorted(props.items()))\n\n    ordering_list = []\n    if \"type\" in layer_info:\n        ordering_list.append(\"type\")\n        ee_type = layer_info[\"type\"]\n    else:\n        ee_type = \"\"\n\n    if \"id\" in layer_info:\n        ordering_list.append(\"id\")\n        ee_id = layer_info[\"id\"]\n    else:\n        ee_id = \"\"\n\n    ordering_list.append(\"version\")\n    ordering_list.append(\"bands\")\n    ordering_list.append(\"properties\")\n\n    layer_info = _order_items(layer_info, ordering_list)\n    nodes = _process_info(layer_info)\n\n    if len(layer_name) &gt; 0:\n        layer_name = f\"{layer_name}: \"\n\n    if \"bands\" in layer_info:\n        band_info = f' ({len(layer_info[\"bands\"])} bands)'\n    else:\n        band_info = \"\"\n    root_node = Node(f\"{layer_name}{ee_type} {band_info}\", nodes=nodes, opened=opened)\n    # root_node.open_icon = \"plus-square\"\n    # root_node.open_icon_style = \"success\"\n    # root_node.close_icon = \"minus-square\"\n    # root_node.close_icon_style = \"info\"\n\n    if return_node:\n        return root_node\n    else:\n        tree = Tree()\n        tree.add_node(root_node)\n        return tree\n</code></pre>"},{"location":"common/#geemap.common.get_local_tile_layer","title":"<code>get_local_tile_layer(source, port='default', debug=False, projection='EPSG:3857', band=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, tile_format='ipyleaflet', layer_name='Local COG', return_client=False, **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a local raster dataset or remote Cloud Optimized GeoTIFF (COG).     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),     try adding to following two lines to the beginning of the notebook if the raster does not render properly.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> <code>'default'</code> <code>debug</code> <code>bool</code> <p>If True, the server will be started in debug mode. Defaults to False.</p> <code>False</code> <code>projection</code> <code>str</code> <p>The projection of the GeoTIFF. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>band</code> <code>int</code> <p>The band to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>tile_format</code> <code>str</code> <p>The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>'Local COG'</code> <code>return_client</code> <code>bool</code> <p>If True, the tile client will be returned. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer | folium.TileLayer</code> <p>An ipyleaflet.TileLayer or folium.TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def get_local_tile_layer(\n    source,\n    port=\"default\",\n    debug=False,\n    projection=\"EPSG:3857\",\n    band=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    tile_format=\"ipyleaflet\",\n    layer_name=\"Local COG\",\n    return_client=False,\n    **kwargs,\n):\n\"\"\"Generate an ipyleaflet/folium TileLayer from a local raster dataset or remote Cloud Optimized GeoTIFF (COG).\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n        try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        debug (bool, optional): If True, the server will be started in debug mode. Defaults to False.\n        projection (str, optional): The projection of the GeoTIFF. Defaults to \"EPSG:3857\".\n        band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        tile_format (str, optional): The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n        layer_name (str, optional): The layer name to use. Defaults to None.\n        return_client (bool, optional): If True, the tile client will be returned. Defaults to False.\n\n    Returns:\n        ipyleaflet.TileLayer | folium.TileLayer: An ipyleaflet.TileLayer or folium.TileLayer.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    output = widgets.Output()\n\n    check_package(\n        \"localtileserver\", URL=\"https://github.com/banesullivan/localtileserver\"\n    )\n\n    # Make it compatible with binder and JupyterHub\n    if os.environ.get(\"JUPYTERHUB_SERVICE_PREFIX\") is not None:\n        os.environ[\n            \"LOCALTILESERVER_CLIENT_PREFIX\"\n        ] = f\"{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}\"\n\n    from localtileserver import (\n        get_leaflet_tile_layer,\n        get_folium_tile_layer,\n        TileClient,\n    )\n\n    if isinstance(source, str):\n        if not source.startswith(\"http\"):\n            if source.startswith(\"~\"):\n                source = os.path.expanduser(source)\n            else:\n                source = os.path.abspath(source)\n            if not os.path.exists(source):\n                raise ValueError(\"The source path does not exist.\")\n        else:\n            source = github_raw_url(source)\n    else:\n        raise ValueError(\"The source must either be a string or TileClient\")\n\n    if isinstance(palette, str):\n        palette = get_palette_colors(palette, hashtag=True)\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    if layer_name is None:\n        if source.startswith(\"http\"):\n            layer_name = \"RemoteTile_\" + random_string(3)\n        else:\n            layer_name = \"LocalTile_\" + random_string(3)\n\n    with output:\n        tile_client = TileClient(source, port=port, debug=debug)\n\n        if tile_format == \"ipyleaflet\":\n            tile_layer = get_leaflet_tile_layer(\n                tile_client,\n                port=port,\n                debug=debug,\n                projection=projection,\n                band=band,\n                palette=palette,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attribution=attribution,\n                name=layer_name,\n                max_zoom=30,\n                max_native_zoom=30,\n                **kwargs,\n            )\n        else:\n            tile_layer = get_folium_tile_layer(\n                tile_client,\n                port=port,\n                debug=debug,\n                projection=projection,\n                band=band,\n                palette=palette,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attr=attribution,\n                overlay=True,\n                name=layer_name,\n                max_zoom=30,\n                max_native_zoom=30,\n                **kwargs,\n            )\n\n    if return_client:\n        return tile_layer, tile_client\n    else:\n        return tile_layer\n</code></pre>"},{"location":"common/#geemap.common.get_palettable","title":"<code>get_palettable(types=None)</code>","text":"<p>Get a list of palettable color palettes.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>list</code> <p>A list of palettable types to return, e.g., types=['matplotlib', 'cartocolors']. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of palettable color palettes.</p> Source code in <code>geemap/common.py</code> <pre><code>def get_palettable(types=None):\n\"\"\"Get a list of palettable color palettes.\n\n    Args:\n        types (list, optional): A list of palettable types to return, e.g., types=['matplotlib', 'cartocolors']. Defaults to None.\n\n    Returns:\n        list: A list of palettable color palettes.\n    \"\"\"\n    try:\n        import palettable\n    except ImportError:\n        raise ImportError(\n            \"The palettable package is not installed. Please install it with `pip install palettable`.\"\n        )\n\n    if types is not None and (not isinstance(types, list)):\n        raise ValueError(\"The types must be a list.\")\n\n    allowed_palettes = [\n        \"cartocolors\",\n        \"cmocean\",\n        \"colorbrewer\",\n        \"cubehelix\",\n        \"lightbartlein\",\n        \"matplotlib\",\n        \"mycarta\",\n        \"scientific\",\n        \"tableau\",\n        \"wesanderson\",\n    ]\n\n    if types is None:\n        types = allowed_palettes[:]\n\n    if all(x in allowed_palettes for x in types):\n        pass\n    else:\n        raise ValueError(\n            \"The types must be one of the following: \" + \", \".join(allowed_palettes)\n        )\n\n    palettes = []\n\n    if \"cartocolors\" in types:\n        cartocolors_diverging = [\n            f\"cartocolors.diverging.{c}\"\n            for c in dir(palettable.cartocolors.diverging)[:-19]\n        ]\n        cartocolors_qualitative = [\n            f\"cartocolors.qualitative.{c}\"\n            for c in dir(palettable.cartocolors.qualitative)[:-19]\n        ]\n        cartocolors_sequential = [\n            f\"cartocolors.sequential.{c}\"\n            for c in dir(palettable.cartocolors.sequential)[:-41]\n        ]\n\n        palettes = (\n            palettes\n            + cartocolors_diverging\n            + cartocolors_qualitative\n            + cartocolors_sequential\n        )\n\n    if \"cmocean\" in types:\n        cmocean_diverging = [\n            f\"cmocean.diverging.{c}\" for c in dir(palettable.cmocean.diverging)[:-19]\n        ]\n        cmocean_sequential = [\n            f\"cmocean.sequential.{c}\" for c in dir(palettable.cmocean.sequential)[:-19]\n        ]\n\n        palettes = palettes + cmocean_diverging + cmocean_sequential\n\n    if \"colorbrewer\" in types:\n        colorbrewer_diverging = [\n            f\"colorbrewer.diverging.{c}\"\n            for c in dir(palettable.colorbrewer.diverging)[:-19]\n        ]\n        colorbrewer_qualitative = [\n            f\"colorbrewer.qualitative.{c}\"\n            for c in dir(palettable.colorbrewer.qualitative)[:-19]\n        ]\n        colorbrewer_sequential = [\n            f\"colorbrewer.sequential.{c}\"\n            for c in dir(palettable.colorbrewer.sequential)[:-41]\n        ]\n\n        palettes = (\n            palettes\n            + colorbrewer_diverging\n            + colorbrewer_qualitative\n            + colorbrewer_sequential\n        )\n\n    if \"cubehelix\" in types:\n        cubehelix = [\n            \"classic_16\",\n            \"cubehelix1_16\",\n            \"cubehelix2_16\",\n            \"cubehelix3_16\",\n            \"jim_special_16\",\n            \"perceptual_rainbow_16\",\n            \"purple_16\",\n            \"red_16\",\n        ]\n        cubehelix = [f\"cubehelix.{c}\" for c in cubehelix]\n        palettes = palettes + cubehelix\n\n    if \"lightbartlein\" in types:\n        lightbartlein_diverging = [\n            f\"lightbartlein.diverging.{c}\"\n            for c in dir(palettable.lightbartlein.diverging)[:-19]\n        ]\n        lightbartlein_sequential = [\n            f\"lightbartlein.sequential.{c}\"\n            for c in dir(palettable.lightbartlein.sequential)[:-19]\n        ]\n\n        palettes = palettes + lightbartlein_diverging + lightbartlein_sequential\n\n    if \"matplotlib\" in types:\n        matplotlib_colors = [\n            f\"matplotlib.{c}\" for c in dir(palettable.matplotlib)[:-16]\n        ]\n        palettes = palettes + matplotlib_colors\n\n    if \"mycarta\" in types:\n        mycarta = [f\"mycarta.{c}\" for c in dir(palettable.mycarta)[:-16]]\n        palettes = palettes + mycarta\n\n    if \"scientific\" in types:\n        scientific_diverging = [\n            f\"scientific.diverging.{c}\"\n            for c in dir(palettable.scientific.diverging)[:-19]\n        ]\n        scientific_sequential = [\n            f\"scientific.sequential.{c}\"\n            for c in dir(palettable.scientific.sequential)[:-19]\n        ]\n\n        palettes = palettes + scientific_diverging + scientific_sequential\n\n    if \"tableau\" in types:\n        tableau = [f\"tableau.{c}\" for c in dir(palettable.tableau)[:-14]]\n        palettes = palettes + tableau\n\n    return palettes\n</code></pre>"},{"location":"common/#geemap.common.get_palette_colors","title":"<code>get_palette_colors(cmap_name=None, n_class=None, hashtag=False)</code>","text":"<p>Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>The name of the matplotlib colormap. Defaults to None.</p> <code>None</code> <code>n_class</code> <code>int</code> <p>The number of colors. Defaults to None.</p> <code>None</code> <code>hashtag</code> <code>bool</code> <p>Whether to return a list of hex colors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of hex colors.</p> Source code in <code>geemap/common.py</code> <pre><code>def get_palette_colors(cmap_name=None, n_class=None, hashtag=False):\n\"\"\"Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Args:\n        cmap_name (str, optional): The name of the matplotlib colormap. Defaults to None.\n        n_class (int, optional): The number of colors. Defaults to None.\n        hashtag (bool, optional): Whether to return a list of hex colors. Defaults to False.\n\n    Returns:\n        list: A list of hex colors.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    cmap = plt.cm.get_cmap(cmap_name, n_class)\n    colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n    if hashtag:\n        colors = [\"#\" + i for i in colors]\n    return colors\n</code></pre>"},{"location":"common/#geemap.common.get_wms_layers","title":"<code>get_wms_layers(url, return_titles=False)</code>","text":"<p>Returns a list of WMS layers from a WMS service.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the WMS service.</p> required <code>return_titles</code> <code>bool</code> <p>If True, the titles of the layers will be returned. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of WMS layers.</p> Source code in <code>geemap/common.py</code> <pre><code>def get_wms_layers(url, return_titles=False):\n\"\"\"Returns a list of WMS layers from a WMS service.\n\n    Args:\n        url (str): The URL of the WMS service.\n        return_titles (bool, optional): If True, the titles of the layers will be returned. Defaults to False.\n\n    Returns:\n        list: A list of WMS layers.\n    \"\"\"\n    from owslib.wms import WebMapService\n\n    wms = WebMapService(url)\n    layers = list(wms.contents)\n    layers.sort()\n    if return_titles:\n        return layers, [wms[layer].title for layer in layers]\n    else:\n        return layers\n</code></pre>"},{"location":"common/#geemap.common.github_raw_url","title":"<code>github_raw_url(url)</code>","text":"<p>Get the raw URL for a GitHub file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The GitHub URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The raw URL.</p> Source code in <code>geemap/common.py</code> <pre><code>def github_raw_url(url):\n\"\"\"Get the raw URL for a GitHub file.\n\n    Args:\n        url (str): The GitHub URL.\n    Returns:\n        str: The raw URL.\n    \"\"\"\n    if isinstance(url, str) and url.startswith(\"https://github.com/\") and \"blob\" in url:\n        url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\", 1\n        )\n    return url\n</code></pre>"},{"location":"common/#geemap.common.has_transparency","title":"<code>has_transparency(img)</code>","text":"<p>Checks whether an image has transparency.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>a PIL Image object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it has transparency, False otherwise.</p> Source code in <code>geemap/common.py</code> <pre><code>def has_transparency(img):\n\"\"\"Checks whether an image has transparency.\n\n    Args:\n        img (object):  a PIL Image object.\n\n    Returns:\n        bool: True if it has transparency, False otherwise.\n    \"\"\"\n\n    if img.mode == \"P\":\n        transparent = img.info.get(\"transparency\", -1)\n        for _, index in img.getcolors():\n            if index == transparent:\n                return True\n    elif img.mode == \"RGBA\":\n        extrema = img.getextrema()\n        if extrema[3][0] &lt; 255:\n            return True\n\n    return False\n</code></pre>"},{"location":"common/#geemap.common.hex_to_rgb","title":"<code>hex_to_rgb(value='FFFFFF')</code>","text":"<p>Converts hex color to RGB color.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Hex color code as a string. Defaults to 'FFFFFF'.</p> <code>'FFFFFF'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>RGB color as a tuple.</p> Source code in <code>geemap/common.py</code> <pre><code>def hex_to_rgb(value=\"FFFFFF\"):\n\"\"\"Converts hex color to RGB color.\n\n    Args:\n        value (str, optional): Hex color code as a string. Defaults to 'FFFFFF'.\n\n    Returns:\n        tuple: RGB color as a tuple.\n    \"\"\"\n    value = value.lstrip(\"#\")\n    lv = len(value)\n    return tuple(int(value[i : i + lv // 3], 16) for i in range(0, lv, lv // 3))\n</code></pre>"},{"location":"common/#geemap.common.html_to_gradio","title":"<code>html_to_gradio(html, width='100%', height='500px', **kwargs)</code>","text":"<p>Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as     attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>The width of the map. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map. Defaults to '500px'.</p> <code>'500px'</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML string to use in Gradio.</p> Source code in <code>geemap/common.py</code> <pre><code>def html_to_gradio(html, width=\"100%\", height=\"500px\", **kwargs):\n\"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n        attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n    Args:\n        width (str, optional): The width of the map. Defaults to '100%'.\n        height (str, optional): The height of the map. Defaults to '500px'.\n\n    Returns:\n        str: The HTML string to use in Gradio.\n    \"\"\"\n\n    if isinstance(width, int):\n        width = f\"{width}px\"\n\n    if isinstance(height, int):\n        height = f\"{height}px\"\n\n    if isinstance(html, str):\n        with open(html, \"r\") as f:\n            lines = f.readlines()\n    elif isinstance(html, list):\n        lines = html\n    else:\n        raise TypeError(\"html must be a file path or a list of strings\")\n\n    output = []\n    skipped_lines = []\n    for index, line in enumerate(lines):\n        if index in skipped_lines:\n            continue\n        if line.lstrip().startswith('{\"attribution\":'):\n            continue\n        elif \"on(L.Draw.Event.CREATED, function(e)\" in line:\n            for i in range(14):\n                skipped_lines.append(index + i)\n        elif \"L.Control.geocoder\" in line:\n            for i in range(5):\n                skipped_lines.append(index + i)\n        elif \"function(e)\" in line:\n            print(\n                f\"Warning: The folium plotting backend does not support functions in code blocks. Please delete line {index + 1}.\"\n            )\n        else:\n            output.append(line + \"\\n\")\n\n    return f\"\"\"&lt;iframe style=\"width: {width}; height: {height}\" name=\"result\" allow=\"midi; geolocation; microphone; camera; \n    display-capture; encrypted-media;\" sandbox=\"allow-modals allow-forms \n    allow-scripts allow-same-origin allow-popups \n    allow-top-navigation-by-user-activation allow-downloads\" allowfullscreen=\"\" \n    allowpaymentrequest=\"\" frameborder=\"0\" srcdoc='{\"\".join(output)}'&gt;&lt;/iframe&gt;\"\"\"\n</code></pre>"},{"location":"common/#geemap.common.html_to_streamlit","title":"<code>html_to_streamlit(filename, width=None, height=None, scrolling=False, replace_dict={})</code>","text":"<p>Renders an HTML file as a Streamlit component.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the HTML file.</p> required <code>width</code> <code>int</code> <p>Width of the map. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>None</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <code>replace_dict</code> <code>dict</code> <p>A dictionary of strings to replace in the HTML file. Defaults to {}.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the filename does not exist.</p> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>geemap/common.py</code> <pre><code>def html_to_streamlit(\n    filename, width=None, height=None, scrolling=False, replace_dict={}\n):\n\"\"\"Renders an HTML file as a Streamlit component.\n    Args:\n        filename (str): The filename of the HTML file.\n        width (int, optional): Width of the map. Defaults to None.\n        height (int, optional): Height of the map. Defaults to 600.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n        replace_dict (dict, optional): A dictionary of strings to replace in the HTML file. Defaults to {}.\n\n    Raises:\n        ValueError: If the filename does not exist.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    import streamlit.components.v1 as components\n\n    if not os.path.exists(filename):\n        raise ValueError(\"filename must exist.\")\n\n    f = open(filename, \"r\")\n\n    html = f.read()\n\n    for key, value in replace_dict.items():\n        html = html.replace(key, value)\n\n    f.close()\n    return components.html(html, width=width, height=height, scrolling=scrolling)\n</code></pre>"},{"location":"common/#geemap.common.image_area","title":"<code>image_area(img, region=None, scale=None, denominator=1.0)</code>","text":"<p>Calculates the area of an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>ee.Image</p> required <code>region</code> <code>object</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>denominator</code> <code>float</code> <p>The denominator to use for converting size from square meters to other units. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.Dictionary</p> Source code in <code>geemap/common.py</code> <pre><code>def image_area(img, region=None, scale=None, denominator=1.0):\n\"\"\"Calculates the area of an image.\n\n    Args:\n        img (object): ee.Image\n        region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        denominator (float, optional): The denominator to use for converting size from square meters to other units. Defaults to 1.0.\n\n    Returns:\n        object: ee.Dictionary\n    \"\"\"\n    if region is None:\n        region = img.geometry()\n\n    if scale is None:\n        scale = image_scale(img)\n\n    pixel_area = (\n        img.unmask().neq(ee.Image(0)).multiply(ee.Image.pixelArea()).divide(denominator)\n    )\n    img_area = pixel_area.reduceRegion(\n        **{\n            \"geometry\": region,\n            \"reducer\": ee.Reducer.sum(),\n            \"scale\": scale,\n            \"maxPixels\": 1e12,\n        }\n    )\n    return img_area\n</code></pre>"},{"location":"common/#geemap.common.image_area_by_group","title":"<code>image_area_by_group(img, groups=None, region=None, scale=None, denominator=1.0, out_csv=None, labels=None, decimal_places=4, verbose=True)</code>","text":"<p>Calculates the area of each class of an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>ee.Image</p> required <code>groups</code> <code>object</code> <p>The groups to use for the area calculation. Defaults to None.</p> <code>None</code> <code>region</code> <code>object</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>denominator</code> <code>float</code> <p>The denominator to use for converting size from square meters to other units. Defaults to 1.0.</p> <code>1.0</code> <code>out_csv</code> <code>str</code> <p>The path to the output CSV file. Defaults to None.</p> <code>None</code> <code>labels</code> <code>object</code> <p>The class labels to use in the output CSV file. Defaults to None.</p> <code>None</code> <code>decimal_places</code> <code>int</code> <p>The number of decimal places to use for the output. Defaults to 2.</p> <code>4</code> <code>verbose</code> <code>bool</code> <p>If True, print the progress. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>object</code> <p>pandas.DataFrame</p> Source code in <code>geemap/common.py</code> <pre><code>def image_area_by_group(\n    img,\n    groups=None,\n    region=None,\n    scale=None,\n    denominator=1.0,\n    out_csv=None,\n    labels=None,\n    decimal_places=4,\n    verbose=True,\n):\n\"\"\"Calculates the area of each class of an image.\n\n    Args:\n        img (object): ee.Image\n        groups (object, optional): The groups to use for the area calculation. Defaults to None.\n        region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        denominator (float, optional): The denominator to use for converting size from square meters to other units. Defaults to 1.0.\n        out_csv (str, optional): The path to the output CSV file. Defaults to None.\n        labels (object, optional): The class labels to use in the output CSV file. Defaults to None.\n        decimal_places (int, optional): The number of decimal places to use for the output. Defaults to 2.\n        verbose (bool, optional): If True, print the progress. Defaults to True.\n\n    Returns:\n        object: pandas.DataFrame\n    \"\"\"\n    import pandas as pd\n\n    values = []\n    if region is None:\n        region = ee.Geometry.BBox(-179.9, -89.5, 179.9, 89.5)\n\n    if groups is None:\n        groups = image_value_list(img, region, scale)\n\n    if not isinstance(groups, list):\n        groups = groups.getInfo()\n\n    groups.sort(key=int)\n\n    for group in groups:\n        if verbose:\n            print(f\"Calculating area for group {group} ...\")\n        area = image_area(img.eq(float(group)), region, scale, denominator)\n        values.append(area.values().get(0).getInfo())\n\n    d = {\"group\": groups, \"area\": values}\n    df = pd.DataFrame(data=d)\n    df = df.set_index(\"group\")\n    df[\"percentage\"] = df[\"area\"] / df[\"area\"].sum()\n    df = df.astype(float).round(decimal_places)\n    if isinstance(labels, list) and len(labels) == len(values):\n        df[\"labels\"] = labels\n\n    if out_csv is not None:\n        df.to_csv(out_csv)\n    else:\n        return df\n</code></pre>"},{"location":"common/#geemap.common.image_band_names","title":"<code>image_band_names(img)</code>","text":"<p>Gets image band names.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The input image.</p> required <p>Returns:</p> Type Description <code>ee.List</code> <p>The returned list of image band names.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_band_names(img):\n\"\"\"Gets image band names.\n\n    Args:\n        img (ee.Image): The input image.\n\n    Returns:\n        ee.List: The returned list of image band names.\n    \"\"\"\n    return img.bandNames()\n</code></pre>"},{"location":"common/#geemap.common.image_bandcount","title":"<code>image_bandcount(image, **kwargs)</code>","text":"<p>Get the number of bands in an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of bands in the image.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_bandcount(image, **kwargs):\n\"\"\"Get the number of bands in an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        int: The number of bands in the image.\n    \"\"\"\n\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return len(client.metadata()[\"bands\"])\n</code></pre>"},{"location":"common/#geemap.common.image_bounds","title":"<code>image_bounds(image, **kwargs)</code>","text":"<p>Get the bounds of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of bounds in the form of [(south, west), (north, east)].</p> Source code in <code>geemap/common.py</code> <pre><code>def image_bounds(image, **kwargs):\n\"\"\"Get the bounds of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        list: A list of bounds in the form of [(south, west), (north, east)].\n    \"\"\"\n\n    image_check(image)\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    bounds = client.bounds()\n    return [(bounds[0], bounds[2]), (bounds[1], bounds[3])]\n</code></pre>"},{"location":"common/#geemap.common.image_cell_size","title":"<code>image_cell_size(img)</code>","text":"<p>Retrieves the image cell size (e.g., spatial resolution)</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>ee.Image</p> required <p>Returns:</p> Type Description <code>float</code> <p>The nominal scale in meters.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_cell_size(img):\n\"\"\"Retrieves the image cell size (e.g., spatial resolution)\n\n    Args:\n        img (object): ee.Image\n\n    Returns:\n        float: The nominal scale in meters.\n    \"\"\"\n    bands = img.bandNames()\n    scales = bands.map(lambda b: img.select([b]).projection().nominalScale())\n    scale = ee.Algorithms.If(\n        scales.distinct().size().gt(1),\n        ee.Dictionary.fromLists(bands.getInfo(), scales),\n        scales.get(0),\n    )\n    return scale\n</code></pre>"},{"location":"common/#geemap.common.image_center","title":"<code>image_center(image, **kwargs)</code>","text":"<p>Get the center of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (latitude, longitude).</p> Source code in <code>geemap/common.py</code> <pre><code>def image_center(image, **kwargs):\n\"\"\"Get the center of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        tuple: A tuple of (latitude, longitude).\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.center()\n</code></pre>"},{"location":"common/#geemap.common.image_client","title":"<code>image_client(image, **kwargs)</code>","text":"<p>Get a LocalTileserver TileClient from an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>TileClient</code> <p>A LocalTileserver TileClient.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_client(image, **kwargs):\n\"\"\"Get a LocalTileserver TileClient from an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        TileClient: A LocalTileserver TileClient.\n    \"\"\"\n    image_check(image)\n\n    _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    return client\n</code></pre>"},{"location":"common/#geemap.common.image_convolution","title":"<code>image_convolution(image, kernel=None, resample=None, projection='EPSG:3857', **kwargs)</code>","text":"<p>Performs a convolution on an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image | ee.ImageCollection</code> <p>The image to convolve.</p> required <code>kernel</code> <code>ee.Kernel</code> <p>The kernel to convolve with. Defaults to None, a 7x7 gaussian kernel.</p> <code>None</code> <code>resample</code> <code>str</code> <p>The resample method to use. It can be either 'bilinear' or 'bicubic'\". Defaults to None, which uses the image's resample method.</p> <code>None</code> <code>projection</code> <code>str</code> <p>The projection to use. Defaults to 'EPSG:3857'.</p> <code>'EPSG:3857'</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The convolved image.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_convolution(\n    image, kernel=None, resample=None, projection=\"EPSG:3857\", **kwargs\n):\n\"\"\"Performs a convolution on an image.\n\n    Args:\n        image (ee.Image | ee.ImageCollection): The image to convolve.\n        kernel (ee.Kernel, optional): The kernel to convolve with. Defaults to None, a 7x7 gaussian kernel.\n        resample (str, optional): The resample method to use. It can be either 'bilinear' or 'bicubic'\". Defaults to None, which uses the image's resample method.\n        projection (str, optional): The projection to use. Defaults to 'EPSG:3857'.\n\n    Returns:\n        ee.Image: The convolved image.\n    \"\"\"\n    if isinstance(image, ee.ImageCollection):\n        image = image.mosaic()\n    elif not isinstance(image, ee.Image):\n        raise ValueError(\"image must be an ee.Image or ee.ImageCollection.\")\n\n    if kernel is None:\n        kernel = ee.Kernel.gaussian(radius=3, sigma=2, units=\"pixels\", normalize=True)\n    elif not isinstance(kernel, ee.Kernel):\n        raise ValueError(\"kernel must be an ee.Kernel.\")\n\n    if resample is not None:\n        if resample not in [\"bilinear\", \"bicubic\"]:\n            raise ValueError(\"resample must be one of 'bilinear' or 'bicubic'\")\n\n    result = image.convolve(kernel)\n\n    if resample is not None:\n        result = result.resample(resample)\n\n    return result.setDefaultProjection(projection)\n</code></pre>"},{"location":"common/#geemap.common.image_count","title":"<code>image_count(collection, region=None, band=None, start_date=None, end_date=None, clip=False)</code>","text":"<p>Create an image with the number of available images for a specific region.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>ee.ImageCollection</code> <p>The collection to be queried.</p> required <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region to be queried.</p> <code>None</code> <code>start_date</code> <code>str | ee.Date</code> <p>The start date of the query.</p> <code>None</code> <code>band</code> <code>str</code> <p>The band to be queried.</p> <code>None</code> <code>end_date</code> <code>str | ee.Date</code> <p>The end date of the query.</p> <code>None</code> <code>clip</code> <code>bool</code> <p>Whether to clip the image to the region.</p> <code>False</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The image with each pixel value representing the number of available images.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_count(\n    collection, region=None, band=None, start_date=None, end_date=None, clip=False\n):\n\"\"\"Create an image with the number of available images for a specific region.\n    Args:\n        collection (ee.ImageCollection): The collection to be queried.\n        region (ee.Geometry | ee.FeatureCollection, optional): The region to be queried.\n        start_date (str | ee.Date, optional): The start date of the query.\n        band (str, optional): The band to be queried.\n        end_date (str | ee.Date, optional): The end date of the query.\n        clip (bool, optional): Whether to clip the image to the region.\n\n    Returns:\n        ee.Image: The image with each pixel value representing the number of available images.\n    \"\"\"\n    if not isinstance(collection, ee.ImageCollection):\n        raise TypeError(\"collection must be an ee.ImageCollection.\")\n\n    if region is not None:\n        if isinstance(region, ee.Geometry) or isinstance(region, ee.FeatureCollection):\n            pass\n        else:\n            raise TypeError(\"region must be an ee.Geometry or ee.FeatureCollection.\")\n\n    if (start_date is not None) and (end_date is not None):\n        pass\n    elif (start_date is None) and (end_date is None):\n        pass\n    else:\n        raise ValueError(\"start_date and end_date must be provided.\")\n\n    if band is None:\n        first_image = collection.first()\n        band = first_image.bandNames().get(0)\n\n    if region is not None:\n        collection = collection.filterBounds(region)\n\n    if start_date is not None and end_date is not None:\n        collection = collection.filterDate(start_date, end_date)\n\n    image = (\n        collection.filter(ee.Filter.listContains(\"system:band_names\", band))\n        .select([band])\n        .reduce(ee.Reducer.count())\n    )\n\n    if clip:\n        image = image.clip(region)\n\n    return image\n</code></pre>"},{"location":"common/#geemap.common.image_date","title":"<code>image_date(img, date_format='YYYY-MM-dd')</code>","text":"<p>Retrieves the image acquisition date.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>ee.Image</p> required <code>date_format</code> <code>str</code> <p>The date format to use. Defaults to 'YYYY-MM-dd'.</p> <code>'YYYY-MM-dd'</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the acquisition of the image.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_date(img, date_format=\"YYYY-MM-dd\"):\n\"\"\"Retrieves the image acquisition date.\n\n    Args:\n        img (object): ee.Image\n        date_format (str, optional): The date format to use. Defaults to 'YYYY-MM-dd'.\n\n    Returns:\n        str: A string representing the acquisition of the image.\n    \"\"\"\n    return ee.Date(img.get(\"system:time_start\")).format(date_format)\n</code></pre>"},{"location":"common/#geemap.common.image_dates","title":"<code>image_dates(img_col, date_format='YYYY-MM-dd')</code>","text":"<p>Get image dates of all images in an ImageCollection.</p> <p>Parameters:</p> Name Type Description Default <code>img_col</code> <code>object</code> <p>ee.ImageCollection</p> required <code>date_format</code> <code>str</code> <p>A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html; if omitted will use ISO standard date formatting. Defaults to 'YYYY-MM-dd'.</p> <code>'YYYY-MM-dd'</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.List</p> Source code in <code>geemap/common.py</code> <pre><code>def image_dates(img_col, date_format=\"YYYY-MM-dd\"):\n\"\"\"Get image dates of all images in an ImageCollection.\n\n    Args:\n        img_col (object): ee.ImageCollection\n        date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html; if omitted will use ISO standard date formatting. Defaults to 'YYYY-MM-dd'.\n\n    Returns:\n        object: ee.List\n    \"\"\"\n    dates = img_col.aggregate_array(\"system:time_start\")\n    new_dates = dates.map(lambda d: ee.Date(d).format(date_format))\n    return new_dates\n</code></pre>"},{"location":"common/#geemap.common.image_geotransform","title":"<code>image_geotransform(image, **kwargs)</code>","text":"<p>Get the geotransform of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of geotransform values.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_geotransform(image, **kwargs):\n\"\"\"Get the geotransform of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        list: A list of geotransform values.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"GeoTransform\"]\n</code></pre>"},{"location":"common/#geemap.common.image_histogram","title":"<code>image_histogram(img, region=None, scale=None, x_label=None, y_label=None, title=None, width=None, height=500, plot_args={}, layout_args={}, return_df=False, **kwargs)</code>","text":"<p>Create a histogram of an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The image to calculate the histogram.</p> required <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>x_label</code> <code>str</code> <p>Label for the x axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>str</code> <p>Label for the y axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the plot in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the plot in pixels. Defaults to 500.</p> <code>500</code> <code>layout_args</code> <code>dict</code> <p>Layout arguments for the plot to be passed to fig.update_layout(),</p> <code>{}</code> <code>return_df</code> <code>bool</code> <p>If True, return a pandas dataframe. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>pandas DataFrame | plotly figure object</code> <p>A dataframe or plotly figure object.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_histogram(\n    img,\n    region=None,\n    scale=None,\n    x_label=None,\n    y_label=None,\n    title=None,\n    width=None,\n    height=500,\n    plot_args={},\n    layout_args={},\n    return_df=False,\n    **kwargs,\n):\n\"\"\"Create a histogram of an image.\n\n    Args:\n        img (ee.Image): The image to calculate the histogram.\n        region (ee.Geometry | ee.FeatureCollection, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        x_label (str, optional): Label for the x axis. Defaults to None.\n        y_label (str, optional): Label for the y axis. Defaults to None.\n        title (str, optional): Title for the plot. Defaults to None.\n        width (int, optional): Width of the plot in pixels. Defaults to None.\n        height (int, optional): Height of the plot in pixels. Defaults to 500.\n        layout_args (dict, optional): Layout arguments for the plot to be passed to fig.update_layout(),\n        return_df (bool, optional): If True, return a pandas dataframe. Defaults to False.\n\n    Returns:\n        pandas DataFrame | plotly figure object: A dataframe or plotly figure object.\n    \"\"\"\n    import pandas as pd\n    import plotly.express as px\n\n    hist = image_value_list(img, region, scale, return_hist=True, **kwargs).getInfo()\n    keys = sorted(hist, key=int)\n    values = [hist.get(key) for key in keys]\n\n    data = pd.DataFrame({\"key\": keys, \"value\": values})\n\n    if return_df:\n        return data\n    else:\n        labels = {}\n\n        if x_label is not None:\n            labels[\"key\"] = x_label\n        if y_label is not None:\n            labels[\"value\"] = y_label\n\n        try:\n            fig = px.bar(\n                data,\n                x=\"key\",\n                y=\"value\",\n                labels=labels,\n                title=title,\n                width=width,\n                height=height,\n                **plot_args,\n            )\n\n            if isinstance(layout_args, dict):\n                fig.update_layout(**layout_args)\n\n            return fig\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.image_max_value","title":"<code>image_max_value(img, region=None, scale=None)</code>","text":"<p>Retrieves the maximum value of an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>The image to calculate the maximum value.</p> required <code>region</code> <code>object</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.Number</p> Source code in <code>geemap/common.py</code> <pre><code>def image_max_value(img, region=None, scale=None):\n\"\"\"Retrieves the maximum value of an image.\n\n    Args:\n        img (object): The image to calculate the maximum value.\n        region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n\n    Returns:\n        object: ee.Number\n    \"\"\"\n    if region is None:\n        region = img.geometry()\n\n    if scale is None:\n        scale = image_scale(img)\n\n    max_value = img.reduceRegion(\n        **{\n            \"reducer\": ee.Reducer.max(),\n            \"geometry\": region,\n            \"scale\": scale,\n            \"maxPixels\": 1e12,\n            \"bestEffort\": True,\n        }\n    )\n    return max_value\n</code></pre>"},{"location":"common/#geemap.common.image_mean_value","title":"<code>image_mean_value(img, region=None, scale=None)</code>","text":"<p>Retrieves the mean value of an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>The image to calculate the mean value.</p> required <code>region</code> <code>object</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.Number</p> Source code in <code>geemap/common.py</code> <pre><code>def image_mean_value(img, region=None, scale=None):\n\"\"\"Retrieves the mean value of an image.\n\n    Args:\n        img (object): The image to calculate the mean value.\n        region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n\n    Returns:\n        object: ee.Number\n    \"\"\"\n    if region is None:\n        region = img.geometry()\n\n    if scale is None:\n        scale = image_scale(img)\n\n    mean_value = img.reduceRegion(\n        **{\n            \"reducer\": ee.Reducer.mean(),\n            \"geometry\": region,\n            \"scale\": scale,\n            \"maxPixels\": 1e12,\n            \"bestEffort\": True,\n        }\n    )\n    return mean_value\n</code></pre>"},{"location":"common/#geemap.common.image_metadata","title":"<code>image_metadata(image, **kwargs)</code>","text":"<p>Get the metadata of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of image metadata.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_metadata(image, **kwargs):\n\"\"\"Get the metadata of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        dict: A dictionary of image metadata.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()\n</code></pre>"},{"location":"common/#geemap.common.image_min_value","title":"<code>image_min_value(img, region=None, scale=None)</code>","text":"<p>Retrieves the minimum value of an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>The image to calculate the minimum value.</p> required <code>region</code> <code>object</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.Number</p> Source code in <code>geemap/common.py</code> <pre><code>def image_min_value(img, region=None, scale=None):\n\"\"\"Retrieves the minimum value of an image.\n\n    Args:\n        img (object): The image to calculate the minimum value.\n        region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n\n    Returns:\n        object: ee.Number\n    \"\"\"\n    if region is None:\n        region = img.geometry()\n\n    if scale is None:\n        scale = image_scale(img)\n\n    min_value = img.reduceRegion(\n        **{\n            \"reducer\": ee.Reducer.min(),\n            \"geometry\": region,\n            \"scale\": scale,\n            \"maxPixels\": 1e12,\n            \"bestEffort\": True,\n        }\n    )\n    return min_value\n</code></pre>"},{"location":"common/#geemap.common.image_projection","title":"<code>image_projection(image, **kwargs)</code>","text":"<p>Get the projection of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The projection of the image.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_projection(image, **kwargs):\n\"\"\"Get the projection of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        str: The projection of the image.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"Projection\"]\n</code></pre>"},{"location":"common/#geemap.common.image_props","title":"<code>image_props(img, date_format='YYYY-MM-dd')</code>","text":"<p>Gets image properties.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The input image.</p> required <code>date_format</code> <code>str</code> <p>The output date format. Defaults to 'YYYY-MM-dd HH:mm:ss'.</p> <code>'YYYY-MM-dd'</code> <p>Returns:</p> Type Description <code>dd.Dictionary</code> <p>The dictionary containing image properties.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_props(img, date_format=\"YYYY-MM-dd\"):\n\"\"\"Gets image properties.\n\n    Args:\n        img (ee.Image): The input image.\n        date_format (str, optional): The output date format. Defaults to 'YYYY-MM-dd HH:mm:ss'.\n\n    Returns:\n        dd.Dictionary: The dictionary containing image properties.\n    \"\"\"\n    if not isinstance(img, ee.Image):\n        print(\"The input object must be an ee.Image\")\n        return\n\n    keys = img.propertyNames().remove(\"system:footprint\").remove(\"system:bands\")\n    values = keys.map(lambda p: img.get(p))\n    props = ee.Dictionary.fromLists(keys, values)\n\n    names = keys.getInfo()\n\n    bands = img.bandNames()\n    scales = bands.map(lambda b: img.select([b]).projection().nominalScale())\n    scale = ee.Algorithms.If(\n        scales.distinct().size().gt(1),\n        ee.Dictionary.fromLists(bands.getInfo(), scales),\n        scales.get(0),\n    )\n\n    props = props.set(\"NOMINAL_SCALE\", scale)\n\n    if \"system:time_start\" in names:\n        image_date = ee.Date(img.get(\"system:time_start\")).format(date_format)\n        time_start = ee.Date(img.get(\"system:time_start\")).format(\"YYYY-MM-dd HH:mm:ss\")\n        # time_end = ee.Date(img.get('system:time_end')).format('YYYY-MM-dd HH:mm:ss')\n        time_end = ee.Algorithms.If(\n            ee.List(img.propertyNames()).contains(\"system:time_end\"),\n            ee.Date(img.get(\"system:time_end\")).format(\"YYYY-MM-dd HH:mm:ss\"),\n            time_start,\n        )\n        props = props.set(\"system:time_start\", time_start)\n        props = props.set(\"system:time_end\", time_end)\n        props = props.set(\"IMAGE_DATE\", image_date)\n\n    if \"system:asset_size\" in names:\n        asset_size = (\n            ee.Number(img.get(\"system:asset_size\"))\n            .divide(1e6)\n            .format()\n            .cat(ee.String(\" MB\"))\n        )\n\n        props = props.set(\"system:asset_size\", asset_size)\n\n    return props\n</code></pre>"},{"location":"common/#geemap.common.image_reclassify","title":"<code>image_reclassify(img, in_list, out_list)</code>","text":"<p>Reclassify an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>The image to which the remapping is applied.</p> required <code>in_list</code> <code>list</code> <p>The source values (numbers or EEArrays). All values in this list will be mapped to the corresponding value in 'out_list'.</p> required <code>out_list</code> <code>list</code> <p>The destination values (numbers or EEArrays). These are used to replace the corresponding values in 'from'. Must have the same number of values as 'in_list'.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.Image</p> Source code in <code>geemap/common.py</code> <pre><code>def image_reclassify(img, in_list, out_list):\n\"\"\"Reclassify an image.\n\n    Args:\n        img (object): The image to which the remapping is applied.\n        in_list (list): The source values (numbers or EEArrays). All values in this list will be mapped to the corresponding value in 'out_list'.\n        out_list (list): The destination values (numbers or EEArrays). These are used to replace the corresponding values in 'from'. Must have the same number of values as 'in_list'.\n\n    Returns:\n        object: ee.Image\n    \"\"\"\n    image = img.remap(in_list, out_list)\n    return image\n</code></pre>"},{"location":"common/#geemap.common.image_resolution","title":"<code>image_resolution(image, **kwargs)</code>","text":"<p>Get the resolution of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The resolution of the image.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_resolution(image, **kwargs):\n\"\"\"Get the resolution of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        float: The resolution of the image.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"GeoTransform\"][1]\n</code></pre>"},{"location":"common/#geemap.common.image_scale","title":"<code>image_scale(img)</code>","text":"<p>Retrieves the image cell size (e.g., spatial resolution)</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>ee.Image</p> required <p>Returns:</p> Type Description <code>float</code> <p>The nominal scale in meters.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_scale(img):\n\"\"\"Retrieves the image cell size (e.g., spatial resolution)\n\n    Args:\n        img (object): ee.Image\n\n    Returns:\n        float: The nominal scale in meters.\n    \"\"\"\n    # bands = img.bandNames()\n    # scales = bands.map(lambda b: img.select([b]).projection().nominalScale())\n    # scale = ee.Algorithms.If(scales.distinct().size().gt(1), ee.Dictionary.fromLists(bands.getInfo(), scales), scales.get(0))\n    return img.select(0).projection().nominalScale()\n</code></pre>"},{"location":"common/#geemap.common.image_set_crs","title":"<code>image_set_crs(image, epsg)</code>","text":"<p>Define the CRS of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath</p> required <code>epsg</code> <code>int</code> <p>The EPSG code of the CRS to set.</p> required Source code in <code>geemap/common.py</code> <pre><code>def image_set_crs(image, epsg):\n\"\"\"Define the CRS of an image.\n\n    Args:\n        image (str): The input image filepath\n        epsg (int): The EPSG code of the CRS to set.\n    \"\"\"\n\n    from rasterio.crs import CRS\n    import rasterio\n\n    with rasterio.open(image, \"r+\") as rds:\n        rds.crs = CRS.from_epsg(epsg)\n</code></pre>"},{"location":"common/#geemap.common.image_size","title":"<code>image_size(image, **kwargs)</code>","text":"<p>Get the size (width, height) of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (width, height).</p> Source code in <code>geemap/common.py</code> <pre><code>def image_size(image, **kwargs):\n\"\"\"Get the size (width, height) of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        tuple: A tuple of (width, height).\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n\n    metadata = client.metadata()\n    return metadata[\"sourceSizeX\"], metadata[\"sourceSizeY\"]\n</code></pre>"},{"location":"common/#geemap.common.image_smoothing","title":"<code>image_smoothing(img, reducer, kernel)</code>","text":"<p>Smooths an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>The image to be smoothed.</p> required <code>reducer</code> <code>object</code> <p>ee.Reducer</p> required <code>kernel</code> <code>object</code> <p>ee.Kernel</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.Image</p> Source code in <code>geemap/common.py</code> <pre><code>def image_smoothing(img, reducer, kernel):\n\"\"\"Smooths an image.\n\n    Args:\n        img (object): The image to be smoothed.\n        reducer (object): ee.Reducer\n        kernel (object): ee.Kernel\n\n    Returns:\n        object: ee.Image\n    \"\"\"\n    image = img.reduceNeighborhood(\n        **{\n            \"reducer\": reducer,\n            \"kernel\": kernel,\n        }\n    )\n    return image\n</code></pre>"},{"location":"common/#geemap.common.image_stats","title":"<code>image_stats(img, region=None, scale=None)</code>","text":"<p>Gets image descriptive statistics.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The input image to calculate descriptive statistics.</p> required <code>region</code> <code>object</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.Dictionary</code> <p>A dictionary containing the description statistics of the input image.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_stats(img, region=None, scale=None):\n\"\"\"Gets image descriptive statistics.\n\n    Args:\n        img (ee.Image): The input image to calculate descriptive statistics.\n        region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n\n    Returns:\n        ee.Dictionary: A dictionary containing the description statistics of the input image.\n    \"\"\"\n\n    if not isinstance(img, ee.Image):\n        print(\"The input object must be an ee.Image\")\n        return\n\n    stat_types = [\"min\", \"max\", \"mean\", \"std\", \"sum\"]\n\n    image_min = image_min_value(img, region, scale)\n    image_max = image_max_value(img, region, scale)\n    image_mean = image_mean_value(img, region, scale)\n    image_std = image_std_value(img, region, scale)\n    image_sum = image_sum_value(img, region, scale)\n\n    stat_results = ee.List([image_min, image_max, image_mean, image_std, image_sum])\n\n    stats = ee.Dictionary.fromLists(stat_types, stat_results)\n\n    return stats\n</code></pre>"},{"location":"common/#geemap.common.image_stats_by_zone","title":"<code>image_stats_by_zone(image, zones, out_csv=None, labels=None, region=None, scale=None, reducer='MEAN', bestEffort=True, **kwargs)</code>","text":"<p>Calculate statistics for an image by zone.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The image to calculate statistics for.</p> required <code>zones</code> <code>ee.Image</code> <p>The zones to calculate statistics for.</p> required <code>out_csv</code> <code>str</code> <p>The path to the output CSV file. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>The list of zone labels to use for the output CSV. Defaults to None.</p> <code>None</code> <code>region</code> <code>ee.Geometry</code> <p>The region over which to reduce data. Defaults to the footprint of zone image.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>reducer</code> <code>str | ee.Reducer</code> <p>The reducer to use. It can be one of MEAN, MAXIMUM, MINIMUM, MODE, STD, MIN_MAX, SUM, VARIANCE. Defaults to MEAN.</p> <code>'MEAN'</code> <code>bestEffort</code> <code>bool</code> <p>If the polygon would contain too many pixels at the given scale, compute and use a larger scale which would allow the operation to succeed. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str | pd.DataFrame</code> <p>The path to the output CSV file or a pandas DataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_stats_by_zone(\n    image,\n    zones,\n    out_csv=None,\n    labels=None,\n    region=None,\n    scale=None,\n    reducer=\"MEAN\",\n    bestEffort=True,\n    **kwargs,\n):\n\"\"\"Calculate statistics for an image by zone.\n\n    Args:\n        image (ee.Image): The image to calculate statistics for.\n        zones (ee.Image): The zones to calculate statistics for.\n        out_csv (str, optional): The path to the output CSV file. Defaults to None.\n        labels (list, optional): The list of zone labels to use for the output CSV. Defaults to None.\n        region (ee.Geometry, optional): The region over which to reduce data. Defaults to the footprint of zone image.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        reducer (str | ee.Reducer, optional): The reducer to use. It can be one of MEAN, MAXIMUM, MINIMUM, MODE, STD, MIN_MAX, SUM, VARIANCE. Defaults to MEAN.\n        bestEffort (bool, optional): If the polygon would contain too many pixels at the given scale, compute and use a larger scale which would allow the operation to succeed. Defaults to True.\n\n    Returns:\n        str | pd.DataFrame: The path to the output CSV file or a pandas DataFrame.\n    \"\"\"\n    import pandas as pd\n\n    if region is not None:\n        if isinstance(region, ee.Geometry):\n            pass\n        elif isinstance(region, ee.FeatureCollection):\n            region = region.geometry()\n        else:\n            raise ValueError(\"region must be an ee.Geometry or ee.FeatureCollection\")\n\n    if scale is None:\n        scale = image_scale(image)\n\n    allowed_stats = {\n        \"MEAN\": ee.Reducer.mean(),\n        \"MAXIMUM\": ee.Reducer.max(),\n        \"MEDIAN\": ee.Reducer.median(),\n        \"MINIMUM\": ee.Reducer.min(),\n        \"MODE\": ee.Reducer.mode(),\n        \"STD\": ee.Reducer.stdDev(),\n        \"MIN_MAX\": ee.Reducer.minMax(),\n        \"SUM\": ee.Reducer.sum(),\n        \"VARIANCE\": ee.Reducer.variance(),\n    }\n\n    if isinstance(reducer, str):\n        if reducer.upper() not in allowed_stats:\n            raise ValueError(\n                \"reducer must be one of: {}\".format(\", \".join(allowed_stats.keys()))\n            )\n        else:\n            reducer = allowed_stats[reducer.upper()]\n    elif isinstance(reducer, ee.Reducer):\n        pass\n    else:\n        raise ValueError(\n            \"reducer must be one of: {}\".format(\", \".join(allowed_stats.keys()))\n        )\n\n    values = image_value_list(zones, region=region)\n    values = values.map(lambda x: ee.Number.parse(x))\n\n    def get_stats(value):\n        img = image.updateMask(zones.eq(ee.Number(value)))\n        kwargs[\"reducer\"] = reducer\n        kwargs[\"scale\"] = scale\n        kwargs[\"geometry\"] = region\n        kwargs[\"bestEffort\"] = bestEffort\n        stat = img.reduceRegion(**kwargs)\n        return ee.Image().set({\"zone\": value}).set({\"stat\": stat.values().get(0)})\n\n    collection = ee.ImageCollection(values.map(lambda x: get_stats(x)))\n    keys = collection.aggregate_array(\"zone\").getInfo()\n    values = collection.aggregate_array(\"stat\").getInfo()\n\n    if labels is not None and isinstance(labels, list):\n        if len(labels) != len(keys):\n            warnings.warn(\"labels are not the same length as keys, ignoring labels.\")\n            df = pd.DataFrame({\"zone\": keys, \"stat\": values})\n        else:\n            df = pd.DataFrame({\"zone\": keys, \"label\": labels, \"stat\": values})\n    else:\n        df = pd.DataFrame({\"zone\": keys, \"stat\": values})\n\n    if out_csv is not None:\n        check_file_path(out_csv)\n        df.to_csv(out_csv, index=False)\n        return out_csv\n    else:\n        return df\n</code></pre>"},{"location":"common/#geemap.common.image_std_value","title":"<code>image_std_value(img, region=None, scale=None)</code>","text":"<p>Retrieves the standard deviation of an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>The image to calculate the standard deviation.</p> required <code>region</code> <code>object</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.Number</p> Source code in <code>geemap/common.py</code> <pre><code>def image_std_value(img, region=None, scale=None):\n\"\"\"Retrieves the standard deviation of an image.\n\n    Args:\n        img (object): The image to calculate the standard deviation.\n        region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n\n    Returns:\n        object: ee.Number\n    \"\"\"\n    if region is None:\n        region = img.geometry()\n\n    if scale is None:\n        scale = image_scale(img)\n\n    std_value = img.reduceRegion(\n        **{\n            \"reducer\": ee.Reducer.stdDev(),\n            \"geometry\": region,\n            \"scale\": scale,\n            \"maxPixels\": 1e12,\n            \"bestEffort\": True,\n        }\n    )\n    return std_value\n</code></pre>"},{"location":"common/#geemap.common.image_sum_value","title":"<code>image_sum_value(img, region=None, scale=None)</code>","text":"<p>Retrieves the sum of an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>The image to calculate the standard deviation.</p> required <code>region</code> <code>object</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.Number</p> Source code in <code>geemap/common.py</code> <pre><code>def image_sum_value(img, region=None, scale=None):\n\"\"\"Retrieves the sum of an image.\n\n    Args:\n        img (object): The image to calculate the standard deviation.\n        region (object, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n\n    Returns:\n        object: ee.Number\n    \"\"\"\n    if region is None:\n        region = img.geometry()\n\n    if scale is None:\n        scale = image_scale(img)\n\n    sum_value = img.reduceRegion(\n        **{\n            \"reducer\": ee.Reducer.sum(),\n            \"geometry\": region,\n            \"scale\": scale,\n            \"maxPixels\": 1e12,\n            \"bestEffort\": True,\n        }\n    )\n    return sum_value\n</code></pre>"},{"location":"common/#geemap.common.image_to_cog","title":"<code>image_to_cog(source, dst_path=None, profile='deflate', **kwargs)</code>","text":"<p>Converts an image to a COG file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>A dataset path, URL or rasterio.io.DatasetReader object.</p> required <code>dst_path</code> <code>str</code> <p>An output dataset path or or PathLike object. Defaults to None.</p> <code>None</code> <code>profile</code> <code>str</code> <p>COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".</p> <code>'deflate'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If rio-cogeo is not installed.</p> <code>FileNotFoundError</code> <p>If the source file could not be found.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_to_cog(source, dst_path=None, profile=\"deflate\", **kwargs):\n\"\"\"Converts an image to a COG file.\n\n    Args:\n        source (str): A dataset path, URL or rasterio.io.DatasetReader object.\n        dst_path (str, optional): An output dataset path or or PathLike object. Defaults to None.\n        profile (str, optional): COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".\n\n    Raises:\n        ImportError: If rio-cogeo is not installed.\n        FileNotFoundError: If the source file could not be found.\n    \"\"\"\n    try:\n        from rio_cogeo.cogeo import cog_translate\n        from rio_cogeo.profiles import cog_profiles\n\n    except ImportError:\n        raise ImportError(\n            \"The rio-cogeo package is not installed. Please install it with `pip install rio-cogeo` or `conda install rio-cogeo -c conda-forge`.\"\n        )\n\n    if not source.startswith(\"http\"):\n        source = check_file_path(source)\n\n        if not os.path.exists(source):\n            raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    if dst_path is None:\n        if not source.startswith(\"http\"):\n            dst_path = os.path.splitext(source)[0] + \"_cog.tif\"\n        else:\n            dst_path = temp_file_path(extension=\".tif\")\n\n    dst_path = check_file_path(dst_path)\n\n    dst_profile = cog_profiles.get(profile)\n    cog_translate(source, dst_path, dst_profile, **kwargs)\n</code></pre>"},{"location":"common/#geemap.common.image_to_numpy","title":"<code>image_to_numpy(image)</code>","text":"<p>Converts an image to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>A dataset path, URL or rasterio.io.DatasetReader object.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the provided file could not be found.</p> <p>Returns:</p> Type Description <code>np.array</code> <p>A numpy array.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_to_numpy(image):\n\"\"\"Converts an image to a numpy array.\n\n    Args:\n        image (str): A dataset path, URL or rasterio.io.DatasetReader object.\n\n    Raises:\n        FileNotFoundError: If the provided file could not be found.\n\n    Returns:\n        np.array: A numpy array.\n    \"\"\"\n    import rasterio\n\n    if not os.path.exists(image):\n        raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    with rasterio.open(image, \"r\") as ds:\n        arr = ds.read()  # read all raster values\n\n    return arr\n</code></pre>"},{"location":"common/#geemap.common.image_value_list","title":"<code>image_value_list(img, region=None, scale=None, return_hist=False, **kwargs)</code>","text":"<p>Get the unique values of an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The image to calculate the unique values.</p> required <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region over which to reduce data. Defaults to the footprint of the image's first band.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>return_hist</code> <code>bool</code> <p>If True, return a histogram of the values. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ee.List | ee.Dictionary</code> <p>A list of unique values or a dictionary containing a list of unique values and a histogram.</p> Source code in <code>geemap/common.py</code> <pre><code>def image_value_list(img, region=None, scale=None, return_hist=False, **kwargs):\n\"\"\"Get the unique values of an image.\n\n    Args:\n        img (ee.Image): The image to calculate the unique values.\n        region (ee.Geometry | ee.FeatureCollection, optional): The region over which to reduce data. Defaults to the footprint of the image's first band.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        return_hist (bool, optional): If True, return a histogram of the values. Defaults to False.\n\n    Returns:\n        ee.List | ee.Dictionary: A list of unique values or a dictionary containing a list of unique values and a histogram.\n    \"\"\"\n    if region is None:\n        geom = img.geometry().bounds()\n        region = ee.FeatureCollection([ee.Feature(geom)])\n    elif isinstance(region, ee.Geometry):\n        region = ee.FeatureCollection([ee.Feature(region)])\n    elif isinstance(region, ee.FeatureCollection):\n        pass\n    else:\n        raise ValueError(\"region must be an ee.Geometry or ee.FeatureCollection\")\n\n    if scale is None:\n        scale = img.select(0).projection().nominalScale().multiply(10)\n\n    reducer = ee.Reducer.frequencyHistogram()\n    kwargs[\"scale\"] = scale\n    kwargs[\"reducer\"] = reducer\n    kwargs[\"collection\"] = region\n\n    result = img.reduceRegions(**kwargs)\n    hist = ee.Dictionary(result.first().get(\"histogram\"))\n    if return_hist:\n        return hist\n    else:\n        return hist.keys()\n</code></pre>"},{"location":"common/#geemap.common.in_colab_shell","title":"<code>in_colab_shell()</code>","text":"<p>Tests if the code is being executed within Google Colab.</p> Source code in <code>geemap/common.py</code> <pre><code>def in_colab_shell():\n\"\"\"Tests if the code is being executed within Google Colab.\"\"\"\n    import sys\n\n    if \"google.colab\" in sys.modules:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#geemap.common.install_from_github","title":"<code>install_from_github(url)</code>","text":"<p>Install a package from a GitHub repository.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the GitHub repository.</p> required Source code in <code>geemap/common.py</code> <pre><code>def install_from_github(url):\n\"\"\"Install a package from a GitHub repository.\n\n    Args:\n        url (str): The URL of the GitHub repository.\n    \"\"\"\n\n    try:\n        download_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        if not os.path.exists(download_dir):\n            os.makedirs(download_dir)\n\n        repo_name = os.path.basename(url)\n        zip_url = os.path.join(url, \"archive/master.zip\")\n        filename = repo_name + \"-master.zip\"\n        download_from_url(\n            url=zip_url, out_file_name=filename, out_dir=download_dir, unzip=True\n        )\n\n        pkg_dir = os.path.join(download_dir, repo_name + \"-master\")\n        pkg_name = os.path.basename(url)\n        work_dir = os.getcwd()\n        os.chdir(pkg_dir)\n        print(f\"Installing {pkg_name}...\")\n        cmd = \"pip install .\"\n        os.system(cmd)\n        os.chdir(work_dir)\n        print(f\"{pkg_name} has been installed successfully.\")\n        # print(\"\\nPlease comment out 'install_from_github()' and restart the kernel to take effect:\\nJupyter menu -&gt; Kernel -&gt; Restart &amp; Clear Output\")\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.is_arcpy","title":"<code>is_arcpy()</code>","text":"<p>Check if arcpy is available.</p> <p>Returns:</p> Type Description <code>book</code> <p>True if arcpy is available, False otherwise.</p> Source code in <code>geemap/common.py</code> <pre><code>def is_arcpy():\n\"\"\"Check if arcpy is available.\n\n    Returns:\n        book: True if arcpy is available, False otherwise.\n    \"\"\"\n    import sys\n\n    if \"arcpy\" in sys.modules:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#geemap.common.is_drive_mounted","title":"<code>is_drive_mounted()</code>","text":"<p>Checks whether Google Drive is mounted in Google Colab.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if Google Drive is mounted, False otherwise.</p> Source code in <code>geemap/common.py</code> <pre><code>def is_drive_mounted():\n\"\"\"Checks whether Google Drive is mounted in Google Colab.\n\n    Returns:\n        bool: Returns True if Google Drive is mounted, False otherwise.\n    \"\"\"\n    drive_path = \"/content/drive/My Drive\"\n    if os.path.exists(drive_path):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#geemap.common.is_latlon_valid","title":"<code>is_latlon_valid(location)</code>","text":"<p>Checks whether a pair of coordinates is valid.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A pair of latlon coordinates separated by comma or space.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if valid.</p> Source code in <code>geemap/common.py</code> <pre><code>def is_latlon_valid(location):\n\"\"\"Checks whether a pair of coordinates is valid.\n\n    Args:\n        location (str): A pair of latlon coordinates separated by comma or space.\n\n    Returns:\n        bool: Returns True if valid.\n    \"\"\"\n    latlon = []\n    if \",\" in location:\n        latlon = [float(x) for x in location.split(\",\")]\n    elif \" \" in location:\n        latlon = [float(x) for x in location.split(\" \")]\n    else:\n        print(\n            \"The coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3\"\n        )\n        return False\n\n    try:\n        lat, lon = float(latlon[0]), float(latlon[1])\n        if lat &gt;= -90 and lat &lt;= 90 and lon &gt;= -180 and lon &lt;= 180:\n            return True\n        else:\n            return False\n    except Exception as e:\n        print(e)\n        return False\n</code></pre>"},{"location":"common/#geemap.common.is_tool","title":"<code>is_tool(name)</code>","text":"<p>Check whether <code>name</code> is on PATH and marked as executable.</p> Source code in <code>geemap/common.py</code> <pre><code>def is_tool(name):\n\"\"\"Check whether `name` is on PATH and marked as executable.\"\"\"\n\n    # from shutil import which\n\n    return shutil.which(name) is not None\n</code></pre>"},{"location":"common/#geemap.common.jpg_to_gif","title":"<code>jpg_to_gif(in_dir, out_gif, fps=10, loop=0)</code>","text":"<p>Convert a list of jpg images to gif.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>The input directory containing jpg images.</p> required <code>out_gif</code> <code>str</code> <p>The output file path to the gif.</p> required <code>fps</code> <code>int</code> <p>Frames per second. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>bool</code> <p>controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>No jpg images could be found.</p> Source code in <code>geemap/common.py</code> <pre><code>def jpg_to_gif(in_dir, out_gif, fps=10, loop=0):\n\"\"\"Convert a list of jpg images to gif.\n\n    Args:\n        in_dir (str): The input directory containing jpg images.\n        out_gif (str): The output file path to the gif.\n        fps (int, optional): Frames per second. Defaults to 10.\n        loop (bool, optional): controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    Raises:\n        FileNotFoundError: No jpg images could be found.\n    \"\"\"\n    import glob\n\n    from PIL import Image\n\n    if not out_gif.endswith(\".gif\"):\n        raise ValueError(\"The out_gif must be a gif file.\")\n\n    out_gif = os.path.abspath(out_gif)\n\n    out_dir = os.path.dirname(out_gif)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    # Create the frames\n    frames = []\n    imgs = list(glob.glob(os.path.join(in_dir, \"*.jpg\")))\n    imgs.sort()\n\n    if len(imgs) == 0:\n        raise FileNotFoundError(f\"No jpg could be found in {in_dir}.\")\n\n    for i in imgs:\n        new_frame = Image.open(i)\n        frames.append(new_frame)\n\n    # Save into a GIF file that loops forever\n    frames[0].save(\n        out_gif,\n        format=\"GIF\",\n        append_images=frames[1:],\n        save_all=True,\n        duration=1000 / fps,\n        loop=loop,\n    )\n</code></pre>"},{"location":"common/#geemap.common.jrc_hist_monthly_history","title":"<code>jrc_hist_monthly_history(collection=None, region=None, start_date='1984-03-16', end_date=None, start_month=1, end_month=12, scale=None, frequency='year', reducer='mean', denominator=10000.0, x_label=None, y_label=None, title=None, width=None, height=None, layout_args={}, return_df=False, **kwargs)</code>","text":"<p>Create a JRC monthly history plot.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>ee.ImageCollection</code> <p>The image collection of JRC surface water monthly history. Default to ee.ImageCollection('JRC/GSW1_4/MonthlyHistory')</p> <code>None</code> <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region to plot. Default to None.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>The start date of the plot. Default to '1984-03-16'.</p> <code>'1984-03-16'</code> <code>end_date</code> <code>str</code> <p>The end date of the plot. Default to the current date.</p> <code>None</code> <code>start_month</code> <code>int</code> <p>The start month of the plot. Default to 1.</p> <code>1</code> <code>end_month</code> <code>int</code> <p>The end month of the plot. Default to 12.</p> <code>12</code> <code>scale</code> <code>float</code> <p>The scale to compute the statistics. Default to None.</p> <code>None</code> <code>frequency</code> <code>str</code> <p>The frequency of the plot. Can be either 'year' or 'month', Default to 'year'.</p> <code>'year'</code> <code>reducer</code> <code>str</code> <p>The reducer to compute the statistics. Can be either 'mean', 'min', 'max', 'median', etc. Default to 'mean'.</p> <code>'mean'</code> <code>denominator</code> <code>int</code> <p>The denominator to convert area from square meters to other units. Default to 1e4, converting to hectares.</p> <code>10000.0</code> <code>x_label</code> <code>str</code> <p>Label for the x axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>str</code> <p>Label for the y axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the plot in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the plot in pixels. Defaults to 500.</p> <code>None</code> <code>layout_args</code> <code>dict</code> <p>Layout arguments for the plot to be passed to fig.update_layout(),</p> <code>{}</code> <code>return_df</code> <code>bool</code> <p>Whether to return the dataframe of the plot. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Pandas dataframe of the plot.</p> Source code in <code>geemap/common.py</code> <pre><code>def jrc_hist_monthly_history(\n    collection=None,\n    region=None,\n    start_date=\"1984-03-16\",\n    end_date=None,\n    start_month=1,\n    end_month=12,\n    scale=None,\n    frequency=\"year\",\n    reducer=\"mean\",\n    denominator=1e4,\n    x_label=None,\n    y_label=None,\n    title=None,\n    width=None,\n    height=None,\n    layout_args={},\n    return_df=False,\n    **kwargs,\n):\n\"\"\"Create a JRC monthly history plot.\n\n    Args:\n        collection (ee.ImageCollection, optional): The image collection of JRC surface water monthly history.\n            Default to ee.ImageCollection('JRC/GSW1_4/MonthlyHistory')\n        region (ee.Geometry | ee.FeatureCollection, optional): The region to plot. Default to None.\n        start_date (str, optional): The start date of the plot. Default to '1984-03-16'.\n        end_date (str, optional): The end date of the plot. Default to the current date.\n        start_month (int, optional): The start month of the plot. Default to 1.\n        end_month (int, optional): The end month of the plot. Default to 12.\n        scale (float, optional): The scale to compute the statistics. Default to None.\n        frequency (str, optional): The frequency of the plot. Can be either 'year' or 'month', Default to 'year'.\n        reducer (str, optional): The reducer to compute the statistics. Can be either 'mean', 'min', 'max', 'median', etc. Default to 'mean'.\n        denominator (int, optional): The denominator to convert area from square meters to other units. Default to 1e4, converting to hectares.\n        x_label (str, optional): Label for the x axis. Defaults to None.\n        y_label (str, optional): Label for the y axis. Defaults to None.\n        title (str, optional): Title for the plot. Defaults to None.\n        width (int, optional): Width of the plot in pixels. Defaults to None.\n        height (int, optional): Height of the plot in pixels. Defaults to 500.\n        layout_args (dict, optional): Layout arguments for the plot to be passed to fig.update_layout(),\n        return_df (bool, optional): Whether to return the dataframe of the plot. Defaults to False.\n\n    Returns:\n        pd.DataFrame: Pandas dataframe of the plot.\n    \"\"\"\n\n    from datetime import date\n    import pandas as pd\n    import plotly.express as px\n\n    if end_date is None:\n        end_date = date.today().strftime(\"%Y-%m-%d\")\n\n    if collection is None:\n        collection = ee.ImageCollection(\"JRC/GSW1_4/MonthlyHistory\")\n\n    if frequency not in [\"year\", \"month\"]:\n        raise ValueError(\"frequency must be 'year' or 'month'.\")\n\n    images = (\n        collection.filterDate(start_date, end_date)\n        .filter(ee.Filter.calendarRange(start_month, end_month, \"month\"))\n        .map(lambda img: img.eq(2).selfMask())\n    )\n\n    def cal_area(img):\n        pixel_area = img.multiply(ee.Image.pixelArea()).divide(denominator)\n        img_area = pixel_area.reduceRegion(\n            **{\n                \"geometry\": region,\n                \"reducer\": ee.Reducer.sum(),\n                \"scale\": scale,\n                \"maxPixels\": 1e12,\n                \"bestEffort\": True,\n            }\n        )\n        return img.set({\"area\": img_area})\n\n    areas = images.map(cal_area)\n    stats = areas.aggregate_array(\"area\").getInfo()\n    values = [item[\"water\"] for item in stats]\n    labels = areas.aggregate_array(\"system:index\").getInfo()\n    months = [label.split(\"_\")[1] for label in labels]\n\n    if frequency == \"month\":\n        area_df = pd.DataFrame({\"Month\": labels, \"Area\": values, \"month\": months})\n    else:\n        dates = [d[:4] for d in labels]\n        data_dict = {\"Date\": labels, \"Year\": dates, \"Area\": values}\n        df = pd.DataFrame(data_dict)\n        result = df.groupby(\"Year\").agg(reducer)\n        area_df = pd.DataFrame({\"Year\": result.index, \"Area\": result[\"Area\"]})\n        area_df = area_df.reset_index(drop=True)\n\n    if return_df:\n        return area_df\n    else:\n        labels = {}\n\n        if x_label is not None:\n            labels[frequency.title()] = x_label\n        if y_label is not None:\n            labels[\"Area\"] = y_label\n\n        fig = px.bar(\n            area_df,\n            x=frequency.title(),\n            y=\"Area\",\n            labels=labels,\n            title=title,\n            width=width,\n            height=height,\n            **kwargs,\n        )\n\n        fig.update_layout(**layout_args)\n\n        return fig\n</code></pre>"},{"location":"common/#geemap.common.kml_to_ee","title":"<code>kml_to_ee(in_kml, **kwargs)</code>","text":"<p>Converts a KML to ee.FeatureColleciton.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The file path to the input KML.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KML could not be found.</p> <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def kml_to_ee(in_kml, **kwargs):\n\"\"\"Converts a KML to ee.FeatureColleciton.\n\n    Args:\n        in_kml (str): The file path to the input KML.\n\n    Raises:\n        FileNotFoundError: The input KML could not be found.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The input KML could not be found.\")\n\n    out_json = os.path.join(os.getcwd(), \"tmp.geojson\")\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    kml_to_geojson(in_kml, out_json, **kwargs)\n    ee_object = geojson_to_ee(out_json)\n    os.remove(out_json)\n    return ee_object\n</code></pre>"},{"location":"common/#geemap.common.kml_to_geojson","title":"<code>kml_to_geojson(in_kml, out_geojson=None, **kwargs)</code>","text":"<p>Converts a KML to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The file path to the input KML.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the output GeoJSON. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KML could not be found.</p> <code>TypeError</code> <p>The output must be a GeoJSON.</p> Source code in <code>geemap/common.py</code> <pre><code>def kml_to_geojson(in_kml, out_geojson=None, **kwargs):\n\"\"\"Converts a KML to GeoJSON.\n\n    Args:\n        in_kml (str): The file path to the input KML.\n        out_geojson (str): The file path to the output GeoJSON. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The input KML could not be found.\n        TypeError: The output must be a GeoJSON.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The input KML could not be found.\")\n\n    if out_geojson is not None:\n        out_geojson = os.path.abspath(out_geojson)\n        ext = os.path.splitext(out_geojson)[1].lower()\n        if ext not in [\".json\", \".geojson\"]:\n            raise TypeError(\"The output file must be a GeoJSON.\")\n\n        out_dir = os.path.dirname(out_geojson)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n    import fiona\n\n    # print(fiona.supported_drivers)\n    fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n    gdf = gpd.read_file(in_kml, driver=\"KML\", **kwargs)\n\n    if out_geojson is not None:\n        gdf.to_file(out_geojson, driver=\"GeoJSON\", **kwargs)\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"common/#geemap.common.kml_to_shp","title":"<code>kml_to_shp(in_kml, out_shp, **kwargs)</code>","text":"<p>Converts a KML to shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The file path to the input KML.</p> required <code>out_shp</code> <code>str</code> <p>The file path to the output shapefile.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KML could not be found.</p> <code>TypeError</code> <p>The output must be a shapefile.</p> Source code in <code>geemap/common.py</code> <pre><code>def kml_to_shp(in_kml, out_shp, **kwargs):\n\"\"\"Converts a KML to shapefile.\n\n    Args:\n        in_kml (str): The file path to the input KML.\n        out_shp (str): The file path to the output shapefile.\n\n    Raises:\n        FileNotFoundError: The input KML could not be found.\n        TypeError: The output must be a shapefile.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The input KML could not be found.\")\n\n    out_shp = os.path.abspath(out_shp)\n    if not out_shp.endswith(\".shp\"):\n        raise TypeError(\"The output must be a shapefile.\")\n\n    out_dir = os.path.dirname(out_shp)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n    import fiona\n\n    # import fiona\n    # print(fiona.supported_drivers)\n    fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n    df = gpd.read_file(in_kml, driver=\"KML\", **kwargs)\n    df.to_file(out_shp, **kwargs)\n</code></pre>"},{"location":"common/#geemap.common.kmz_to_ee","title":"<code>kmz_to_ee(in_kmz, **kwargs)</code>","text":"<p>Converts a KMZ to ee.FeatureColleciton.</p> <p>Parameters:</p> Name Type Description Default <code>in_kmz</code> <code>str</code> <p>The file path to the input KMZ.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KMZ could not be found.</p> <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def kmz_to_ee(in_kmz, **kwargs):\n\"\"\"Converts a KMZ to ee.FeatureColleciton.\n\n    Args:\n        in_kmz (str): The file path to the input KMZ.\n\n    Raises:\n        FileNotFoundError: The input KMZ could not be found.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n    in_kmz = os.path.abspath(in_kmz)\n    if not os.path.exists(in_kmz):\n        raise FileNotFoundError(\"The input KMZ could not be found.\")\n\n    out_dir = os.path.dirname(in_kmz)\n    out_kml = os.path.join(out_dir, \"doc.kml\")\n    with zipfile.ZipFile(in_kmz, \"r\") as zip_ref:\n        zip_ref.extractall(out_dir)\n\n    fc = kml_to_ee(out_kml, **kwargs)\n    os.remove(out_kml)\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.landsat_scaling","title":"<code>landsat_scaling(image, thermal_bands=True, apply_fmask=False)</code>","text":"<p>Apply scaling factors to a Landsat image. See an example at     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T1_L2</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The input Landsat image.</p> required <code>thermal_bands</code> <code>bool</code> <p>Whether to apply scaling to thermal bands. Defaults to True.</p> <code>True</code> <code>apply_fmask</code> <code>bool</code> <p>Whether to apply Fmask cloud mask. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The scaled Landsat image.</p> Source code in <code>geemap/common.py</code> <pre><code>def landsat_scaling(image, thermal_bands=True, apply_fmask=False):\n\"\"\"Apply scaling factors to a Landsat image. See an example at\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T1_L2\n\n    Args:\n        image (ee.Image): The input Landsat image.\n        thermal_bands (bool, optional): Whether to apply scaling to thermal bands. Defaults to True.\n        apply_fmask (bool, optional): Whether to apply Fmask cloud mask. Defaults to False.\n\n    Returns:\n        ee.Image: The scaled Landsat image.\n    \"\"\"\n\n    # Apply the scaling factors to the appropriate bands.\n    opticalBands = image.select(\"SR_B.\").multiply(0.0000275).add(-0.2)\n    if thermal_bands:\n        thermalBands = image.select(\"ST_B.*\").multiply(0.00341802).add(149)\n\n    if apply_fmask:\n        # Replace the original bands with the scaled ones and apply the masks.\n        # Bit 0 - Fill\n        # Bit 1 - Dilated Cloud\n        # Bit 2 - Cirrus\n        # Bit 3 - Cloud\n        # Bit 4 - Cloud Shadow\n        qaMask = image.select(\"QA_PIXEL\").bitwiseAnd(int(\"11111\", 2)).eq(0)\n        if thermal_bands:\n            return (\n                image.addBands(thermalBands, None, True)\n                .addBands(opticalBands, None, True)\n                .updateMask(qaMask)\n            )\n        else:\n            return image.addBands(opticalBands, None, True).updateMask(qaMask)\n\n    else:\n        if thermal_bands:\n            return image.addBands(thermalBands, None, True).addBands(\n                opticalBands, None, True\n            )\n        else:\n            return image.addBands(opticalBands, None, True)\n</code></pre>"},{"location":"common/#geemap.common.latitude_grid","title":"<code>latitude_grid(step=1.0, west=-180, east=180, south=-85, north=85)</code>","text":"<p>Create a latitude grid.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>The step size in degrees. Defaults to 1.0.</p> <code>1.0</code> <code>west</code> <code>int</code> <p>The west boundary in degrees. Defaults to -180.</p> <code>-180</code> <code>east</code> <code>int</code> <p>The east boundary in degrees. Defaults to 180.</p> <code>180</code> <code>south</code> <code>int</code> <p>The south boundary in degrees. Defaults to -85.</p> <code>-85</code> <code>north</code> <code>int</code> <p>The north boundary in degrees. Defaults to 85.</p> <code>85</code> <p>Returns:</p> Type Description <code>ee.FeatureColleciton</code> <p>A feature collection of latitude grids.</p> Source code in <code>geemap/common.py</code> <pre><code>def latitude_grid(step=1.0, west=-180, east=180, south=-85, north=85):\n\"\"\"Create a latitude grid.\n\n    Args:\n        step (float, optional): The step size in degrees. Defaults to 1.0.\n        west (int, optional): The west boundary in degrees. Defaults to -180.\n        east (int, optional): The east boundary in degrees. Defaults to 180.\n        south (int, optional): The south boundary in degrees. Defaults to -85.\n        north (int, optional): The north boundary in degrees. Defaults to 85.\n\n    Returns:\n        ee.FeatureColleciton: A feature collection of latitude grids.\n    \"\"\"\n    values = ee.List.sequence(south, north - step, step)\n\n    def create_feature(lat):\n        return ee.Feature(\n            ee.Geometry.BBox(west, lat, east, ee.Number(lat).add(step))\n        ).set(\n            {\n                \"south\": lat,\n                \"west\": west,\n                \"north\": ee.Number(lat).add(step),\n                \"east\": east,\n            }\n        )\n\n    features = ee.FeatureCollection(values.map(create_feature))\n    return features\n</code></pre>"},{"location":"common/#geemap.common.latlon_from_text","title":"<code>latlon_from_text(location)</code>","text":"<p>Extracts latlon from text.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A pair of latlon coordinates separated by comma or space.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Returns (lat, lon) if valid.</p> Source code in <code>geemap/common.py</code> <pre><code>def latlon_from_text(location):\n\"\"\"Extracts latlon from text.\n\n    Args:\n        location (str): A pair of latlon coordinates separated by comma or space.\n\n    Returns:\n        bool: Returns (lat, lon) if valid.\n    \"\"\"\n    latlon = []\n    try:\n        if \",\" in location:\n            latlon = [float(x) for x in location.split(\",\")]\n        elif \" \" in location:\n            latlon = [float(x) for x in location.split(\" \")]\n        else:\n            print(\n                \"The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3\"\n            )\n            return None\n\n        lat, lon = latlon[0], latlon[1]\n        if lat &gt;= -90 and lat &lt;= 90 and lon &gt;= -180 and lon &lt;= 180:\n            return lat, lon\n        else:\n            return None\n\n    except Exception as e:\n        print(e)\n        print(\n            \"The lat-lon coordinates should be numbers only and separated by comma or space, such as 40.2, -100.3\"\n        )\n        return None\n</code></pre>"},{"location":"common/#geemap.common.latlon_grid","title":"<code>latlon_grid(lat_step=1.0, lon_step=1.0, west=-180, east=180, south=-85, north=85)</code>","text":"<p>Create a retangular grid of latitude and longitude.</p> <p>Parameters:</p> Name Type Description Default <code>lat_step</code> <code>float</code> <p>The step size in degrees. Defaults to 1.0.</p> <code>1.0</code> <code>lon_step</code> <code>float</code> <p>The step size in degrees. Defaults to 1.0.</p> <code>1.0</code> <code>west</code> <code>int</code> <p>The west boundary in degrees. Defaults to -180.</p> <code>-180</code> <code>east</code> <code>int</code> <p>The east boundary in degrees. Defaults to 180.</p> <code>180</code> <code>south</code> <code>int</code> <p>The south boundary in degrees. Defaults to -85.</p> <code>-85</code> <code>north</code> <code>int</code> <p>The north boundary in degrees. Defaults to 85.</p> <code>85</code> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>A feature collection of latitude and longitude grids.</p> Source code in <code>geemap/common.py</code> <pre><code>def latlon_grid(lat_step=1.0, lon_step=1.0, west=-180, east=180, south=-85, north=85):\n\"\"\"Create a retangular grid of latitude and longitude.\n\n    Args:\n        lat_step (float, optional): The step size in degrees. Defaults to 1.0.\n        lon_step (float, optional): The step size in degrees. Defaults to 1.0.\n        west (int, optional): The west boundary in degrees. Defaults to -180.\n        east (int, optional): The east boundary in degrees. Defaults to 180.\n        south (int, optional): The south boundary in degrees. Defaults to -85.\n        north (int, optional): The north boundary in degrees. Defaults to 85.\n\n    Returns:\n        ee.FeatureCollection: A feature collection of latitude and longitude grids.\n    \"\"\"\n    longitudes = ee.List.sequence(west, east - lon_step, lon_step)\n    latitudes = ee.List.sequence(south, north - lat_step, lat_step)\n\n    def create_lat_feature(lat):\n        def create_lon_features(lon):\n            return ee.Feature(\n                ee.Geometry.BBox(\n                    lon, lat, ee.Number(lon).add(lon_step), ee.Number(lat).add(lat_step)\n                )\n            ).set(\n                {\n                    \"south\": lat,\n                    \"west\": lon,\n                    \"north\": ee.Number(lat).add(lat_step),\n                    \"east\": ee.Number(lon).add(lon_step),\n                }\n            )\n\n        return ee.FeatureCollection(longitudes.map(create_lon_features))\n\n    return ee.FeatureCollection(latitudes.map(create_lat_feature)).flatten()\n</code></pre>"},{"location":"common/#geemap.common.legend_from_ee","title":"<code>legend_from_ee(ee_class_table)</code>","text":"<p>Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1</p> <p>Parameters:</p> Name Type Description Default <code>ee_class_table</code> <code>str</code> <p>An Earth Engine class table with triple quotes.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Returns a legend dictionary that can be used to create a legend.</p> Source code in <code>geemap/common.py</code> <pre><code>def legend_from_ee(ee_class_table):\n\"\"\"Extract legend from an Earth Engine class table on the Earth Engine Data Catalog page\n    such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1\n\n    Args:\n        ee_class_table (str): An Earth Engine class table with triple quotes.\n\n    Returns:\n        dict: Returns a legend dictionary that can be used to create a legend.\n    \"\"\"\n    try:\n        ee_class_table = ee_class_table.strip()\n        lines = ee_class_table.split(\"\\n\")[1:]\n\n        if lines[0] == \"Value\\tColor\\tDescription\":\n            lines = lines[1:]\n\n        legend_dict = {}\n        for _, line in enumerate(lines):\n            items = line.split(\"\\t\")\n            items = [item.strip() for item in items]\n            color = items[1]\n            key = items[0] + \" \" + items[2]\n            legend_dict[key] = color\n\n        return legend_dict\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.list_vars","title":"<code>list_vars(var_type=None)</code>","text":"<p>Lists all defined avariables.</p> <p>Parameters:</p> Name Type Description Default <code>var_type</code> <code>object</code> <p>The object type of variables to list. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of all defined variables.</p> Source code in <code>geemap/common.py</code> <pre><code>def list_vars(var_type=None):\n\"\"\"Lists all defined avariables.\n\n    Args:\n        var_type (object, optional): The object type of variables to list. Defaults to None.\n\n    Returns:\n        list: A list of all defined variables.\n    \"\"\"\n    result = []\n\n    for var in globals():\n        reserved_vars = [\n            \"In\",\n            \"Out\",\n            \"get_ipython\",\n            \"exit\",\n            \"quit\",\n            \"json\",\n            \"getsizeof\",\n            \"NamespaceMagics\",\n            \"np\",\n            \"var_dic_list\",\n            \"list_vars\",\n            \"ee\",\n            \"geemap\",\n        ]\n\n        if (not var.startswith(\"_\")) and (var not in reserved_vars):\n            if var_type is not None and isinstance(eval(var), var_type):\n                result.append(var)\n            elif var_type is None:\n                result.append(var)\n\n    return result\n</code></pre>"},{"location":"common/#geemap.common.lnglat_to_meters","title":"<code>lnglat_to_meters(longitude, latitude)</code>","text":"<p>coordinate conversion between lat/lon in decimal degrees to web mercator</p> <p>Parameters:</p> Name Type Description Default <code>longitude</code> <code>float</code> <p>The longitude.</p> required <code>latitude</code> <code>float</code> <p>The latitude.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x, y) in meters.</p> Source code in <code>geemap/common.py</code> <pre><code>def lnglat_to_meters(longitude, latitude):\n\"\"\"coordinate conversion between lat/lon in decimal degrees to web mercator\n\n    Args:\n        longitude (float): The longitude.\n        latitude (float): The latitude.\n\n    Returns:\n        tuple: A tuple of (x, y) in meters.\n    \"\"\"\n    import numpy as np\n\n    origin_shift = np.pi * 6378137\n    easting = longitude * origin_shift / 180.0\n    northing = np.log(np.tan((90 + latitude) * np.pi / 360.0)) * origin_shift / np.pi\n\n    if np.isnan(easting):\n        if longitude &gt; 0:\n            easting = 20026376\n        else:\n            easting = -20026376\n\n    if np.isnan(northing):\n        if latitude &gt; 0:\n            northing = 20048966\n        else:\n            northing = -20048966\n\n    return (easting, northing)\n</code></pre>"},{"location":"common/#geemap.common.load_GeoTIFF","title":"<code>load_GeoTIFF(URL)</code>","text":"<p>Loads a Cloud Optimized GeoTIFF (COG) as an Image. Only Google Cloud Storage is supported. The URL can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF</p> <p>Parameters:</p> Name Type Description Default <code>URL</code> <code>str</code> <p>The Cloud Storage URL of the GeoTIFF to load.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>an Earth Engine image.</p> Source code in <code>geemap/common.py</code> <pre><code>def load_GeoTIFF(URL):\n\"\"\"Loads a Cloud Optimized GeoTIFF (COG) as an Image. Only Google Cloud Storage is supported. The URL can be one of the following formats:\n    Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif\n    Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif\n    Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF\n\n    Args:\n        URL (str): The Cloud Storage URL of the GeoTIFF to load.\n\n    Returns:\n        ee.Image: an Earth Engine image.\n    \"\"\"\n\n    uri = URL.strip()\n\n    if uri.startswith(\"http\"):\n        uri = get_direct_url(uri)\n\n    if uri.startswith(\"https://storage.googleapis.com/\"):\n        uri = uri.replace(\"https://storage.googleapis.com/\", \"gs://\")\n    elif uri.startswith(\"https://storage.cloud.google.com/\"):\n        uri = uri.replace(\"https://storage.cloud.google.com/\", \"gs://\")\n\n    if not uri.startswith(\"gs://\"):\n        raise Exception(\n            f'Invalid GCS URL: {uri}. Expected something of the form \"gs://bucket/path/to/object.tif\".'\n        )\n\n    if not uri.lower().endswith(\".tif\"):\n        raise Exception(\n            f'Invalid GCS URL: {uri}. Expected something of the form \"gs://bucket/path/to/object.tif\".'\n        )\n\n    cloud_image = ee.Image.loadGeoTIFF(uri)\n    return cloud_image\n</code></pre>"},{"location":"common/#geemap.common.load_GeoTIFFs","title":"<code>load_GeoTIFFs(URLs)</code>","text":"<p>Loads a list of Cloud Optimized GeoTIFFs (COG) as an ImageCollection. URLs is a list of URL, which can be one of the following formats: Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF</p> <p>Parameters:</p> Name Type Description Default <code>URLs</code> <code>list</code> <p>A list of Cloud Storage URL of the GeoTIFF to load.</p> required <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>An Earth Engine ImageCollection.</p> Source code in <code>geemap/common.py</code> <pre><code>def load_GeoTIFFs(URLs):\n\"\"\"Loads a list of Cloud Optimized GeoTIFFs (COG) as an ImageCollection. URLs is a list of URL, which can be one of the following formats:\n    Option 1: gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif\n    Option 2: https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif\n    Option 3: https://storage.cloud.google.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF\n\n    Args:\n        URLs (list): A list of Cloud Storage URL of the GeoTIFF to load.\n\n    Returns:\n        ee.ImageCollection: An Earth Engine ImageCollection.\n    \"\"\"\n\n    if not isinstance(URLs, list):\n        raise Exception(\"The URLs argument must be a list.\")\n\n    URIs = []\n    for URL in URLs:\n        uri = URL.strip()\n\n        if uri.startswith(\"http\"):\n            uri = get_direct_url(uri)\n\n        if uri.startswith(\"https://storage.googleapis.com/\"):\n            uri = uri.replace(\"https://storage.googleapis.com/\", \"gs://\")\n        elif uri.startswith(\"https://storage.cloud.google.com/\"):\n            uri = uri.replace(\"https://storage.cloud.google.com/\", \"gs://\")\n\n        if not uri.startswith(\"gs://\"):\n            raise Exception(\n                f'Invalid GCS URL: {uri}. Expected something of the form \"gs://bucket/path/to/object.tif\".'\n            )\n\n        if not uri.lower().endswith(\".tif\"):\n            raise Exception(\n                f'Invalid GCS URL: {uri}. Expected something of the form \"gs://bucket/path/to/object.tif\".'\n            )\n\n        URIs.append(uri)\n\n    URIs = ee.List(URIs)\n    collection = URIs.map(lambda uri: ee.Image.loadGeoTIFF(uri))\n    return ee.ImageCollection(collection)\n</code></pre>"},{"location":"common/#geemap.common.local_tile_bands","title":"<code>local_tile_bands(source)</code>","text":"<p>Get band names from COG.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | TileClient</code> <p>A local COG file path or TileClient</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of band names.</p> Source code in <code>geemap/common.py</code> <pre><code>def local_tile_bands(source):\n\"\"\"Get band names from COG.\n\n    Args:\n        source (str | TileClient): A local COG file path or TileClient\n\n    Returns:\n        list: A list of band names.\n    \"\"\"\n    check_package(\"localtileserver\", \"https://github.com/banesullivan/localtileserver\")\n    from localtileserver import TileClient\n\n    if isinstance(source, str):\n        tile_client = TileClient(source)\n    elif isinstance(source, TileClient):\n        tile_client = source\n    else:\n        raise ValueError(\"source must be a string or TileClient object.\")\n\n    bandnames = list(tile_client.metadata()[\"bands\"].keys())\n    return bandnames\n</code></pre>"},{"location":"common/#geemap.common.local_tile_pixel_value","title":"<code>local_tile_pixel_value(lon, lat, tile_client, verbose=True, **kwargs)</code>","text":"<p>Get pixel value from COG.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'</p> required <code>bidx</code> <code>str</code> <p>Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> required <code>verbose</code> <code>bool</code> <p>Print status messages. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>geemap/common.py</code> <pre><code>def local_tile_pixel_value(\n    lon,\n    lat,\n    tile_client,\n    verbose=True,\n    **kwargs,\n):\n\"\"\"Get pixel value from COG.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a COG, e.g., 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\n        bidx (str, optional): Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        verbose (bool, optional): Print status messages. Defaults to True.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    r = tile_client.pixel(lat, lon, units=\"EPSG:4326\", **kwargs)\n    if \"bands\" in r:\n        return r[\"bands\"]\n    else:\n        if verbose:\n            print(\"No pixel value found.\")\n        return None\n</code></pre>"},{"location":"common/#geemap.common.local_tile_vmin_vmax","title":"<code>local_tile_vmin_vmax(source, bands=None, **kwargs)</code>","text":"<p>Get vmin and vmax from COG.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | TileClient</code> <p>A local COG file path or TileClient object.</p> required <code>bands</code> <code>str | list</code> <p>A list of band names. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If source is not a TileClient object or a local COG file path.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of vmin and vmax.</p> Source code in <code>geemap/common.py</code> <pre><code>def local_tile_vmin_vmax(\n    source,\n    bands=None,\n    **kwargs,\n):\n\"\"\"Get vmin and vmax from COG.\n\n    Args:\n        source (str | TileClient): A local COG file path or TileClient object.\n        bands (str | list, optional): A list of band names. Defaults to None.\n\n    Raises:\n        ValueError: If source is not a TileClient object or a local COG file path.\n\n    Returns:\n        tuple: A tuple of vmin and vmax.\n    \"\"\"\n    check_package(\"localtileserver\", \"https://github.com/banesullivan/localtileserver\")\n    from localtileserver import TileClient\n\n    if isinstance(source, str):\n        tile_client = TileClient(source)\n    elif isinstance(source, TileClient):\n        tile_client = source\n    else:\n        raise ValueError(\"source must be a string or TileClient object.\")\n\n    stats = tile_client.metadata()[\"bands\"]\n    bandnames = list(stats.keys())\n\n    if isinstance(bands, str):\n        bands = [bands]\n    elif isinstance(bands, list):\n        pass\n    elif bands is None:\n        bands = bandnames\n\n    if all(b in bandnames for b in bands):\n        vmin = min([stats[b][\"min\"] for b in bands])\n        vmax = max([stats[b][\"max\"] for b in bands])\n    else:\n        vmin = min([stats[b][\"min\"] for b in bandnames])\n        vmax = max([stats[b][\"max\"] for b in bandnames])\n    return vmin, vmax\n</code></pre>"},{"location":"common/#geemap.common.longitude_grid","title":"<code>longitude_grid(step=1.0, west=-180, east=180, south=-85, north=85)</code>","text":"<p>Create a longitude grid.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>The step size in degrees. Defaults to 1.0.</p> <code>1.0</code> <code>west</code> <code>int</code> <p>The west boundary in degrees. Defaults to -180.</p> <code>-180</code> <code>east</code> <code>int</code> <p>The east boundary in degrees. Defaults to 180.</p> <code>180</code> <code>south</code> <code>int</code> <p>The south boundary in degrees. Defaults to -85.</p> <code>-85</code> <code>north</code> <code>int</code> <p>The north boundary in degrees. Defaults to 85.</p> <code>85</code> <p>Returns:</p> Type Description <code>ee.FeatureColleciton</code> <p>A feature collection of longitude grids.</p> Source code in <code>geemap/common.py</code> <pre><code>def longitude_grid(step=1.0, west=-180, east=180, south=-85, north=85):\n\"\"\"Create a longitude grid.\n\n    Args:\n        step (float, optional): The step size in degrees. Defaults to 1.0.\n        west (int, optional): The west boundary in degrees. Defaults to -180.\n        east (int, optional): The east boundary in degrees. Defaults to 180.\n        south (int, optional): The south boundary in degrees. Defaults to -85.\n        north (int, optional): The north boundary in degrees. Defaults to 85.\n\n    Returns:\n        ee.FeatureColleciton: A feature collection of longitude grids.\n    \"\"\"\n\n    values = ee.List.sequence(west, east - step, step)\n\n    def create_feature(lon):\n        return ee.Feature(\n            ee.Geometry.BBox(lon, south, ee.Number(lon).add(step), north)\n        ).set(\n            {\n                \"south\": south,\n                \"west\": lon,\n                \"north\": north,\n                \"east\": ee.Number(lon).add(step),\n            }\n        )\n\n    features = ee.FeatureCollection(values.map(create_feature))\n    return features\n</code></pre>"},{"location":"common/#geemap.common.meters_to_lnglat","title":"<code>meters_to_lnglat(x, y)</code>","text":"<p>coordinate conversion between web mercator to lat/lon in decimal degrees</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x coordinate.</p> required <code>y</code> <code>float</code> <p>The y coordinate.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (longitude, latitude) in decimal degrees.</p> Source code in <code>geemap/common.py</code> <pre><code>def meters_to_lnglat(x, y):\n\"\"\"coordinate conversion between web mercator to lat/lon in decimal degrees\n\n    Args:\n        x (float): The x coordinate.\n        y (float): The y coordinate.\n\n    Returns:\n        tuple: A tuple of (longitude, latitude) in decimal degrees.\n    \"\"\"\n    import numpy as np\n\n    origin_shift = np.pi * 6378137\n    longitude = (x / origin_shift) * 180.0\n    latitude = (y / origin_shift) * 180.0\n    latitude = (\n        180 / np.pi * (2 * np.arctan(np.exp(latitude * np.pi / 180.0)) - np.pi / 2.0)\n    )\n    return (longitude, latitude)\n</code></pre>"},{"location":"common/#geemap.common.minimum_bounding_box","title":"<code>minimum_bounding_box(geojson)</code>","text":"<p>Gets the minimum bounding box for a geojson polygon.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>A geojson dictionary.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)).</p> Source code in <code>geemap/common.py</code> <pre><code>def minimum_bounding_box(geojson):\n\"\"\"Gets the minimum bounding box for a geojson polygon.\n\n    Args:\n        geojson (dict): A geojson dictionary.\n\n    Returns:\n        tuple: Returns a tuple containing the minimum bounding box in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -120)).\n    \"\"\"\n    coordinates = []\n    try:\n        if \"geometry\" in geojson.keys():\n            coordinates = geojson[\"geometry\"][\"coordinates\"][0]\n        else:\n            coordinates = geojson[\"coordinates\"][0]\n        lower_left = min([x[1] for x in coordinates]), min(\n            [x[0] for x in coordinates]\n        )  # (lat, lon)\n        upper_right = max([x[1] for x in coordinates]), max(\n            [x[0] for x in coordinates]\n        )  # (lat, lon)\n        bounds = (lower_left, upper_right)\n        return bounds\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.mosaic","title":"<code>mosaic(images, output, merge_args={}, verbose=True, **kwargs)</code>","text":"<p>Mosaics a list of images into a single image. Inspired by https://bit.ly/3A6roDK.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | list</code> <p>An input directory containing images or a list of images.</p> required <code>output</code> <code>str</code> <p>The output image filepath.</p> required <code>merge_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the rasterio.merge function. Defaults to {}.</p> <code>{}</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress. Defaults to True.</p> <code>True</code> Source code in <code>geemap/common.py</code> <pre><code>def mosaic(images, output, merge_args={}, verbose=True, **kwargs):\n\"\"\"Mosaics a list of images into a single image. Inspired by https://bit.ly/3A6roDK.\n\n    Args:\n        images (str | list): An input directory containing images or a list of images.\n        output (str): The output image filepath.\n        merge_args (dict, optional): A dictionary of arguments to pass to the rasterio.merge function. Defaults to {}.\n        verbose (bool, optional): Whether to print progress. Defaults to True.\n\n    \"\"\"\n    from rasterio.merge import merge\n    import rasterio as rio\n    from pathlib import Path\n\n    output = os.path.abspath(output)\n\n    if isinstance(images, str):\n        path = Path(images)\n        raster_files = list(path.iterdir())\n    elif isinstance(images, list):\n        raster_files = images\n    else:\n        raise ValueError(\"images must be a list of raster files.\")\n\n    raster_to_mosiac = []\n\n    if not os.path.exists(os.path.dirname(output)):\n        os.makedirs(os.path.dirname(output))\n\n    for index, p in enumerate(raster_files):\n        if verbose:\n            print(f\"Reading {index+1}/{len(raster_files)}: {os.path.basename(p)}\")\n        raster = rio.open(p, **kwargs)\n        raster_to_mosiac.append(raster)\n\n    if verbose:\n        print(\"Merging rasters...\")\n    arr, transform = merge(raster_to_mosiac, **merge_args)\n\n    output_meta = raster.meta.copy()\n    output_meta.update(\n        {\n            \"driver\": \"GTiff\",\n            \"height\": arr.shape[1],\n            \"width\": arr.shape[2],\n            \"transform\": transform,\n        }\n    )\n\n    with rio.open(output, \"w\", **output_meta) as m:\n        m.write(arr)\n</code></pre>"},{"location":"common/#geemap.common.netcdf_tile_layer","title":"<code>netcdf_tile_layer(filename, variables=None, palette=None, vmin=None, vmax=None, nodata=None, port='default', debug=False, projection='EPSG:3857', attribution=None, tile_format='ipyleaflet', layer_name='NetCDF layer', return_client=False, shift_lon=True, lat='lat', lon='lon', **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a netCDF file.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),     try adding to following two lines to the beginning of the notebook if the raster does not render properly.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netCDF file.</p> required <code>variables</code> <code>int</code> <p>The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> <code>'default'</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>If True, the server will be started in debug mode. Defaults to False.</p> <code>False</code> <code>projection</code> <code>str</code> <p>The projection of the GeoTIFF. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>tile_format</code> <code>str</code> <p>The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"NetCDF layer\".</p> <code>'NetCDF layer'</code> <code>return_client</code> <code>bool</code> <p>If True, the tile client will be returned. Defaults to False.</p> <code>False</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer | folium.TileLayer</code> <p>An ipyleaflet.TileLayer or folium.TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def netcdf_tile_layer(\n    filename,\n    variables=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    port=\"default\",\n    debug=False,\n    projection=\"EPSG:3857\",\n    attribution=None,\n    tile_format=\"ipyleaflet\",\n    layer_name=\"NetCDF layer\",\n    return_client=False,\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    **kwargs,\n):\n\"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n        try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n    Args:\n        filename (str): File path or HTTP URL to the netCDF file.\n        variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        debug (bool, optional): If True, the server will be started in debug mode. Defaults to False.\n        projection (str, optional): The projection of the GeoTIFF. Defaults to \"EPSG:3857\".\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        tile_format (str, optional): The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n        layer_name (str, optional): The layer name to use. Defaults to \"NetCDF layer\".\n        return_client (bool, optional): If True, the tile client will be returned. Defaults to False.\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n\n    Returns:\n        ipyleaflet.TileLayer | folium.TileLayer: An ipyleaflet.TileLayer or folium.TileLayer.\n    \"\"\"\n\n    check_package(\n        \"localtileserver\", URL=\"https://github.com/banesullivan/localtileserver\"\n    )\n\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    output = filename.replace(\".nc\", \".tif\")\n\n    xds = xr.open_dataset(filename, **kwargs)\n\n    if shift_lon:\n        xds.coords[lon] = (xds.coords[lon] + 180) % 360 - 180\n        xds = xds.sortby(xds.lon)\n\n    allowed_vars = list(xds.data_vars.keys())\n    if isinstance(variables, str):\n        if variables not in allowed_vars:\n            raise ValueError(f\"{variables} is not a subset of {allowed_vars}.\")\n        variables = [variables]\n\n    if variables is not None and len(variables) &gt; 3:\n        raise ValueError(\"Only 3 variables can be plotted at a time.\")\n\n    if variables is not None and (not set(variables).issubset(allowed_vars)):\n        raise ValueError(f\"{variables} must be a subset of {allowed_vars}.\")\n\n    xds.rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.to_raster(output)\n    if variables is None:\n        if len(allowed_vars) &gt;= 3:\n            band_idx = [1, 2, 3]\n        else:\n            band_idx = [1]\n    else:\n        band_idx = [allowed_vars.index(var) + 1 for var in variables]\n\n    tile_layer = get_local_tile_layer(\n        output,\n        port=port,\n        debug=debug,\n        projection=projection,\n        band=band_idx,\n        palette=palette,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        tile_format=tile_format,\n        layer_name=layer_name,\n        return_client=return_client,\n    )\n    return tile_layer\n</code></pre>"},{"location":"common/#geemap.common.netcdf_to_ee","title":"<code>netcdf_to_ee(nc_file, var_names, band_names=None, lon='lon', lat='lat')</code>","text":"<p>Creates an ee.Image from netCDF variables band_names that are read from nc_file. Currently only supports variables in a regular longitude/latitude grid (EPSG:4326).</p> <p>Parameters:</p> Name Type Description Default <code>nc_file</code> <code>str</code> <p>the name of the netCDF file to read</p> required <code>var_names</code> <code>str or list</code> <p>the name(s) of the variable(s) to read</p> required <code>band_names</code> <code>list</code> <p>if given, the bands are renamed to band_names. Defaults to the original var_names</p> <code>None</code> <code>lon</code> <code>str</code> <p>the name of the longitude variable in the netCDF file. Defaults to \"lon\"</p> <code>'lon'</code> <code>lat</code> <code>str</code> <p>the name of the latitude variable in the netCDF file. Defaults to \"lat\"</p> <code>'lat'</code> <p>Returns:</p> Type Description <code>image</code> <p>An ee.Image</p> Source code in <code>geemap/common.py</code> <pre><code>def netcdf_to_ee(nc_file, var_names, band_names=None, lon=\"lon\", lat=\"lat\"):\n\"\"\"\n    Creates an ee.Image from netCDF variables band_names that are read from nc_file. Currently only supports variables in a regular longitude/latitude grid (EPSG:4326).\n\n    Args:\n        nc_file (str): the name of the netCDF file to read\n        var_names (str or list): the name(s) of the variable(s) to read\n        band_names (list, optional): if given, the bands are renamed to band_names. Defaults to the original var_names\n        lon (str, optional): the name of the longitude variable in the netCDF file. Defaults to \"lon\"\n        lat (str, optional): the name of the latitude variable in the netCDF file. Defaults to \"lat\"\n\n    Returns:\n        image: An ee.Image\n\n    \"\"\"\n    try:\n        import xarray as xr\n\n    except Exception:\n        raise ImportError(\n            \"You need to install xarray first. See https://github.com/pydata/xarray\"\n        )\n\n    import numpy as np\n\n    try:\n        if not isinstance(nc_file, str):\n            print(\"The input file must be a string.\")\n            return\n        if band_names and not isinstance(band_names, (list, str)):\n            print(\"Band names must be a string or list.\")\n            return\n        if not isinstance(lon, str) or not isinstance(lat, str):\n            print(\"The longitude and latitude variable names must be a string.\")\n            return\n\n        ds = xr.open_dataset(nc_file)\n        data = ds[var_names]\n\n        lon_data = data[lon]\n        lat_data = data[lat]\n\n        dim_lon = np.unique(np.ediff1d(lon_data))\n        dim_lat = np.unique(np.ediff1d(lat_data))\n\n        if (len(dim_lon) != 1) or (len(dim_lat) != 1):\n            print(\"The netCDF file is not a regular longitude/latitude grid\")\n            return\n\n        try:\n            data = data.to_array()\n            # ^ this is only needed (and works) if we have more than 1 variable\n            # axis_for_roll will be used in case we need to use np.roll\n            # and should be 1 for the case with more than 1 variable\n            axis_for_roll = 1\n        except Exception:\n            axis_for_roll = 0\n            # .to_array() does not work (and is not needed!) if there is only 1 variable\n            # in this case, the axis_for_roll needs to be 0\n\n        data_np = np.array(data)\n\n        do_transpose = True  # To do: figure out if we need to transpose the data or not\n        if do_transpose:\n            try:\n                data_np = np.transpose(data_np, (0, 2, 1))\n            except Exception:\n                data_np = np.transpose(data_np)\n\n        # Figure out if we need to roll the data or not\n        # (see https://github.com/gee-community/geemap/issues/285#issuecomment-791385176)\n        if np.max(lon_data) &gt; 180:\n            data_np = np.roll(data_np, 180, axis=axis_for_roll)\n            west_lon = lon_data[0] - 180\n        else:\n            west_lon = lon_data[0]\n\n        transform = [dim_lon[0], 0, float(west_lon), 0, dim_lat[0], float(lat_data[0])]\n\n        if band_names is None:\n            band_names = var_names\n\n        image = numpy_to_ee(\n            data_np, \"EPSG:4326\", transform=transform, band_names=band_names\n        )\n\n        return image\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.netcdf_to_tif","title":"<code>netcdf_to_tif(filename, output=None, variables=None, shift_lon=True, lat='lat', lon='lon', return_vars=False, **kwargs)</code>","text":"<p>Convert a netcdf file to a GeoTIFF file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the netcdf file.</p> required <code>output</code> <code>str</code> <p>Path to the output GeoTIFF file. Defaults to None. If None, the output file will be the same as the input file with the extension changed to .tif.</p> <code>None</code> <code>variables</code> <code>str | list</code> <p>Name of the variable or a list of variables to extract. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> <code>return_vars</code> <code>bool</code> <p>Flag to return all variables. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray or rioxarray package is not installed.</p> <code>FileNotFoundError</code> <p>If the netcdf file is not found.</p> <code>ValueError</code> <p>If the variable is not found in the netcdf file.</p> Source code in <code>geemap/common.py</code> <pre><code>def netcdf_to_tif(\n    filename,\n    output=None,\n    variables=None,\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    return_vars=False,\n    **kwargs,\n):\n\"\"\"Convert a netcdf file to a GeoTIFF file.\n\n    Args:\n        filename (str): Path to the netcdf file.\n        output (str, optional): Path to the output GeoTIFF file. Defaults to None. If None, the output file will be the same as the input file with the extension changed to .tif.\n        variables (str | list, optional): Name of the variable or a list of variables to extract. Defaults to None. If None, all variables will be extracted.\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n        return_vars (bool, optional): Flag to return all variables. Defaults to False.\n\n    Raises:\n        ImportError: If the xarray or rioxarray package is not installed.\n        FileNotFoundError: If the netcdf file is not found.\n        ValueError: If the variable is not found in the netcdf file.\n    \"\"\"\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    if output is None:\n        output = filename.replace(\".nc\", \".tif\")\n    else:\n        output = check_file_path(output)\n\n    xds = xr.open_dataset(filename, **kwargs)\n\n    if shift_lon:\n        xds.coords[lon] = (xds.coords[lon] + 180) % 360 - 180\n        xds = xds.sortby(xds.lon)\n\n    allowed_vars = list(xds.data_vars.keys())\n    if isinstance(variables, str):\n        if variables not in allowed_vars:\n            raise ValueError(f\"{variables} is not a valid variable.\")\n        variables = [variables]\n\n    if variables is not None and (not set(variables).issubset(allowed_vars)):\n        raise ValueError(f\"{variables} must be a subset of {allowed_vars}.\")\n\n    if variables is None:\n        xds.rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.to_raster(output)\n    else:\n        xds[variables].rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.to_raster(output)\n\n    if return_vars:\n        return output, allowed_vars\n    else:\n        return output\n</code></pre>"},{"location":"common/#geemap.common.num_round","title":"<code>num_round(num, decimal=2)</code>","text":"<p>Rounds a number to a specified number of decimal places.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>float</code> <p>The number to round.</p> required <code>decimal</code> <code>int</code> <p>The number of decimal places to round. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>float</code> <p>The number with the specified decimal places rounded.</p> Source code in <code>geemap/common.py</code> <pre><code>def num_round(num, decimal=2):\n\"\"\"Rounds a number to a specified number of decimal places.\n\n    Args:\n        num (float): The number to round.\n        decimal (int, optional): The number of decimal places to round. Defaults to 2.\n\n    Returns:\n        float: The number with the specified decimal places rounded.\n    \"\"\"\n    return round(num, decimal)\n</code></pre>"},{"location":"common/#geemap.common.numpy_to_cog","title":"<code>numpy_to_cog(np_array, out_cog, bounds=None, profile=None, dtype=None, crs='epsg:4326')</code>","text":"<p>Converts a numpy array to a COG file.</p> <p>Parameters:</p> Name Type Description Default <code>np_array</code> <code>np.array</code> <p>A numpy array representing the image.</p> required <code>out_cog</code> <code>str</code> <p>The output COG file path.</p> required <code>bounds</code> <code>tuple</code> <p>The bounds of the image in the format of (minx, miny, maxx, maxy). Defaults to None.</p> <code>None</code> <code>profile</code> <code>str | dict</code> <p>File path to an existing COG file or a dictionary representing the profile. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>The data type of the output COG file. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system of the output COG file. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> Source code in <code>geemap/common.py</code> <pre><code>def numpy_to_cog(\n    np_array, out_cog, bounds=None, profile=None, dtype=None, crs=\"epsg:4326\"\n):\n\"\"\"Converts a numpy array to a COG file.\n\n    Args:\n        np_array (np.array): A numpy array representing the image.\n        out_cog (str): The output COG file path.\n        bounds (tuple, optional): The bounds of the image in the format of (minx, miny, maxx, maxy). Defaults to None.\n        profile (str | dict, optional): File path to an existing COG file or a dictionary representing the profile. Defaults to None.\n        dtype (str, optional): The data type of the output COG file. Defaults to None.\n        crs (str, optional): The coordinate reference system of the output COG file. Defaults to \"epsg:4326\".\n\n    \"\"\"\n\n    import numpy as np\n    import rasterio\n    from rasterio.io import MemoryFile\n    from rasterio.transform import from_bounds\n\n    from rio_cogeo.cogeo import cog_translate\n    from rio_cogeo.profiles import cog_profiles\n\n    warnings.filterwarnings(\"ignore\")\n\n    if not isinstance(np_array, np.ndarray):\n        raise TypeError(\"The input array must be a numpy array.\")\n\n    out_dir = os.path.dirname(out_cog)\n    check_dir(out_dir)\n\n    if profile is not None:\n        if isinstance(profile, str):\n            if not os.path.exists(profile):\n                raise FileNotFoundError(\"The provided file could not be found.\")\n            with rasterio.open(profile) as ds:\n                bounds = ds.bounds\n        elif isinstance(profile, rasterio.profiles.Profile):\n            profile = dict(profile)\n        elif not isinstance(profile, dict):\n            raise TypeError(\"The provided profile must be a file path or a dictionary.\")\n\n    if bounds is None:\n        bounds = (-180.0, -85.0511287798066, 180.0, 85.0511287798066)\n\n    if not isinstance(bounds, tuple) and len(bounds) != 4:\n        raise TypeError(\"The provided bounds must be a tuple of length 4.\")\n\n    # Rasterio uses numpy array of shape of `(bands, height, width)`\n\n    if len(np_array.shape) == 3:\n        nbands = np_array.shape[0]\n        height = np_array.shape[1]\n        width = np_array.shape[2]\n    elif len(np_array.shape) == 2:\n        nbands = 1\n        height = np_array.shape[0]\n        width = np_array.shape[1]\n        np_array = np_array.reshape((1, height, width))\n    else:\n        raise ValueError(\"The input array must be a 2D or 3D numpy array.\")\n\n    src_transform = from_bounds(*bounds, width=width, height=height)\n    if dtype is None:\n        dtype = str(np_array.dtype)\n\n    if isinstance(profile, dict):\n        src_profile = profile\n        src_profile[\"count\"] = nbands\n    else:\n        src_profile = dict(\n            driver=\"GTiff\",\n            dtype=dtype,\n            count=nbands,\n            height=height,\n            width=width,\n            crs=crs,\n            transform=src_transform,\n        )\n\n    with MemoryFile() as memfile:\n        with memfile.open(**src_profile) as mem:\n            # Populate the input file with numpy array\n            mem.write(np_array)\n\n            dst_profile = cog_profiles.get(\"deflate\")\n            cog_translate(\n                mem,\n                out_cog,\n                dst_profile,\n                in_memory=True,\n                quiet=True,\n            )\n</code></pre>"},{"location":"common/#geemap.common.numpy_to_ee","title":"<code>numpy_to_ee(np_array, crs=None, transform=None, transformWkt=None, band_names=None)</code>","text":"<p>Creates an ee.Image from a 3D numpy array where each 2D numpy slice is added to a band, and a geospatial transform that indicates where to put the data. If the np_array is already 2D only, then it is only a one-band image.</p> <p>Parameters:</p> Name Type Description Default <code>np_array</code> <code>np.array</code> <p>the 3D (or 2D) numpy array to add to an image</p> required <code>crs</code> <code>str</code> <p>The base coordinate reference system of this Projection, given as a well-known authority code (e.g. 'EPSG:4326') or a WKT string.</p> <code>None</code> <code>transform</code> <code>list</code> <p>The transform between projected coordinates and the base coordinate system, specified as a 2x3 affine transform matrix in row-major order: [xScale, xShearing, xTranslation, yShearing, yScale, yTranslation]. May not specify both this and 'transformWkt'.</p> <code>None</code> <code>transformWkt</code> <code>str</code> <p>The transform between projected coordinates and the base coordinate system, specified as a WKT string. May not specify both this and 'transform'.</p> <code>None</code> <code>band_names</code> <code>str or list</code> <p>The list of names for the bands. The default names are 'constant', and 'constant_1', 'constant_2', etc.</p> <code>None</code> <p>Returns:</p> Type Description <code>image</code> <p>An ee.Image</p> Source code in <code>geemap/common.py</code> <pre><code>def numpy_to_ee(np_array, crs=None, transform=None, transformWkt=None, band_names=None):\n\"\"\"\n    Creates an ee.Image from a 3D numpy array where each 2D numpy slice is added to a band, and a geospatial transform that indicates where to put the data. If the np_array is already 2D only, then it is only a one-band image.\n\n    Args:\n        np_array (np.array): the 3D (or 2D) numpy array to add to an image\n        crs (str): The base coordinate reference system of this Projection, given as a well-known authority code (e.g. 'EPSG:4326') or a WKT string.\n        transform (list): The transform between projected coordinates and the base coordinate system, specified as a 2x3 affine transform matrix in row-major order: [xScale, xShearing, xTranslation, yShearing, yScale, yTranslation]. May not specify both this and 'transformWkt'.\n        transformWkt (str): The transform between projected coordinates and the base coordinate system, specified as a WKT string. May not specify both this and 'transform'.\n        band_names (str or list, optional): The list of names for the bands. The default names are 'constant', and 'constant_1', 'constant_2', etc.\n\n    Returns:\n        image: An ee.Image\n\n    \"\"\"\n    import numpy as np\n\n    if not isinstance(np_array, np.ndarray):\n        print(\"The input must be a numpy.ndarray.\")\n        return\n    if not len(np_array.shape) in [2, 3]:\n        print(\"The input must have 2 or 3 dimensions\")\n        return\n    if band_names and not isinstance(band_names, (list, str)):\n        print(\"Band names must be a str or list\")\n        return\n\n    try:\n        projection = ee.Projection(crs, transform, transformWkt)\n        coords = ee.Image.pixelCoordinates(projection).floor().int32()\n        x = coords.select(\"x\")\n        y = coords.select(\"y\")\n        s = np_array.shape\n        if len(s) &lt; 3:\n            dimx = s[0]\n            dimy = s[1]\n        else:\n            dimx = s[1]\n            dimy = s[2]\n            dimz = s[0]\n\n        coord_mask = x.gte(0).And(y.gte(0)).And(x.lt(dimx)).And(y.lt(dimy))\n        coords = coords.updateMask(coord_mask)\n\n        def list_to_ee(a_list):\n            ee_data = ee.Array(a_list)\n            image = ee.Image(ee_data).arrayGet(coords)\n            return image\n\n        if len(s) &lt; 3:\n            image = list_to_ee(np_array.tolist())\n        else:\n            image = list_to_ee(np_array[0].tolist())\n            for z in np.arange(1, dimz):\n                image = image.addBands(list_to_ee(np_array[z].tolist()))\n\n        if band_names:\n            image = image.rename(band_names)\n\n        return image\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.nwi_add_color","title":"<code>nwi_add_color(fc)</code>","text":"<p>Converts NWI vector dataset to image and add color to it.</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>object</code> <p>ee.FeatureCollection</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.Image</p> Source code in <code>geemap/common.py</code> <pre><code>def nwi_add_color(fc):\n\"\"\"Converts NWI vector dataset to image and add color to it.\n\n    Args:\n        fc (object): ee.FeatureCollection\n\n    Returns:\n        object: ee.Image\n    \"\"\"\n    emergent = ee.FeatureCollection(\n        fc.filter(ee.Filter.eq(\"WETLAND_TY\", \"Freshwater Emergent Wetland\"))\n    )\n    emergent = emergent.map(lambda f: f.set(\"R\", 127).set(\"G\", 195).set(\"B\", 28))\n    # print(emergent.first())\n\n    forested = fc.filter(\n        ee.Filter.eq(\"WETLAND_TY\", \"Freshwater Forested/Shrub Wetland\")\n    )\n    forested = forested.map(lambda f: f.set(\"R\", 0).set(\"G\", 136).set(\"B\", 55))\n\n    pond = fc.filter(ee.Filter.eq(\"WETLAND_TY\", \"Freshwater Pond\"))\n    pond = pond.map(lambda f: f.set(\"R\", 104).set(\"G\", 140).set(\"B\", 192))\n\n    lake = fc.filter(ee.Filter.eq(\"WETLAND_TY\", \"Lake\"))\n    lake = lake.map(lambda f: f.set(\"R\", 19).set(\"G\", 0).set(\"B\", 124))\n\n    riverine = fc.filter(ee.Filter.eq(\"WETLAND_TY\", \"Riverine\"))\n    riverine = riverine.map(lambda f: f.set(\"R\", 1).set(\"G\", 144).set(\"B\", 191))\n\n    fc = ee.FeatureCollection(\n        emergent.merge(forested).merge(pond).merge(lake).merge(riverine)\n    )\n\n    #   base = ee.Image(0).mask(0).toInt8()\n    base = ee.Image().byte()\n    img = base.paint(fc, \"R\").addBands(\n        base.paint(fc, \"G\").addBands(base.paint(fc, \"B\"))\n    )\n\n    return img\n</code></pre>"},{"location":"common/#geemap.common.open_github","title":"<code>open_github(subdir=None)</code>","text":"<p>Opens the GitHub repository for this package.</p> <p>Parameters:</p> Name Type Description Default <code>subdir</code> <code>str</code> <p>Sub-directory of the repository. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def open_github(subdir=None):\n\"\"\"Opens the GitHub repository for this package.\n\n    Args:\n        subdir (str, optional): Sub-directory of the repository. Defaults to None.\n    \"\"\"\n    import webbrowser\n\n    url = \"https://github.com/gee-community/geemap\"\n\n    if subdir == \"source\":\n        url += \"/tree/master/geemap/\"\n    elif subdir == \"examples\":\n        url += \"/tree/master/examples\"\n    elif subdir == \"tutorials\":\n        url += \"/tree/master/tutorials\"\n\n    webbrowser.open_new_tab(url)\n</code></pre>"},{"location":"common/#geemap.common.open_image_from_url","title":"<code>open_image_from_url(url, timeout=300, proxies=None)</code>","text":"<p>Loads an image from the specified URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the image.</p> required <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>Dictionary of proxies. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Image object.</p> Source code in <code>geemap/common.py</code> <pre><code>def open_image_from_url(url, timeout=300, proxies=None):\n\"\"\"Loads an image from the specified URL.\n\n    Args:\n        url (str): URL of the image.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n        proxies (dict, optional): Dictionary of proxies. Defaults to None.\n\n    Returns:\n        object: Image object.\n    \"\"\"\n    from PIL import Image\n\n    # from io import BytesIO\n    # from urllib.parse import urlparse\n\n    try:\n        url = get_direct_url(url)\n        response = requests.get(url, timeout=timeout, proxies=proxies)\n        img = Image.open(io.BytesIO(response.content))\n        return img\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.open_youtube","title":"<code>open_youtube()</code>","text":"<p>Opens the YouTube tutorials for geemap.</p> Source code in <code>geemap/common.py</code> <pre><code>def open_youtube():\n\"\"\"Opens the YouTube tutorials for geemap.\"\"\"\n    import webbrowser\n\n    url = \"https://www.youtube.com/playlist?list=PLAxJ4-o7ZoPccOFv1dCwvGI6TYnirRTg3\"\n    webbrowser.open_new_tab(url)\n</code></pre>"},{"location":"common/#geemap.common.osm_to_ee","title":"<code>osm_to_ee(query, which_result=None, by_osmid=False, buffer_dist=None, geodesic=True)</code>","text":"<p>Retrieves place(s) by name or ID from the Nominatim API as an ee.FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>INT</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>geodesic</code> <code>bool</code> <p>Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>An Earth Engine FeatureCollection.</p> Source code in <code>geemap/common.py</code> <pre><code>def osm_to_ee(\n    query, which_result=None, by_osmid=False, buffer_dist=None, geodesic=True\n):\n\"\"\"Retrieves place(s) by name or ID from the Nominatim API as an ee.FeatureCollection.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.\n\n    Returns:\n        ee.FeatureCollection: An Earth Engine FeatureCollection.\n    \"\"\"\n    gdf = osm_to_gdf(query, which_result, by_osmid, buffer_dist)\n    fc = gdf_to_ee(gdf, geodesic)\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.osm_to_gdf","title":"<code>osm_to_gdf(query, which_result=None, by_osmid=False, buffer_dist=None)</code>","text":"<p>Retrieves place(s) by name or ID from the Nominatim API as a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>INT</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def osm_to_gdf(\n    query,\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n):\n\"\"\"Retrieves place(s) by name or ID from the Nominatim API as a GeoDataFrame.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        GeoDataFrame: A GeoPandas GeoDataFrame.\n    \"\"\"\n    check_package(\n        \"geopandas\", \"https://geopandas.org/getting_started.html#installation\"\n    )\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/\")\n\n    try:\n        import osmnx as ox\n\n        gdf = ox.geocode_to_gdf(query, which_result, by_osmid, buffer_dist)\n        return gdf\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.osm_to_geojson","title":"<code>osm_to_geojson(query, which_result=None, by_osmid=False, buffer_dist=None)</code>","text":"<p>Retrieves place(s) by name or ID from the Nominatim API as an ee.FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>INT</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>An Earth Engine FeatureCollection.</p> Source code in <code>geemap/common.py</code> <pre><code>def osm_to_geojson(query, which_result=None, by_osmid=False, buffer_dist=None):\n\"\"\"Retrieves place(s) by name or ID from the Nominatim API as an ee.FeatureCollection.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        ee.FeatureCollection: An Earth Engine FeatureCollection.\n    \"\"\"\n    gdf = osm_to_gdf(query, which_result, by_osmid, buffer_dist)\n    return gdf.__geo_interface__\n</code></pre>"},{"location":"common/#geemap.common.osm_to_geopandas","title":"<code>osm_to_geopandas(query, which_result=None, by_osmid=False, buffer_dist=None)</code>","text":"<p>Retrieves place(s) by name or ID from the Nominatim API as a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>INT</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def osm_to_gdf(\n    query,\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n):\n\"\"\"Retrieves place(s) by name or ID from the Nominatim API as a GeoDataFrame.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        GeoDataFrame: A GeoPandas GeoDataFrame.\n    \"\"\"\n    check_package(\n        \"geopandas\", \"https://geopandas.org/getting_started.html#installation\"\n    )\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/\")\n\n    try:\n        import osmnx as ox\n\n        gdf = ox.geocode_to_gdf(query, which_result, by_osmid, buffer_dist)\n        return gdf\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.pandas_to_ee","title":"<code>pandas_to_ee(df, latitude='latitude', longitude='longitude', **kwargs)</code>","text":"<p>Converts a pandas DataFrame to ee.FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>An input pandas.DataFrame.</p> required <code>latitude</code> <code>str</code> <p>Column name for the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>Column name for the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>The input data type must be pandas.DataFrame.</p> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>The ee.FeatureCollection converted from the input pandas DataFrame.</p> Source code in <code>geemap/common.py</code> <pre><code>def df_to_ee(df, latitude=\"latitude\", longitude=\"longitude\", **kwargs):\n\"\"\"Converts a pandas DataFrame to ee.FeatureCollection.\n\n    Args:\n        df (pandas.DataFrame): An input pandas.DataFrame.\n        latitude (str, optional): Column name for the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): Column name for the longitude column. Defaults to 'longitude'.\n\n    Raises:\n        TypeError: The input data type must be pandas.DataFrame.\n\n    Returns:\n        ee.FeatureCollection: The ee.FeatureCollection converted from the input pandas DataFrame.\n    \"\"\"\n    import pandas as pd\n\n    if not isinstance(df, pd.DataFrame):\n        raise TypeError(\"The input data type must be pandas.DataFrame.\")\n\n    geojson = df_to_geojson(df, latitude=latitude, longitude=longitude)\n    fc = geojson_to_ee(geojson)\n\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.planet_biannual_tiles_tropical","title":"<code>planet_biannual_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  bi-annual imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_biannual_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n\"\"\"Generates Planet  bi-annual imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    import folium\n    import ipyleaflet\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_biannual_tropical(api_key, token_name)\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 15]\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#geemap.common.planet_biannual_tropical","title":"<code>planet_biannual_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_biannual_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n\"\"\"Generates Planet bi-annual imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    dates = [\n        \"2015-12_2016-05\",\n        \"2016-06_2016-11\",\n        \"2016-12_2017-05\",\n        \"2017-06_2017-11\",\n        \"2017-12_2018-05\",\n        \"2018-06_2018-11\",\n        \"2018-12_2019-05\",\n        \"2019-06_2019-11\",\n        \"2019-12_2020-05\",\n        \"2020-06_2020-08\",\n    ]\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/planet_medres_normalized_analytic_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for d in dates:\n        url = f\"{prefix}{d}{subfix}{api_key}\"\n        link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#geemap.common.planet_by_month","title":"<code>planet_by_month(year=2016, month=1, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Gets Planet global mosaic tile url by month. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The Planet API key is not provided.</p> <code>ValueError</code> <p>The year is invalid.</p> <code>ValueError</code> <p>The month is invalid.</p> <code>ValueError</code> <p>The month is invalid.</p> <p>Returns:</p> Type Description <code>str</code> <p>A Planet global mosaic tile url.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_by_month(\n    year=2016,\n    month=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n):\n\"\"\"Gets Planet global mosaic tile url by month. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: The Planet API key is not provided.\n        ValueError: The year is invalid.\n        ValueError: The month is invalid.\n        ValueError: The month is invalid.\n\n    Returns:\n        str: A Planet global mosaic tile url.\n    \"\"\"\n    # from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = datetime.date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    # quarter_now = (month_now - 1) // 3 + 1\n\n    if year &gt; year_now:\n        raise ValueError(f\"Year must be between 2016 and {year_now}.\")\n    elif year == year_now and month &gt;= month_now:\n        raise ValueError(f\"Month must be less than {month_now} for year {year_now}\")\n\n    if month &lt; 1 or month &gt; 12:\n        raise ValueError(\"Month must be between 1 and 12.\")\n\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_monthly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    m_str = str(year) + \"_\" + str(month).zfill(2)\n    url = f\"{prefix}{m_str}{subfix}{api_key}\"\n\n    return url\n</code></pre>"},{"location":"common/#geemap.common.planet_by_quarter","title":"<code>planet_by_quarter(year=2016, quarter=1, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Gets Planet global mosaic tile url by quarter. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The Planet API key is not provided.</p> <code>ValueError</code> <p>The year is invalid.</p> <code>ValueError</code> <p>The quarter is invalid.</p> <code>ValueError</code> <p>The quarter is invalid.</p> <p>Returns:</p> Type Description <code>str</code> <p>A Planet global mosaic tile url.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_by_quarter(\n    year=2016,\n    quarter=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n):\n\"\"\"Gets Planet global mosaic tile url by quarter. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: The Planet API key is not provided.\n        ValueError: The year is invalid.\n        ValueError: The quarter is invalid.\n        ValueError: The quarter is invalid.\n\n    Returns:\n        str: A Planet global mosaic tile url.\n    \"\"\"\n    # from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = datetime.date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    quarter_now = (month_now - 1) // 3 + 1\n\n    if year &gt; year_now:\n        raise ValueError(f\"Year must be between 2016 and {year_now}.\")\n    elif year == year_now and quarter &gt;= quarter_now:\n        raise ValueError(f\"Quarter must be less than {quarter_now} for year {year_now}\")\n\n    if quarter &lt; 1 or quarter &gt; 4:\n        raise ValueError(\"Quarter must be between 1 and 4.\")\n\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_quarterly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    m_str = str(year) + \"q\" + str(quarter)\n    url = f\"{prefix}{m_str}{subfix}{api_key}\"\n\n    return url\n</code></pre>"},{"location":"common/#geemap.common.planet_catalog","title":"<code>planet_catalog(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_catalog(api_key=None, token_name=\"PLANET_API_KEY\"):\n\"\"\"Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    quarterly = planet_quarterly(api_key, token_name)\n    monthly = planet_monthly(api_key, token_name)\n    return quarterly + monthly\n</code></pre>"},{"location":"common/#geemap.common.planet_catalog_tropical","title":"<code>planet_catalog_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_catalog_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n\"\"\"Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    biannual = planet_biannual_tropical(api_key, token_name)\n    monthly = planet_monthly_tropical(api_key, token_name)\n    return biannual + monthly\n</code></pre>"},{"location":"common/#geemap.common.planet_monthly","title":"<code>planet_monthly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_monthly(api_key=None, token_name=\"PLANET_API_KEY\"):\n\"\"\"Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    # from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = datetime.date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_monthly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for month in range(1, 13):\n            m_str = str(year) + \"_\" + str(month).zfill(2)\n\n            if year == year_now and month &gt;= month_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#geemap.common.planet_monthly_tiles","title":"<code>planet_monthly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_monthly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n\"\"\"Generates Planet  monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n    import folium\n    import ipyleaflet\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_monthly(api_key, token_name)\n\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 7]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#geemap.common.planet_monthly_tiles_tropical","title":"<code>planet_monthly_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_monthly_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n\"\"\"Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n    import folium\n    import ipyleaflet\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_monthly_tropical(api_key, token_name)\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 7]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#geemap.common.planet_monthly_tropical","title":"<code>planet_monthly_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_monthly_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n\"\"\"Generates Planet monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    # from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = datetime.date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n\n    links = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/planet_medres_normalized_analytic_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2020, year_now + 1):\n        for month in range(1, 13):\n            m_str = str(year) + \"-\" + str(month).zfill(2)\n\n            if year == 2020 and month &lt; 9:\n                continue\n            if year == year_now and month &gt;= month_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            links.append(url)\n\n    return links\n</code></pre>"},{"location":"common/#geemap.common.planet_quarterly","title":"<code>planet_quarterly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_quarterly(api_key=None, token_name=\"PLANET_API_KEY\"):\n\"\"\"Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    # from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = datetime.date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    quarter_now = (month_now - 1) // 3 + 1\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_quarterly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for quarter in range(1, 5):\n            m_str = str(year) + \"q\" + str(quarter)\n\n            if year == year_now and quarter &gt;= quarter_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#geemap.common.planet_quarterly_tiles","title":"<code>planet_quarterly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_quarterly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n\"\"\"Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n    import folium\n    import ipyleaflet\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    links = planet_quarterly(api_key, token_name)\n\n    for url in links:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 6]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#geemap.common.planet_tile_by_month","title":"<code>planet_tile_by_month(year=2016, month=1, name=None, api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_tile_by_month(\n    year=2016,\n    month=1,\n    name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    tile_format=\"ipyleaflet\",\n):\n\"\"\"Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n    import folium\n    import ipyleaflet\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    url = planet_by_month(year, month, api_key, token_name)\n\n    if name is None:\n        name = \"Planet_\" + str(year) + \"_\" + str(month).zfill(2)\n\n    if tile_format == \"ipyleaflet\":\n        tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n    else:\n        tile = folium.TileLayer(\n            tiles=url,\n            attr=\"Planet\",\n            name=name,\n            overlay=True,\n            control=True,\n        )\n\n    return tile\n</code></pre>"},{"location":"common/#geemap.common.planet_tile_by_quarter","title":"<code>planet_tile_by_quarter(year=2016, quarter=1, name=None, api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_tile_by_quarter(\n    year=2016,\n    quarter=1,\n    name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    tile_format=\"ipyleaflet\",\n):\n\"\"\"Generates Planet quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    import folium\n    import ipyleaflet\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    url = planet_by_quarter(year, quarter, api_key, token_name)\n\n    if name is None:\n        name = \"Planet_\" + str(year) + \"_q\" + str(quarter)\n\n    if tile_format == \"ipyleaflet\":\n        tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n    else:\n        tile = folium.TileLayer(\n            tiles=url,\n            attr=\"Planet\",\n            name=name,\n            overlay=True,\n            control=True,\n        )\n\n    return tile\n</code></pre>"},{"location":"common/#geemap.common.planet_tiles","title":"<code>planet_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_tiles(api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"):\n\"\"\"Generates Planet imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    catalog = {}\n    quarterly = planet_quarterly_tiles(api_key, token_name, tile_format)\n    monthly = planet_monthly_tiles(api_key, token_name, tile_format)\n\n    for key in quarterly:\n        catalog[key] = quarterly[key]\n\n    for key in monthly:\n        catalog[key] = monthly[key]\n\n    return catalog\n</code></pre>"},{"location":"common/#geemap.common.planet_tiles_tropical","title":"<code>planet_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geemap/common.py</code> <pre><code>def planet_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n\"\"\"Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    catalog = {}\n    biannul = planet_biannual_tiles_tropical(api_key, token_name, tile_format)\n    monthly = planet_monthly_tiles_tropical(api_key, token_name, tile_format)\n\n    for key in biannul:\n        catalog[key] = biannul[key]\n\n    for key in monthly:\n        catalog[key] = monthly[key]\n\n    return catalog\n</code></pre>"},{"location":"common/#geemap.common.plot_raster","title":"<code>plot_raster(image, band=None, cmap='terrain', proj='EPSG:3857', figsize=None, open_kwargs={}, **kwargs)</code>","text":"<p>Plot a raster image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | xarray.DataArray </code> <p>The input raster image, can be a file path, HTTP URL, or xarray.DataArray.</p> required <code>band</code> <code>int</code> <p>The band index, starting from zero. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap to use. Defaults to \"terrain\".</p> <code>'terrain'</code> <code>proj</code> <code>str</code> <p>The EPSG projection code. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>figsize</code> <code>tuple</code> <p>The figure size as a tuple, such as (10, 8). Defaults to None.</p> <code>None</code> <code>open_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to xarray.DataArray.plot().</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def plot_raster(\n    image,\n    band=None,\n    cmap=\"terrain\",\n    proj=\"EPSG:3857\",\n    figsize=None,\n    open_kwargs={},\n    **kwargs,\n):\n\"\"\"Plot a raster image.\n\n    Args:\n        image (str | xarray.DataArray ): The input raster image, can be a file path, HTTP URL, or xarray.DataArray.\n        band (int, optional): The band index, starting from zero. Defaults to None.\n        cmap (str, optional): The matplotlib colormap to use. Defaults to \"terrain\".\n        proj (str, optional): The EPSG projection code. Defaults to \"EPSG:3857\".\n        figsize (tuple, optional): The figure size as a tuple, such as (10, 8). Defaults to None.\n        open_kwargs (dict, optional): The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.\n        **kwargs: Additional keyword arguments to pass to xarray.DataArray.plot().\n\n    \"\"\"\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if in_colab_shell():\n        print(\"The plot_raster_3d() function is not supported in Colab.\")\n        return\n\n    try:\n        import pvxarray\n        import rioxarray\n        import xarray\n    except ImportError:\n        raise ImportError(\n            \"pyxarray and rioxarray are required for plotting. Please install them using 'pip install rioxarray pyvista-xarray'.\"\n        )\n\n    if isinstance(image, str):\n        da = rioxarray.open_rasterio(image, **open_kwargs)\n    elif isinstance(image, xarray.DataArray):\n        da = image\n    else:\n        raise ValueError(\"image must be a string or xarray.Dataset.\")\n\n    if band is not None:\n        da = da[dict(band=band)]\n\n    da = da.rio.reproject(proj)\n    kwargs[\"cmap\"] = cmap\n    kwargs[\"figsize\"] = figsize\n    da.plot(**kwargs)\n</code></pre>"},{"location":"common/#geemap.common.plot_raster_3d","title":"<code>plot_raster_3d(image, band=None, cmap='terrain', factor=1.0, proj='EPSG:3857', background=None, x=None, y=None, z=None, order=None, component=None, open_kwargs={}, mesh_kwargs={}, **kwargs)</code>","text":"<p>Plot a raster image in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | xarray.DataArray</code> <p>The input raster image, can be a file path, HTTP URL, or xarray.DataArray.</p> required <code>band</code> <code>int</code> <p>The band index, starting from zero. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap to use. Defaults to \"terrain\".</p> <code>'terrain'</code> <code>factor</code> <code>float</code> <p>The scaling factor for the raster. Defaults to 1.0.</p> <code>1.0</code> <code>proj</code> <code>str</code> <p>The EPSG projection code. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>background</code> <code>str</code> <p>The background color. Defaults to None.</p> <code>None</code> <code>x</code> <code>str</code> <p>The x coordinate. Defaults to None.</p> <code>None</code> <code>y</code> <code>str</code> <p>The y coordinate. Defaults to None.</p> <code>None</code> <code>z</code> <code>str</code> <p>The z coordinate. Defaults to None.</p> <code>None</code> <code>order</code> <code>str</code> <p>The order of the coordinates. Defaults to None.</p> <code>None</code> <code>component</code> <code>str</code> <p>The component of the coordinates. Defaults to None.</p> <code>None</code> <code>open_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.</p> <code>{}</code> <code>mesh_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to pyvista.mesh.warp_by_scalar(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to xarray.DataArray.plot().</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def plot_raster_3d(\n    image,\n    band=None,\n    cmap=\"terrain\",\n    factor=1.0,\n    proj=\"EPSG:3857\",\n    background=None,\n    x=None,\n    y=None,\n    z=None,\n    order=None,\n    component=None,\n    open_kwargs={},\n    mesh_kwargs={},\n    **kwargs,\n):\n\"\"\"Plot a raster image in 3D.\n\n    Args:\n        image (str | xarray.DataArray): The input raster image, can be a file path, HTTP URL, or xarray.DataArray.\n        band (int, optional): The band index, starting from zero. Defaults to None.\n        cmap (str, optional): The matplotlib colormap to use. Defaults to \"terrain\".\n        factor (float, optional): The scaling factor for the raster. Defaults to 1.0.\n        proj (str, optional): The EPSG projection code. Defaults to \"EPSG:3857\".\n        background (str, optional): The background color. Defaults to None.\n        x (str, optional): The x coordinate. Defaults to None.\n        y (str, optional): The y coordinate. Defaults to None.\n        z (str, optional): The z coordinate. Defaults to None.\n        order (str, optional): The order of the coordinates. Defaults to None.\n        component (str, optional): The component of the coordinates. Defaults to None.\n        open_kwargs (dict, optional): The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.\n        mesh_kwargs (dict, optional): The keyword arguments to pass to pyvista.mesh.warp_by_scalar(). Defaults to {}.\n        **kwargs: Additional keyword arguments to pass to xarray.DataArray.plot().\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    try:\n        import pvxarray\n        import pyvista\n        import rioxarray\n        import xarray\n    except ImportError:\n        raise ImportError(\n            \"pyxarray and rioxarray are required for plotting. Please install them using 'pip install rioxarray pyvista-xarray'.\"\n        )\n\n    if isinstance(background, str):\n        pyvista.global_theme.background = background\n\n    if isinstance(image, str):\n        da = rioxarray.open_rasterio(image, **open_kwargs)\n    elif isinstance(image, xarray.DataArray):\n        da = image\n    else:\n        raise ValueError(\"image must be a string or xarray.Dataset.\")\n\n    if band is not None:\n        da = da[dict(band=band)]\n\n    da = da.rio.reproject(proj)\n    mesh_kwargs[\"factor\"] = factor\n    kwargs[\"cmap\"] = cmap\n\n    coords = list(da.coords)\n\n    if x is None:\n        if \"x\" in coords:\n            x = \"x\"\n        elif \"lon\" in coords:\n            x = \"lon\"\n    if y is None:\n        if \"y\" in coords:\n            y = \"y\"\n        elif \"lat\" in coords:\n            y = \"lat\"\n    if z is None:\n        if \"z\" in coords:\n            z = \"z\"\n        elif \"elevation\" in coords:\n            z = \"elevation\"\n        elif \"band\" in coords:\n            z = \"band\"\n\n    # Grab the mesh object for use with PyVista\n    mesh = da.pyvista.mesh(x=x, y=y, z=z, order=order, component=component)\n\n    # Warp top and plot in 3D\n    mesh.warp_by_scalar(**mesh_kwargs).plot(**kwargs)\n</code></pre>"},{"location":"common/#geemap.common.png_to_gif","title":"<code>png_to_gif(in_dir, out_gif, fps=10, loop=0)</code>","text":"<p>Convert a list of png images to gif.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>The input directory containing png images.</p> required <code>out_gif</code> <code>str</code> <p>The output file path to the gif.</p> required <code>fps</code> <code>int</code> <p>Frames per second. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>bool</code> <p>controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>No png images could be found.</p> Source code in <code>geemap/common.py</code> <pre><code>def png_to_gif(in_dir, out_gif, fps=10, loop=0):\n\"\"\"Convert a list of png images to gif.\n\n    Args:\n        in_dir (str): The input directory containing png images.\n        out_gif (str): The output file path to the gif.\n        fps (int, optional): Frames per second. Defaults to 10.\n        loop (bool, optional): controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    Raises:\n        FileNotFoundError: No png images could be found.\n    \"\"\"\n    import glob\n\n    from PIL import Image\n\n    if not out_gif.endswith(\".gif\"):\n        raise ValueError(\"The out_gif must be a gif file.\")\n\n    out_gif = os.path.abspath(out_gif)\n\n    out_dir = os.path.dirname(out_gif)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    # Create the frames\n    frames = []\n    imgs = list(glob.glob(os.path.join(in_dir, \"*.png\")))\n    imgs.sort()\n\n    if len(imgs) == 0:\n        raise FileNotFoundError(f\"No png could be found in {in_dir}.\")\n\n    for i in imgs:\n        new_frame = Image.open(i)\n        frames.append(new_frame)\n\n    # Save into a GIF file that loops forever\n    frames[0].save(\n        out_gif,\n        format=\"GIF\",\n        append_images=frames[1:],\n        save_all=True,\n        duration=1000 / fps,\n        loop=loop,\n    )\n</code></pre>"},{"location":"common/#geemap.common.points_from_xy","title":"<code>points_from_xy(data, x='longitude', y='latitude', z=None, crs=None, **kwargs)</code>","text":"<p>Create a GeoPandas GeoDataFrame from a csv or Pandas DataFrame containing x, y, z values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>z</code> <code>str</code> <p>The column name for the z values. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str | int</code> <p>The coordinate reference system for the GeoDataFrame. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A GeoPandas GeoDataFrame containing x, y, z values.</p> Source code in <code>geemap/common.py</code> <pre><code>def points_from_xy(data, x=\"longitude\", y=\"latitude\", z=None, crs=None, **kwargs):\n\"\"\"Create a GeoPandas GeoDataFrame from a csv or Pandas DataFrame containing x, y, z values.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        z (str, optional): The column name for the z values. Defaults to None.\n        crs (str | int, optional): The coordinate reference system for the GeoDataFrame. Defaults to None.\n\n    Returns:\n        geopandas.GeoDataFrame: A GeoPandas GeoDataFrame containing x, y, z values.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import pandas as pd\n\n    if crs is None:\n        crs = \"epsg:4326\"\n\n    data = github_raw_url(data)\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif isinstance(data, str):\n        if not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data, **kwargs)\n    else:\n        raise TypeError(\"The data must be a pandas DataFrame or a csv file path.\")\n\n    gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df[x], df[y], z=z, crs=crs))\n\n    return gdf\n</code></pre>"},{"location":"common/#geemap.common.postgis_to_ee","title":"<code>postgis_to_ee(sql, con, geom_col='geom', crs=None, geodestic=False, **kwargs)</code>","text":"<p>Reads data from a PostGIS database and returns a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>geom_col</code> <code>str</code> <p>Column name to convert to shapely geometries. Defaults to \"geom\".</p> <code>'geom'</code> <code>crs</code> <code>str | dict</code> <p>CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.</p> <code>None</code> <code>geodestic</code> <code>bool</code> <p>Whether to use geodestic coordinates. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>geemap/common.py</code> <pre><code>def postgis_to_ee(sql, con, geom_col=\"geom\", crs=None, geodestic=False, **kwargs):\n\"\"\"Reads data from a PostGIS database and returns a GeoDataFrame.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        geom_col (str, optional): Column name to convert to shapely geometries. Defaults to \"geom\".\n        crs (str | dict, optional): CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.\n        geodestic (bool, optional): Whether to use geodestic coordinates. Defaults to False.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    gdf = read_postgis(sql, con, geom_col, crs=crs, **kwargs)\n    fc = gdf_to_ee(gdf, geodesic=geodestic)\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.random_sampling","title":"<code>random_sampling(image, region=None, scale=None, projection=None, factor=None, numPixels=None, seed=0, dropNulls=True, tileScale=1.0, geometries=True, to_pandas=False)</code>","text":"<p>Samples the pixels of an image, returning them as a FeatureCollection. Each feature will have 1 property per band in the input image. Note that the default behavior is to drop features that intersect masked pixels, which result in null-valued properties (see dropNulls argument).</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The image to sample.</p> required <code>region</code> <code>ee.Geometry</code> <p>The region to sample from. If unspecified, uses the image's whole footprint. Defaults to None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to sample in.. Defaults to None.</p> <code>None</code> <code>projection</code> <code>ee.Projection</code> <p>The projection in which to sample. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale.. Defaults to None.</p> <code>None</code> <code>factor</code> <code>float</code> <p>A subsampling factor, within (0, 1]. If specified, 'numPixels' must not be specified. Defaults to no subsampling. Defaults to None.</p> <code>None</code> <code>numPixels</code> <code>int</code> <p>The approximate number of pixels to sample. If specified, 'factor' must not be specified. Defaults to None.</p> <code>None</code> <code>seed</code> <code>int</code> <p>A randomization seed to use for subsampling. Defaults to True. Defaults to 0.</p> <code>0</code> <code>dropNulls</code> <code>bool</code> <p>Post filter the result to drop features that have null-valued properties. Defaults to True.</p> <code>True</code> <code>tileScale</code> <code>float</code> <p>Post filter the result to drop features that have null-valued properties. Defaults to 1.</p> <code>1.0</code> <code>geometries</code> <code>bool</code> <p>If true, adds the center of the sampled pixel as the geometry property of the output feature. Otherwise, geometries will be omitted (saving memory). Defaults to True.</p> <code>True</code> <code>to_pandas</code> <code>bool</code> <p>Whether to return the result as a pandas dataframe. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the input image is not an ee.Image.</p> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>Random sampled points.</p> Source code in <code>geemap/common.py</code> <pre><code>def random_sampling(\n    image,\n    region=None,\n    scale=None,\n    projection=None,\n    factor=None,\n    numPixels=None,\n    seed=0,\n    dropNulls=True,\n    tileScale=1.0,\n    geometries=True,\n    to_pandas=False,\n):\n\"\"\"Samples the pixels of an image, returning them as a FeatureCollection. Each feature will have 1 property per band in the input image. Note that the default behavior is to drop features that intersect masked pixels, which result in null-valued properties (see dropNulls argument).\n\n    Args:\n        image (ee.Image): The image to sample.\n        region (ee.Geometry, optional): The region to sample from. If unspecified, uses the image's whole footprint. Defaults to None.\n        scale (float, optional): A nominal scale in meters of the projection to sample in.. Defaults to None.\n        projection (ee.Projection, optional): The projection in which to sample. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale.. Defaults to None.\n        factor (float, optional): A subsampling factor, within (0, 1]. If specified, 'numPixels' must not be specified. Defaults to no subsampling. Defaults to None.\n        numPixels (int, optional): The approximate number of pixels to sample. If specified, 'factor' must not be specified. Defaults to None.\n        seed (int, optional): A randomization seed to use for subsampling. Defaults to True. Defaults to 0.\n        dropNulls (bool, optional): Post filter the result to drop features that have null-valued properties. Defaults to True.\n        tileScale (float, optional): Post filter the result to drop features that have null-valued properties. Defaults to 1.\n        geometries (bool, optional): If true, adds the center of the sampled pixel as the geometry property of the output feature. Otherwise, geometries will be omitted (saving memory). Defaults to True.\n        to_pandas (bool, optional): Whether to return the result as a pandas dataframe. Defaults to False.\n\n    Raises:\n        TypeError: If the input image is not an ee.Image.\n\n    Returns:\n        ee.FeatureCollection: Random sampled points.\n    \"\"\"\n    if not isinstance(image, ee.Image):\n        raise TypeError(\"The image must be ee.Image\")\n\n    points = image.sample(\n        **{\n            \"region\": region,\n            \"scale\": scale,\n            \"projection\": projection,\n            \"factor\": factor,\n            \"numPixels\": numPixels,\n            \"seed\": seed,\n            \"dropNulls\": dropNulls,\n            \"tileScale\": tileScale,\n            \"geometries\": geometries,\n        }\n    )\n\n    if to_pandas:\n        return ee_to_df(points)\n    else:\n        return points\n</code></pre>"},{"location":"common/#geemap.common.random_string","title":"<code>random_string(string_length=3)</code>","text":"<p>Generates a random string of fixed length.</p> <p>Parameters:</p> Name Type Description Default <code>string_length</code> <code>int</code> <p>Fixed length. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>str</code> <p>A random string</p> Source code in <code>geemap/common.py</code> <pre><code>def random_string(string_length=3):\n\"\"\"Generates a random string of fixed length.\n\n    Args:\n        string_length (int, optional): Fixed length. Defaults to 3.\n\n    Returns:\n        str: A random string\n    \"\"\"\n    import random\n    import string\n\n    # random.seed(1001)\n    letters = string.ascii_lowercase\n    return \"\".join(random.choice(letters) for i in range(string_length))\n</code></pre>"},{"location":"common/#geemap.common.read_api_csv","title":"<code>read_api_csv()</code>","text":"<p>Extracts Earth Engine API from a csv file and returns a dictionary containing information about each function.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The dictionary containing information about each function, including name, description, function form, return type, arguments, html.</p> Source code in <code>geemap/common.py</code> <pre><code>def read_api_csv():\n\"\"\"Extracts Earth Engine API from a csv file and returns a dictionary containing information about each function.\n\n    Returns:\n        dict: The dictionary containing information about each function, including name, description, function form, return type, arguments, html.\n    \"\"\"\n    import copy\n\n    import pkg_resources\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    data_dir = os.path.join(pkg_dir, \"data\")\n    template_dir = os.path.join(data_dir, \"template\")\n    csv_file = os.path.join(template_dir, \"ee_api_docs.csv\")\n    html_file = os.path.join(template_dir, \"ee_api_docs.html\")\n\n    with open(html_file) as f:\n        in_html_lines = f.readlines()\n\n    api_dict = {}\n\n    with open(csv_file, \"r\", encoding=\"utf-8\") as f:\n        csv_reader = csv.DictReader(f, delimiter=\"\\t\")\n\n        for line in csv_reader:\n            out_html_lines = copy.copy(in_html_lines)\n            out_html_lines[65] = in_html_lines[65].replace(\n                \"function_name\", line[\"name\"]\n            )\n            out_html_lines[66] = in_html_lines[66].replace(\n                \"function_description\", line.get(\"description\")\n            )\n            out_html_lines[74] = in_html_lines[74].replace(\n                \"function_usage\", line.get(\"function\")\n            )\n            out_html_lines[75] = in_html_lines[75].replace(\n                \"function_returns\", line.get(\"returns\")\n            )\n\n            arguments = line.get(\"argument\")\n            types = line.get(\"type\")\n            details = line.get(\"details\")\n\n            if \"|\" in arguments:\n                argument_items = arguments.split(\"|\")\n            else:\n                argument_items = [arguments]\n\n            if \"|\" in types:\n                types_items = types.split(\"|\")\n            else:\n                types_items = [types]\n\n            if \"|\" in details:\n                details_items = details.split(\"|\")\n            else:\n                details_items = [details]\n\n            out_argument_lines = []\n\n            for index in range(len(argument_items)):\n                in_argument_lines = in_html_lines[87:92]\n                in_argument_lines[1] = in_argument_lines[1].replace(\n                    \"function_argument\", argument_items[index]\n                )\n                in_argument_lines[2] = in_argument_lines[2].replace(\n                    \"function_type\", types_items[index]\n                )\n                in_argument_lines[3] = in_argument_lines[3].replace(\n                    \"function_details\", details_items[index]\n                )\n                out_argument_lines.append(\"\".join(in_argument_lines))\n\n            out_html_lines = (\n                out_html_lines[:87] + out_argument_lines + out_html_lines[92:]\n            )\n\n            contents = \"\".join(out_html_lines)\n\n            api_dict[line[\"name\"]] = {\n                \"description\": line.get(\"description\"),\n                \"function\": line.get(\"function\"),\n                \"returns\": line.get(\"returns\"),\n                \"argument\": line.get(\"argument\"),\n                \"type\": line.get(\"type\"),\n                \"details\": line.get(\"details\"),\n                \"html\": contents,\n            }\n\n    return api_dict\n</code></pre>"},{"location":"common/#geemap.common.read_file_from_url","title":"<code>read_file_from_url(url, return_type='list', encoding='utf-8')</code>","text":"<p>Reads a file from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file.</p> required <code>return_type</code> <code>str</code> <p>The return type, can either be string or list. Defaults to \"list\".</p> <code>'list'</code> <code>encoding</code> <code>str</code> <p>The encoding of the file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The return type must be either list or string.</p> <p>Returns:</p> Type Description <code>str | list</code> <p>The contents of the file.</p> Source code in <code>geemap/common.py</code> <pre><code>def read_file_from_url(url, return_type=\"list\", encoding=\"utf-8\"):\n\"\"\"Reads a file from a URL.\n\n    Args:\n        url (str): The URL of the file.\n        return_type (str, optional): The return type, can either be string or list. Defaults to \"list\".\n        encoding (str, optional): The encoding of the file. Defaults to \"utf-8\".\n\n    Raises:\n        ValueError: The return type must be either list or string.\n\n    Returns:\n        str | list: The contents of the file.\n    \"\"\"\n    from urllib.request import urlopen\n\n    if return_type == \"list\":\n        return [line.decode(encoding).rstrip() for line in urlopen(url).readlines()]\n    elif return_type == \"string\":\n        return urlopen(url).read().decode(encoding)\n    else:\n        raise ValueError(\"The return type must be either list or string.\")\n</code></pre>"},{"location":"common/#geemap.common.read_lidar","title":"<code>read_lidar(filename, **kwargs)</code>","text":"<p>Read a LAS file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>A local file path or HTTP URL to a LAS file.</p> required <p>Returns:</p> Type Description <code>LasData</code> <p>The LasData object return by laspy.read.</p> Source code in <code>geemap/common.py</code> <pre><code>def read_lidar(filename, **kwargs):\n\"\"\"Read a LAS file.\n\n    Args:\n        filename (str): A local file path or HTTP URL to a LAS file.\n\n    Returns:\n        LasData: The LasData object return by laspy.read.\n    \"\"\"\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if (\n        isinstance(filename, str)\n        and filename.startswith(\"http\")\n        and (filename.endswith(\".las\") or filename.endswith(\".laz\"))\n    ):\n        filename = github_raw_url(filename)\n        filename = download_file(filename)\n\n    return laspy.read(filename, **kwargs)\n</code></pre>"},{"location":"common/#geemap.common.read_netcdf","title":"<code>read_netcdf(filename, **kwargs)</code>","text":"<p>Read a netcdf file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netcdf file.</p> required <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray or rioxarray package is not installed.</p> <code>FileNotFoundError</code> <p>If the netcdf file is not found.</p> <p>Returns:</p> Type Description <code>xarray.Dataset</code> <p>The netcdf file as an xarray dataset.</p> Source code in <code>geemap/common.py</code> <pre><code>def read_netcdf(filename, **kwargs):\n\"\"\"Read a netcdf file.\n\n    Args:\n        filename (str): File path or HTTP URL to the netcdf file.\n\n    Raises:\n        ImportError: If the xarray or rioxarray package is not installed.\n        FileNotFoundError: If the netcdf file is not found.\n\n    Returns:\n        xarray.Dataset: The netcdf file as an xarray dataset.\n    \"\"\"\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    xds = xr.open_dataset(filename, **kwargs)\n    return xds\n</code></pre>"},{"location":"common/#geemap.common.read_postgis","title":"<code>read_postgis(sql, con, geom_col='geom', crs=None, **kwargs)</code>","text":"<p>Reads data from a PostGIS database and returns a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>geom_col</code> <code>str</code> <p>Column name to convert to shapely geometries. Defaults to \"geom\".</p> <code>'geom'</code> <code>crs</code> <code>str | dict</code> <p>CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>geemap/common.py</code> <pre><code>def read_postgis(sql, con, geom_col=\"geom\", crs=None, **kwargs):\n\"\"\"Reads data from a PostGIS database and returns a GeoDataFrame.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        geom_col (str, optional): Column name to convert to shapely geometries. Defaults to \"geom\".\n        crs (str | dict, optional): CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    gdf = gpd.read_postgis(sql, con, geom_col, crs, **kwargs)\n    return gdf\n</code></pre>"},{"location":"common/#geemap.common.remove_geometry","title":"<code>remove_geometry(fc)</code>","text":"<p>Remove .geo coordinate field from a FeatureCollection</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>object</code> <p>The input FeatureCollection.</p> required <p>Returns:</p> Type Description <code>object</code> <p>The output FeatureCollection without the geometry field.</p> Source code in <code>geemap/common.py</code> <pre><code>def remove_geometry(fc):\n\"\"\"Remove .geo coordinate field from a FeatureCollection\n\n    Args:\n        fc (object): The input FeatureCollection.\n\n    Returns:\n        object: The output FeatureCollection without the geometry field.\n    \"\"\"\n    return fc.select([\".*\"], None, False)\n</code></pre>"},{"location":"common/#geemap.common.rename_bands","title":"<code>rename_bands(img, in_band_names, out_band_names)</code>","text":"<p>Renames image bands.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>The image to be renamed.</p> required <code>in_band_names</code> <code>list</code> <p>The list of of input band names.</p> required <code>out_band_names</code> <code>list</code> <p>The list of output band names.</p> required <p>Returns:</p> Type Description <code>object</code> <p>The output image with the renamed bands.</p> Source code in <code>geemap/common.py</code> <pre><code>def rename_bands(img, in_band_names, out_band_names):\n\"\"\"Renames image bands.\n\n    Args:\n        img (object): The image to be renamed.\n        in_band_names (list): The list of of input band names.\n        out_band_names (list): The list of output band names.\n\n    Returns:\n        object: The output image with the renamed bands.\n    \"\"\"\n    return img.select(in_band_names, out_band_names)\n</code></pre>"},{"location":"common/#geemap.common.reproject","title":"<code>reproject(image, output, dst_crs='EPSG:4326', resampling='nearest', **kwargs)</code>","text":"<p>Reprojects an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath.</p> required <code>output</code> <code>str</code> <p>The output image filepath.</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>resampling</code> <code>Resampling</code> <p>The resampling method. Defaults to \"nearest\".</p> <code>'nearest'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.open.</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def reproject(image, output, dst_crs=\"EPSG:4326\", resampling=\"nearest\", **kwargs):\n\"\"\"Reprojects an image.\n\n    Args:\n        image (str): The input image filepath.\n        output (str): The output image filepath.\n        dst_crs (str, optional): The destination CRS. Defaults to \"EPSG:4326\".\n        resampling (Resampling, optional): The resampling method. Defaults to \"nearest\".\n        **kwargs: Additional keyword arguments to pass to rasterio.open.\n\n    \"\"\"\n    import rasterio as rio\n    from rasterio.warp import calculate_default_transform, reproject, Resampling\n\n    if isinstance(resampling, str):\n        resampling = getattr(Resampling, resampling)\n\n    image = os.path.abspath(image)\n    output = os.path.abspath(output)\n\n    if not os.path.exists(os.path.dirname(output)):\n        os.makedirs(os.path.dirname(output))\n\n    with rio.open(image, **kwargs) as src:\n        transform, width, height = calculate_default_transform(\n            src.crs, dst_crs, src.width, src.height, *src.bounds\n        )\n        kwargs = src.meta.copy()\n        kwargs.update(\n            {\n                \"crs\": dst_crs,\n                \"transform\": transform,\n                \"width\": width,\n                \"height\": height,\n            }\n        )\n\n        with rio.open(output, \"w\", **kwargs) as dst:\n            for i in range(1, src.count + 1):\n                reproject(\n                    source=rio.band(src, i),\n                    destination=rio.band(dst, i),\n                    src_transform=src.transform,\n                    src_crs=src.crs,\n                    dst_transform=transform,\n                    dst_crs=dst_crs,\n                    resampling=resampling,\n                    **kwargs,\n                )\n</code></pre>"},{"location":"common/#geemap.common.requireJS","title":"<code>requireJS(lib_path=None, Map=None)</code>","text":"<p>Import Earth Engine JavaScript libraries. Based on the Open Earth Engine Library (OEEL).     For more info, visit https://www.open-geocomputing.org/OpenEarthEngineLibrary.</p> <p>Parameters:</p> Name Type Description Default <code>lib_path</code> <code>str</code> <p>A local file path or HTTP URL to a JavaScript library. It can also be in a format like 'users/gena/packages:grid'. Defaults to None.</p> <code>None</code> <code>Map</code> <code>geemap.Map</code> <p>An geemap.Map object. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>oeel object.</p> Source code in <code>geemap/common.py</code> <pre><code>def requireJS(lib_path=None, Map=None):\n\"\"\"Import Earth Engine JavaScript libraries. Based on the Open Earth Engine Library (OEEL).\n        For more info, visit https://www.open-geocomputing.org/OpenEarthEngineLibrary.\n\n    Args:\n        lib_path (str, optional): A local file path or HTTP URL to a JavaScript library. It can also be in a format like 'users/gena/packages:grid'. Defaults to None.\n        Map (geemap.Map, optional): An geemap.Map object. Defaults to None.\n\n    Returns:\n        object: oeel object.\n    \"\"\"\n    try:\n        from oeel import oeel\n    except ImportError:\n        raise ImportError(\n            \"oeel is required for requireJS. Please install it using 'pip install oeel'.\"\n        )\n\n    ee_initialize()\n\n    if lib_path is None:\n        if Map is not None:\n            oeel.setMap(Map)\n        return oeel\n    elif isinstance(lib_path, str):\n        if lib_path.startswith(\"http\"):\n            lib_path = get_direct_url(lib_path)\n\n        lib_path = change_require(lib_path)\n\n        if Map is not None:\n            oeel.setMap(Map)\n        return oeel.requireJS(lib_path)\n\n    else:\n        raise ValueError(\"lib_path must be a string.\")\n</code></pre>"},{"location":"common/#geemap.common.rgb_to_hex","title":"<code>rgb_to_hex(rgb=(255, 255, 255))</code>","text":"<p>Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255.</p> <p>Parameters:</p> Name Type Description Default <code>rgb</code> <code>tuple</code> <p>RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255).</p> <code>(255, 255, 255)</code> <p>Returns:</p> Type Description <code>str</code> <p>hex color code</p> Source code in <code>geemap/common.py</code> <pre><code>def rgb_to_hex(rgb=(255, 255, 255)):\n\"\"\"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255.\n\n    Args:\n        rgb (tuple, optional): RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255).\n\n    Returns:\n        str: hex color code\n    \"\"\"\n    return \"%02x%02x%02x\" % rgb\n</code></pre>"},{"location":"common/#geemap.common.save_colorbar","title":"<code>save_colorbar(out_fig=None, width=4.0, height=0.3, vmin=0, vmax=1.0, palette=None, vis_params=None, cmap='gray', discrete=False, label=None, label_size=10, label_weight='normal', tick_size=8, bg_color='white', orientation='horizontal', dpi='figure', transparent=False, show_colorbar=True, **kwargs)</code>","text":"<p>Create a standalone colorbar and save it as an image.</p> <p>Parameters:</p> Name Type Description Default <code>out_fig</code> <code>str</code> <p>Path to the output image.</p> <code>None</code> <code>width</code> <code>float</code> <p>Width of the colorbar in inches. Default is 4.0.</p> <code>4.0</code> <code>height</code> <code>float</code> <p>Height of the colorbar in inches. Default is 0.3.</p> <code>0.3</code> <code>vmin</code> <code>float</code> <p>Minimum value of the colorbar. Default is 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value of the colorbar. Default is 1.0.</p> <code>1.0</code> <code>palette</code> <code>list</code> <p>List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>label_size</code> <code>int</code> <p>Font size for the colorbar label. Defaults to 12.</p> <code>10</code> <code>label_weight</code> <code>str</code> <p>Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".</p> <code>'normal'</code> <code>tick_size</code> <code>int</code> <p>Font size for the colorbar tick labels. Defaults to 10.</p> <code>8</code> <code>bg_color</code> <code>str</code> <p>Background color for the colorbar. Defaults to \"white\".</p> <code>'white'</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>dpi</code> <code>float | str</code> <p>The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".</p> <code>'figure'</code> <code>transparent</code> <code>bool</code> <p>Whether to make the background transparent. Defaults to False.</p> <code>False</code> <code>show_colorbar</code> <code>bool</code> <p>Whether to show the colorbar. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Other keyword arguments to pass to matplotlib.pyplot.savefig().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the output image.</p> Source code in <code>geemap/common.py</code> <pre><code>def save_colorbar(\n    out_fig=None,\n    width=4.0,\n    height=0.3,\n    vmin=0,\n    vmax=1.0,\n    palette=None,\n    vis_params=None,\n    cmap=\"gray\",\n    discrete=False,\n    label=None,\n    label_size=10,\n    label_weight=\"normal\",\n    tick_size=8,\n    bg_color=\"white\",\n    orientation=\"horizontal\",\n    dpi=\"figure\",\n    transparent=False,\n    show_colorbar=True,\n    **kwargs,\n):\n\"\"\"Create a standalone colorbar and save it as an image.\n\n    Args:\n        out_fig (str): Path to the output image.\n        width (float): Width of the colorbar in inches. Default is 4.0.\n        height (float): Height of the colorbar in inches. Default is 0.3.\n        vmin (float): Minimum value of the colorbar. Default is 0.\n        vmax (float): Maximum value of the colorbar. Default is 1.0.\n        palette (list): List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.\n        vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n        label_weight (str, optional): Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".\n        tick_size (int, optional): Font size for the colorbar tick labels. Defaults to 10.\n        bg_color (str, optional): Background color for the colorbar. Defaults to \"white\".\n        orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n        dpi (float | str, optional): The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".\n        transparent (bool, optional): Whether to make the background transparent. Defaults to False.\n        show_colorbar (bool, optional): Whether to show the colorbar. Defaults to True.\n        **kwargs: Other keyword arguments to pass to matplotlib.pyplot.savefig().\n\n    Returns:\n        str: Path to the output image.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n    import numpy as np\n    from .colormaps import palettes, get_palette\n\n    if out_fig is None:\n        out_fig = temp_file_path(\"png\")\n    else:\n        out_fig = check_file_path(out_fig)\n\n    if vis_params is None:\n        vis_params = {}\n    elif not isinstance(vis_params, dict):\n        raise TypeError(\"The vis_params must be a dictionary.\")\n\n    if palette is not None:\n        if palette in [\"ndvi\", \"ndwi\", \"dem\"]:\n            palette = palettes[palette]\n        elif palette in list(palettes.keys()):\n            palette = get_palette(palette)\n        vis_params[\"palette\"] = palette\n\n    orientation = orientation.lower()\n    if orientation not in [\"horizontal\", \"vertical\"]:\n        raise ValueError(\"The orientation must be either horizontal or vertical.\")\n\n    if \"opacity\" in vis_params:\n        alpha = vis_params[\"opacity\"]\n        if type(alpha) not in (int, float):\n            raise ValueError(\"The provided opacity value must be type scalar.\")\n    else:\n        alpha = 1\n\n    if cmap is not None:\n        cmap = mpl.pyplot.get_cmap(cmap)\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    if \"palette\" in vis_params:\n        hexcodes = to_hex_colors(vis_params[\"palette\"])\n        if discrete:\n            cmap = mpl.colors.ListedColormap(hexcodes)\n            vals = np.linspace(vmin, vmax, cmap.N + 1)\n            norm = mpl.colors.BoundaryNorm(vals, cmap.N)\n\n        else:\n            cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                \"custom\", hexcodes, N=256\n            )\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    elif cmap is not None:\n        cmap = mpl.pyplot.get_cmap(cmap)\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    else:\n        raise ValueError(\n            'cmap keyword or \"palette\" key in vis_params must be provided.'\n        )\n\n    fig, ax = plt.subplots(figsize=(width, height))\n    cb = mpl.colorbar.ColorbarBase(\n        ax, norm=norm, alpha=alpha, cmap=cmap, orientation=orientation, **kwargs\n    )\n    if label is not None:\n        cb.set_label(label=label, size=label_size, weight=label_weight)\n    cb.ax.tick_params(labelsize=tick_size)\n\n    if transparent:\n        bg_color = None\n\n    if bg_color is not None:\n        kwargs[\"facecolor\"] = bg_color\n    if \"bbox_inches\" not in kwargs:\n        kwargs[\"bbox_inches\"] = \"tight\"\n\n    fig.savefig(out_fig, dpi=dpi, transparent=transparent, **kwargs)\n    if not show_colorbar:\n        plt.close(fig)\n    return out_fig\n</code></pre>"},{"location":"common/#geemap.common.screen_capture","title":"<code>screen_capture(filename, monitor=1)</code>","text":"<p>Takes a full screenshot of the selected monitor.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The output file path to the screenshot.</p> required <code>monitor</code> <code>int</code> <p>The monitor to take the screenshot. Defaults to 1.</p> <code>1</code> Source code in <code>geemap/common.py</code> <pre><code>def screen_capture(filename, monitor=1):\n\"\"\"Takes a full screenshot of the selected monitor.\n\n    Args:\n        filename (str): The output file path to the screenshot.\n        monitor (int, optional): The monitor to take the screenshot. Defaults to 1.\n    \"\"\"\n    try:\n        from mss import mss\n    except ImportError:\n        raise ImportError(\"Please install mss package using 'pip install mss'\")\n\n    out_dir = os.path.dirname(filename)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if not isinstance(monitor, int):\n        print(\"The monitor number must be an integer.\")\n        return\n\n    try:\n        with mss() as sct:\n            sct.shot(output=filename, mon=monitor)\n            return filename\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.search_api_tree","title":"<code>search_api_tree(keywords, api_tree)</code>","text":"<p>Search Earth Engine API and return functions containing the specified keywords</p> <p>Parameters:</p> Name Type Description Default <code>keywords</code> <code>str</code> <p>The keywords to search for.</p> required <code>api_tree</code> <code>dict</code> <p>The dictionary containing the Earth Engine API tree.</p> required <p>Returns:</p> Type Description <code>object</code> <p>An ipytree object/widget.</p> Source code in <code>geemap/common.py</code> <pre><code>def search_api_tree(keywords, api_tree):\n\"\"\"Search Earth Engine API and return functions containing the specified keywords\n\n    Args:\n        keywords (str): The keywords to search for.\n        api_tree (dict): The dictionary containing the Earth Engine API tree.\n\n    Returns:\n        object: An ipytree object/widget.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    sub_tree = Tree()\n\n    for key in api_tree.keys():\n        if keywords.lower() in key.lower():\n            sub_tree.add_node(api_tree[key])\n\n    return sub_tree\n</code></pre>"},{"location":"common/#geemap.common.search_ee_data","title":"<code>search_ee_data(keywords, regex=False, source='ee', types=None, keys=['id', 'provider', 'tags', 'title'])</code>","text":"<p>Searches Earth Engine data catalog.</p> <p>Parameters:</p> Name Type Description Default <code>keywords</code> <code>str | list</code> <p>Keywords to search for can be id, provider, tag and so on. Split by space if string, e.g. \"1 2\" becomes ['1','2'].</p> required <code>regex</code> <code>bool</code> <p>Allow searching for regular expressions. Defaults to false.</p> <code>False</code> <code>source</code> <code>str</code> <p>Can be 'ee', 'community' or 'all'. Defaults to 'ee'. For more details, see https://github.com/samapriya/awesome-gee-community-datasets/blob/master/community_datasets.json</p> <code>'ee'</code> <code>types</code> <code>list</code> <p>List of valid collection types. Defaults to None so no filter is applied. A possible filter ['image_collection']</p> <code>None</code> <code>keys</code> <code>list</code> <p>List of metadata fields to search from.  Defaults to ['id','provider','tags','title']</p> <code>['id', 'provider', 'tags', 'title']</code> <p>Returns:</p> Type Description <code>list</code> <p>Returns a list of assets.</p> Source code in <code>geemap/common.py</code> <pre><code>def search_ee_data(\n    keywords,\n    regex=False,\n    source=\"ee\",\n    types=None,\n    keys=[\"id\", \"provider\", \"tags\", \"title\"],\n):\n\"\"\"Searches Earth Engine data catalog.\n\n    Args:\n        keywords (str | list): Keywords to search for can be id, provider, tag and so on. Split by space if string, e.g. \"1 2\" becomes ['1','2'].\n        regex (bool, optional): Allow searching for regular expressions. Defaults to false.\n        source (str, optional): Can be 'ee', 'community' or 'all'. Defaults to 'ee'. For more details, see https://github.com/samapriya/awesome-gee-community-datasets/blob/master/community_datasets.json\n        types (list, optional): List of valid collection types. Defaults to None so no filter is applied. A possible filter ['image_collection']\n        keys (list, optional): List of metadata fields to search from.  Defaults to ['id','provider','tags','title']\n\n    Returns:\n        list: Returns a list of assets.\n    \"\"\"\n    if isinstance(keywords, str):\n        keywords = keywords.split(\" \")\n\n    import re\n    from functools import reduce\n\n    def search_collection(pattern, dict_):\n        if regex:\n            if any(re.match(pattern, dict_[key]) for key in keys):\n                return dict_\n        elif any(pattern in dict_[key] for key in keys):\n            return dict_\n        return {}\n\n    def search_all(pattern):\n        # updated daily\n        a = \"https://raw.githubusercontent.com/samapriya/Earth-Engine-Datasets-List/master/gee_catalog.json\"\n        b = \"https://raw.githubusercontent.com/samapriya/awesome-gee-community-datasets/master/community_datasets.json\"\n        sources = {\"ee\": [a], \"community\": [b], \"all\": [a, b]}\n        matches = []\n        for link in sources[source]:\n            r = requests.get(link)\n            catalog_list = r.json()\n            matches += [search_collection(pattern, x) for x in catalog_list]\n        matches = [x for x in matches if x]\n        if types:\n            return [x for x in matches if x[\"type\"] in types]\n        return matches\n\n    try:\n        assets = list(\n            {json.dumps(match) for match in search_all(pattern=k)} for k in keywords\n        )\n        assets = sorted(list(reduce(set.intersection, assets)))\n        assets = [json.loads(x) for x in assets]\n\n        results = []\n        for asset in assets:\n            asset_dates = (\n                asset.get(\"start_date\", \"Unknown\")\n                + \" - \"\n                + asset.get(\"end_date\", \"Unknown\")\n            )\n            asset_snippet = asset[\"id\"]\n            if \"ee.\" in asset_snippet:\n                start_index = asset_snippet.index(\"'\") + 1\n                end_index = asset_snippet.index(\"'\", start_index)\n                asset_id = asset_snippet[start_index:end_index]\n            else:\n                asset_id = asset_snippet\n\n            asset[\"dates\"] = asset_dates\n            asset[\"id\"] = asset_id\n            asset[\"uid\"] = asset_id.replace(\"/\", \"_\")\n\n            results.append(asset)\n\n        return results\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.search_qms","title":"<code>search_qms(keyword, limit=10, list_only=True, add_prefix=True, timeout=300)</code>","text":"<p>Search for QMS tile providers from Quick Map Services.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return. Defaults to 10.</p> <code>10</code> <code>list_only</code> <code>bool</code> <p>If True, only the list of services will be returned. Defaults to True.</p> <code>True</code> <code>add_prefix</code> <code>bool</code> <p>If True, the prefix \"qms.\" will be added to the service name. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>The timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of QMS tile providers.</p> Source code in <code>geemap/common.py</code> <pre><code>def search_qms(keyword, limit=10, list_only=True, add_prefix=True, timeout=300):\n\"\"\"Search for QMS tile providers from Quick Map Services.\n\n    Args:\n        keyword (str): The keyword to search for.\n        limit (int, optional): The maximum number of results to return. Defaults to 10.\n        list_only (bool, optional): If True, only the list of services will be returned. Defaults to True.\n        add_prefix (bool, optional): If True, the prefix \"qms.\" will be added to the service name. Defaults to True.\n        timeout (int, optional): The timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A list of QMS tile providers.\n    \"\"\"\n\n    QMS_API = \"https://qms.nextgis.com/api/v1/geoservices\"\n    services = requests.get(\n        f\"{QMS_API}/?search={keyword}&amp;type=tms&amp;epsg=3857&amp;limit={limit}\", timeout=timeout\n    )\n    services = services.json()\n    if services[\"results\"]:\n        providers = services[\"results\"]\n        if list_only:\n            if add_prefix:\n                return [\"qms.\" + provider[\"name\"] for provider in providers]\n            else:\n                return [provider[\"name\"] for provider in providers]\n        else:\n            return providers\n    else:\n        return None\n</code></pre>"},{"location":"common/#geemap.common.search_xyz_services","title":"<code>search_xyz_services(keyword, name=None, list_only=True, add_prefix=True)</code>","text":"<p>Search for XYZ tile providers from xyzservices.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for.</p> required <code>name</code> <code>str</code> <p>The name of the xyz tile. Defaults to None.</p> <code>None</code> <code>list_only</code> <code>bool</code> <p>If True, only the list of services will be returned. Defaults to True.</p> <code>True</code> <code>add_prefix</code> <code>bool</code> <p>If True, the prefix \"xyz.\" will be added to the service name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of XYZ tile providers.</p> Source code in <code>geemap/common.py</code> <pre><code>def search_xyz_services(keyword, name=None, list_only=True, add_prefix=True):\n\"\"\"Search for XYZ tile providers from xyzservices.\n\n    Args:\n        keyword (str): The keyword to search for.\n        name (str, optional): The name of the xyz tile. Defaults to None.\n        list_only (bool, optional): If True, only the list of services will be returned. Defaults to True.\n        add_prefix (bool, optional): If True, the prefix \"xyz.\" will be added to the service name. Defaults to True.\n\n    Returns:\n        list: A list of XYZ tile providers.\n    \"\"\"\n\n    import xyzservices.providers as xyz\n\n    if name is None:\n        providers = xyz.filter(keyword=keyword).flatten()\n    else:\n        providers = xyz.filter(name=name).flatten()\n\n    if list_only:\n        if add_prefix:\n            return [\"xyz.\" + provider for provider in providers]\n        else:\n            return [provider for provider in providers]\n    else:\n        return providers\n</code></pre>"},{"location":"common/#geemap.common.set_api_key","title":"<code>set_api_key(token_name, api_key, m=None)</code>","text":"<p>Sets an API key as an environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>token_name</code> <code>str</code> <p>The token name.</p> required <code>api_key</code> <code>str</code> <p>The API key.</p> required <code>m</code> <code>ipyleaflet.Map | folium.Map</code> <p>A Map instance.. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def set_api_key(token_name, api_key, m=None):\n\"\"\"Sets an API key as an environment variable.\n\n    Args:\n        token_name (str): The token name.\n        api_key (str): The API key.\n        m (ipyleaflet.Map | folium.Map, optional): A Map instance.. Defaults to None.\n    \"\"\"\n    os.environ[token_name] = api_key\n    if m is not None:\n        m.api_keys[token_name] = api_key\n</code></pre>"},{"location":"common/#geemap.common.set_proxy","title":"<code>set_proxy(port=1080, ip='http://127.0.0.1', timeout=300)</code>","text":"<p>Sets proxy if needed. This is only needed for countries where Google services are not available.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The proxy port number. Defaults to 1080.</p> <code>1080</code> <code>ip</code> <code>str</code> <p>The IP address. Defaults to 'http://127.0.0.1'.</p> <code>'http://127.0.0.1'</code> <code>timeout</code> <code>int</code> <p>The timeout in seconds. Defaults to 300.</p> <code>300</code> Source code in <code>geemap/common.py</code> <pre><code>def set_proxy(port=1080, ip=\"http://127.0.0.1\", timeout=300):\n\"\"\"Sets proxy if needed. This is only needed for countries where Google services are not available.\n\n    Args:\n        port (int, optional): The proxy port number. Defaults to 1080.\n        ip (str, optional): The IP address. Defaults to 'http://127.0.0.1'.\n        timeout (int, optional): The timeout in seconds. Defaults to 300.\n    \"\"\"\n    try:\n        if not ip.startswith(\"http\"):\n            ip = \"http://\" + ip\n        proxy = \"{}:{}\".format(ip, port)\n\n        os.environ[\"HTTP_PROXY\"] = proxy\n        os.environ[\"HTTPS_PROXY\"] = proxy\n\n        a = requests.get(\"https://earthengine.google.com/\", timeout=timeout)\n\n        if a.status_code != 200:\n            print(\n                \"Failed to connect to Earth Engine. Please double check the port number and ip address.\"\n            )\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.setupJS","title":"<code>setupJS()</code>","text":"<p>Install npm packages for Earth Engine JavaScript libraries. Based on the Open Earth Engine Library (OEEL).</p> Source code in <code>geemap/common.py</code> <pre><code>def setupJS():\n\"\"\"Install npm packages for Earth Engine JavaScript libraries. Based on the Open Earth Engine Library (OEEL).\"\"\"\n    try:\n        os.system(\"npm install @google/earthengine\")\n        os.system(\"npm install zeromq@6.0.0-beta.6\")\n        os.system(\"npm install request\")\n    except Exception as e:\n        raise Exception(\n            f\"Error installing npm packages: {e}. Make sure that you have installed nodejs. See https://nodejs.org/\"\n        )\n</code></pre>"},{"location":"common/#geemap.common.show_html","title":"<code>show_html(html)</code>","text":"<p>Shows HTML within Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>File path or HTML string.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <p>Returns:</p> Type Description <code>ipywidgets.HTML</code> <p>HTML widget.</p> Source code in <code>geemap/common.py</code> <pre><code>def show_html(html):\n\"\"\"Shows HTML within Jupyter notebook.\n\n    Args:\n        html (str): File path or HTML string.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n\n    Returns:\n        ipywidgets.HTML: HTML widget.\n    \"\"\"\n    if os.path.exists(html):\n        with open(html, \"r\") as f:\n            content = f.read()\n\n        widget = widgets.HTML(value=content)\n        return widget\n    else:\n        try:\n            widget = widgets.HTML(value=html)\n            return widget\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.show_image","title":"<code>show_image(img_path, width=None, height=None)</code>","text":"<p>Shows an image within Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The image file path.</p> required <code>width</code> <code>int</code> <p>Width of the image in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the image in pixels. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def show_image(img_path, width=None, height=None):\n\"\"\"Shows an image within Jupyter notebook.\n\n    Args:\n        img_path (str): The image file path.\n        width (int, optional): Width of the image in pixels. Defaults to None.\n        height (int, optional): Height of the image in pixels. Defaults to None.\n\n    \"\"\"\n    from IPython.display import display\n\n    try:\n        out = widgets.Output()\n        # layout={'border': '1px solid black'})\n        # layout={'border': '1px solid black', 'width': str(width + 20) + 'px', 'height': str(height + 10) + 'px'},)\n        out.clear_output(wait=True)\n        display(out)\n        with out:\n            if isinstance(img_path, str) and img_path.startswith(\"http\"):\n                file_path = download_file(img_path)\n            else:\n                file_path = img_path\n            file = open(file_path, \"rb\")\n            image = file.read()\n            if (width is None) and (height is None):\n                display(widgets.Image(value=image))\n            elif (width is not None) and (height is not None):\n                display(widgets.Image(value=image, width=width, height=height))\n            else:\n                print(\"You need set both width and height.\")\n                return\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.show_youtube","title":"<code>show_youtube(id='h0pz3S6Tvx0')</code>","text":"<p>Displays a YouTube video within Jupyter notebooks.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique ID of the video. Defaults to 'h0pz3S6Tvx0'.</p> <code>'h0pz3S6Tvx0'</code> Source code in <code>geemap/common.py</code> <pre><code>def show_youtube(id=\"h0pz3S6Tvx0\"):\n\"\"\"Displays a YouTube video within Jupyter notebooks.\n\n    Args:\n        id (str, optional): Unique ID of the video. Defaults to 'h0pz3S6Tvx0'.\n\n    \"\"\"\n    from IPython.display import YouTubeVideo, display\n\n    if \"/\" in id:\n        id = id.split(\"/\")[-1]\n\n    try:\n        out = widgets.Output(layout={\"width\": \"815px\"})\n        # layout={'border': '1px solid black', 'width': '815px'})\n        out.clear_output(wait=True)\n        display(out)\n        with out:\n            display(YouTubeVideo(id, width=800, height=450))\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.shp_to_ee","title":"<code>shp_to_ee(in_shp, **kwargs)</code>","text":"<p>Converts a shapefile to Earth Engine objects. Note that the CRS of the shapefile must be EPSG:4326</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path to a shapefile.</p> required <p>Returns:</p> Type Description <code>object</code> <p>Earth Engine objects representing the shapefile.</p> Source code in <code>geemap/common.py</code> <pre><code>def shp_to_ee(in_shp, **kwargs):\n\"\"\"Converts a shapefile to Earth Engine objects. Note that the CRS of the shapefile must be EPSG:4326\n\n    Args:\n        in_shp (str): File path to a shapefile.\n\n    Returns:\n        object: Earth Engine objects representing the shapefile.\n    \"\"\"\n    # ee_initialize()\n    try:\n        if \"encoding\" in kwargs:\n            json_data = shp_to_geojson(in_shp, encoding=kwargs.pop(\"encoding\"))\n        else:\n            json_data = shp_to_geojson(in_shp)\n        ee_object = geojson_to_ee(json_data)\n        return ee_object\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.shp_to_gdf","title":"<code>shp_to_gdf(in_shp, **kwargs)</code>","text":"<p>Converts a shapefile to Geopandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path to the input shapefile.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shp could not be found.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame</p> Source code in <code>geemap/common.py</code> <pre><code>def shp_to_gdf(in_shp, **kwargs):\n\"\"\"Converts a shapefile to Geopandas dataframe.\n\n    Args:\n        in_shp (str): File path to the input shapefile.\n\n    Raises:\n        FileNotFoundError: The provided shp could not be found.\n\n    Returns:\n        gpd.GeoDataFrame: geopandas.GeoDataFrame\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_shp = os.path.abspath(in_shp)\n    if not os.path.exists(in_shp):\n        raise FileNotFoundError(\"The provided shp could not be found.\")\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    try:\n        return gpd.read_file(in_shp, **kwargs)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.shp_to_geojson","title":"<code>shp_to_geojson(in_shp, filename=None, **kwargs)</code>","text":"<p>Converts a shapefile to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path of the input shapefile.</p> required <code>filename</code> <code>str</code> <p>File path of the output GeoJSON. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>The json object representing the shapefile.</p> Source code in <code>geemap/common.py</code> <pre><code>def shp_to_geojson(in_shp, filename=None, **kwargs):\n\"\"\"Converts a shapefile to GeoJSON.\n\n    Args:\n        in_shp (str): File path of the input shapefile.\n        filename (str, optional): File path of the output GeoJSON. Defaults to None.\n\n    Returns:\n        object: The json object representing the shapefile.\n    \"\"\"\n    try:\n        import shapefile\n\n        # from datetime import date\n\n        in_shp = os.path.abspath(in_shp)\n\n        if filename is not None:\n            ext = os.path.splitext(filename)[1]\n            print(ext)\n            if ext.lower() not in [\".json\", \".geojson\"]:\n                raise TypeError(\"The output file extension must the .json or .geojson.\")\n\n            if not os.path.exists(os.path.dirname(filename)):\n                os.makedirs(os.path.dirname(filename))\n\n        if not is_GCS(in_shp):\n            try:\n                import geopandas as gpd\n\n            except Exception:\n                raise ImportError(\n                    \"GeoPandas is required to perform reprojection of the data. See https://geopandas.org/install.html\"\n                )\n\n            try:\n                in_gdf = gpd.read_file(in_shp)\n                out_gdf = in_gdf.to_crs(epsg=\"4326\")\n                out_shp = in_shp.replace(\".shp\", \"_gcs.shp\")\n                out_gdf.to_file(out_shp)\n                in_shp = out_shp\n            except Exception as e:\n                raise Exception(e)\n\n        if \"encoding\" in kwargs:\n            reader = shapefile.Reader(in_shp, encoding=kwargs.pop(\"encoding\"))\n        else:\n            reader = shapefile.Reader(in_shp)\n        out_dict = reader.__geo_interface__\n        # fields = reader.fields[1:]\n        # field_names = [field[0] for field in fields]\n        # # pyShp returns dates as `datetime.date` or as `bytes` when they are empty\n        # # This is not JSON compatible, so we keep track of them to convert them to str\n        # date_fields_names = [field[0] for field in fields if field[1] == \"D\"]\n        # buffer = []\n        # for sr in reader.shapeRecords():\n        #     atr = dict(zip(field_names, sr.record))\n        #     for date_field in date_fields_names:\n        #         value = atr[date_field]\n        #         # convert date to string, similar to pyShp writing\n        #         # https://github.com/GeospatialPython/pyshp/blob/69c60f6d07c329f7d3ac2cba79bc03643bd424d8/shapefile.py#L1814\n        #         if isinstance(value, date):\n        #             value = \"{:04d}{:02d}{:02d}\".format(\n        #                 value.year, value.month, value.day\n        #             )\n        #         elif not value:  # empty bytes string\n        #             value = \"0\" * 8  # QGIS NULL for date type\n        #         atr[date_field] = value\n        #     geom = sr.shape.__geo_interface__\n        #     buffer.append(dict(type=\"Feature\", geometry=geom, properties=atr))\n\n        # out_dict = {\"type\": \"FeatureCollection\", \"features\": buffer}\n\n        if filename is not None:\n            # from json import dumps\n\n            with open(filename, \"w\") as geojson:\n                geojson.write(json.dumps(out_dict, indent=2) + \"\\n\")\n        else:\n            return out_dict\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.shp_to_geopandas","title":"<code>shp_to_geopandas(in_shp, **kwargs)</code>","text":"<p>Converts a shapefile to Geopandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path to the input shapefile.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shp could not be found.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame</p> Source code in <code>geemap/common.py</code> <pre><code>def shp_to_gdf(in_shp, **kwargs):\n\"\"\"Converts a shapefile to Geopandas dataframe.\n\n    Args:\n        in_shp (str): File path to the input shapefile.\n\n    Raises:\n        FileNotFoundError: The provided shp could not be found.\n\n    Returns:\n        gpd.GeoDataFrame: geopandas.GeoDataFrame\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_shp = os.path.abspath(in_shp)\n    if not os.path.exists(in_shp):\n        raise FileNotFoundError(\"The provided shp could not be found.\")\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    try:\n        return gpd.read_file(in_shp, **kwargs)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.stac_assets","title":"<code>stac_assets(url=None, collection=None, item=None, titiler_endpoint=None, timeout=300, **kwargs)</code>","text":"<p>Get all assets of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of assets.</p> Source code in <code>geemap/common.py</code> <pre><code>def stac_assets(\n    url=None, collection=None, item=None, titiler_endpoint=None, timeout=300, **kwargs\n):\n\"\"\"Get all assets of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A list of assets.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        url = get_direct_url(url)\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/assets\", params=kwargs, timeout=timeout\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_assets(), params=kwargs, timeout=timeout\n        ).json()\n\n    return r\n</code></pre>"},{"location":"common/#geemap.common.stac_bands","title":"<code>stac_bands(url=None, collection=None, item=None, titiler_endpoint=None, timeout=300, **kwargs)</code>","text":"<p>Get band names of a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of band names</p> Source code in <code>geemap/common.py</code> <pre><code>def stac_bands(\n    url=None, collection=None, item=None, titiler_endpoint=None, timeout=300, **kwargs\n):\n\"\"\"Get band names of a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A list of band names\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        url = get_direct_url(url)\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/assets\", params=kwargs, timeout=timeout\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_assets(), params=kwargs, timeout=timeout\n        ).json()\n\n    return r\n</code></pre>"},{"location":"common/#geemap.common.stac_bounds","title":"<code>stac_bounds(url=None, collection=None, item=None, titiler_endpoint=None, timeout=300, **kwargs)</code>","text":"<p>Get the bounding box of a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of values representing [left, bottom, right, top]</p> Source code in <code>geemap/common.py</code> <pre><code>def stac_bounds(\n    url=None, collection=None, item=None, titiler_endpoint=None, timeout=300, **kwargs\n):\n\"\"\"Get the bounding box of a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A list of values representing [left, bottom, right, top]\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        url = get_direct_url(url)\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/bounds\", params=kwargs, timeout=timeout\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_bounds(), params=kwargs, timeout=timeout\n        ).json()\n\n    bounds = r[\"bounds\"]\n    return bounds\n</code></pre>"},{"location":"common/#geemap.common.stac_center","title":"<code>stac_center(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the centroid of a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing (longitude, latitude)</p> Source code in <code>geemap/common.py</code> <pre><code>def stac_center(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs):\n\"\"\"Get the centroid of a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        tuple: A tuple representing (longitude, latitude)\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if isinstance(url, str):\n        url = get_direct_url(url)\n    bounds = stac_bounds(url, collection, item, titiler_endpoint, **kwargs)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lon, lat)\n    return center\n</code></pre>"},{"location":"common/#geemap.common.stac_info","title":"<code>stac_info(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, timeout=300, **kwargs)</code>","text":"<p>Get band info of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>geemap/common.py</code> <pre><code>def stac_info(\n    url=None,\n    collection=None,\n    item=None,\n    assets=None,\n    titiler_endpoint=None,\n    timeout=300,\n    **kwargs,\n):\n\"\"\"Get band info of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        url = get_direct_url(url)\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n    if assets is not None:\n        kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/info\", params=kwargs, timeout=timeout\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_info(), params=kwargs, timeout=timeout\n        ).json()\n\n    return r\n</code></pre>"},{"location":"common/#geemap.common.stac_info_geojson","title":"<code>stac_info_geojson(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, timeout=300, **kwargs)</code>","text":"<p>Get band info of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>geemap/common.py</code> <pre><code>def stac_info_geojson(\n    url=None,\n    collection=None,\n    item=None,\n    assets=None,\n    titiler_endpoint=None,\n    timeout=300,\n    **kwargs,\n):\n\"\"\"Get band info of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        url = get_direct_url(url)\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n    if assets is not None:\n        kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/info.geojson\", params=kwargs, timeout=timeout\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_info_geojson(), params=kwargs, timeout=timeout\n        ).json()\n\n    return r\n</code></pre>"},{"location":"common/#geemap.common.stac_pixel_value","title":"<code>stac_pixel_value(lon, lat, url=None, collection=None, item=None, assets=None, titiler_endpoint=None, verbose=True, timeout=300, **kwargs)</code>","text":"<p>Get pixel value from STAC assets.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print out the error message. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of pixel values for each asset.</p> Source code in <code>geemap/common.py</code> <pre><code>def stac_pixel_value(\n    lon,\n    lat,\n    url=None,\n    collection=None,\n    item=None,\n    assets=None,\n    titiler_endpoint=None,\n    verbose=True,\n    timeout=300,\n    **kwargs,\n):\n\"\"\"Get pixel value from STAC assets.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        verbose (bool, optional): Print out the error message. Defaults to True.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A dictionary of pixel values for each asset.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        url = get_direct_url(url)\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    if assets is None:\n        assets = stac_assets(\n            url=url,\n            collection=collection,\n            item=item,\n            titiler_endpoint=titiler_endpoint,\n        )\n        assets = \",\".join(assets)\n    kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/{lon},{lat}\", params=kwargs, timeout=timeout\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_pixel_value(lon, lat),\n            params=kwargs,\n            timeout=timeout,\n        ).json()\n\n    if \"detail\" in r:\n        if verbose:\n            print(r[\"detail\"])\n        return None\n    else:\n        values = [v[0] for v in r[\"values\"]]\n        result = dict(zip(assets.split(\",\"), values))\n        return result\n</code></pre>"},{"location":"common/#geemap.common.stac_stats","title":"<code>stac_stats(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, timeout=300, **kwargs)</code>","text":"<p>Get band statistics of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band statistics.</p> Source code in <code>geemap/common.py</code> <pre><code>def stac_stats(\n    url=None,\n    collection=None,\n    item=None,\n    assets=None,\n    titiler_endpoint=None,\n    timeout=300,\n    **kwargs,\n):\n\"\"\"Get band statistics of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        list: A dictionary of band statistics.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        url = get_direct_url(url)\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n    if assets is not None:\n        kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/statistics\", params=kwargs, timeout=timeout\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_statistics(), params=kwargs, timeout=timeout\n        ).json()\n\n    return r\n</code></pre>"},{"location":"common/#geemap.common.stac_tile","title":"<code>stac_tile(url=None, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, timeout=300, **kwargs)</code>","text":"<p>Get a tile layer from a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <p>Returns:</p> Type Description <code>str</code> <p>Returns the STAC Tile layer URL.</p> Source code in <code>geemap/common.py</code> <pre><code>def stac_tile(\n    url=None,\n    collection=None,\n    item=None,\n    assets=None,\n    bands=None,\n    titiler_endpoint=None,\n    timeout=300,\n    **kwargs,\n):\n\"\"\"Get a tile layer from a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n\n    Returns:\n        str: Returns the STAC Tile layer URL.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        url = get_direct_url(url)\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    if \"palette\" in kwargs:\n        kwargs[\"colormap_name\"] = kwargs[\"palette\"]\n        del kwargs[\"palette\"]\n\n    if isinstance(bands, list) and len(set(bands)) == 1:\n        bands = bands[0]\n\n    if isinstance(assets, list) and len(set(assets)) == 1:\n        assets = assets[0]\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(titiler_endpoint, PlanetaryComputerEndpoint):\n        if isinstance(bands, str):\n            bands = bands.split(\",\")\n        if isinstance(assets, str):\n            assets = assets.split(\",\")\n        if assets is None and (bands is not None):\n            assets = bands\n        else:\n            kwargs[\"bidx\"] = bands\n\n        kwargs[\"assets\"] = assets\n\n        # if (\"expression\" in kwargs) and (\"rescale\" not in kwargs):\n        #     stats = stac_stats(\n        #         collection=collection,\n        #         item=item,\n        #         expression=kwargs[\"expression\"],\n        #         titiler_endpoint=titiler_endpoint,\n        #     )\n        #     kwargs[\n        #         \"rescale\"\n        #     ] = f\"{stats[0]['percentile_2']},{stats[0]['percentile_98']}\"\n\n        # if (\"asset_expression\" in kwargs) and (\"rescale\" not in kwargs):\n        #     stats = stac_stats(\n        #         collection=collection,\n        #         item=item,\n        #         expression=kwargs[\"asset_expression\"],\n        #         titiler_endpoint=titiler_endpoint,\n        #     )\n        #     kwargs[\n        #         \"rescale\"\n        #     ] = f\"{stats[0]['percentile_2']},{stats[0]['percentile_98']}\"\n\n        if (\n            (assets is not None)\n            and (\"asset_expression\" not in kwargs)\n            and (\"expression\" not in kwargs)\n            and (\"rescale\" not in kwargs)\n        ):\n            stats = stac_stats(\n                collection=collection,\n                item=item,\n                assets=assets,\n                titiler_endpoint=titiler_endpoint,\n            )\n            if \"detail\" not in stats:\n                try:\n                    percentile_2 = min([stats[s][\"percentile_2\"] for s in stats])\n                    percentile_98 = max([stats[s][\"percentile_98\"] for s in stats])\n                except:\n                    percentile_2 = min(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_2\"]\n                            for s in stats\n                        ]\n                    )\n                    percentile_98 = max(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_98\"]\n                            for s in stats\n                        ]\n                    )\n                kwargs[\"rescale\"] = f\"{percentile_2},{percentile_98}\"\n            else:\n                print(stats[\"detail\"])  # When operation times out.\n\n    else:\n        if isinstance(bands, str):\n            bands = bands.split(\",\")\n        if isinstance(assets, str):\n            assets = assets.split(\",\")\n\n        if assets is None and (bands is not None):\n            assets = bands\n        else:\n            kwargs[\"asset_bidx\"] = bands\n        kwargs[\"assets\"] = assets\n\n    TileMatrixSetId = \"WebMercatorQuad\"\n    if \"TileMatrixSetId\" in kwargs.keys():\n        TileMatrixSetId = kwargs[\"TileMatrixSetId\"]\n        kwargs.pop(\"TileMatrixSetId\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/{TileMatrixSetId}/tilejson.json\",\n            params=kwargs,\n            timeout=timeout,\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_item(), params=kwargs, timeout=timeout\n        ).json()\n\n    return r[\"tiles\"][0]\n</code></pre>"},{"location":"common/#geemap.common.str_to_num","title":"<code>str_to_num(in_str)</code>","text":"<p>Converts a string to an ee.Number.</p> <p>Parameters:</p> Name Type Description Default <code>in_str</code> <code>str</code> <p>The string to convert to a number.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.Number</p> Source code in <code>geemap/common.py</code> <pre><code>def str_to_num(in_str):\n\"\"\"Converts a string to an ee.Number.\n\n    Args:\n        in_str (str): The string to convert to a number.\n\n    Returns:\n        object: ee.Number\n    \"\"\"\n    return ee.Number.parse(str)\n</code></pre>"},{"location":"common/#geemap.common.summarize_by_group","title":"<code>summarize_by_group(collection, column, group, group_name, stats_type, return_dict=True)</code>","text":"<p>Calculates summary statistics by group.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>object</code> <p>The input feature collection</p> required <code>column</code> <code>str</code> <p>The value column to calculate summary statistics.</p> required <code>group</code> <code>str</code> <p>The name of the group column.</p> required <code>group_name</code> <code>str</code> <p>The new group name to use.</p> required <code>stats_type</code> <code>str</code> <p>The type of summary statistics.</p> required <code>return_dict</code> <code>bool</code> <p>Whether to return the result as a dictionary.</p> <code>True</code> <p>Returns:</p> Type Description <code>object</code> <p>ee.Dictionary or ee.List</p> Source code in <code>geemap/common.py</code> <pre><code>def summarize_by_group(\n    collection, column, group, group_name, stats_type, return_dict=True\n):\n\"\"\"Calculates summary statistics by group.\n\n    Args:\n        collection (object): The input feature collection\n        column (str): The value column to calculate summary statistics.\n        group (str): The name of the group column.\n        group_name (str): The new group name to use.\n        stats_type (str): The type of summary statistics.\n        return_dict (bool): Whether to return the result as a dictionary.\n\n    Returns:\n        object: ee.Dictionary or ee.List\n    \"\"\"\n    stats_type = stats_type.lower()\n    allowed_stats = [\"min\", \"max\", \"mean\", \"median\", \"sum\", \"stdDev\", \"variance\"]\n    if stats_type not in allowed_stats:\n        print(\n            \"The stats type must be one of the following: {}\".format(\n                \",\".join(allowed_stats)\n            )\n        )\n        return\n\n    stats_dict = {\n        \"min\": ee.Reducer.min(),\n        \"max\": ee.Reducer.max(),\n        \"mean\": ee.Reducer.mean(),\n        \"median\": ee.Reducer.median(),\n        \"sum\": ee.Reducer.sum(),\n        \"stdDev\": ee.Reducer.stdDev(),\n        \"variance\": ee.Reducer.variance(),\n    }\n\n    selectors = [column, group]\n    stats = collection.reduceColumns(\n        **{\n            \"selectors\": selectors,\n            \"reducer\": stats_dict[stats_type].group(\n                **{\"groupField\": 1, \"groupName\": group_name}\n            ),\n        }\n    )\n    results = ee.List(ee.Dictionary(stats).get(\"groups\"))\n    if return_dict:\n        keys = results.map(lambda k: ee.Dictionary(k).get(group_name))\n        values = results.map(lambda v: ee.Dictionary(v).get(stats_type))\n        results = ee.Dictionary.fromLists(keys, values)\n\n    return results\n</code></pre>"},{"location":"common/#geemap.common.summary_stats","title":"<code>summary_stats(collection, column)</code>","text":"<p>Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean, sample standard deviation, sample variance, total standard deviation and total variance of the selected property.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>FeatureCollection</code> <p>The input feature collection to calculate summary statistics.</p> required <code>column</code> <code>str</code> <p>The name of the column to calculate summary statistics.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The dictionary containing information about the summary statistics.</p> Source code in <code>geemap/common.py</code> <pre><code>def summary_stats(collection, column):\n\"\"\"Aggregates over a given property of the objects in a collection, calculating the sum, min, max, mean,\n    sample standard deviation, sample variance, total standard deviation and total variance of the selected property.\n\n    Args:\n        collection (FeatureCollection): The input feature collection to calculate summary statistics.\n        column (str): The name of the column to calculate summary statistics.\n\n    Returns:\n        dict: The dictionary containing information about the summary statistics.\n    \"\"\"\n    stats = collection.aggregate_stats(column).getInfo()\n    return eval(str(stats))\n</code></pre>"},{"location":"common/#geemap.common.system_fonts","title":"<code>system_fonts(show_full_path=False)</code>","text":"<p>Gets a list of system fonts</p> <pre><code># Common font locations:\n# Linux: /usr/share/fonts/TTF/\n# Windows: C:/Windows/Fonts\n# macOS:  System &gt; Library &gt; Fonts\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>show_full_path</code> <code>bool</code> <p>Whether to show the full path of each system font. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of system fonts.</p> Source code in <code>geemap/common.py</code> <pre><code>def system_fonts(show_full_path=False):\n\"\"\"Gets a list of system fonts\n\n        # Common font locations:\n        # Linux: /usr/share/fonts/TTF/\n        # Windows: C:/Windows/Fonts\n        # macOS:  System &gt; Library &gt; Fonts\n\n    Args:\n        show_full_path (bool, optional): Whether to show the full path of each system font. Defaults to False.\n\n    Returns:\n        list: A list of system fonts.\n    \"\"\"\n    try:\n        import matplotlib.font_manager\n\n        font_list = matplotlib.font_manager.findSystemFonts(\n            fontpaths=None, fontext=\"ttf\"\n        )\n        font_list.sort()\n\n        font_names = [os.path.basename(f) for f in font_list]\n        font_names.sort()\n\n        if show_full_path:\n            return font_list\n        else:\n            return font_names\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.temp_file_path","title":"<code>temp_file_path(extension)</code>","text":"<p>Returns a temporary file path.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The file extension.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The temporary file path.</p> Source code in <code>geemap/common.py</code> <pre><code>def temp_file_path(extension):\n\"\"\"Returns a temporary file path.\n\n    Args:\n        extension (str): The file extension.\n\n    Returns:\n        str: The temporary file path.\n    \"\"\"\n\n    import tempfile\n    import uuid\n\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    file_id = str(uuid.uuid4())\n    file_path = os.path.join(tempfile.gettempdir(), f\"{file_id}{extension}\")\n\n    return file_path\n</code></pre>"},{"location":"common/#geemap.common.tif_to_jp2","title":"<code>tif_to_jp2(filename, output, creationOptions=None)</code>","text":"<p>Converts a GeoTIFF to JPEG2000.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the GeoTIFF file.</p> required <code>output</code> <code>str</code> <p>The path to the output JPEG2000 file.</p> required <code>creationOptions</code> <code>list</code> <p>A list of creation options for the JPEG2000 file. See https://gdal.org/drivers/raster/jp2openjpeg.html. For example, to specify the compression ratio, use <code>[\"QUALITY=20\"]</code>. A value of 20 means the file will be 20% of the size in comparison to uncompressed data.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def tif_to_jp2(filename, output, creationOptions=None):\n\"\"\"Converts a GeoTIFF to JPEG2000.\n\n    Args:\n        filename (str): The path to the GeoTIFF file.\n        output (str): The path to the output JPEG2000 file.\n        creationOptions (list): A list of creation options for the JPEG2000 file. See\n            https://gdal.org/drivers/raster/jp2openjpeg.html. For example, to specify the compression\n            ratio, use ``[\"QUALITY=20\"]``. A value of 20 means the file will be 20% of the size in comparison\n            to uncompressed data.\n\n    \"\"\"\n\n    if not os.path.exists(filename):\n        raise Exception(f\"File {filename} does not exist\")\n\n    if not output.endswith(\".jp2\"):\n        output += \".jp2\"\n\n    try:\n        from osgeo import gdal\n    except ImportError:\n        raise ImportError(\"GDAL is required to convert GeoTIFF to JPEG2000\")\n\n    in_ds = gdal.Open(filename)\n    gdal.Translate(output, in_ds, format=\"JP2OpenJPEG\", creationOptions=creationOptions)\n    in_ds = None\n</code></pre>"},{"location":"common/#geemap.common.tms_to_geotiff","title":"<code>tms_to_geotiff(output, bbox, zoom=None, resolution=None, source='OpenStreetMap', crs='EPSG:3857', to_cog=False, quiet=False, **kwargs)</code>","text":"<p>Download TMS tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.     Credits to the GitHub user @gumblex.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The output GeoTIFF file.</p> required <code>bbox</code> <code>list</code> <p>The bounding box [minx, miny, maxx, maxy], e.g., [-122.5216, 37.733, -122.3661, 37.8095]</p> required <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>float</code> <p>The resolution in meters. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().</p> <code>{}</code> Source code in <code>geemap/common.py</code> <pre><code>def tms_to_geotiff(\n    output,\n    bbox,\n    zoom=None,\n    resolution=None,\n    source=\"OpenStreetMap\",\n    crs=\"EPSG:3857\",\n    to_cog=False,\n    quiet=False,\n    **kwargs,\n):\n\"\"\"Download TMS tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.\n        Credits to the GitHub user @gumblex.\n\n    Args:\n        output (str): The output GeoTIFF file.\n        bbox (list): The bounding box [minx, miny, maxx, maxy], e.g., [-122.5216, 37.733, -122.3661, 37.8095]\n        zoom (int, optional): The map zoom level. Defaults to None.\n        resolution (float, optional): The resolution in meters. Defaults to None.\n        source (str, optional): The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\",\n            \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".\n        crs (str, optional): The coordinate reference system. Defaults to \"EPSG:3857\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        quiet (bool, optional): Suppress output. Defaults to False.\n        **kwargs: Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().\n\n    \"\"\"\n\n    import io\n    import math\n    import itertools\n    import concurrent.futures\n\n    import numpy\n    from PIL import Image\n\n    try:\n        from osgeo import gdal, osr\n    except ImportError:\n        raise ImportError(\"GDAL is not installed. Install it with pip install GDAL\")\n\n    try:\n        import httpx\n\n        SESSION = httpx.Client()\n    except ImportError:\n        import requests\n\n        SESSION = requests.Session()\n\n    xyz_tiles = {\n        \"OPENSTREETMAP\": {\n            \"url\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"attribution\": \"OpenStreetMap\",\n            \"name\": \"OpenStreetMap\",\n        },\n        \"ROADMAP\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Maps\",\n        },\n        \"SATELLITE\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n        \"TERRAIN\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Terrain\",\n        },\n        \"HYBRID\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n    }\n\n    if isinstance(source, str) and source.upper() in xyz_tiles:\n        source = xyz_tiles[source.upper()][\"url\"]\n    elif isinstance(source, str) and source.startswith(\"http\"):\n        pass\n    else:\n        raise ValueError(\n            'source must be one of \"OpenStreetMap\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or a URL'\n        )\n\n    def resolution_to_zoom_level(resolution):\n\"\"\"\n        Convert map resolution in meters to zoom level for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        # Web Mercator tile size in meters at zoom level 0\n        initial_resolution = 156543.03392804097\n\n        # Calculate the zoom level\n        zoom_level = math.log2(initial_resolution / resolution)\n\n        return int(zoom_level)\n\n    if isinstance(bbox, list) and len(bbox) == 4:\n        west, south, east, north = bbox\n    else:\n        raise ValueError(\n            \"bbox must be a list of 4 coordinates in the format of [xmin, ymin, xmax, ymax]\"\n        )\n\n    if zoom is None and resolution is None:\n        raise ValueError(\"Either zoom or resolution must be provided\")\n    elif zoom is not None and resolution is not None:\n        raise ValueError(\"Only one of zoom or resolution can be provided\")\n\n    if resolution is not None:\n        zoom = resolution_to_zoom_level(resolution)\n\n    EARTH_EQUATORIAL_RADIUS = 6378137.0\n\n    Image.MAX_IMAGE_PIXELS = None\n\n    gdal.UseExceptions()\n    web_mercator = osr.SpatialReference()\n    web_mercator.ImportFromEPSG(3857)\n\n    WKT_3857 = web_mercator.ExportToWkt()\n\n    def from4326_to3857(lat, lon):\n        xtile = math.radians(lon) * EARTH_EQUATORIAL_RADIUS\n        ytile = (\n            math.log(math.tan(math.radians(45 + lat / 2.0))) * EARTH_EQUATORIAL_RADIUS\n        )\n        return (xtile, ytile)\n\n    def deg2num(lat, lon, zoom):\n        lat_r = math.radians(lat)\n        n = 2**zoom\n        xtile = (lon + 180) / 360 * n\n        ytile = (1 - math.log(math.tan(lat_r) + 1 / math.cos(lat_r)) / math.pi) / 2 * n\n        return (xtile, ytile)\n\n    def is_empty(im):\n        extrema = im.getextrema()\n        if len(extrema) &gt;= 3:\n            if len(extrema) &gt; 3 and extrema[-1] == (0, 0):\n                return True\n            for ext in extrema[:3]:\n                if ext != (0, 0):\n                    return False\n            return True\n        else:\n            return extrema[0] == (0, 0)\n\n    def paste_tile(bigim, base_size, tile, corner_xy, bbox):\n        if tile is None:\n            return bigim\n        im = Image.open(io.BytesIO(tile))\n        mode = \"RGB\" if im.mode == \"RGB\" else \"RGBA\"\n        size = im.size\n        if bigim is None:\n            base_size[0] = size[0]\n            base_size[1] = size[1]\n            newim = Image.new(\n                mode, (size[0] * (bbox[2] - bbox[0]), size[1] * (bbox[3] - bbox[1]))\n            )\n        else:\n            newim = bigim\n\n        dx = abs(corner_xy[0] - bbox[0])\n        dy = abs(corner_xy[1] - bbox[1])\n        xy0 = (size[0] * dx, size[1] * dy)\n        if mode == \"RGB\":\n            newim.paste(im, xy0)\n        else:\n            if im.mode != mode:\n                im = im.convert(mode)\n            if not is_empty(im):\n                newim.paste(im, xy0)\n        im.close()\n        return newim\n\n    def finish_picture(bigim, base_size, bbox, x0, y0, x1, y1):\n        xfrac = x0 - bbox[0]\n        yfrac = y0 - bbox[1]\n        x2 = round(base_size[0] * xfrac)\n        y2 = round(base_size[1] * yfrac)\n        imgw = round(base_size[0] * (x1 - x0))\n        imgh = round(base_size[1] * (y1 - y0))\n        retim = bigim.crop((x2, y2, x2 + imgw, y2 + imgh))\n        if retim.mode == \"RGBA\" and retim.getextrema()[3] == (255, 255):\n            retim = retim.convert(\"RGB\")\n        bigim.close()\n        return retim\n\n    def get_tile(url):\n        retry = 3\n        while 1:\n            try:\n                r = SESSION.get(url, timeout=60)\n                break\n            except Exception:\n                retry -= 1\n                if not retry:\n                    raise\n        if r.status_code == 404:\n            return None\n        elif not r.content:\n            return None\n        r.raise_for_status()\n        return r.content\n\n    def draw_tile(\n        source, lat0, lon0, lat1, lon1, zoom, filename, quiet=False, **kwargs\n    ):\n        x0, y0 = deg2num(lat0, lon0, zoom)\n        x1, y1 = deg2num(lat1, lon1, zoom)\n        if x0 &gt; x1:\n            x0, x1 = x1, x0\n        if y0 &gt; y1:\n            y0, y1 = y1, y0\n        corners = tuple(\n            itertools.product(\n                range(math.floor(x0), math.ceil(x1)),\n                range(math.floor(y0), math.ceil(y1)),\n            )\n        )\n        totalnum = len(corners)\n        futures = []\n        with concurrent.futures.ThreadPoolExecutor(5) as executor:\n            for x, y in corners:\n                futures.append(\n                    executor.submit(get_tile, source.format(z=zoom, x=x, y=y))\n                )\n            bbox = (math.floor(x0), math.floor(y0), math.ceil(x1), math.ceil(y1))\n            bigim = None\n            base_size = [256, 256]\n            for k, (fut, corner_xy) in enumerate(zip(futures, corners), 1):\n                bigim = paste_tile(bigim, base_size, fut.result(), corner_xy, bbox)\n                if not quiet:\n                    print(\"Downloaded image %d/%d\" % (k, totalnum))\n\n        if not quiet:\n            print(\"Saving GeoTIFF. Please wait...\")\n        img = finish_picture(bigim, base_size, bbox, x0, y0, x1, y1)\n        imgbands = len(img.getbands())\n        driver = gdal.GetDriverByName(\"GTiff\")\n\n        if \"options\" not in kwargs:\n            kwargs[\"options\"] = [\n                \"COMPRESS=DEFLATE\",\n                \"PREDICTOR=2\",\n                \"ZLEVEL=9\",\n                \"TILED=YES\",\n            ]\n\n        gtiff = driver.Create(\n            filename,\n            img.size[0],\n            img.size[1],\n            imgbands,\n            gdal.GDT_Byte,\n            **kwargs,\n        )\n        xp0, yp0 = from4326_to3857(lat0, lon0)\n        xp1, yp1 = from4326_to3857(lat1, lon1)\n        pwidth = abs(xp1 - xp0) / img.size[0]\n        pheight = abs(yp1 - yp0) / img.size[1]\n        gtiff.SetGeoTransform((min(xp0, xp1), pwidth, 0, max(yp0, yp1), 0, -pheight))\n        gtiff.SetProjection(WKT_3857)\n        for band in range(imgbands):\n            array = numpy.array(img.getdata(band), dtype=\"u8\")\n            array = array.reshape((img.size[1], img.size[0]))\n            band = gtiff.GetRasterBand(band + 1)\n            band.WriteArray(array)\n        gtiff.FlushCache()\n\n        if not quiet:\n            print(f\"Image saved to {filename}\")\n        return img\n\n    try:\n        draw_tile(source, south, west, north, east, zoom, output, quiet, **kwargs)\n        if crs.upper() != \"EPSG:3857\":\n            reproject(output, output, crs, to_cog=to_cog)\n        elif to_cog:\n            image_to_cog(output, output)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.to_hex_colors","title":"<code>to_hex_colors(colors)</code>","text":"<p>Convert a GEE color palette into hexadecimal color codes. can handle mixin formats</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>A list of hex color codes.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of hex color codes prefixed with #.</p> Source code in <code>geemap/common.py</code> <pre><code>def to_hex_colors(colors):\n\"\"\"Convert a GEE color palette into hexadecimal color codes. can handle mixin formats\n\n    Args:\n        colors (list): A list of hex color codes.\n\n    Returns:\n        list: A list of hex color codes prefixed with #.\n    \"\"\"\n\n    return [check_color(c) for c in colors]\n</code></pre>"},{"location":"common/#geemap.common.update_package","title":"<code>update_package()</code>","text":"<p>Updates the geemap package from the geemap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.</p> Source code in <code>geemap/common.py</code> <pre><code>def update_package():\n\"\"\"Updates the geemap package from the geemap GitHub repository without the need to use pip or conda.\n    In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.\n\n    \"\"\"\n\n    try:\n        download_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        if not os.path.exists(download_dir):\n            os.makedirs(download_dir)\n        clone_repo(out_dir=download_dir)\n\n        pkg_dir = os.path.join(download_dir, \"geemap-master\")\n        work_dir = os.getcwd()\n        os.chdir(pkg_dir)\n\n        if shutil.which(\"pip\") is None:\n            cmd = \"pip3 install .\"\n        else:\n            cmd = \"pip install .\"\n\n        os.system(cmd)\n        os.chdir(work_dir)\n\n        print(\n            \"\\nPlease comment out 'geemap.update_package()' and restart the kernel to take effect:\\nJupyter menu -&gt; Kernel -&gt; Restart &amp; Clear Output\"\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.upload_to_imgur","title":"<code>upload_to_imgur(in_gif)</code>","text":"<p>Uploads an image to imgur.com</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the image.</p> required Source code in <code>geemap/common.py</code> <pre><code>def upload_to_imgur(in_gif):\n\"\"\"Uploads an image to imgur.com\n\n    Args:\n        in_gif (str): The file path to the image.\n    \"\"\"\n    import subprocess\n\n    pkg_name = \"imgur-uploader\"\n    if not is_tool(pkg_name):\n        check_install(pkg_name)\n\n    try:\n        IMGUR_API_ID = os.environ.get(\"IMGUR_API_ID\", None)\n        IMGUR_API_SECRET = os.environ.get(\"IMGUR_API_SECRET\", None)\n        credentials_path = os.path.join(\n            os.path.expanduser(\"~\"), \".config/imgur_uploader/uploader.cfg\"\n        )\n\n        if (\n            (IMGUR_API_ID is not None) and (IMGUR_API_SECRET is not None)\n        ) or os.path.exists(credentials_path):\n            proc = subprocess.Popen([\"imgur-uploader\", in_gif], stdout=subprocess.PIPE)\n            for _ in range(0, 2):\n                line = proc.stdout.readline()\n                print(line.rstrip().decode(\"utf-8\"))\n            # while True:\n            #     line = proc.stdout.readline()\n            #     if not line:\n            #         break\n            #     print(line.rstrip().decode(\"utf-8\"))\n        else:\n            print(\n                \"Imgur API credentials could not be found. Please check https://pypi.org/project/imgur-uploader/ for instructions on how to get Imgur API credentials\"\n            )\n            return\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.use_mkdocs","title":"<code>use_mkdocs()</code>","text":"<p>Test if the current notebook is running in mkdocs.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the notebook is running in mkdocs.</p> Source code in <code>geemap/common.py</code> <pre><code>def use_mkdocs():\n\"\"\"Test if the current notebook is running in mkdocs.\n\n    Returns:\n        bool: True if the notebook is running in mkdocs.\n    \"\"\"\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#geemap.common.vec_area","title":"<code>vec_area(fc)</code>","text":"<p>Calculate the area (m2) of each each feature in a feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>object</code> <p>The feature collection to compute the area.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def vec_area(fc):\n\"\"\"Calculate the area (m2) of each each feature in a feature collection.\n\n    Args:\n        fc (object): The feature collection to compute the area.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n    return fc.map(lambda f: f.set({\"area_m2\": f.area(1).round()}))\n</code></pre>"},{"location":"common/#geemap.common.vec_area_ha","title":"<code>vec_area_ha(fc)</code>","text":"<p>Calculate the area (hectare) of each each feature in a feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>object</code> <p>The feature collection to compute the area.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def vec_area_ha(fc):\n\"\"\"Calculate the area (hectare) of each each feature in a feature collection.\n\n    Args:\n        fc (object): The feature collection to compute the area.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n    return fc.map(lambda f: f.set({\"area_ha\": f.area(1).divide(1e4).round()}))\n</code></pre>"},{"location":"common/#geemap.common.vec_area_km2","title":"<code>vec_area_km2(fc)</code>","text":"<p>Calculate the area (km2) of each each feature in a feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>object</code> <p>The feature collection to compute the area.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def vec_area_km2(fc):\n\"\"\"Calculate the area (km2) of each each feature in a feature collection.\n\n    Args:\n        fc (object): The feature collection to compute the area.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n    return fc.map(lambda f: f.set({\"area_km2\": f.area(1).divide(1e6).round()}))\n</code></pre>"},{"location":"common/#geemap.common.vec_area_mi2","title":"<code>vec_area_mi2(fc)</code>","text":"<p>Calculate the area (square mile) of each each feature in a feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>object</code> <p>The feature collection to compute the area.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.FeatureCollection</p> Source code in <code>geemap/common.py</code> <pre><code>def vec_area_mi2(fc):\n\"\"\"Calculate the area (square mile) of each each feature in a feature collection.\n\n    Args:\n        fc (object): The feature collection to compute the area.\n\n    Returns:\n        object: ee.FeatureCollection\n    \"\"\"\n    return fc.map(lambda f: f.set({\"area_mi2\": f.area(1).divide(2.59e6).round()}))\n</code></pre>"},{"location":"common/#geemap.common.vector_centroids","title":"<code>vector_centroids(ee_object)</code>","text":"<p>Returns the centroids of an ee.FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.FeatureCollection</code> <p>The ee.FeatureCollection to get the centroids of.</p> required <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the ee_object is not an ee.FeatureCollection.</p> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>The centroids of the ee_object.</p> Source code in <code>geemap/common.py</code> <pre><code>def vector_centroids(ee_object):\n\"\"\"Returns the centroids of an ee.FeatureCollection.\n\n    Args:\n        ee_object (ee.FeatureCollection): The ee.FeatureCollection to get the centroids of.\n\n    Raises:\n        TypeError: If the ee_object is not an ee.FeatureCollection.\n\n    Returns:\n        ee.FeatureCollection: The centroids of the ee_object.\n    \"\"\"\n    if not isinstance(ee_object, ee.FeatureCollection):\n        raise TypeError(\"The input must be an Earth Engine FeatureCollection.\")\n\n    centroids = ee_object.map(\n        lambda f: ee.Feature(f.geometry().centroid(0.001), f.toDictionary())\n    )\n\n    centroids = centroids.map(\n        lambda f: f.set(\n            {\n                \"longitude\": f.geometry().coordinates().get(0),\n                \"latitude\": f.geometry().coordinates().get(1),\n            }\n        )\n    )\n\n    return centroids\n</code></pre>"},{"location":"common/#geemap.common.vector_styling","title":"<code>vector_styling(ee_object, column, palette, color='000000', colorOpacity=1.0, pointSize=3, pointShape='circle', width=1, lineType='solid', fillColorOpacity=0.66)</code>","text":"<p>Add a new property to each feature containing a stylying dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>An ee.FeatureCollection.</p> required <code>column</code> <code>str</code> <p>The column name to use for styling.</p> required <code>palette</code> <code>list | dict</code> <p>The palette (e.g., list of colors or a dict containing label and color pairs) to use for styling.</p> required <code>color</code> <code>str</code> <p>A default color (CSS 3.0 color value e.g. 'FF0000' or 'red') to use for drawing the features. Defaults to \"black\".</p> <code>'000000'</code> <code>colorOpacity</code> <code>float</code> <p>Opacity between 0-1 of the features. Defaults to 1</p> <code>1.0</code> <code>pointSize</code> <code>int</code> <p>The default size in pixels of the point markers. Defaults to 3.</p> <code>3</code> <code>pointShape</code> <code>str</code> <p>The default shape of the marker to draw at each point location. One of: circle, square, diamond, cross, plus, pentagram, hexagram, triangle, triangle_up, triangle_down, triangle_left, triangle_right, pentagon, hexagon, star5, star6. This argument also supports the following Matlab marker abbreviations: o, s, d, x, +, p, h, ^, v, &lt;, &gt;. Defaults to \"circle\".</p> <code>'circle'</code> <code>width</code> <code>int</code> <p>The default line width for lines and outlines for polygons and point shapes. Defaults to 1.</p> <code>1</code> <code>lineType</code> <code>str</code> <p>The default line style for lines and outlines of polygons and point shapes. Defaults to 'solid'. One of: solid, dotted, dashed. Defaults to \"solid\".</p> <code>'solid'</code> <code>fillColorOpacity</code> <code>float</code> <p>Opacity between 0-1 of the fill. Defaults to 0.66. Color of the fill is based on the column name or index in the palette.</p> <code>0.66</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The provided column name is invalid.</p> <code>TypeError</code> <p>The provided palette is invalid.</p> <code>TypeError</code> <p>The provided ee_object is not an ee.FeatureCollection.</p> <p>Returns:</p> Type Description <code>object</code> <p>An ee.FeatureCollection containing the styling attribute.</p> Source code in <code>geemap/common.py</code> <pre><code>def vector_styling(\n    ee_object,\n    column,\n    palette,\n    color=\"000000\",\n    colorOpacity=1.0,\n    pointSize=3,\n    pointShape=\"circle\",\n    width=1,\n    lineType=\"solid\",\n    fillColorOpacity=0.66,\n):\n\"\"\"Add a new property to each feature containing a stylying dictionary.\n\n    Args:\n        ee_object (object): An ee.FeatureCollection.\n        column (str): The column name to use for styling.\n        palette (list | dict): The palette (e.g., list of colors or a dict containing label and color pairs) to use for styling.\n        color (str, optional): A default color (CSS 3.0 color value e.g. 'FF0000' or 'red') to use for drawing the features. Defaults to \"black\".\n        colorOpacity (float, optional): Opacity between 0-1 of the features. Defaults to 1\n        pointSize (int, optional): The default size in pixels of the point markers. Defaults to 3.\n        pointShape (str, optional): The default shape of the marker to draw at each point location. One of: circle, square, diamond, cross, plus, pentagram, hexagram, triangle, triangle_up, triangle_down, triangle_left, triangle_right, pentagon, hexagon, star5, star6. This argument also supports the following Matlab marker abbreviations: o, s, d, x, +, p, h, ^, v, &lt;, &gt;. Defaults to \"circle\".\n        width (int, optional): The default line width for lines and outlines for polygons and point shapes. Defaults to 1.\n        lineType (str, optional): The default line style for lines and outlines of polygons and point shapes. Defaults to 'solid'. One of: solid, dotted, dashed. Defaults to \"solid\".\n        fillColorOpacity (float, optional): Opacity between 0-1 of the fill. Defaults to 0.66. Color of the fill is based on the column name or index in the palette.\n    Raises:\n        ValueError: The provided column name is invalid.\n        TypeError: The provided palette is invalid.\n        TypeError: The provided ee_object is not an ee.FeatureCollection.\n\n    Returns:\n        object: An ee.FeatureCollection containing the styling attribute.\n    \"\"\"\n    from box import Box\n\n    if isinstance(ee_object, ee.FeatureCollection):\n        prop_names = ee.Feature(ee_object.first()).propertyNames().getInfo()\n        arr = ee_object.aggregate_array(column).distinct().sort()\n\n        if column not in prop_names:\n            raise ValueError(f\"The column name must of one of {', '.join(prop_names)}\")\n\n        if isinstance(palette, Box):\n            try:\n                palette = list(palette[\"default\"])\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(palette, tuple):\n            palette = list(palette)\n        elif isinstance(palette, dict):\n            values = list(arr.getInfo())\n            labels = list(palette.keys())\n            if not all(elem in values for elem in labels):\n                raise ValueError(\n                    f\"The keys of the palette must contain the following elements: {', '.join(values)}\"\n                )\n            else:\n                colors = [palette[value] for value in values]\n                palette = colors\n\n        if not isinstance(palette, list):\n            raise TypeError(\"The palette must be a list.\")\n\n        colors = ee.List(\n            [\n                color.strip() + str(hex(int(fillColorOpacity * 255)))[2:].zfill(2)\n                for color in palette\n            ]\n        )\n        fc = ee_object.map(lambda f: f.set({\"styleIndex\": arr.indexOf(f.get(column))}))\n        step = arr.size().divide(colors.size()).ceil()\n        fc = fc.map(\n            lambda f: f.set(\n                {\n                    \"style\": {\n                        \"color\": color + str(hex(int(colorOpacity * 255)))[2:].zfill(2),\n                        \"pointSize\": pointSize,\n                        \"pointShape\": pointShape,\n                        \"width\": width,\n                        \"lineType\": lineType,\n                        \"fillColor\": colors.get(\n                            ee.Number(\n                                ee.Number(f.get(\"styleIndex\")).divide(step)\n                            ).floor()\n                        ),\n                    }\n                }\n            )\n        )\n\n        return fc\n\n    else:\n        raise TypeError(\"The ee_object must be an ee.FeatureCollection.\")\n</code></pre>"},{"location":"common/#geemap.common.vector_to_ee","title":"<code>vector_to_ee(filename, bbox=None, mask=None, rows=None, geodesic=True, **kwargs)</code>","text":"<p>Converts any geopandas-supported vector dataset to ee.FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>bbox</code> <code>tuple | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.</p> <code>None</code> <code>mask</code> <code>dict | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.</p> <code>None</code> <code>rows</code> <code>int or slice</code> <p>Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.</p> <code>None</code> <code>geodesic</code> <code>bool</code> <p>Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>Earth Engine FeatureCollection.</p> Source code in <code>geemap/common.py</code> <pre><code>def vector_to_ee(\n    filename,\n    bbox=None,\n    mask=None,\n    rows=None,\n    geodesic=True,\n    **kwargs,\n):\n\"\"\"Converts any geopandas-supported vector dataset to ee.FeatureCollection.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n        mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n        rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n        geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.\n\n    Returns:\n        ee.FeatureCollection: Earth Engine FeatureCollection.\n    \"\"\"\n    geojson = vector_to_geojson(\n        filename, bbox=bbox, mask=mask, rows=rows, epsg=\"4326\", **kwargs\n    )\n\n    return geojson_to_ee(geojson, geodesic=geodesic)\n</code></pre>"},{"location":"common/#geemap.common.vector_to_geojson","title":"<code>vector_to_geojson(filename, out_geojson=None, bbox=None, mask=None, rows=None, epsg='4326', **kwargs)</code>","text":"<p>Converts any geopandas-supported vector dataset to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the output GeoJSON. Defaults to None.</p> <code>None</code> <code>bbox</code> <code>tuple | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.</p> <code>None</code> <code>mask</code> <code>dict | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.</p> <code>None</code> <code>rows</code> <code>int or slice</code> <p>Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.</p> <code>None</code> <code>epsg</code> <code>str</code> <p>The EPSG number to convert to. Defaults to \"4326\".</p> <code>'4326'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>When the output file path is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the GeoJSON.</p> Source code in <code>geemap/common.py</code> <pre><code>def vector_to_geojson(\n    filename, out_geojson=None, bbox=None, mask=None, rows=None, epsg=\"4326\", **kwargs\n):\n\"\"\"Converts any geopandas-supported vector dataset to GeoJSON.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        out_geojson (str, optional): The file path to the output GeoJSON. Defaults to None.\n        bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n        mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n        rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n        epsg (str, optional): The EPSG number to convert to. Defaults to \"4326\".\n\n    Raises:\n        ValueError: When the output file path is invalid.\n\n    Returns:\n        dict: A dictionary containing the GeoJSON.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import fiona\n\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n    else:\n        filename = download_file(github_raw_url(filename))\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".kml\":\n        fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n        df = gpd.read_file(\n            filename, bbox=bbox, mask=mask, rows=rows, driver=\"KML\", **kwargs\n        )\n    else:\n        df = gpd.read_file(filename, bbox=bbox, mask=mask, rows=rows, **kwargs)\n    gdf = df.to_crs(epsg=epsg)\n\n    if out_geojson is not None:\n        if not out_geojson.lower().endswith(\".geojson\"):\n            raise ValueError(\"The output file must have a geojson file extension.\")\n\n        out_geojson = os.path.abspath(out_geojson)\n        out_dir = os.path.dirname(out_geojson)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        gdf.to_file(out_geojson, driver=\"GeoJSON\")\n\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"common/#geemap.common.view_lidar","title":"<code>view_lidar(filename, cmap='terrain', backend='pyvista', background=None, **kwargs)</code>","text":"<p>View LiDAR data in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filepath to the LiDAR data.</p> required <code>cmap</code> <code>str</code> <p>The colormap to use. Defaults to \"terrain\". cmap currently does not work for the open3d backend.</p> <code>'terrain'</code> <code>backend</code> <code>str</code> <p>The plotting backend to use, can be pyvista, ipygany, panel, and open3d. Defaults to \"pyvista\".</p> <code>'pyvista'</code> <code>background</code> <code>str</code> <p>The background color to use. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If the backend is not supported.</p> Source code in <code>geemap/common.py</code> <pre><code>def view_lidar(filename, cmap=\"terrain\", backend=\"pyvista\", background=None, **kwargs):\n\"\"\"View LiDAR data in 3D.\n\n    Args:\n        filename (str): The filepath to the LiDAR data.\n        cmap (str, optional): The colormap to use. Defaults to \"terrain\". cmap currently does not work for the open3d backend.\n        backend (str, optional): The plotting backend to use, can be pyvista, ipygany, panel, and open3d. Defaults to \"pyvista\".\n        background (str, optional): The background color to use. Defaults to None.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        ValueError: If the backend is not supported.\n    \"\"\"\n\n    if in_colab_shell():\n        print(\"The view_lidar() function is not supported in Colab.\")\n        return\n\n    warnings.filterwarnings(\"ignore\")\n    filename = os.path.abspath(filename)\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    backend = backend.lower()\n    if backend in [\"pyvista\", \"ipygany\", \"panel\"]:\n        try:\n            import pyntcloud\n        except ImportError:\n            print(\n                \"The pyvista and pyntcloud packages are required for this function. Use pip install geemap[lidar] to install them.\"\n            )\n            return\n\n        try:\n            if backend == \"pyvista\":\n                backend = None\n            if backend == \"ipygany\":\n                cmap = None\n            data = pyntcloud.PyntCloud.from_file(filename)\n            mesh = data.to_instance(\"pyvista\", mesh=False)\n            mesh = mesh.elevation()\n            mesh.plot(\n                scalars=\"Elevation\",\n                cmap=cmap,\n                jupyter_backend=backend,\n                background=background,\n                **kwargs,\n            )\n\n        except Exception as e:\n            print(\"Something went wrong.\")\n            print(e)\n            return\n\n    elif backend == \"open3d\":\n        try:\n            import laspy\n            import open3d as o3d\n            import numpy as np\n        except ImportError:\n            print(\n                \"The laspy and open3d packages are required for this function. Use pip install laspy open3d to install them.\"\n            )\n            return\n\n        try:\n            las = laspy.read(filename)\n            point_data = np.stack([las.X, las.Y, las.Z], axis=0).transpose((1, 0))\n            geom = o3d.geometry.PointCloud()\n            geom.points = o3d.utility.Vector3dVector(point_data)\n            # geom.colors =  o3d.utility.Vector3dVector(colors)  # need to add colors. A list in the form of [[r,g,b], [r,g,b]] with value range 0-1. https://github.com/isl-org/Open3D/issues/614\n            o3d.visualization.draw_geometries([geom], **kwargs)\n\n        except Exception as e:\n            print(\"Something went wrong.\")\n            print(e)\n            return\n\n    else:\n        raise ValueError(f\"{backend} is not a valid backend.\")\n</code></pre>"},{"location":"common/#geemap.common.vis_to_qml","title":"<code>vis_to_qml(ee_class_table, out_qml)</code>","text":"<p>Create a QGIS Layer Style (.qml) based on an Earth Engine class table from the Earth Engine Data Catalog page such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1</p> <p>Parameters:</p> Name Type Description Default <code>ee_class_table</code> <code>str</code> <p>An Earth Engine class table with triple quotes.</p> required <code>out_qml</code> <code>str</code> <p>File path to the output QGIS Layer Style (.qml).</p> required Source code in <code>geemap/common.py</code> <pre><code>def vis_to_qml(ee_class_table, out_qml):\n\"\"\"Create a QGIS Layer Style (.qml) based on an Earth Engine class table from the Earth Engine Data Catalog page\n    such as https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1\n\n    Args:\n        ee_class_table (str): An Earth Engine class table with triple quotes.\n        out_qml (str): File path to the output QGIS Layer Style (.qml).\n    \"\"\"\n    import pkg_resources\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    data_dir = os.path.join(pkg_dir, \"data\")\n    template_dir = os.path.join(data_dir, \"template\")\n    qml_template = os.path.join(template_dir, \"NLCD.qml\")\n\n    out_dir = os.path.dirname(out_qml)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    with open(qml_template) as f:\n        lines = f.readlines()\n        header = lines[:31]\n        footer = lines[51:]\n\n    entries = []\n    try:\n        ee_class_table = ee_class_table.strip()\n        lines = ee_class_table.split(\"\\n\")[1:]\n\n        if lines[0] == \"Value\\tColor\\tDescription\":\n            lines = lines[1:]\n\n        for line in lines:\n            items = line.split(\"\\t\")\n            items = [item.strip() for item in items]\n            value = items[0]\n            color = items[1]\n            label = items[2]\n            entry = '        &lt;paletteEntry alpha=\"255\" color=\"#{}\" value=\"{}\" label=\"{}\"/&gt;\\n'.format(\n                color, value, label\n            )\n            entries.append(entry)\n\n        out_lines = header + entries + footer\n        with open(out_qml, \"w\") as f:\n            f.writelines(out_lines)\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geemap.common.write_lidar","title":"<code>write_lidar(source, destination, do_compress=None, laz_backend=None)</code>","text":"<p>Writes to a stream or file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | laspy.lasdatas.base.LasBase</code> <p>The source data to be written.</p> required <code>destination</code> <code>str</code> <p>The destination filepath.</p> required <code>do_compress</code> <code>bool</code> <p>Flags to indicate if you want to compress the data. Defaults to None.</p> <code>None</code> <code>laz_backend</code> <code>str</code> <p>The laz backend to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def write_lidar(source, destination, do_compress=None, laz_backend=None):\n\"\"\"Writes to a stream or file.\n\n    Args:\n        source (str | laspy.lasdatas.base.LasBase): The source data to be written.\n        destination (str): The destination filepath.\n        do_compress (bool, optional): Flags to indicate if you want to compress the data. Defaults to None.\n        laz_backend (str, optional): The laz backend to use. Defaults to None.\n    \"\"\"\n\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if isinstance(source, str):\n        source = read_lidar(source)\n\n    source.write(destination, do_compress=do_compress, laz_backend=laz_backend)\n</code></pre>"},{"location":"common/#geemap.common.xy_to_points","title":"<code>xy_to_points(in_csv, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Converts a csv containing points (latitude and longitude) into an ee.FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/giswqs/data/main/world/world_cities.csv</p> required <code>latitude</code> <code>str</code> <p>Column name for the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>Column name for the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> <p>Returns:</p> Type Description <code>ee.FeatureCollection</code> <p>The ee.FeatureCollection containing the points converted from the input csv.</p> Source code in <code>geemap/common.py</code> <pre><code>def xy_to_points(in_csv, latitude=\"latitude\", longitude=\"longitude\", encoding=\"utf-8\"):\n\"\"\"Converts a csv containing points (latitude and longitude) into an ee.FeatureCollection.\n\n    Args:\n        in_csv (str): File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/giswqs/data/main/world/world_cities.csv\n        latitude (str, optional): Column name for the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): Column name for the longitude column. Defaults to 'longitude'.\n\n    Returns:\n        ee.FeatureCollection: The ee.FeatureCollection containing the points converted from the input csv.\n    \"\"\"\n\n    geojson = csv_to_geojson(in_csv, None, latitude, longitude, encoding)\n    fc = geojson_to_ee(geojson)\n    return fc\n</code></pre>"},{"location":"common/#geemap.common.zonal_statistics","title":"<code>zonal_statistics(in_value_raster, in_zone_vector, out_file_path=None, statistics_type='MEAN', scale=None, crs=None, tile_scale=1.0, return_fc=False, verbose=True, timeout=300, proxies=None, **kwargs)</code>","text":"<p>Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz.</p> <p>Parameters:</p> Name Type Description Default <code>in_value_raster</code> <code>object</code> <p>An ee.Image or ee.ImageCollection that contains the values on which to calculate a statistic.</p> required <code>in_zone_vector</code> <code>object</code> <p>An ee.FeatureCollection that defines the zones.</p> required <code>out_file_path</code> <code>str</code> <p>Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz</p> <code>None</code> <code>statistics_type</code> <code>str</code> <p>Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps.</p> <code>'MEAN'</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.</p> <code>None</code> <code>tile_scale</code> <code>float</code> <p>A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0.</p> <code>1.0</code> <code>verbose</code> <code>bool</code> <p>Whether to print descriptive text when the programming is running. Default to True.</p> <code>True</code> <code>return_fc</code> <code>bool</code> <p>Whether to return the results as an ee.FeatureCollection. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Default to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxy servers to use for the request. Default to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def zonal_stats(\n    in_value_raster,\n    in_zone_vector,\n    out_file_path=None,\n    statistics_type=\"MEAN\",\n    scale=None,\n    crs=None,\n    tile_scale=1.0,\n    return_fc=False,\n    verbose=True,\n    timeout=300,\n    proxies=None,\n    **kwargs,\n):\n\"\"\"Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz.\n\n    Args:\n        in_value_raster (object): An ee.Image or ee.ImageCollection that contains the values on which to calculate a statistic.\n        in_zone_vector (object): An ee.FeatureCollection that defines the zones.\n        out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz\n        statistics_type (str, optional): Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.\n        tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0.\n        verbose (bool, optional): Whether to print descriptive text when the programming is running. Default to True.\n        return_fc (bool, optional): Whether to return the results as an ee.FeatureCollection. Defaults to False.\n        timeout (int, optional): Timeout in seconds. Default to 300.\n        proxies (dict, optional): A dictionary of proxy servers to use for the request. Default to None.\n    \"\"\"\n\n    if isinstance(in_value_raster, ee.ImageCollection):\n        in_value_raster = in_value_raster.toBands()\n\n    if not isinstance(in_value_raster, ee.Image):\n        print(\"The input raster must be an ee.Image.\")\n        return\n\n    if not isinstance(in_zone_vector, ee.FeatureCollection):\n        print(\"The input zone data must be an ee.FeatureCollection.\")\n        return\n\n    if out_file_path is None:\n        out_file_path = os.path.join(os.getcwd(), \"zonal_stats.csv\")\n\n    allowed_formats = [\"csv\", \"geojson\", \"kml\", \"kmz\", \"shp\"]\n    filename = os.path.abspath(out_file_path)\n    basename = os.path.basename(filename)\n    # name = os.path.splitext(basename)[0]\n    filetype = os.path.splitext(basename)[1][1:].lower()\n\n    if not (filetype in allowed_formats):\n        print(\n            \"The file type must be one of the following: {}\".format(\n                \", \".join(allowed_formats)\n            )\n        )\n        return\n\n    # Parameters for histogram\n    # The maximum number of buckets to use when building a histogram; will be rounded up to a power of 2.\n    max_buckets = None\n    # The minimum histogram bucket width, or null to allow any power of 2.\n    min_bucket_width = None\n    # The number of values to accumulate before building the initial histogram.\n    max_raw = None\n    hist_min = 1.0  # The lower (inclusive) bound of the first bucket.\n    hist_max = 100.0  # The upper (exclusive) bound of the last bucket.\n    hist_steps = 10  # The number of buckets to use.\n\n    if \"max_buckets\" in kwargs.keys():\n        max_buckets = kwargs[\"max_buckets\"]\n    if \"min_bucket_width\" in kwargs.keys():\n        min_bucket_width = kwargs[\"min_bucket\"]\n    if \"max_raw\" in kwargs.keys():\n        max_raw = kwargs[\"max_raw\"]\n\n    if (\n        statistics_type.upper() == \"FIXED_HIST\"\n        and (\"hist_min\" in kwargs.keys())\n        and (\"hist_max\" in kwargs.keys())\n        and (\"hist_steps\" in kwargs.keys())\n    ):\n        hist_min = kwargs[\"hist_min\"]\n        hist_max = kwargs[\"hist_max\"]\n        hist_steps = kwargs[\"hist_steps\"]\n    elif statistics_type.upper() == \"FIXED_HIST\":\n        print(\n            \"To use fixedHistogram, please provide these three parameters: hist_min, hist_max, and hist_steps.\"\n        )\n        return\n\n    allowed_statistics = {\n        \"COUNT\": ee.Reducer.count(),\n        \"MEAN\": ee.Reducer.mean(),\n        \"MEAN_UNWEIGHTED\": ee.Reducer.mean().unweighted(),\n        \"MAXIMUM\": ee.Reducer.max(),\n        \"MEDIAN\": ee.Reducer.median(),\n        \"MINIMUM\": ee.Reducer.min(),\n        \"MODE\": ee.Reducer.mode(),\n        \"STD\": ee.Reducer.stdDev(),\n        \"MIN_MAX\": ee.Reducer.minMax(),\n        \"SUM\": ee.Reducer.sum(),\n        \"VARIANCE\": ee.Reducer.variance(),\n        \"HIST\": ee.Reducer.histogram(\n            maxBuckets=max_buckets, minBucketWidth=min_bucket_width, maxRaw=max_raw\n        ),\n        \"FIXED_HIST\": ee.Reducer.fixedHistogram(hist_min, hist_max, hist_steps),\n        \"COMBINED_COUNT_MEAN\": ee.Reducer.count().combine(\n            ee.Reducer.mean(), sharedInputs=True\n        ),\n        \"COMBINED_COUNT_MEAN_UNWEIGHTED\": ee.Reducer.count().combine(\n            ee.Reducer.mean().unweighted(), sharedInputs=True\n        ),\n    }\n\n    if not (statistics_type.upper() in allowed_statistics.keys()):\n        print(\n            \"The statistics type must be one of the following: {}\".format(\n                \", \".join(list(allowed_statistics.keys()))\n            )\n        )\n        return\n\n    if scale is None:\n        scale = in_value_raster.projection().nominalScale().multiply(10)\n\n    try:\n        if verbose:\n            print(\"Computing statistics ...\")\n        result = in_value_raster.reduceRegions(\n            collection=in_zone_vector,\n            reducer=allowed_statistics[statistics_type],\n            scale=scale,\n            crs=crs,\n            tileScale=tile_scale,\n        )\n        if return_fc:\n            return result\n        else:\n            ee_export_vector(result, filename, timeout=timeout, proxies=proxies)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.zonal_statistics_by_group","title":"<code>zonal_statistics_by_group(in_value_raster, in_zone_vector, out_file_path=None, statistics_type='SUM', decimal_places=0, denominator=1.0, scale=None, crs=None, crs_transform=None, best_effort=True, max_pixels=10000000.0, tile_scale=1.0, return_fc=False, verbose=True, timeout=300, proxies=None, **kwargs)</code>","text":"<p>Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz.</p> <p>Parameters:</p> Name Type Description Default <code>in_value_raster</code> <code>object</code> <p>An integer Image that contains the values on which to calculate area/percentage.</p> required <code>in_zone_vector</code> <code>object</code> <p>An ee.FeatureCollection that defines the zones.</p> required <code>out_file_path</code> <code>str</code> <p>Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz</p> <code>None</code> <code>statistics_type</code> <code>str</code> <p>Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'.</p> <code>'SUM'</code> <code>decimal_places</code> <code>int</code> <p>The number of decimal places to use. Defaults to 0.</p> <code>0</code> <code>denominator</code> <code>float</code> <p>To convert area units (e.g., from square meters to square kilometers). Defaults to 1.0.</p> <code>1.0</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.</p> <code>None</code> <code>crs_transform</code> <code>list</code> <p>The list of CRS transform values. This is a row-major ordering of the 3x2 transform matrix. This option is mutually exclusive with 'scale', and replaces any transform already set on the projection.</p> <code>None</code> <code>best_effort</code> <code>bool</code> <p>If the polygon would contain too many pixels at the given scale, compute and use a larger scale which would allow the operation to succeed.</p> <code>True</code> <code>max_pixels</code> <code>int</code> <p>The maximum number of pixels to reduce. Defaults to 1e7.</p> <code>10000000.0</code> <code>tile_scale</code> <code>float</code> <p>A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0.</p> <code>1.0</code> <code>verbose</code> <code>bool</code> <p>Whether to print descriptive text when the programming is running. Default to True.</p> <code>True</code> <code>return_fc</code> <code>bool</code> <p>Whether to return the results as an ee.FeatureCollection. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxies to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def zonal_stats_by_group(\n    in_value_raster,\n    in_zone_vector,\n    out_file_path=None,\n    statistics_type=\"SUM\",\n    decimal_places=0,\n    denominator=1.0,\n    scale=None,\n    crs=None,\n    crs_transform=None,\n    best_effort=True,\n    max_pixels=1e7,\n    tile_scale=1.0,\n    return_fc=False,\n    verbose=True,\n    timeout=300,\n    proxies=None,\n    **kwargs,\n):\n\"\"\"Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz.\n\n    Args:\n        in_value_raster (object): An integer Image that contains the values on which to calculate area/percentage.\n        in_zone_vector (object): An ee.FeatureCollection that defines the zones.\n        out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz\n        statistics_type (str, optional): Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'.\n        decimal_places (int, optional): The number of decimal places to use. Defaults to 0.\n        denominator (float, optional): To convert area units (e.g., from square meters to square kilometers). Defaults to 1.0.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.\n        crs_transform (list, optional): The list of CRS transform values. This is a row-major ordering of the 3x2 transform matrix. This option is mutually exclusive with 'scale', and replaces any transform already set on the projection.\n        best_effort (bool, optional): If the polygon would contain too many pixels at the given scale, compute and use a larger scale which would allow the operation to succeed.\n        max_pixels (int, optional): The maximum number of pixels to reduce. Defaults to 1e7.\n        tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0.\n        verbose (bool, optional): Whether to print descriptive text when the programming is running. Default to True.\n        return_fc (bool, optional): Whether to return the results as an ee.FeatureCollection. Defaults to False.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n        proxies (dict, optional): A dictionary of proxies to use. Defaults to None.\n\n    \"\"\"\n\n    if isinstance(in_value_raster, ee.ImageCollection):\n        in_value_raster = in_value_raster.toBands()\n\n    if not isinstance(in_value_raster, ee.Image):\n        print(\"The input raster must be an ee.Image.\")\n        return\n\n    if out_file_path is None:\n        out_file_path = os.path.join(os.getcwd(), \"zonal_stats_by_group.csv\")\n\n    band_count = in_value_raster.bandNames().size().getInfo()\n\n    band_name = \"\"\n    if band_count == 1:\n        band_name = in_value_raster.bandNames().get(0)\n    else:\n        print(\"The input image can only have one band.\")\n        return\n\n    band_types = in_value_raster.bandTypes().get(band_name).getInfo()\n    band_type = band_types.get(\"precision\")\n    if band_type != \"int\":\n        print(\"The input image band must be integer type.\")\n        return\n\n    if not isinstance(in_zone_vector, ee.FeatureCollection):\n        print(\"The input zone data must be an ee.FeatureCollection.\")\n        return\n\n    allowed_formats = [\"csv\", \"geojson\", \"kml\", \"kmz\", \"shp\"]\n    filename = os.path.abspath(out_file_path)\n    basename = os.path.basename(filename)\n    # name = os.path.splitext(basename)[0]\n    filetype = os.path.splitext(basename)[1][1:]\n\n    if not (filetype.lower() in allowed_formats):\n        print(\n            \"The file type must be one of the following: {}\".format(\n                \", \".join(allowed_formats)\n            )\n        )\n        return\n\n    out_dir = os.path.dirname(filename)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    allowed_statistics = [\"SUM\", \"PERCENTAGE\"]\n    if not (statistics_type.upper() in allowed_statistics):\n        print(\n            \"The statistics type can only be one of {}\".format(\n                \", \".join(allowed_statistics)\n            )\n        )\n        return\n\n    if scale is None:\n        scale = in_value_raster.projection().nominalScale().multiply(10)\n\n    try:\n        if verbose:\n            print(\"Computing ... \")\n        geometry = in_zone_vector.geometry()\n\n        hist = in_value_raster.reduceRegion(\n            ee.Reducer.frequencyHistogram(),\n            geometry=geometry,\n            scale=scale,\n            crs=crs,\n            crsTransform=crs_transform,\n            bestEffort=best_effort,\n            maxPixels=max_pixels,\n            tileScale=tile_scale,\n        )\n        class_values = (\n            ee.Dictionary(hist.get(band_name))\n            .keys()\n            .map(lambda v: ee.Number.parse(v))\n            .sort()\n        )\n\n        class_names = class_values.map(\n            lambda c: ee.String(\"Class_\").cat(ee.Number(c).format())\n        )\n\n        # class_count = class_values.size().getInfo()\n        dataset = ee.Image.pixelArea().divide(denominator).addBands(in_value_raster)\n\n        init_result = dataset.reduceRegions(\n            **{\n                \"collection\": in_zone_vector,\n                \"reducer\": ee.Reducer.sum().group(\n                    **{\n                        \"groupField\": 1,\n                        \"groupName\": \"group\",\n                    }\n                ),\n                \"scale\": scale,\n            }\n        )\n\n        # def build_dict(input_list):\n\n        #     decimal_format = '%.{}f'.format(decimal_places)\n        #     in_dict = input_list.map(lambda x: ee.Dictionary().set(ee.String('Class_').cat(\n        #         ee.Number(ee.Dictionary(x).get('group')).format()), ee.Number.parse(ee.Number(ee.Dictionary(x).get('sum')).format(decimal_format))))\n        #     return in_dict\n\n        def get_keys(input_list):\n            return input_list.map(\n                lambda x: ee.String(\"Class_\").cat(\n                    ee.Number(ee.Dictionary(x).get(\"group\")).format()\n                )\n            )\n\n        def get_values(input_list):\n            decimal_format = \"%.{}f\".format(decimal_places)\n            return input_list.map(\n                lambda x: ee.Number.parse(\n                    ee.Number(ee.Dictionary(x).get(\"sum\")).format(decimal_format)\n                )\n            )\n\n        def set_attribute(f):\n            groups = ee.List(f.get(\"groups\"))\n            keys = get_keys(groups)\n            values = get_values(groups)\n            total_area = ee.List(values).reduce(ee.Reducer.sum())\n\n            def get_class_values(x):\n                cls_value = ee.Algorithms.If(\n                    keys.contains(x), values.get(keys.indexOf(x)), 0\n                )\n                cls_value = ee.Algorithms.If(\n                    ee.String(statistics_type).compareTo(ee.String(\"SUM\")),\n                    ee.Number(cls_value).divide(ee.Number(total_area)),\n                    cls_value,\n                )\n                return cls_value\n\n            full_values = class_names.map(lambda x: get_class_values(x))\n            attr_dict = ee.Dictionary.fromLists(class_names, full_values)\n            attr_dict = attr_dict.set(\"Class_sum\", total_area)\n\n            return f.set(attr_dict).set(\"groups\", None)\n\n        final_result = init_result.map(set_attribute)\n        if return_fc:\n            return final_result\n        else:\n            ee_export_vector(final_result, filename, timeout=timeout, proxies=proxies)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.zonal_stats","title":"<code>zonal_stats(in_value_raster, in_zone_vector, out_file_path=None, statistics_type='MEAN', scale=None, crs=None, tile_scale=1.0, return_fc=False, verbose=True, timeout=300, proxies=None, **kwargs)</code>","text":"<p>Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz.</p> <p>Parameters:</p> Name Type Description Default <code>in_value_raster</code> <code>object</code> <p>An ee.Image or ee.ImageCollection that contains the values on which to calculate a statistic.</p> required <code>in_zone_vector</code> <code>object</code> <p>An ee.FeatureCollection that defines the zones.</p> required <code>out_file_path</code> <code>str</code> <p>Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz</p> <code>None</code> <code>statistics_type</code> <code>str</code> <p>Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps.</p> <code>'MEAN'</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.</p> <code>None</code> <code>tile_scale</code> <code>float</code> <p>A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0.</p> <code>1.0</code> <code>verbose</code> <code>bool</code> <p>Whether to print descriptive text when the programming is running. Default to True.</p> <code>True</code> <code>return_fc</code> <code>bool</code> <p>Whether to return the results as an ee.FeatureCollection. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Default to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxy servers to use for the request. Default to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def zonal_stats(\n    in_value_raster,\n    in_zone_vector,\n    out_file_path=None,\n    statistics_type=\"MEAN\",\n    scale=None,\n    crs=None,\n    tile_scale=1.0,\n    return_fc=False,\n    verbose=True,\n    timeout=300,\n    proxies=None,\n    **kwargs,\n):\n\"\"\"Summarizes the values of a raster within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz.\n\n    Args:\n        in_value_raster (object): An ee.Image or ee.ImageCollection that contains the values on which to calculate a statistic.\n        in_zone_vector (object): An ee.FeatureCollection that defines the zones.\n        out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz\n        statistics_type (str, optional): Statistic type to be calculated. Defaults to 'MEAN'. For 'HIST', you can provide three parameters: max_buckets, min_bucket_width, and max_raw. For 'FIXED_HIST', you must provide three parameters: hist_min, hist_max, and hist_steps.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.\n        tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0.\n        verbose (bool, optional): Whether to print descriptive text when the programming is running. Default to True.\n        return_fc (bool, optional): Whether to return the results as an ee.FeatureCollection. Defaults to False.\n        timeout (int, optional): Timeout in seconds. Default to 300.\n        proxies (dict, optional): A dictionary of proxy servers to use for the request. Default to None.\n    \"\"\"\n\n    if isinstance(in_value_raster, ee.ImageCollection):\n        in_value_raster = in_value_raster.toBands()\n\n    if not isinstance(in_value_raster, ee.Image):\n        print(\"The input raster must be an ee.Image.\")\n        return\n\n    if not isinstance(in_zone_vector, ee.FeatureCollection):\n        print(\"The input zone data must be an ee.FeatureCollection.\")\n        return\n\n    if out_file_path is None:\n        out_file_path = os.path.join(os.getcwd(), \"zonal_stats.csv\")\n\n    allowed_formats = [\"csv\", \"geojson\", \"kml\", \"kmz\", \"shp\"]\n    filename = os.path.abspath(out_file_path)\n    basename = os.path.basename(filename)\n    # name = os.path.splitext(basename)[0]\n    filetype = os.path.splitext(basename)[1][1:].lower()\n\n    if not (filetype in allowed_formats):\n        print(\n            \"The file type must be one of the following: {}\".format(\n                \", \".join(allowed_formats)\n            )\n        )\n        return\n\n    # Parameters for histogram\n    # The maximum number of buckets to use when building a histogram; will be rounded up to a power of 2.\n    max_buckets = None\n    # The minimum histogram bucket width, or null to allow any power of 2.\n    min_bucket_width = None\n    # The number of values to accumulate before building the initial histogram.\n    max_raw = None\n    hist_min = 1.0  # The lower (inclusive) bound of the first bucket.\n    hist_max = 100.0  # The upper (exclusive) bound of the last bucket.\n    hist_steps = 10  # The number of buckets to use.\n\n    if \"max_buckets\" in kwargs.keys():\n        max_buckets = kwargs[\"max_buckets\"]\n    if \"min_bucket_width\" in kwargs.keys():\n        min_bucket_width = kwargs[\"min_bucket\"]\n    if \"max_raw\" in kwargs.keys():\n        max_raw = kwargs[\"max_raw\"]\n\n    if (\n        statistics_type.upper() == \"FIXED_HIST\"\n        and (\"hist_min\" in kwargs.keys())\n        and (\"hist_max\" in kwargs.keys())\n        and (\"hist_steps\" in kwargs.keys())\n    ):\n        hist_min = kwargs[\"hist_min\"]\n        hist_max = kwargs[\"hist_max\"]\n        hist_steps = kwargs[\"hist_steps\"]\n    elif statistics_type.upper() == \"FIXED_HIST\":\n        print(\n            \"To use fixedHistogram, please provide these three parameters: hist_min, hist_max, and hist_steps.\"\n        )\n        return\n\n    allowed_statistics = {\n        \"COUNT\": ee.Reducer.count(),\n        \"MEAN\": ee.Reducer.mean(),\n        \"MEAN_UNWEIGHTED\": ee.Reducer.mean().unweighted(),\n        \"MAXIMUM\": ee.Reducer.max(),\n        \"MEDIAN\": ee.Reducer.median(),\n        \"MINIMUM\": ee.Reducer.min(),\n        \"MODE\": ee.Reducer.mode(),\n        \"STD\": ee.Reducer.stdDev(),\n        \"MIN_MAX\": ee.Reducer.minMax(),\n        \"SUM\": ee.Reducer.sum(),\n        \"VARIANCE\": ee.Reducer.variance(),\n        \"HIST\": ee.Reducer.histogram(\n            maxBuckets=max_buckets, minBucketWidth=min_bucket_width, maxRaw=max_raw\n        ),\n        \"FIXED_HIST\": ee.Reducer.fixedHistogram(hist_min, hist_max, hist_steps),\n        \"COMBINED_COUNT_MEAN\": ee.Reducer.count().combine(\n            ee.Reducer.mean(), sharedInputs=True\n        ),\n        \"COMBINED_COUNT_MEAN_UNWEIGHTED\": ee.Reducer.count().combine(\n            ee.Reducer.mean().unweighted(), sharedInputs=True\n        ),\n    }\n\n    if not (statistics_type.upper() in allowed_statistics.keys()):\n        print(\n            \"The statistics type must be one of the following: {}\".format(\n                \", \".join(list(allowed_statistics.keys()))\n            )\n        )\n        return\n\n    if scale is None:\n        scale = in_value_raster.projection().nominalScale().multiply(10)\n\n    try:\n        if verbose:\n            print(\"Computing statistics ...\")\n        result = in_value_raster.reduceRegions(\n            collection=in_zone_vector,\n            reducer=allowed_statistics[statistics_type],\n            scale=scale,\n            crs=crs,\n            tileScale=tile_scale,\n        )\n        if return_fc:\n            return result\n        else:\n            ee_export_vector(result, filename, timeout=timeout, proxies=proxies)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.zonal_stats_by_group","title":"<code>zonal_stats_by_group(in_value_raster, in_zone_vector, out_file_path=None, statistics_type='SUM', decimal_places=0, denominator=1.0, scale=None, crs=None, crs_transform=None, best_effort=True, max_pixels=10000000.0, tile_scale=1.0, return_fc=False, verbose=True, timeout=300, proxies=None, **kwargs)</code>","text":"<p>Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz.</p> <p>Parameters:</p> Name Type Description Default <code>in_value_raster</code> <code>object</code> <p>An integer Image that contains the values on which to calculate area/percentage.</p> required <code>in_zone_vector</code> <code>object</code> <p>An ee.FeatureCollection that defines the zones.</p> required <code>out_file_path</code> <code>str</code> <p>Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz</p> <code>None</code> <code>statistics_type</code> <code>str</code> <p>Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'.</p> <code>'SUM'</code> <code>decimal_places</code> <code>int</code> <p>The number of decimal places to use. Defaults to 0.</p> <code>0</code> <code>denominator</code> <code>float</code> <p>To convert area units (e.g., from square meters to square kilometers). Defaults to 1.0.</p> <code>1.0</code> <code>scale</code> <code>float</code> <p>A nominal scale in meters of the projection to work in. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.</p> <code>None</code> <code>crs_transform</code> <code>list</code> <p>The list of CRS transform values. This is a row-major ordering of the 3x2 transform matrix. This option is mutually exclusive with 'scale', and replaces any transform already set on the projection.</p> <code>None</code> <code>best_effort</code> <code>bool</code> <p>If the polygon would contain too many pixels at the given scale, compute and use a larger scale which would allow the operation to succeed.</p> <code>True</code> <code>max_pixels</code> <code>int</code> <p>The maximum number of pixels to reduce. Defaults to 1e7.</p> <code>10000000.0</code> <code>tile_scale</code> <code>float</code> <p>A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0.</p> <code>1.0</code> <code>verbose</code> <code>bool</code> <p>Whether to print descriptive text when the programming is running. Default to True.</p> <code>True</code> <code>return_fc</code> <code>bool</code> <p>Whether to return the results as an ee.FeatureCollection. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds. Defaults to 300.</p> <code>300</code> <code>proxies</code> <code>dict</code> <p>A dictionary of proxies to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/common.py</code> <pre><code>def zonal_stats_by_group(\n    in_value_raster,\n    in_zone_vector,\n    out_file_path=None,\n    statistics_type=\"SUM\",\n    decimal_places=0,\n    denominator=1.0,\n    scale=None,\n    crs=None,\n    crs_transform=None,\n    best_effort=True,\n    max_pixels=1e7,\n    tile_scale=1.0,\n    return_fc=False,\n    verbose=True,\n    timeout=300,\n    proxies=None,\n    **kwargs,\n):\n\"\"\"Summarizes the area or percentage of a raster by group within the zones of another dataset and exports the results as a csv, shp, json, kml, or kmz.\n\n    Args:\n        in_value_raster (object): An integer Image that contains the values on which to calculate area/percentage.\n        in_zone_vector (object): An ee.FeatureCollection that defines the zones.\n        out_file_path (str): Output file path that will contain the summary of the values in each zone. The file type can be: csv, shp, json, kml, kmz\n        statistics_type (str, optional): Can be either 'SUM' or 'PERCENTAGE' . Defaults to 'SUM'.\n        decimal_places (int, optional): The number of decimal places to use. Defaults to 0.\n        denominator (float, optional): To convert area units (e.g., from square meters to square kilometers). Defaults to 1.0.\n        scale (float, optional): A nominal scale in meters of the projection to work in. Defaults to None.\n        crs (str, optional): The projection to work in. If unspecified, the projection of the image's first band is used. If specified in addition to scale, rescaled to the specified scale. Defaults to None.\n        crs_transform (list, optional): The list of CRS transform values. This is a row-major ordering of the 3x2 transform matrix. This option is mutually exclusive with 'scale', and replaces any transform already set on the projection.\n        best_effort (bool, optional): If the polygon would contain too many pixels at the given scale, compute and use a larger scale which would allow the operation to succeed.\n        max_pixels (int, optional): The maximum number of pixels to reduce. Defaults to 1e7.\n        tile_scale (float, optional): A scaling factor used to reduce aggregation tile size; using a larger tileScale (e.g. 2 or 4) may enable computations that run out of memory with the default. Defaults to 1.0.\n        verbose (bool, optional): Whether to print descriptive text when the programming is running. Default to True.\n        return_fc (bool, optional): Whether to return the results as an ee.FeatureCollection. Defaults to False.\n        timeout (int, optional): Timeout in seconds. Defaults to 300.\n        proxies (dict, optional): A dictionary of proxies to use. Defaults to None.\n\n    \"\"\"\n\n    if isinstance(in_value_raster, ee.ImageCollection):\n        in_value_raster = in_value_raster.toBands()\n\n    if not isinstance(in_value_raster, ee.Image):\n        print(\"The input raster must be an ee.Image.\")\n        return\n\n    if out_file_path is None:\n        out_file_path = os.path.join(os.getcwd(), \"zonal_stats_by_group.csv\")\n\n    band_count = in_value_raster.bandNames().size().getInfo()\n\n    band_name = \"\"\n    if band_count == 1:\n        band_name = in_value_raster.bandNames().get(0)\n    else:\n        print(\"The input image can only have one band.\")\n        return\n\n    band_types = in_value_raster.bandTypes().get(band_name).getInfo()\n    band_type = band_types.get(\"precision\")\n    if band_type != \"int\":\n        print(\"The input image band must be integer type.\")\n        return\n\n    if not isinstance(in_zone_vector, ee.FeatureCollection):\n        print(\"The input zone data must be an ee.FeatureCollection.\")\n        return\n\n    allowed_formats = [\"csv\", \"geojson\", \"kml\", \"kmz\", \"shp\"]\n    filename = os.path.abspath(out_file_path)\n    basename = os.path.basename(filename)\n    # name = os.path.splitext(basename)[0]\n    filetype = os.path.splitext(basename)[1][1:]\n\n    if not (filetype.lower() in allowed_formats):\n        print(\n            \"The file type must be one of the following: {}\".format(\n                \", \".join(allowed_formats)\n            )\n        )\n        return\n\n    out_dir = os.path.dirname(filename)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    allowed_statistics = [\"SUM\", \"PERCENTAGE\"]\n    if not (statistics_type.upper() in allowed_statistics):\n        print(\n            \"The statistics type can only be one of {}\".format(\n                \", \".join(allowed_statistics)\n            )\n        )\n        return\n\n    if scale is None:\n        scale = in_value_raster.projection().nominalScale().multiply(10)\n\n    try:\n        if verbose:\n            print(\"Computing ... \")\n        geometry = in_zone_vector.geometry()\n\n        hist = in_value_raster.reduceRegion(\n            ee.Reducer.frequencyHistogram(),\n            geometry=geometry,\n            scale=scale,\n            crs=crs,\n            crsTransform=crs_transform,\n            bestEffort=best_effort,\n            maxPixels=max_pixels,\n            tileScale=tile_scale,\n        )\n        class_values = (\n            ee.Dictionary(hist.get(band_name))\n            .keys()\n            .map(lambda v: ee.Number.parse(v))\n            .sort()\n        )\n\n        class_names = class_values.map(\n            lambda c: ee.String(\"Class_\").cat(ee.Number(c).format())\n        )\n\n        # class_count = class_values.size().getInfo()\n        dataset = ee.Image.pixelArea().divide(denominator).addBands(in_value_raster)\n\n        init_result = dataset.reduceRegions(\n            **{\n                \"collection\": in_zone_vector,\n                \"reducer\": ee.Reducer.sum().group(\n                    **{\n                        \"groupField\": 1,\n                        \"groupName\": \"group\",\n                    }\n                ),\n                \"scale\": scale,\n            }\n        )\n\n        # def build_dict(input_list):\n\n        #     decimal_format = '%.{}f'.format(decimal_places)\n        #     in_dict = input_list.map(lambda x: ee.Dictionary().set(ee.String('Class_').cat(\n        #         ee.Number(ee.Dictionary(x).get('group')).format()), ee.Number.parse(ee.Number(ee.Dictionary(x).get('sum')).format(decimal_format))))\n        #     return in_dict\n\n        def get_keys(input_list):\n            return input_list.map(\n                lambda x: ee.String(\"Class_\").cat(\n                    ee.Number(ee.Dictionary(x).get(\"group\")).format()\n                )\n            )\n\n        def get_values(input_list):\n            decimal_format = \"%.{}f\".format(decimal_places)\n            return input_list.map(\n                lambda x: ee.Number.parse(\n                    ee.Number(ee.Dictionary(x).get(\"sum\")).format(decimal_format)\n                )\n            )\n\n        def set_attribute(f):\n            groups = ee.List(f.get(\"groups\"))\n            keys = get_keys(groups)\n            values = get_values(groups)\n            total_area = ee.List(values).reduce(ee.Reducer.sum())\n\n            def get_class_values(x):\n                cls_value = ee.Algorithms.If(\n                    keys.contains(x), values.get(keys.indexOf(x)), 0\n                )\n                cls_value = ee.Algorithms.If(\n                    ee.String(statistics_type).compareTo(ee.String(\"SUM\")),\n                    ee.Number(cls_value).divide(ee.Number(total_area)),\n                    cls_value,\n                )\n                return cls_value\n\n            full_values = class_names.map(lambda x: get_class_values(x))\n            attr_dict = ee.Dictionary.fromLists(class_names, full_values)\n            attr_dict = attr_dict.set(\"Class_sum\", total_area)\n\n            return f.set(attr_dict).set(\"groups\", None)\n\n        final_result = init_result.map(set_attribute)\n        if return_fc:\n            return final_result\n        else:\n            ee_export_vector(final_result, filename, timeout=timeout, proxies=proxies)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geemap.common.zoom_level_resolution","title":"<code>zoom_level_resolution(zoom, latitude=0)</code>","text":"<p>Returns the approximate pixel scale based on zoom level and latutude.     See https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>The zoom level.</p> required <code>latitude</code> <code>float</code> <p>The latitude. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>float</code> <p>Map resolution in meters.</p> Source code in <code>geemap/common.py</code> <pre><code>def zoom_level_resolution(zoom, latitude=0):\n\"\"\"Returns the approximate pixel scale based on zoom level and latutude.\n        See https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution\n\n    Args:\n        zoom (int): The zoom level.\n        latitude (float, optional): The latitude. Defaults to 0.\n\n    Returns:\n        float: Map resolution in meters.\n    \"\"\"\n    import math\n\n    resolution = 156543.04 * math.cos(latitude) / math.pow(2, zoom)\n    return abs(resolution)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/gee-community/geemap/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geemap could always use more documentation, whether as part of the official geemap docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/gee-community/geemap/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started","text":"<p>Ready to contribute? Here's how to set up geemap for local development.</p> <ol> <li> <p>Fork the geemap repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>git clone git@github.com:your_name_here/geemap.git\n</code></pre> </li> <li> <p>Install your local copy into a conda env. Assuming you have conda installed, this is how you set up your fork for local development:</p> <pre><code>conda create -n geemap-test python\n</code></pre> <pre><code>conda activate geemap-test\n</code></pre> <pre><code>cd geemap/\n</code></pre> <pre><code>pip install -e .\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox:</p> <pre><code>flake8 geemap tests\n</code></pre> <pre><code>python setup.py test or pytest\n</code></pre> <p>To get flake8 and tox, just pip install them into your conda env.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\n</code></pre> <pre><code>git commit -m \"Your detailed description of your changes.\"\n</code></pre> <pre><code>git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.6, 3.7 and 3.8, and for PyPy. Check https://github.com/gee-community/geemap/actions and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"conversion/","title":"conversion module","text":"<p>Module for converting Google Earth Engine (GEE) JavaScripts to Python scripts and Jupyter notebooks.</p> <p>To convert a GEE JavaScript to Python script:                                       js_to_python(in_file out_file)</p> <p>To convert all GEE JavaScripts in a folder recursively to Python scripts:           js_to_python_dir(in_dir, out_dir)</p> <p>To convert a GEE Python script to Jupyter notebook:                                 py_to_ipynb(in_file, template_file, out_file)</p> <p>To convert all GEE Python scripts in a folder recursively to Jupyter notebooks:     py_to_ipynb_dir(in_dir, template_file, out_dir)</p> <p>To execute a Jupyter notebook and save output cells:                                execute_notebook(in_file)</p> <p>To execute all Jupyter notebooks in a folder recursively:                           execute_notebook_dir(in_dir)           </p>"},{"location":"conversion/#geemap.conversion.check_map_functions","title":"<code>check_map_functions(input_lines)</code>","text":"<p>Extracts Earth Engine map function</p> <p>Parameters:</p> Name Type Description Default <code>input_lines</code> <code>list</code> <p>List of Earth Engine JavaScrips</p> required <p>Returns:</p> Type Description <code>list</code> <p>Output JavaScript with map function</p> Source code in <code>geemap/conversion.py</code> <pre><code>def check_map_functions(input_lines):\n\"\"\"Extracts Earth Engine map function\n\n    Args:\n        input_lines (list): List of Earth Engine JavaScrips\n\n    Returns:\n        list: Output JavaScript with map function\n    \"\"\"\n    output_lines = []\n    for index, line in enumerate(input_lines):\n        if (\".map(function\" in line) or (\".map (function\") in line:\n            bracket_index = line.index(\"{\")\n            matching_line_index, matching_char_index = find_matching_bracket(\n                input_lines, index, bracket_index\n            )\n\n            func_start_index = line.index(\"function\")\n            func_name = \"func_\" + random_string()\n            func_header = line[func_start_index:].replace(\n                \"function\", \"function \" + func_name\n            )\n            output_lines.append(\"\\n\")\n            output_lines.append(func_header)\n\n            for sub_index, tmp_line in enumerate(\n                input_lines[index + 1 : matching_line_index]\n            ):\n                output_lines.append(tmp_line)\n                input_lines[index + 1 + sub_index] = \"\"\n\n            header_line = line[:func_start_index] + func_name\n            header_line = header_line.rstrip()\n\n            func_footer = input_lines[matching_line_index][: matching_char_index + 1]\n            output_lines.append(func_footer)\n\n            footer_line = input_lines[matching_line_index][\n                matching_char_index + 1 :\n            ].strip()\n            if footer_line == \")\" or footer_line == \");\":\n                header_line = header_line + footer_line\n                footer_line = \"\"\n\n            input_lines[matching_line_index] = footer_line\n\n            output_lines.append(header_line)\n            output_lines.append(footer_line)\n        else:\n            output_lines.append(line)\n\n    return output_lines\n</code></pre>"},{"location":"conversion/#geemap.conversion.convert_for_loop","title":"<code>convert_for_loop(line)</code>","text":"<p>Converts JavaScript for loop to Python for loop.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>Input JavaScript for loop</p> required <p>Returns:</p> Type Description <code>str</code> <p>Converted Python for loop.</p> Source code in <code>geemap/conversion.py</code> <pre><code>def convert_for_loop(line):\n\"\"\"Converts JavaScript for loop to Python for loop.\n\n    Args:\n        line (str): Input JavaScript for loop\n\n    Returns:\n        str: Converted Python for loop.\n    \"\"\"\n    new_line = \"\"\n    if \"var \" in line:\n        line = line.replace(\"var \", \"\")\n    start_index = line.index(\"(\")\n    end_index = line.index(\")\")\n\n    prefix = line[:(start_index)]\n    suffix = line[(end_index + 1) :]\n\n    params = line[(start_index + 1) : end_index]\n\n    if \" in \" in params and params.count(\";\") == 0:\n        new_line = prefix + \"{}:\".format(params) + suffix\n        return new_line\n\n    items = params.split(\"=\")\n    param_name = items[0].strip()\n    items = params.split(\";\")\n\n    subitems = []\n\n    for item in items:\n        subitems.append(item.split(\" \")[-1])\n\n    start = subitems[0]\n    end = subitems[1]\n    step = subitems[2]\n\n    if \"++\" in step:\n        step = 1\n    elif \"--\" in step:\n        step = -1\n\n    prefix = line[:(start_index)]\n    suffix = line[(end_index + 1) :]\n    new_line = (\n        prefix\n        + \"{} in range({}, {}, {}):\".format(param_name, start, end, step)\n        + suffix\n    )\n\n    return new_line\n</code></pre>"},{"location":"conversion/#geemap.conversion.create_new_cell","title":"<code>create_new_cell(contents, replace=False)</code>","text":"<p>Create a new cell in Jupyter notebook based on the contents.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>str</code> <p>A string of Python code.</p> required Source code in <code>geemap/conversion.py</code> <pre><code>def create_new_cell(contents, replace=False):\n\"\"\"Create a new cell in Jupyter notebook based on the contents.\n\n    Args:\n        contents (str): A string of Python code.\n    \"\"\"\n    from IPython.core.getipython import get_ipython\n\n    shell = get_ipython()\n    shell.set_next_input(contents, replace=replace)\n</code></pre>"},{"location":"conversion/#geemap.conversion.download_gee_app","title":"<code>download_gee_app(url, out_file=None)</code>","text":"<p>Downloads JavaScript source code from a GEE App</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the GEE App.</p> required <code>out_file</code> <code>str</code> <p>The output file path for the downloaded JavaScript. Defaults to None.</p> <code>None</code> Source code in <code>geemap/conversion.py</code> <pre><code>def download_gee_app(url, out_file=None):\n\"\"\"Downloads JavaScript source code from a GEE App\n\n    Args:\n        url (str): The URL of the GEE App.\n        out_file (str, optional): The output file path for the downloaded JavaScript. Defaults to None.\n    \"\"\"\n    cwd = os.getcwd()\n    out_file_name = os.path.basename(url) + \".js\"\n    out_file_path = os.path.join(cwd, out_file_name)\n    items = url.split(\"/\")\n    items[3] = \"javascript\"\n    items[4] = items[4] + \"-modules.json\"\n    json_url = \"/\".join(items)\n    print(f\"The json url: {json_url}\")\n\n    if out_file is not None:\n        out_file_path = out_file\n        if not out_file_path.endswith(\"js\"):\n            out_file_path += \".js\"\n\n    out_dir = os.path.dirname(out_file_path)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    json_path = out_file_path + \"on\"\n\n    try:\n        urllib.request.urlretrieve(json_url, json_path)\n    except Exception:\n        raise Exception(\"The URL is invalid. Please double check the URL.\")\n\n    with open(out_file_path, \"w\") as f1:\n        with open(json_path, encoding=\"utf-8\") as f2:\n            lines = f2.readlines()\n            for line in lines:\n                # print(line)\n                items = line.split(\"\\\\n\")\n                for index, item in enumerate(items):\n                    if (index &gt; 0) and (index &lt; (len(items) - 1)):\n                        item = item.replace('\\\\\"', '\"')\n                        item = item.replace(r\"\\\\\", \"\\n\")\n                        item = item.replace(\"\\\\r\", \"\")\n                        f1.write(item + \"\\n\")\n    os.remove(json_path)\n    print(f\"The JavaScript is saved at: {out_file_path}\")\n</code></pre>"},{"location":"conversion/#geemap.conversion.execute_notebook","title":"<code>execute_notebook(in_file)</code>","text":"<p>Executes a Jupyter notebook and save output cells</p> <p>Parameters:</p> Name Type Description Default <code>in_file</code> <code>str</code> <p>Input Jupyter notebook.</p> required Source code in <code>geemap/conversion.py</code> <pre><code>def execute_notebook(in_file):\n\"\"\"Executes a Jupyter notebook and save output cells\n\n    Args:\n        in_file (str): Input Jupyter notebook.\n    \"\"\"\n    # command = 'jupyter nbconvert --to notebook --execute ' + in_file + ' --inplace'\n    command = 'jupyter nbconvert --to notebook --execute \"{}\" --inplace'.format(in_file)\n    print(os.popen(command).read().rstrip())\n    # os.popen(command)\n</code></pre>"},{"location":"conversion/#geemap.conversion.execute_notebook_dir","title":"<code>execute_notebook_dir(in_dir)</code>","text":"<p>Executes all Jupyter notebooks in the given directory recursively and save output cells.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>Input folder containing notebooks.</p> required Source code in <code>geemap/conversion.py</code> <pre><code>def execute_notebook_dir(in_dir):\n\"\"\"Executes all Jupyter notebooks in the given directory recursively and save output cells.\n\n    Args:\n        in_dir (str): Input folder containing notebooks.\n    \"\"\"\n    print(\"Executing Earth Engine Jupyter notebooks ...\\n\")\n\n    in_dir = os.path.abspath(in_dir)\n    files = list(Path(in_dir).rglob(\"*.ipynb\"))\n    count = len(files)\n    if files is not None:\n        for index, file in enumerate(files):\n            in_file = str(file)\n            print(f\"Processing {index + 1}/{count}: {file} ...\")\n            execute_notebook(in_file)\n</code></pre>"},{"location":"conversion/#geemap.conversion.find_matching_bracket","title":"<code>find_matching_bracket(lines, start_line_index, start_char_index, matching_char='{')</code>","text":"<p>Finds the position of the matching closing bracket from a list of lines.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list</code> <p>The input list of lines.</p> required <code>start_line_index</code> <code>int</code> <p>The line index where the starting bracket is located.</p> required <code>start_char_index</code> <code>int</code> <p>The position index of the starting bracket.</p> required <code>matching_char</code> <code>str</code> <p>The starting bracket to search for. Defaults to '{'.</p> <code>'{'</code> <p>Returns:</p> Type Description <code>matching_line_index (int)</code> <p>The line index where the matching closing bracket is located. matching_char_index (int): The position index of the matching closing bracket.</p> Source code in <code>geemap/conversion.py</code> <pre><code>def find_matching_bracket(lines, start_line_index, start_char_index, matching_char=\"{\"):\n\"\"\"Finds the position of the matching closing bracket from a list of lines.\n\n    Args:\n        lines (list): The input list of lines.\n        start_line_index (int): The line index where the starting bracket is located.\n        start_char_index (int): The position index of the starting bracket.\n        matching_char (str, optional): The starting bracket to search for. Defaults to '{'.\n\n    Returns:\n        matching_line_index (int): The line index where the matching closing bracket is located.\n        matching_char_index (int): The position index of the matching closing bracket.\n    \"\"\"\n    matching_line_index = -1\n    matching_char_index = -1\n\n    matching_chars = {\"{\": \"}\", \"(\": \")\", \"[\": \"]\"}\n    if matching_char not in matching_chars.keys():\n        print(\n            \"The matching character must be one of the following: {}\".format(\n                \", \".join(matching_chars.keys())\n            )\n        )\n        return matching_line_index, matching_char_index\n\n    # Create a deque to use it as a stack.\n    d = deque()\n\n    for line_index in range(start_line_index, len(lines)):\n        line = lines[line_index]\n        # deal with the line where the starting bracket is located.\n        if line_index == start_line_index:\n            line = lines[line_index][start_char_index:]\n\n        for index, item in enumerate(line):\n            # Pops a starting bracket for each closing bracket\n            if item == matching_chars[matching_char]:\n                d.popleft()\n            # Push all starting brackets\n            elif item == matching_char:\n                d.append(matching_char)\n\n            # If deque becomes empty\n            if not d:\n                matching_line_index = line_index\n                if line_index == start_line_index:\n                    matching_char_index = start_char_index + index\n                else:\n                    matching_char_index = index\n\n                return matching_line_index, matching_char_index\n\n    return matching_line_index, matching_char_index\n</code></pre>"},{"location":"conversion/#geemap.conversion.format_params","title":"<code>format_params(line, sep=':')</code>","text":"<p>Formats keys in a dictionary and adds quotes to the keys. For example, {min: 0, max: 10} will result in ('min': 0, 'max': 10)</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>A string.</p> required <code>sep</code> <code>str</code> <p>Separator. Defaults to ':'.</p> <code>':'</code> <p>Returns:</p> Type Description <code>[str]</code> <p>A string with keys quoted</p> Source code in <code>geemap/conversion.py</code> <pre><code>def format_params(line, sep=\":\"):\n\"\"\"Formats keys in a dictionary and adds quotes to the keys.\n    For example, {min: 0, max: 10} will result in ('min': 0, 'max': 10)\n\n    Args:\n        line (str): A string.\n        sep (str, optional): Separator. Defaults to ':'.\n\n    Returns:\n        [str]: A string with keys quoted\n    \"\"\"\n    # print(line)\n    new_line = line\n    prefix = \"\"\n    # suffix = \"\"\n\n    if line.strip().startswith(\"for\"):  # skip for loop\n        return line\n\n    # find all occurrences of a substring\n    def find_all(a_str, sub):\n        start = 0\n        while True:\n            start = a_str.find(sub, start)\n            if start == -1:\n                return\n            yield start\n            start += len(sub)  # use start += 1 to find overlapping matches\n\n    indices = list(find_all(line, sep))\n    count = len(indices)\n\n    if \"{\" in line:\n        bracket_index = line.index(\"{\")\n        if bracket_index &lt; indices[0]:\n            prefix = line[: bracket_index + 1]\n            line = line[bracket_index + 1 :]\n\n    if count &gt; 0:\n        items = line.split(sep)\n\n        if count == 1:\n            for i in range(0, count):\n                item = items[i].strip()\n                if ('\"' not in item) and (\"'\" not in item):\n                    new_item = \"'\" + item + \"'\"\n                    items[i] = items[i].replace(item, new_item)\n            new_line = \":\".join(items)\n        elif count &gt; 1:\n            for i in range(0, count):\n                item = items[i]\n                if \",\" in item:\n                    subitems = item.split(\",\")\n                    subitem = subitems[-1]\n                    if ('\"' not in subitem) and (\"'\" not in subitem):\n                        new_subitem = \"'\" + subitem.strip() + \"'\"\n                        subitems[-1] = subitems[-1].replace(subitem, new_subitem)\n                        items[i] = \", \".join(subitems)\n                else:\n                    if ('\"' not in item) and (\"'\" not in item):\n                        new_item = \"'\" + item.strip() + \"'\"\n                        padding = len(item) - len(item.strip())\n                        items[i] = \" \" * padding + item.replace(item, new_item)\n\n            new_line = \":\".join(items)\n\n    return prefix + new_line\n</code></pre>"},{"location":"conversion/#geemap.conversion.get_js_examples","title":"<code>get_js_examples(out_dir=None)</code>","text":"<p>Gets Earth Engine JavaScript examples from the geemap package.</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>str</code> <p>The folder to copy the JavaScript examples to. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The folder containing the JavaScript examples.</p> Source code in <code>geemap/conversion.py</code> <pre><code>def get_js_examples(out_dir=None):\n\"\"\"Gets Earth Engine JavaScript examples from the geemap package.\n\n    Args:\n        out_dir (str, optional): The folder to copy the JavaScript examples to. Defaults to None.\n\n    Returns:\n        str: The folder containing the JavaScript examples.\n    \"\"\"\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    example_dir = os.path.join(pkg_dir, \"data\")\n    js_dir = os.path.join(example_dir, \"javascripts\")\n\n    files = list(Path(js_dir).rglob(\"*.js\"))\n    if out_dir is None:\n        out_dir = js_dir\n    else:\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        for file in files:\n            basename = os.path.basename(file)\n            out_path = os.path.join(out_dir, basename)\n            shutil.copyfile(file, out_path)\n\n    return out_dir\n</code></pre>"},{"location":"conversion/#geemap.conversion.get_nb_template","title":"<code>get_nb_template(download_latest=False, out_file=None)</code>","text":"<p>Get the Earth Engine Jupyter notebook template.</p> <p>Parameters:</p> Name Type Description Default <code>download_latest</code> <code>bool</code> <p>If True, downloads the latest notebook template from GitHub. Defaults to False.</p> <code>False</code> <code>out_file</code> <code>str</code> <p>Set the output file path of the notebook template. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The file path of the template.</p> Source code in <code>geemap/conversion.py</code> <pre><code>def get_nb_template(download_latest=False, out_file=None):\n\"\"\"Get the Earth Engine Jupyter notebook template.\n\n    Args:\n        download_latest (bool, optional): If True, downloads the latest notebook template from GitHub. Defaults to False.\n        out_file (str, optional): Set the output file path of the notebook template. Defaults to None.\n\n    Returns:\n        str: The file path of the template.\n    \"\"\"\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    example_dir = os.path.join(pkg_dir, \"data\")\n    template_dir = os.path.join(example_dir, \"template\")\n    template_file = os.path.join(template_dir, \"template.py\")\n\n    if out_file is None:\n        out_file = template_file\n        return out_file\n\n    if not out_file.endswith(\".py\"):\n        out_file = out_file + \".py\"\n\n    if not os.path.exists(os.path.dirname(out_file)):\n        os.makedirs(os.path.dirname(out_file))\n\n    if download_latest:\n        template_url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/template/template.py\"\n        print(f\"Downloading the latest notebook template from {template_url}\")\n        urllib.request.urlretrieve(template_url, out_file)\n    elif out_file is not None:\n        shutil.copyfile(template_file, out_file)\n\n    return out_file\n</code></pre>"},{"location":"conversion/#geemap.conversion.js_snippet_to_py","title":"<code>js_snippet_to_py(in_js_snippet, add_new_cell=True, import_ee=True, import_geemap=False, show_map=True)</code>","text":"<p>Converts an Earth Engine JavaScript snippet wrapped in triple quotes to Python directly on a Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>in_js_snippet</code> <code>str</code> <p>Earth Engine JavaScript within triple quotes.</p> required <code>add_new_cell</code> <code>bool</code> <p>Whether add the converted Python to a new cell.</p> <code>True</code> <code>import_ee</code> <code>bool</code> <p>Whether to import ee. Defaults to True.</p> <code>True</code> <code>import_geemap</code> <code>bool</code> <p>Whether to import geemap. Defaults to False.</p> <code>False</code> <code>show_map</code> <code>bool</code> <p>Whether to show the map. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of Python script.</p> Source code in <code>geemap/conversion.py</code> <pre><code>def js_snippet_to_py(\n    in_js_snippet,\n    add_new_cell=True,\n    import_ee=True,\n    import_geemap=False,\n    show_map=True,\n):\n\"\"\"Converts an Earth Engine JavaScript snippet wrapped in triple quotes to Python directly on a Jupyter notebook.\n\n    Args:\n        in_js_snippet (str): Earth Engine JavaScript within triple quotes.\n        add_new_cell (bool, optional): Whether add the converted Python to a new cell.\n        import_ee (bool, optional): Whether to import ee. Defaults to True.\n        import_geemap (bool, optional): Whether to import geemap. Defaults to False.\n        show_map (bool, optional): Whether to show the map. Defaults to True.\n\n    Returns:\n        list: A list of Python script.\n    \"\"\"\n\n    in_js = temp_file_path(\".js\")\n    out_py = temp_file_path(\".py\")\n\n    try:\n        with open(in_js, \"w\") as f:\n            f.write(in_js_snippet)\n        js_to_python(\n            in_js,\n            out_file=out_py,\n            use_qgis=False,\n            show_map=show_map,\n            import_geemap=import_geemap,\n        )\n\n        out_lines = []\n        if import_ee:\n            out_lines.append(\"import ee\\n\")\n        if import_geemap:\n            out_lines.append(\"import geemap\\n\\n\")\n            out_lines.append(\"Map = geemap.Map()\\n\")\n\n        with open(out_py, encoding=\"utf-8\") as f:\n            lines = f.readlines()\n            for index, line in enumerate(lines):\n                if index &lt; (len(lines) - 1):\n                    if line.strip() == \"import ee\":\n                        continue\n\n                    next_line = lines[index + 1]\n                    if line.strip() == \"\" and next_line.strip() == \"\":\n                        continue\n                    elif \".style(\" in line and (\".style(**\" not in line):\n                        line = line.replace(\".style(\", \".style(**\")\n                        out_lines.append(line)\n                    else:\n                        out_lines.append(line)\n                elif index == (len(lines) - 1) and lines[index].strip() != \"\":\n                    out_lines.append(line)\n\n        os.remove(in_js)\n        os.remove(out_py)\n\n        if add_new_cell:\n            contents = \"\".join(out_lines).strip()\n            create_new_cell(contents)\n        else:\n            return out_lines\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"conversion/#geemap.conversion.js_to_python","title":"<code>js_to_python(in_file, out_file=None, use_qgis=True, github_repo=None, show_map=True, import_geemap=False)</code>","text":"<p>Converts an Earth Engine JavaScript to Python script.</p> <pre><code>!!! args\n    in_file (str): File path of the input JavaScript.\n    out_file (str, optional): File path of the output Python script. Defaults to None.\n    use_qgis (bool, optional): Whether to add \"from ee_plugin import Map\n</code></pre> <p>\" to the output script. Defaults to True.         github_repo (str, optional): GitHub repo url. Defaults to None.         show_map (bool, optional): Whether to add \"Map\" to the output script. Defaults to True.         import_geemap (bool, optional): Whether to add \"import geemap\" to the output script. Defaults to False.</p> <pre><code>!!! returns\n    list: Python script\n</code></pre> Source code in <code>geemap/conversion.py</code> <pre><code>def js_to_python(\n    in_file,\n    out_file=None,\n    use_qgis=True,\n    github_repo=None,\n    show_map=True,\n    import_geemap=False,\n):\n\"\"\"Converts an Earth Engine JavaScript to Python script.\n\n    Args:\n        in_file (str): File path of the input JavaScript.\n        out_file (str, optional): File path of the output Python script. Defaults to None.\n        use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \\n\" to the output script. Defaults to True.\n        github_repo (str, optional): GitHub repo url. Defaults to None.\n        show_map (bool, optional): Whether to add \"Map\" to the output script. Defaults to True.\n        import_geemap (bool, optional): Whether to add \"import geemap\" to the output script. Defaults to False.\n\n    Returns:\n        list: Python script\n    \"\"\"\n    in_file = os.path.abspath(in_file)\n    if out_file is None:\n        out_file = in_file.replace(\".js\", \".py\")\n\n    root_dir = os.path.dirname(os.path.abspath(__file__))\n    if not os.path.isfile(in_file):\n        in_file = os.path.join(root_dir, in_file)\n    if not os.path.isfile(out_file):\n        out_file = os.path.join(root_dir, out_file)\n\n    is_python = False\n    # add_github_url = False\n\n    if use_qgis and import_geemap:\n        raise Exception(\n            \"use_qgis and import_geemap cannot be both True. Please set one of them to False.\"\n        )\n\n    import_str = \"\"\n    if use_qgis:\n        import_str = \"from ee_plugin import Map\\n\"\n    if import_geemap:\n        import_str = \"import geemap\\n\\nMap = geemap.Map()\\n\"\n\n    github_url = \"\"\n    if github_repo is not None:\n        github_url = \"# GitHub URL: \" + github_repo + in_file + \"\\n\\n\"\n\n    math_import = False\n    math_import_str = \"\"\n\n    lines = []\n    with open(in_file, encoding=\"utf-8\") as f:\n        lines = f.readlines()\n\n        math_import = use_math(lines)\n\n        for line in lines:\n            line = line.strip()\n            if line == \"import ee\":\n                is_python = True\n\n    if math_import:\n        math_import_str = \"import math\\n\"\n\n    output = \"\"\n\n    if is_python:  # only update the GitHub URL if it is already a GEE Python script\n        output = github_url + \"\".join(map(str, lines))\n    else:  # deal with JavaScript\n        header = github_url + \"import ee \\n\" + math_import_str + import_str\n        # function_defs = []\n        output = header + \"\\n\"\n\n        with open(in_file, encoding=\"utf-8\") as f:\n            lines = f.readlines()\n\n            # print('Processing {}'.format(in_file))\n            lines = check_map_functions(lines)\n\n            for index, line in enumerate(lines):\n                if (\"/* color\" in line) and (\"*/\" in line):\n                    line = (\n                        line[: line.index(\"/*\")].lstrip()\n                        + line[(line.index(\"*/\") + 2) :]\n                    )\n\n                if (\n                    (\"= function\" in line)\n                    or (\"=function\" in line)\n                    or line.strip().startswith(\"function\")\n                ):\n                    try:\n                        bracket_index = line.index(\"{\")\n                    except Exception as e:\n                        print(\n                            f\"An error occurred when processing {in_file}. The closing curly bracket could not be found in Line {index+1}: {line}. Please reformat the function definition and make sure that both the opening and closing curly brackets apprear on the same line as the function keyword. \"\n                        )\n                        return\n\n                    (\n                        matching_line_index,\n                        matching_char_index,\n                    ) = find_matching_bracket(lines, index, bracket_index)\n\n                    line = line[:bracket_index] + line[bracket_index + 1 :]\n                    if matching_line_index == index:\n                        line = (\n                            line[:matching_char_index] + line[matching_char_index + 1 :]\n                        )\n                    else:\n                        tmp_line = lines[matching_line_index]\n                        lines[matching_line_index] = (\n                            tmp_line[:matching_char_index]\n                            + tmp_line[matching_char_index + 1 :]\n                        )\n\n                    line = (\n                        line.replace(\" = function\", \"\")\n                        .replace(\"=function\", \"\")\n                        .replace(\"function \", \"\")\n                    )\n                    if line.lstrip().startswith(\"//\"):\n                        line = line.replace(\"//\", \"\").lstrip()\n                        line = (\n                            \" \" * (len(line) - len(line.lstrip()))\n                            + \"# def \"\n                            + line.strip()\n                            + \":\"\n                        )\n                    else:\n                        line = (\n                            \" \" * (len(line) - len(line.lstrip()))\n                            + \"def \"\n                            + line.strip()\n                            + \":\"\n                        )\n                elif \"{\" in line:\n                    bracket_index = line.index(\"{\")\n                    (\n                        matching_line_index,\n                        matching_char_index,\n                    ) = find_matching_bracket(lines, index, bracket_index)\n                    if (matching_line_index == index) and (\":\" in line):\n                        pass\n                    elif (\"for (\" in line) or (\"for(\" in line):\n                        line = convert_for_loop(line)\n                        lines[index] = line\n                        bracket_index = line.index(\"{\")\n                        (\n                            matching_line_index,\n                            matching_char_index,\n                        ) = find_matching_bracket(lines, index, bracket_index)\n                        tmp_line = lines[matching_line_index]\n                        lines[matching_line_index] = (\n                            tmp_line[:matching_char_index]\n                            + tmp_line[matching_char_index + 1 :]\n                        )\n                        line = line.replace(\"{\", \"\")\n\n                if line is None:\n                    line = \"\"\n\n                line = line.replace(\"//\", \"#\")\n                line = line.replace(\"var \", \"\", 1)\n                line = line.replace(\"/*\", \"#\")\n                line = line.replace(\"*/\", \"#\")\n                line = line.replace(\"true\", \"True\").replace(\"false\", \"False\")\n                line = line.replace(\"null\", \"None\")\n                line = line.replace(\".or\", \".Or\")\n                line = line.replace(\".and\", \".And\")\n                line = line.replace(\".not\", \".Not\")\n                line = line.replace(\"visualize({\", \"visualize(**{\")\n                line = line.replace(\"Math.PI\", \"math.pi\")\n                line = line.replace(\"Math.\", \"math.\")\n                line = line.replace(\"= new\", \"=\")\n                line = line.rstrip()\n\n                if \".style(\" in line and \".style(**\" not in line:\n                    line = line.replace(\".style(\", \".style(**\")\n\n                if line.endswith(\"+\"):\n                    line = line + \" \\\\\"\n                elif line.endswith(\";\"):\n                    line = line[:-1]\n\n                if line.lstrip().startswith(\"*\"):\n                    line = line.replace(\"*\", \"#\")\n\n                if (\n                    (\":\" in line)\n                    and (not line.strip().startswith(\"#\"))\n                    and (not line.strip().startswith(\"def\"))\n                    and (not line.strip().startswith(\".\"))\n                ):\n                    line = format_params(line)\n\n                if (\n                    index &lt; (len(lines) - 1)\n                    and line.lstrip().startswith(\"#\")\n                    and lines[index + 1].lstrip().startswith(\".\")\n                ):\n                    line = \"\"\n\n                if line.lstrip().startswith(\".\"):\n                    if \"#\" in line:\n                        line = line[: line.index(\"#\")]\n                    output = output.rstrip() + \" \" + \"\\\\\" + \"\\n\" + line + \"\\n\"\n                else:\n                    output += line + \"\\n\"\n\n    if show_map:\n        output += \"Map\"\n\n    out_dir = os.path.dirname(out_file)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    with open(out_file, \"w\") as f:\n        f.write(output)\n\n    return output\n</code></pre>"},{"location":"conversion/#geemap.conversion.js_to_python_dir","title":"<code>js_to_python_dir(in_dir, out_dir=None, use_qgis=True, github_repo=None)</code>","text":"<p>Converts all Earth Engine JavaScripts in a folder recursively to Python scripts.</p> <pre><code>!!! args\n    in_dir (str): The input folder containing Earth Engine JavaScripts.\n    out_dir (str, optional): The output folder containing Earth Engine Python scripts. Defaults to None.\n    use_qgis (bool, optional): Whether to add \"from ee_plugin import Map\n</code></pre> <p>\" to the output script. Defaults to True.         github_repo (str, optional): GitHub repo url. Defaults to None.</p> Source code in <code>geemap/conversion.py</code> <pre><code>def js_to_python_dir(in_dir, out_dir=None, use_qgis=True, github_repo=None):\n\"\"\"Converts all Earth Engine JavaScripts in a folder recursively to Python scripts.\n\n    Args:\n        in_dir (str): The input folder containing Earth Engine JavaScripts.\n        out_dir (str, optional): The output folder containing Earth Engine Python scripts. Defaults to None.\n        use_qgis (bool, optional): Whether to add \"from ee_plugin import Map \\n\" to the output script. Defaults to True.\n        github_repo (str, optional): GitHub repo url. Defaults to None.\n    \"\"\"\n    print(\"Converting Earth Engine JavaScripts to Python scripts...\\n\")\n    in_dir = os.path.abspath(in_dir)\n    if out_dir is None:\n        out_dir = in_dir\n    elif not os.path.exists(out_dir):\n        out_dir = os.path.abspath(out_dir)\n        os.makedirs(out_dir)\n    else:\n        out_dir = os.path.abspath(out_dir)\n\n    files = list(Path(in_dir).rglob(\"*.js\"))\n\n    for index, in_file in enumerate(files):\n        print(f\"Processing {index + 1}/{len(files)}: {in_file}\")\n        # if use_qgis:\n        #     out_file = os.path.splitext(in_file)[0] + \"_qgis.py\"\n        # else:\n        out_file = os.path.splitext(in_file)[0] + \"_geemap.py\"\n        out_file = out_file.replace(in_dir, out_dir)\n        js_to_python(in_file, out_file, use_qgis, github_repo)\n    # print(\"Output Python script folder: {}\".format(out_dir))\n</code></pre>"},{"location":"conversion/#geemap.conversion.py_to_ipynb","title":"<code>py_to_ipynb(in_file, template_file=None, out_file=None, github_username=None, github_repo=None)</code>","text":"<p>Converts Earth Engine Python script to Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>in_file</code> <code>str</code> <p>Input Earth Engine Python script.</p> required <code>template_file</code> <code>str</code> <p>Input Jupyter notebook template.</p> <code>None</code> <code>out_file</code> <code>str</code> <p>Output Jupyter notebook.</p> <code>None</code> <code>github_username</code> <code>str</code> <p>GitHub username. Defaults to None.</p> <code>None</code> <code>github_repo</code> <code>str</code> <p>GitHub repo name. Defaults to None.</p> <code>None</code> Source code in <code>geemap/conversion.py</code> <pre><code>def py_to_ipynb(\n    in_file,\n    template_file=None,\n    out_file=None,\n    github_username=None,\n    github_repo=None,\n):\n\"\"\"Converts Earth Engine Python script to Jupyter notebook.\n\n    Args:\n        in_file (str): Input Earth Engine Python script.\n        template_file (str): Input Jupyter notebook template.\n        out_file (str, optional)): Output Jupyter notebook.\n        github_username (str, optional): GitHub username. Defaults to None.\n        github_repo (str, optional): GitHub repo name. Defaults to None.\n    \"\"\"\n    in_file = os.path.abspath(in_file)\n\n    if template_file is None:\n        template_file = get_nb_template()\n\n    if out_file is None:\n        out_file = os.path.splitext(in_file)[0] + \".ipynb\"\n\n    out_py_file = os.path.splitext(out_file)[0] + \"_tmp.py\"\n\n    out_dir = os.path.dirname(out_file)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n    if out_dir == os.path.dirname(in_file):\n        out_py_file = os.path.splitext(out_file)[0] + \"_tmp.py\"\n\n    content = remove_qgis_import(in_file)\n    if content[-1].strip() == \"Map\":\n        content = content[:-1]\n    header = template_header(template_file)\n    footer = template_footer(template_file)\n\n    if (github_username is not None) and (github_repo is not None):\n        out_py_path = str(out_file).split(\"/\")\n        index = out_py_path.index(github_repo)\n        out_py_relative_path = \"/\".join(out_py_path[index + 1 :])\n        out_ipynb_relative_path = out_py_relative_path.replace(\".py\", \".ipynb\")\n\n        new_header = []\n        for index, line in enumerate(header):\n            if index &lt; 9:  # Change Google Colab and binder URLs\n                line = line.replace(\"giswqs\", github_username)\n                line = line.replace(\"geemap\", github_repo)\n                line = line.replace(\n                    \"examples/template/template.ipynb\", out_ipynb_relative_path\n                )\n            new_header.append(line)\n        header = new_header\n\n    if content is not None:\n        out_text = header + content + footer\n    else:\n        out_text = header + footer\n\n    out_text = out_text[:-1] + [out_text[-1].strip()]\n\n    if not os.path.exists(os.path.dirname(out_py_file)):\n        os.makedirs(os.path.dirname(out_py_file))\n\n    with open(out_py_file, \"w\") as f:\n        f.writelines(out_text)\n\n    try:\n        # command = 'ipynb-py-convert ' + out_py_file + ' ' + out_file\n        command = 'ipynb-py-convert \"{}\" \"{}\"'.format(out_py_file, out_file)\n        print(os.popen(command).read().rstrip())\n        # os.popen(command)\n    except Exception as e:\n        print(\"Please install ipynb-py-convert using the following command:\\n\")\n        print(\"pip install ipynb-py-convert\")\n        raise Exception(e)\n\n    try:\n        os.remove(out_py_file)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"conversion/#geemap.conversion.py_to_ipynb_dir","title":"<code>py_to_ipynb_dir(in_dir, template_file=None, out_dir=None, github_username=None, github_repo=None)</code>","text":"<p>Converts Earth Engine Python scripts in a folder recursively to Jupyter notebooks.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>Input folder containing Earth Engine Python scripts.</p> required <code>out_dir</code> <code>str</code> <p>Output folder. Defaults to None.</p> <code>None</code> <code>template_file</code> <code>str</code> <p>Input jupyter notebook template file.</p> <code>None</code> <code>github_username</code> <code>str</code> <p>GitHub username. Defaults to None.</p> <code>None</code> <code>github_repo</code> <code>str</code> <p>GitHub repo name. Defaults to None.</p> <code>None</code> Source code in <code>geemap/conversion.py</code> <pre><code>def py_to_ipynb_dir(\n    in_dir, template_file=None, out_dir=None, github_username=None, github_repo=None\n):\n\"\"\"Converts Earth Engine Python scripts in a folder recursively to Jupyter notebooks.\n\n    Args:\n        in_dir (str): Input folder containing Earth Engine Python scripts.\n        out_dir str, optional): Output folder. Defaults to None.\n        template_file (str): Input jupyter notebook template file.\n        github_username (str, optional): GitHub username. Defaults to None.\n        github_repo (str, optional): GitHub repo name. Defaults to None.\n    \"\"\"\n    print(\"Converting Earth Engine Python scripts to Jupyter notebooks ...\\n\")\n\n    in_dir = os.path.abspath(in_dir)\n    files = []\n    qgis_files = list(Path(in_dir).rglob(\"*_geemap.py\"))\n    py_files = list(Path(in_dir).rglob(\"*.py\"))\n\n    if len(qgis_files) == len(py_files) / 2:\n        files = qgis_files\n    else:\n        files = py_files\n\n    if out_dir is None:\n        out_dir = in_dir\n    elif not os.path.exists(out_dir):\n        out_dir = os.path.abspath(out_dir)\n        os.makedirs(out_dir)\n    else:\n        out_dir = os.path.abspath(out_dir)\n\n    for index, file in enumerate(files):\n        in_file = str(file)\n        out_file = (\n            in_file.replace(in_dir, out_dir)\n            .replace(\"_qgis\", \"\")\n            .replace(\".py\", \".ipynb\")\n        )\n        print(f\"Processing {index + 1}/{len(files)}: {in_file}\")\n        py_to_ipynb(in_file, template_file, out_file, github_username, github_repo)\n</code></pre>"},{"location":"conversion/#geemap.conversion.remove_qgis_import","title":"<code>remove_qgis_import(in_file)</code>","text":"<p>Removes 'from ee_plugin import Map' from an Earth Engine Python script.</p> <p>Parameters:</p> Name Type Description Default <code>in_file</code> <code>str</code> <p>Input file path of the Python script.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of lines  'from ee_plugin import Map' removed.</p> Source code in <code>geemap/conversion.py</code> <pre><code>def remove_qgis_import(in_file):\n\"\"\"Removes 'from ee_plugin import Map' from an Earth Engine Python script.\n\n    Args:\n        in_file (str): Input file path of the Python script.\n\n    Returns:\n        list: List of lines  'from ee_plugin import Map' removed.\n    \"\"\"\n    in_file = os.path.abspath(in_file)\n    start_index = 0\n    with open(in_file, encoding=\"utf-8\") as f:\n        lines = f.readlines()\n        for index, line in enumerate(lines):\n            if \"from ee_plugin import Map\" in line:\n                start_index = index\n\n                i = 1\n                while True:\n                    line_tmp = lines[start_index + i].strip()\n                    if line_tmp != \"\":\n                        return lines[start_index + i :]\n                    else:\n                        i = i + 1\n            elif \"Map = geemap.Map()\" in line:\n                return lines[index + 1 :]\n</code></pre>"},{"location":"conversion/#geemap.conversion.template_footer","title":"<code>template_footer(in_template)</code>","text":"<p>Extracts footer from the notebook template.</p> <p>Parameters:</p> Name Type Description Default <code>in_template</code> <code>str</code> <p>Input notebook template file path.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of lines.</p> Source code in <code>geemap/conversion.py</code> <pre><code>def template_footer(in_template):\n\"\"\"Extracts footer from the notebook template.\n\n    Args:\n        in_template (str): Input notebook template file path.\n\n    Returns:\n        list: List of lines.\n    \"\"\"\n    footer = []\n    template_lines = []\n    footer_start_index = 0\n\n    with open(in_template, encoding=\"utf-8\") as f:\n        template_lines = f.readlines()\n        for index, line in enumerate(template_lines):\n            if \"## Display the interactive map\" in line:\n                footer_start_index = index - 2\n\n    footer = [\"\\n\"] + template_lines[footer_start_index:]\n\n    return footer\n</code></pre>"},{"location":"conversion/#geemap.conversion.template_header","title":"<code>template_header(in_template)</code>","text":"<p>Extracts header from the notebook template.</p> <p>Parameters:</p> Name Type Description Default <code>in_template</code> <code>str</code> <p>Input notebook template file path.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of lines.</p> Source code in <code>geemap/conversion.py</code> <pre><code>def template_header(in_template):\n\"\"\"Extracts header from the notebook template.\n\n    Args:\n        in_template (str): Input notebook template file path.\n\n    Returns:\n        list: List of lines.\n    \"\"\"\n    header = []\n    template_lines = []\n    header_end_index = 0\n\n    with open(in_template, encoding=\"utf-8\") as f:\n        template_lines = f.readlines()\n        for index, line in enumerate(template_lines):\n            if \"## Add Earth Engine Python script\" in line:\n                header_end_index = index + 6\n\n    header = template_lines[:header_end_index]\n\n    return header\n</code></pre>"},{"location":"conversion/#geemap.conversion.update_nb_header","title":"<code>update_nb_header(in_file, github_username=None, github_repo=None)</code>","text":"<p>Updates notebook header (binder and Google Colab URLs).</p> <p>Parameters:</p> Name Type Description Default <code>in_file</code> <code>str</code> <p>The input Jupyter notebook.</p> required <code>github_username</code> <code>str</code> <p>GitHub username. Defaults to None.</p> <code>None</code> <code>github_repo</code> <code>str</code> <p>GitHub repo name. Defaults to None.</p> <code>None</code> Source code in <code>geemap/conversion.py</code> <pre><code>def update_nb_header(in_file, github_username=None, github_repo=None):\n\"\"\"Updates notebook header (binder and Google Colab URLs).\n\n    Args:\n        in_file (str): The input Jupyter notebook.\n        github_username (str, optional): GitHub username. Defaults to None.\n        github_repo (str, optional): GitHub repo name. Defaults to None.\n    \"\"\"\n    if github_username is None:\n        github_username = \"giswqs\"\n    if github_repo is None:\n        github_repo = \"geemap\"\n\n    index = in_file.index(github_repo)\n    file_relative_path = in_file[index + len(github_repo) + 1 :]\n\n    output_lines = []\n\n    with open(in_file, encoding=\"utf-8\") as f:\n        lines = f.readlines()\n        start_line_index = 2\n        start_char_index = lines[start_line_index].index(\"{\")\n        matching_line_index, _ = find_matching_bracket(\n            lines, start_line_index, start_char_index\n        )\n\n        header = lines[:matching_line_index]\n        content = lines[matching_line_index:]\n\n        new_header = []\n        search_string = \"\"\n        for line in header:\n            line = line.replace(\"giswqs\", github_username)\n            line = line.replace(\"geemap\", github_repo)\n            if \"master?filepath=\" in line:\n                search_string = \"master?filepath=\"\n                start_index = line.index(search_string) + len(search_string)\n                end_index = line.index(\".ipynb\") + 6\n                relative_path = line[start_index:end_index]\n                line = line.replace(relative_path, file_relative_path)\n            elif \"/master/\" in line:\n                search_string = \"/master/\"\n                start_index = line.index(search_string) + len(search_string)\n                end_index = line.index(\".ipynb\") + 6\n                relative_path = line[start_index:end_index]\n                line = line.replace(relative_path, file_relative_path)\n            new_header.append(line)\n\n        output_lines = new_header + content\n\n        with open(in_file, \"w\") as f:\n            f.writelines(output_lines)\n</code></pre>"},{"location":"conversion/#geemap.conversion.update_nb_header_dir","title":"<code>update_nb_header_dir(in_dir, github_username=None, github_repo=None)</code>","text":"<p>Updates header (binder and Google Colab URLs) of all notebooks in a folder .</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>The input directory containing Jupyter notebooks.</p> required <code>github_username</code> <code>str</code> <p>GitHub username. Defaults to None.</p> <code>None</code> <code>github_repo</code> <code>str</code> <p>GitHub repo name. Defaults to None.</p> <code>None</code> Source code in <code>geemap/conversion.py</code> <pre><code>def update_nb_header_dir(in_dir, github_username=None, github_repo=None):\n\"\"\"Updates header (binder and Google Colab URLs) of all notebooks in a folder .\n\n    Args:\n        in_dir (str): The input directory containing Jupyter notebooks.\n        github_username (str, optional): GitHub username. Defaults to None.\n        github_repo (str, optional): GitHub repo name. Defaults to None.\n    \"\"\"\n    files = list(Path(in_dir).rglob(\"*.ipynb\"))\n    for index, file in enumerate(files):\n        file = str(file)\n        if \".ipynb_checkpoints\" in file:\n            del files[index]\n    count = len(files)\n    if files is not None:\n        for index, file in enumerate(files):\n            in_file = str(file)\n            print(f\"Processing {index + 1}/{count}: {file} ...\")\n            update_nb_header(in_file, github_username, github_repo)\n</code></pre>"},{"location":"conversion/#geemap.conversion.use_math","title":"<code>use_math(lines)</code>","text":"<p>Checks if an Earth Engine uses Math library</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list</code> <p>An Earth Engine JavaScript.</p> required <p>Returns:</p> Type Description <code>[bool]</code> <p>Returns True if the script contains 'Math.'. For example 'Math.PI', 'Math.pow'</p> Source code in <code>geemap/conversion.py</code> <pre><code>def use_math(lines):\n\"\"\"Checks if an Earth Engine uses Math library\n\n    Args:\n        lines (list): An Earth Engine JavaScript.\n\n    Returns:\n        [bool]: Returns True if the script contains 'Math.'. For example 'Math.PI', 'Math.pow'\n    \"\"\"\n    math_import = False\n    for line in lines:\n        if \"Math.\" in line:\n            math_import = True\n\n    return math_import\n</code></pre>"},{"location":"datasets/","title":"datasets module","text":""},{"location":"datasets/#geemap.datasets.get_community_data_list","title":"<code>get_community_data_list()</code>","text":"<p>Gets the list community datasets     from https://github.com/samapriya/awesome-gee-community-datasets/blob/master/community_datasets.json</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of Earth Engine asset IDs.</p> Source code in <code>geemap/datasets.py</code> <pre><code>def get_community_data_list():\n\"\"\"Gets the list community datasets\n        from https://github.com/samapriya/awesome-gee-community-datasets/blob/master/community_datasets.json\n\n    Returns:\n        list: The list of Earth Engine asset IDs.\n    \"\"\"\n    collections = search_ee_data(\".*\", regex=True, source=\"community\")\n    return [collection.get(\"id\", None) for collection in collections]\n</code></pre>"},{"location":"datasets/#geemap.datasets.get_data_csv","title":"<code>get_data_csv()</code>","text":"<p>Gets the file path to the CSV file containing the information about the Earth Engien Data Catalog.</p> <p>Returns:</p> Type Description <code>str</code> <p>File path to the CSV file.</p> Source code in <code>geemap/datasets.py</code> <pre><code>def get_data_csv():\n\"\"\"Gets the file path to the CSV file containing the information about the Earth Engien Data Catalog.\n\n    Returns:\n        str: File path to the CSV file.\n    \"\"\"\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    template_dir = os.path.join(pkg_dir, \"data/template\")\n    data_csv = os.path.join(template_dir, \"ee_data_catalog.csv\")\n    return data_csv\n</code></pre>"},{"location":"datasets/#geemap.datasets.get_data_dict","title":"<code>get_data_dict()</code>","text":"<p>Gets the Earth Engine Data Catalog as a nested dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The nested dictionary containing the information about the Earth Engine Data Catalog.</p> Source code in <code>geemap/datasets.py</code> <pre><code>def get_data_dict():\n\"\"\"Gets the Earth Engine Data Catalog as a nested dictionary.\n\n    Returns:\n        dict: The nested dictionary containing the information about the Earth Engine Data Catalog.\n    \"\"\"\n    data_dict = {}\n    datasets = get_data_list()\n\n    for dataset in datasets:\n        tree_dict = {}\n        items = dataset.split(\"/\")\n        for index, key in enumerate(reversed(items)):\n            if index == 0:\n                tree_dict = {key: dataset}\n            else:\n                tree_dict = {key: tree_dict}\n\n        data_dict = merge_dict(data_dict, tree_dict)\n        data_dict[dataset.replace(\"/\", \"_\")] = dataset\n\n    return data_dict\n</code></pre>"},{"location":"datasets/#geemap.datasets.get_data_list","title":"<code>get_data_list()</code>","text":"<p>Gets a list of Earth Engine datasets.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of dataset ids.</p> Source code in <code>geemap/datasets.py</code> <pre><code>def get_data_list():\n\"\"\"Gets a list of Earth Engine datasets.\n\n    Returns:\n        list: The list of dataset ids.\n    \"\"\"\n\n    datasets = get_ee_stac_list()\n    extra_datasets = get_geemap_data_list()\n    community_datasets = get_community_data_list()\n\n    return datasets + extra_datasets + community_datasets\n</code></pre>"},{"location":"datasets/#geemap.datasets.get_ee_stac_list","title":"<code>get_ee_stac_list()</code>","text":"<p>Gets the STAC list of the Earth Engine Data Catalog.</p> <p>Exceptions:</p> Type Description <code>Exception</code> <p>If the JSON file fails to download.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of Earth Engine asset IDs.</p> Source code in <code>geemap/datasets.py</code> <pre><code>def get_ee_stac_list():\n\"\"\"Gets the STAC list of the Earth Engine Data Catalog.\n\n    Raises:\n        Exception: If the JSON file fails to download.\n\n    Returns:\n        list: The list of Earth Engine asset IDs.\n    \"\"\"\n    try:\n        stac_url = \"https://raw.githubusercontent.com/samapriya/Earth-Engine-Datasets-List/master/gee_catalog.json\"\n\n        datasets = []\n        with urllib.request.urlopen(stac_url) as url:\n            data = json.loads(url.read().decode())\n            datasets = [item[\"id\"] for item in data]\n\n        return datasets\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"datasets/#geemap.datasets.get_geemap_data_list","title":"<code>get_geemap_data_list()</code>","text":"<p>Gets the list of the public datasets from GEE users.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of public datasets from GEE users.</p> Source code in <code>geemap/datasets.py</code> <pre><code>def get_geemap_data_list():\n\"\"\"Gets the list of the public datasets from GEE users.\n\n    Returns:\n        list: The list of public datasets from GEE users.\n    \"\"\"\n    extra_ids = [\n        \"countries\",\n        \"us_states\",\n        \"us_cities\",\n        \"chn_admin_line\",\n        \"chn_admin_level0\",\n        \"chn_admin_level1\",\n        \"chn_admin_level2\",\n    ]\n\n    extra_datasets = [f\"users/giswqs/public/{uid}\" for uid in extra_ids]\n    return extra_datasets\n</code></pre>"},{"location":"datasets/#geemap.datasets.get_metadata","title":"<code>get_metadata(asset_id, source='ee')</code>","text":"<p>Gets metadata about an Earth Engine asset.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>The Earth Engine asset id.</p> required <code>source</code> <code>str</code> <p>'ee', 'community' or 'all'.</p> <code>'ee'</code> <p>Exceptions:</p> Type Description <code>Exception</code> <p>If search fails.</p> Source code in <code>geemap/datasets.py</code> <pre><code>def get_metadata(asset_id, source=\"ee\"):\n\"\"\"Gets metadata about an Earth Engine asset.\n\n    Args:\n        asset_id (str): The Earth Engine asset id.\n        source (str): 'ee', 'community' or 'all'.\n\n    Raises:\n        Exception: If search fails.\n    \"\"\"\n    try:\n        ee_assets = search_ee_data(asset_id, source=source)\n        html = ee_data_html(ee_assets[0])\n        html_widget = widgets.HTML()\n        html_widget.value = html\n        display(html_widget)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"datasets/#geemap.datasets.merge_dict","title":"<code>merge_dict(dict1, dict2)</code>","text":"<p>Merges two nested dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>dict1</code> <code>dict</code> <p>The first dictionary to merge.</p> required <code>dict2</code> <code>dict</code> <p>The second dictionary to merge.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The merged dictionary.</p> Source code in <code>geemap/datasets.py</code> <pre><code>def merge_dict(dict1, dict2):\n\"\"\"Merges two nested dictionaries.\n\n    Args:\n        dict1 (dict): The first dictionary to merge.\n        dict2 (dict): The second dictionary to merge.\n\n    Returns:\n        dict: The merged dictionary.\n    \"\"\"\n    return {**dict1, **dict2}\n</code></pre>"},{"location":"datasets/#geemap.datasets.update_data_list","title":"<code>update_data_list(out_dir='.')</code>","text":"<p>Updates the Earth Engine Data Catalog dataset list.</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>str</code> <p>The output directory to save the GitHub repository. Defaults to \".\".</p> <code>'.'</code> <p>Exceptions:</p> Type Description <code>Exception</code> <p>If the CSV file fails to save.</p> Source code in <code>geemap/datasets.py</code> <pre><code>def update_data_list(out_dir=\".\"):\n\"\"\"Updates the Earth Engine Data Catalog dataset list.\n\n    Args:\n        out_dir (str, optional): The output directory to save the GitHub repository. Defaults to \".\".\n\n    Raises:\n        Exception: If the CSV file fails to save.\n    \"\"\"\n    try:\n        url = (\n            \"https://github.com/samapriya/Earth-Engine-Datasets-List/archive/master.zip\"\n        )\n        filename = \"Earth-Engine-Datasets-List-master.zip\"\n        dir_name = filename.replace(\".zip\", \"\")\n\n        out_dir = os.path.abspath(out_dir)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        download_from_url(\n            url, out_file_name=filename, out_dir=out_dir, unzip=True, verbose=False\n        )\n\n        work_dir = os.path.join(out_dir, dir_name)\n        in_csv = list(Path(work_dir).rglob(\"*.csv\"))[0]\n\n        out_csv = get_data_csv()\n\n        shutil.copyfile(in_csv, out_csv)\n        os.remove(os.path.join(out_dir, filename))\n        shutil.rmtree(os.path.join(out_dir, dir_name))\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"deck/","title":"deck module","text":""},{"location":"deck/#geemap.deck.Layer","title":"<code> Layer            (Layer)         </code>","text":"<p>Configures a deck.gl layer for rendering on a map. Parameters passed here will be specific to the particular deck.gl layer that you are choosing to use. Please see the deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers) to determine the particular parameters of your layer. You are highly encouraged to look at the examples in the pydeck documentation.</p> Source code in <code>geemap/deck.py</code> <pre><code>class Layer(pdk.Layer):\n\"\"\"Configures a deck.gl layer for rendering on a map. Parameters passed here will be specific to the particular deck.gl layer that you are choosing to use.\n    Please see the deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers) to determine the particular parameters of your layer.\n    You are highly encouraged to look at the examples in the pydeck documentation.\n    \"\"\"\n\n    def __init__(self, type, data=None, id=None, use_binary_transport=None, **kwargs):\n\"\"\"Initialize a Layer object.\n\n        Args:\n            type (str):  Type of layer to render, e.g., HexagonLayer. See deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers)\n            data (str, optional): Unique name for layer. Defaults to None.\n            id (str | dict | pandas.DataFrame, optional): Either a URL of data to load in or an array of data. Defaults to None.\n            use_binary_transport (bool, optional): Boolean indicating binary data. Defaults to None.\n        \"\"\"\n        super().__init__(type, data, id, use_binary_transport, **kwargs)\n</code></pre>"},{"location":"deck/#geemap.deck.Layer.__init__","title":"<code>__init__(self, type, data=None, id=None, use_binary_transport=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Layer object.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>Type of layer to render, e.g., HexagonLayer. See deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers)</p> required <code>data</code> <code>str</code> <p>Unique name for layer. Defaults to None.</p> <code>None</code> <code>id</code> <code>str | dict | pandas.DataFrame</code> <p>Either a URL of data to load in or an array of data. Defaults to None.</p> <code>None</code> <code>use_binary_transport</code> <code>bool</code> <p>Boolean indicating binary data. Defaults to None.</p> <code>None</code> Source code in <code>geemap/deck.py</code> <pre><code>def __init__(self, type, data=None, id=None, use_binary_transport=None, **kwargs):\n\"\"\"Initialize a Layer object.\n\n    Args:\n        type (str):  Type of layer to render, e.g., HexagonLayer. See deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers)\n        data (str, optional): Unique name for layer. Defaults to None.\n        id (str | dict | pandas.DataFrame, optional): Either a URL of data to load in or an array of data. Defaults to None.\n        use_binary_transport (bool, optional): Boolean indicating binary data. Defaults to None.\n    \"\"\"\n    super().__init__(type, data, id, use_binary_transport, **kwargs)\n</code></pre>"},{"location":"deck/#geemap.deck.Map","title":"<code> Map            (Deck)         </code>","text":"<p>The Map class inherits pydeck.Deck.</p> <p>Returns:</p> Type Description <code>object</code> <p>pydeck.Deck object.</p> Source code in <code>geemap/deck.py</code> <pre><code>class Map(pdk.Deck):\n\"\"\"The Map class inherits pydeck.Deck.\n\n    Returns:\n        object: pydeck.Deck object.\n    \"\"\"\n\n    def __init__(self, center=(20, 0), zoom=1.2, height=800, width=None, **kwargs):\n\"\"\"Initialize a Map object.\n\n        Args:\n            center (tuple, optional): Center of the map in the format of (lat, lon). Defaults to (20, 0).\n            zoom (int, optional): The map zoom level. Defaults to 1.2.\n            height (int, optional): The map height. Note that the height has no effect in Jupyter notebook. Only works for streamlit. Defaults to 800.\n            width (int, optional): The map width. Note that the height has no effect in Jupyter notebook. Only works for streamlit. Defaults to None.\n        \"\"\"\n        # Authenticates Earth Engine and initializes an Earth Engine session\n        if \"ee_initialize\" not in kwargs.keys():\n            kwargs[\"ee_initialize\"] = True\n\n        if kwargs[\"ee_initialize\"]:\n            ee_initialize()\n\n        kwargs.pop(\"ee_initialize\")\n\n        if \"initial_view_state\" not in kwargs:\n            kwargs[\"initial_view_state\"] = pdk.ViewState(\n                latitude=center[0],\n                longitude=center[1],\n                zoom=zoom,\n                height=height,\n                width=width,\n            )\n\n        if \"map_style\" not in kwargs:\n            kwargs[\"map_style\"] = \"light\"\n\n        super().__init__(**kwargs)\n\n    def add_layer(self, layer, layer_name=None, **kwargs):\n\"\"\"Add a layer to the map.\n\n        Args:\n            layer (pydeck.Layer): A pydeck Layer object.\n        \"\"\"\n\n        try:\n            if isinstance(layer, str) and layer.startswith(\"http\"):\n                pdk.settings.custom_libraries = [\n                    {\n                        \"libraryName\": \"MyTileLayerLibrary\",\n                        \"resourceUri\": \"https://cdn.jsdelivr.net/gh/giswqs/pydeck_myTileLayer@master/dist/bundle.js\",\n                    }\n                ]\n                layer = pdk.Layer(\"MyTileLayer\", layer, id=layer_name)\n\n            self.layers.append(layer)\n        except Exception as e:\n            raise Exception(e)\n\n    def add_ee_layer(\n        self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs\n    ):\n\"\"\"Adds a given EE object to the map as a layer.\n\n        Args:\n            ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n            vis_params (dict, optional): The visualization parameters. Defaults to {}.\n            name (str, optional): The name of the layer. Defaults to 'Layer N'.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n        \"\"\"\n        import ee\n        from box import Box\n\n        image = None\n\n        if vis_params is None:\n            vis_params = {}\n\n        if name is None:\n            layer_count = len(self.layers)\n            name = \"Layer \" + str(layer_count + 1)\n\n        if (\n            not isinstance(ee_object, ee.Image)\n            and not isinstance(ee_object, ee.ImageCollection)\n            and not isinstance(ee_object, ee.FeatureCollection)\n            and not isinstance(ee_object, ee.Feature)\n            and not isinstance(ee_object, ee.Geometry)\n        ):\n            err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n            raise AttributeError(err_str)\n\n        if (\n            isinstance(ee_object, ee.geometry.Geometry)\n            or isinstance(ee_object, ee.feature.Feature)\n            or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n        ):\n            features = ee.FeatureCollection(ee_object)\n\n            width = 2\n\n            if \"width\" in vis_params:\n                width = vis_params[\"width\"]\n\n            color = \"000000\"\n\n            if \"color\" in vis_params:\n                color = vis_params[\"color\"]\n\n            image_fill = features.style(**{\"fillColor\": color}).updateMask(\n                ee.Image.constant(0.5)\n            )\n            image_outline = features.style(\n                **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n            )\n\n            image = image_fill.blend(image_outline)\n        elif isinstance(ee_object, ee.image.Image):\n            image = ee_object\n        elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n            image = ee_object.mosaic()\n\n        if \"palette\" in vis_params:\n            if isinstance(vis_params[\"palette\"], tuple):\n                vis_params[\"palette\"] = list(vis_params[\"palette\"])\n            if isinstance(vis_params[\"palette\"], Box):\n                try:\n                    vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n                except Exception as e:\n                    print(\"The provided palette is invalid.\")\n                    raise Exception(e)\n            elif isinstance(vis_params[\"palette\"], str):\n                vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n            elif not isinstance(vis_params[\"palette\"], list):\n                raise ValueError(\n                    \"The palette must be a list of colors or a string or a Box object.\"\n                )\n\n        map_id_dict = ee.Image(image).getMapId(vis_params)\n        url = map_id_dict[\"tile_fetcher\"].url_format\n        self.add_layer(url, layer_name=name, **kwargs)\n\n    addLayer = add_ee_layer\n\n    def add_basemap(self, basemap=\"HYBRID\"):\n\"\"\"Adds a basemap to the map.\n\n        Args:\n            basemap (str): Can be one of string from pydeck_basemaps. Defaults to 'HYBRID'.\n        \"\"\"\n        import xyzservices\n\n        try:\n            if isinstance(basemap, xyzservices.TileProvider):\n                name = basemap.name\n                url = basemap.build_url()\n                self.add_layer(url, name)\n\n            elif basemap in basemaps:\n                pdk.settings.custom_libraries = [\n                    {\n                        \"libraryName\": \"MyTileLayerLibrary\",\n                        \"resourceUri\": \"https://cdn.jsdelivr.net/gh/giswqs/pydeck_myTileLayer@master/dist/bundle.js\",\n                    }\n                ]\n                layer = pdk.Layer(\"MyTileLayer\", basemaps[basemap].url, basemap)\n\n                self.add_layer(layer)\n\n            else:\n                print(\n                    \"Basemap can only be one of the following:\\n  {}\".format(\n                        \"\\n  \".join(basemaps.keys())\n                    )\n                )\n\n        except Exception:\n            raise ValueError(\n                \"Basemap can only be one of the following:\\n  {}\".format(\n                    \"\\n  \".join(basemaps.keys())\n                )\n            )\n\n    def add_gdf(self, gdf, layer_name=None, random_color_column=None, **kwargs):\n\"\"\"Adds a GeoPandas GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoPandas.GeoDataFrame): The GeoPandas GeoDataFrame to add to the map.\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            TypeError: gdf must be a GeoPandas GeoDataFrame.\n        \"\"\"\n\n        try:\n            import geopandas as gpd\n\n            if not isinstance(gdf, gpd.GeoDataFrame):\n                raise TypeError(\"gdf must be a GeoPandas GeoDataFrame.\")\n\n            if layer_name is None:\n                layer_name = \"layer_\" + random_string(3)\n\n            if \"pickable\" not in kwargs:\n                kwargs[\"pickable\"] = True\n            if \"opacity\" not in kwargs:\n                kwargs[\"opacity\"] = 0.5\n            if \"stroked\" not in kwargs:\n                kwargs[\"stroked\"] = True\n            if \"filled\" not in kwargs:\n                kwargs[\"filled\"] = True\n            if \"extruded\" not in kwargs:\n                kwargs[\"extruded\"] = False\n            if \"wireframe\" not in kwargs:\n                kwargs[\"wireframe\"] = True\n            if \"get_line_color\" not in kwargs:\n                kwargs[\"get_line_color\"] = [0, 0, 0]\n            if \"get_line_width\" not in kwargs:\n                kwargs[\"get_line_width\"] = 2\n            if \"line_width_min_pixels\" not in kwargs:\n                kwargs[\"line_width_min_pixels\"] = 1\n\n            if random_color_column is not None:\n                if random_color_column not in gdf.columns.values.tolist():\n                    raise ValueError(\n                        \"The random_color_column provided does not exist in the vector file.\"\n                    )\n                color_lookup = pdk.data_utils.assign_random_colors(\n                    gdf[random_color_column]\n                )\n                gdf[\"color\"] = gdf.apply(\n                    lambda row: color_lookup.get(row[random_color_column]), axis=1\n                )\n                kwargs[\"get_fill_color\"] = \"color\"\n\n            layer = pdk.Layer(\n                \"GeoJsonLayer\",\n                gdf,\n                id=layer_name,\n                **kwargs,\n            )\n            self.add_layer(layer)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_vector(self, filename, layer_name=None, random_color_column=None, **kwargs):\n\"\"\"Adds a vector file to the map.\n\n        Args:\n            filename (str): The input file path to the vector dataset.\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided vector file could not be found.\n        \"\"\"\n\n        try:\n            import geopandas as gpd\n\n            if not filename.startswith(\"http\"):\n                filename = os.path.abspath(filename)\n                if filename.endswith(\".zip\"):\n                    filename = \"zip://\" + filename\n\n            if filename.endswith(\".kml\"):\n                gpd.io.file.fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n                gdf = gpd.read_file(filename, driver=\"KML\")\n            else:\n                gdf = gpd.read_file(filename)\n\n            self.add_gdf(gdf, layer_name, random_color_column, **kwargs)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_geojson(\n        self, filename, layer_name=None, random_color_column=None, **kwargs\n    ):\n\"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            filename (str): The input file path to the vector dataset.\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided vector file could not be found.\n        \"\"\"\n        self.add_vector(filename, layer_name, random_color_column, **kwargs)\n\n    def add_shp(self, filename, layer_name=None, random_color_column=None, **kwargs):\n\"\"\"Adds a shapefile to the map.\n\n        Args:\n            filename (str): The input file path to the vector dataset.\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided vector file could not be found.\n        \"\"\"\n        self.add_vector(filename, layer_name, random_color_column, **kwargs)\n\n    def add_kml(self, filename, layer_name=None, random_color_column=None, **kwargs):\n\"\"\"Adds a KML file to the map.\n\n        Args:\n            filename (str): The input file path to the vector dataset.\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided vector file could not be found.\n        \"\"\"\n        self.add_vector(filename, layer_name, random_color_column, **kwargs)\n</code></pre>"},{"location":"deck/#geemap.deck.Map.__init__","title":"<code>__init__(self, center=(20, 0), zoom=1.2, height=800, width=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>Center of the map in the format of (lat, lon). Defaults to (20, 0).</p> <code>(20, 0)</code> <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to 1.2.</p> <code>1.2</code> <code>height</code> <code>int</code> <p>The map height. Note that the height has no effect in Jupyter notebook. Only works for streamlit. Defaults to 800.</p> <code>800</code> <code>width</code> <code>int</code> <p>The map width. Note that the height has no effect in Jupyter notebook. Only works for streamlit. Defaults to None.</p> <code>None</code> Source code in <code>geemap/deck.py</code> <pre><code>def __init__(self, center=(20, 0), zoom=1.2, height=800, width=None, **kwargs):\n\"\"\"Initialize a Map object.\n\n    Args:\n        center (tuple, optional): Center of the map in the format of (lat, lon). Defaults to (20, 0).\n        zoom (int, optional): The map zoom level. Defaults to 1.2.\n        height (int, optional): The map height. Note that the height has no effect in Jupyter notebook. Only works for streamlit. Defaults to 800.\n        width (int, optional): The map width. Note that the height has no effect in Jupyter notebook. Only works for streamlit. Defaults to None.\n    \"\"\"\n    # Authenticates Earth Engine and initializes an Earth Engine session\n    if \"ee_initialize\" not in kwargs.keys():\n        kwargs[\"ee_initialize\"] = True\n\n    if kwargs[\"ee_initialize\"]:\n        ee_initialize()\n\n    kwargs.pop(\"ee_initialize\")\n\n    if \"initial_view_state\" not in kwargs:\n        kwargs[\"initial_view_state\"] = pdk.ViewState(\n            latitude=center[0],\n            longitude=center[1],\n            zoom=zoom,\n            height=height,\n            width=width,\n        )\n\n    if \"map_style\" not in kwargs:\n        kwargs[\"map_style\"] = \"light\"\n\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"deck/#geemap.deck.Map.addLayer","title":"<code>addLayer(self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs)</code>","text":"<p>Adds a given EE object to the map as a layer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer N'.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/deck.py</code> <pre><code>def add_ee_layer(\n    self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs\n):\n\"\"\"Adds a given EE object to the map as a layer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer N'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n    import ee\n    from box import Box\n\n    image = None\n\n    if vis_params is None:\n        vis_params = {}\n\n    if name is None:\n        layer_count = len(self.layers)\n        name = \"Layer \" + str(layer_count + 1)\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], tuple):\n            vis_params[\"palette\"] = list(vis_params[\"palette\"])\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n    url = map_id_dict[\"tile_fetcher\"].url_format\n    self.add_layer(url, layer_name=name, **kwargs)\n</code></pre>"},{"location":"deck/#geemap.deck.Map.add_basemap","title":"<code>add_basemap(self, basemap='HYBRID')</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Can be one of string from pydeck_basemaps. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> Source code in <code>geemap/deck.py</code> <pre><code>def add_basemap(self, basemap=\"HYBRID\"):\n\"\"\"Adds a basemap to the map.\n\n    Args:\n        basemap (str): Can be one of string from pydeck_basemaps. Defaults to 'HYBRID'.\n    \"\"\"\n    import xyzservices\n\n    try:\n        if isinstance(basemap, xyzservices.TileProvider):\n            name = basemap.name\n            url = basemap.build_url()\n            self.add_layer(url, name)\n\n        elif basemap in basemaps:\n            pdk.settings.custom_libraries = [\n                {\n                    \"libraryName\": \"MyTileLayerLibrary\",\n                    \"resourceUri\": \"https://cdn.jsdelivr.net/gh/giswqs/pydeck_myTileLayer@master/dist/bundle.js\",\n                }\n            ]\n            layer = pdk.Layer(\"MyTileLayer\", basemaps[basemap].url, basemap)\n\n            self.add_layer(layer)\n\n        else:\n            print(\n                \"Basemap can only be one of the following:\\n  {}\".format(\n                    \"\\n  \".join(basemaps.keys())\n                )\n            )\n\n    except Exception:\n        raise ValueError(\n            \"Basemap can only be one of the following:\\n  {}\".format(\n                \"\\n  \".join(basemaps.keys())\n            )\n        )\n</code></pre>"},{"location":"deck/#geemap.deck.Map.add_ee_layer","title":"<code>add_ee_layer(self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs)</code>","text":"<p>Adds a given EE object to the map as a layer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer N'.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/deck.py</code> <pre><code>def add_ee_layer(\n    self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs\n):\n\"\"\"Adds a given EE object to the map as a layer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer N'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n    import ee\n    from box import Box\n\n    image = None\n\n    if vis_params is None:\n        vis_params = {}\n\n    if name is None:\n        layer_count = len(self.layers)\n        name = \"Layer \" + str(layer_count + 1)\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], tuple):\n            vis_params[\"palette\"] = list(vis_params[\"palette\"])\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n    url = map_id_dict[\"tile_fetcher\"].url_format\n    self.add_layer(url, layer_name=name, **kwargs)\n</code></pre>"},{"location":"deck/#geemap.deck.Map.add_gdf","title":"<code>add_gdf(self, gdf, layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a GeoPandas GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoPandas.GeoDataFrame</code> <p>The GeoPandas GeoDataFrame to add to the map.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>gdf must be a GeoPandas GeoDataFrame.</p> Source code in <code>geemap/deck.py</code> <pre><code>def add_gdf(self, gdf, layer_name=None, random_color_column=None, **kwargs):\n\"\"\"Adds a GeoPandas GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoPandas.GeoDataFrame): The GeoPandas GeoDataFrame to add to the map.\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        TypeError: gdf must be a GeoPandas GeoDataFrame.\n    \"\"\"\n\n    try:\n        import geopandas as gpd\n\n        if not isinstance(gdf, gpd.GeoDataFrame):\n            raise TypeError(\"gdf must be a GeoPandas GeoDataFrame.\")\n\n        if layer_name is None:\n            layer_name = \"layer_\" + random_string(3)\n\n        if \"pickable\" not in kwargs:\n            kwargs[\"pickable\"] = True\n        if \"opacity\" not in kwargs:\n            kwargs[\"opacity\"] = 0.5\n        if \"stroked\" not in kwargs:\n            kwargs[\"stroked\"] = True\n        if \"filled\" not in kwargs:\n            kwargs[\"filled\"] = True\n        if \"extruded\" not in kwargs:\n            kwargs[\"extruded\"] = False\n        if \"wireframe\" not in kwargs:\n            kwargs[\"wireframe\"] = True\n        if \"get_line_color\" not in kwargs:\n            kwargs[\"get_line_color\"] = [0, 0, 0]\n        if \"get_line_width\" not in kwargs:\n            kwargs[\"get_line_width\"] = 2\n        if \"line_width_min_pixels\" not in kwargs:\n            kwargs[\"line_width_min_pixels\"] = 1\n\n        if random_color_column is not None:\n            if random_color_column not in gdf.columns.values.tolist():\n                raise ValueError(\n                    \"The random_color_column provided does not exist in the vector file.\"\n                )\n            color_lookup = pdk.data_utils.assign_random_colors(\n                gdf[random_color_column]\n            )\n            gdf[\"color\"] = gdf.apply(\n                lambda row: color_lookup.get(row[random_color_column]), axis=1\n            )\n            kwargs[\"get_fill_color\"] = \"color\"\n\n        layer = pdk.Layer(\n            \"GeoJsonLayer\",\n            gdf,\n            id=layer_name,\n            **kwargs,\n        )\n        self.add_layer(layer)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"deck/#geemap.deck.Map.add_geojson","title":"<code>add_geojson(self, filename, layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path to the vector dataset.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided vector file could not be found.</p> Source code in <code>geemap/deck.py</code> <pre><code>def add_geojson(\n    self, filename, layer_name=None, random_color_column=None, **kwargs\n):\n\"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        filename (str): The input file path to the vector dataset.\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided vector file could not be found.\n    \"\"\"\n    self.add_vector(filename, layer_name, random_color_column, **kwargs)\n</code></pre>"},{"location":"deck/#geemap.deck.Map.add_kml","title":"<code>add_kml(self, filename, layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a KML file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path to the vector dataset.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided vector file could not be found.</p> Source code in <code>geemap/deck.py</code> <pre><code>def add_kml(self, filename, layer_name=None, random_color_column=None, **kwargs):\n\"\"\"Adds a KML file to the map.\n\n    Args:\n        filename (str): The input file path to the vector dataset.\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided vector file could not be found.\n    \"\"\"\n    self.add_vector(filename, layer_name, random_color_column, **kwargs)\n</code></pre>"},{"location":"deck/#geemap.deck.Map.add_layer","title":"<code>add_layer(self, layer, layer_name=None, **kwargs)</code>","text":"<p>Add a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>pydeck.Layer</code> <p>A pydeck Layer object.</p> required Source code in <code>geemap/deck.py</code> <pre><code>def add_layer(self, layer, layer_name=None, **kwargs):\n\"\"\"Add a layer to the map.\n\n    Args:\n        layer (pydeck.Layer): A pydeck Layer object.\n    \"\"\"\n\n    try:\n        if isinstance(layer, str) and layer.startswith(\"http\"):\n            pdk.settings.custom_libraries = [\n                {\n                    \"libraryName\": \"MyTileLayerLibrary\",\n                    \"resourceUri\": \"https://cdn.jsdelivr.net/gh/giswqs/pydeck_myTileLayer@master/dist/bundle.js\",\n                }\n            ]\n            layer = pdk.Layer(\"MyTileLayer\", layer, id=layer_name)\n\n        self.layers.append(layer)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"deck/#geemap.deck.Map.add_shp","title":"<code>add_shp(self, filename, layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path to the vector dataset.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided vector file could not be found.</p> Source code in <code>geemap/deck.py</code> <pre><code>def add_shp(self, filename, layer_name=None, random_color_column=None, **kwargs):\n\"\"\"Adds a shapefile to the map.\n\n    Args:\n        filename (str): The input file path to the vector dataset.\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided vector file could not be found.\n    \"\"\"\n    self.add_vector(filename, layer_name, random_color_column, **kwargs)\n</code></pre>"},{"location":"deck/#geemap.deck.Map.add_vector","title":"<code>add_vector(self, filename, layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a vector file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path to the vector dataset.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided vector file could not be found.</p> Source code in <code>geemap/deck.py</code> <pre><code>def add_vector(self, filename, layer_name=None, random_color_column=None, **kwargs):\n\"\"\"Adds a vector file to the map.\n\n    Args:\n        filename (str): The input file path to the vector dataset.\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided vector file could not be found.\n    \"\"\"\n\n    try:\n        import geopandas as gpd\n\n        if not filename.startswith(\"http\"):\n            filename = os.path.abspath(filename)\n            if filename.endswith(\".zip\"):\n                filename = \"zip://\" + filename\n\n        if filename.endswith(\".kml\"):\n            gpd.io.file.fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n            gdf = gpd.read_file(filename, driver=\"KML\")\n        else:\n            gdf = gpd.read_file(filename)\n\n        self.add_gdf(gdf, layer_name, random_color_column, **kwargs)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"examples/","title":"examples module","text":""},{"location":"examples/#geemap.examples.get_ee_path","title":"<code>get_ee_path(name)</code>","text":"<p>Get the Earth Engine asset ID of an example dataset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset, such as contents, countries, us_cities, us_states, china, CONUS_HU8, chn_admin_level0, chn_admin_level1, chn_admin_level2, chn_admin_line</p> required <p>Returns:</p> Type Description <code>str</code> <p>The Earth Engine asset ID of the dataset.</p> Source code in <code>geemap/examples/__init__.py</code> <pre><code>def get_ee_path(name):\n\"\"\"Get the Earth Engine asset ID of an example dataset.\n\n    Args:\n        name (str): The name of the dataset, such as contents, countries, us_cities, us_states,\n            china, CONUS_HU8, chn_admin_level0, chn_admin_level1, chn_admin_level2, chn_admin_line\n\n    Returns:\n        str: The Earth Engine asset ID of the dataset.\n    \"\"\"\n    return f\"{'users/giswqs/public/'}{name}\"\n</code></pre>"},{"location":"examples/#geemap.examples.get_links","title":"<code>get_links()</code>","text":"<p>Get a list of HTTP URLs to the example datasets.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of HTTP URLs to the example datasets.</p> Source code in <code>geemap/examples/__init__.py</code> <pre><code>def get_links():\n\"\"\"Get a list of HTTP URLs to the example datasets.\n\n    Returns:\n        list: A list of HTTP URLs to the example datasets.\n    \"\"\"\n\n    return list(datasets.values())\n</code></pre>"},{"location":"examples/#geemap.examples.get_names","title":"<code>get_names()</code>","text":"<p>Get a list of names of the example datasets.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of names of the example datasets.</p> Source code in <code>geemap/examples/__init__.py</code> <pre><code>def get_names():\n\"\"\"Get a list of names of the example datasets.\n\n    Returns:\n        list: A list of names of the example datasets.\n    \"\"\"\n\n    return list(datasets.keys())\n</code></pre>"},{"location":"examples/#geemap.examples.get_path","title":"<code>get_path(name)</code>","text":"<p>Get the HTTP URL to an example dataset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the dataset name is not found.</p> <p>Returns:</p> Type Description <code>str</code> <p>The HTTP URL to the dataset.</p> Source code in <code>geemap/examples/__init__.py</code> <pre><code>def get_path(name):\n\"\"\"Get the HTTP URL to an example dataset.\n\n    Args:\n        name (str): The name of the dataset.\n\n    Raises:\n        ValueError: If the dataset name is not found.\n\n    Returns:\n        str: The HTTP URL to the dataset.\n    \"\"\"\n    if name in datasets:\n        return datasets[name]\n    else:\n        raise ValueError(\n            f\"{name} not found in example datasets. It must be one of {list(datasets.keys())}\"\n        )\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-do-i-report-an-issue-or-make-a-feature-request","title":"How do I report an issue or make a feature request","text":"<p>Please go to https://github.com/gee-community/geemap/issues.</p>"},{"location":"faq/#how-do-i-cite-geemap-in-publications","title":"How do I cite geemap in publications","text":"<p>Wu, Q., (2020). geemap: A Python package for interactive mapping with Google Earth Engine. The Journal of Open Source Software, 5(51), 2305. https://doi.org/10.21105/joss.02305</p> <pre><code>Bibtex:\n@article{wu2020geemap,\n    title={geemap: A Python package for interactive mapping with Google Earth Engine},\n    author={Wu, Qiusheng},\n    journal={Journal of Open Source Software},\n    volume={5},\n    number={51},\n    pages={2305},\n    year={2020}\n}\n</code></pre>"},{"location":"faq/#why-the-interactive-map-does-not-show-up","title":"Why the interactive map does not show up","text":"<p>If the interactive map does not show up on Jupyter notebook and JupyterLab, it is probably because the ipyleaflet extentsion is not installed properly. For Jupyter notebook, try running the following two commands within your geemap conda environment:</p> <pre><code>jupyter nbextension install --py --symlink --sys-prefix ipyleaflet\njupyter nbextension enable --py --sys-prefix ipyleaflet\n</code></pre> <p>For JupyterLab, try running the following command within your geemap conda environment:</p> <pre><code>jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter-leaflet\n</code></pre>"},{"location":"faq/#how-to-use-geemap-in-countries-where-google-services-are-blocked","title":"How to use geemap in countries where Google Services are blocked","text":"<p>If you are trying to use geemap in a country where Google Services are blocked (e.g., China), you will need a VPN. Use <code>geemap.set_proxy(port=your-port-number)</code> to connect to Earth Engine servers. Otherwise, you might encounter a connection timeout issue.</p> <pre><code>import geemap\ngeemap.set_proxy(port=your-port-number)\nMap = geemap.Map()\nMap\n</code></pre> <p></p>"},{"location":"foliumap/","title":"foliumap module","text":"<p>This module extends the folium Map class. It is designed to be used in Google Colab, as Google Colab currently does not support ipyleaflet.</p>"},{"location":"foliumap/#geemap.foliumap.CustomControl","title":"<code> CustomControl            (MacroElement)         </code>","text":"<p>Put any HTML on the map as a Leaflet Control. Adopted from https://github.com/python-visualization/folium/pull/1662</p> Source code in <code>geemap/foliumap.py</code> <pre><code>class CustomControl(MacroElement):\n\"\"\"Put any HTML on the map as a Leaflet Control.\n    Adopted from https://github.com/python-visualization/folium/pull/1662\n\n    \"\"\"\n\n    _template = Template(\n\"\"\"\n        {% macro script(this, kwargs) %}\n        L.Control.CustomControl = L.Control.extend({\n            onAdd: function(map) {\n                let div = L.DomUtil.create('div');\n                div.innerHTML = `{{ this.html }}`;\n                return div;\n            },\n            onRemove: function(map) {\n                // Nothing to do here\n            }\n        });\n        L.control.customControl = function(opts) {\n            return new L.Control.CustomControl(opts);\n        }\n        L.control.customControl(\n            { position: \"{{ this.position }}\" }\n        ).addTo({{ this._parent.get_name() }});\n        {% endmacro %}\n    \"\"\"\n    )\n\n    def __init__(self, html, position=\"bottomleft\"):\n        def escape_backticks(text):\n\"\"\"Escape backticks so text can be used in a JS template.\"\"\"\n            import re\n\n            return re.sub(r\"(?&lt;!\\\\)`\", r\"\\`\", text)\n\n        super().__init__()\n        self.html = escape_backticks(html)\n        self.position = position\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.FloatText","title":"<code> FloatText            (MacroElement)         </code>","text":"<p>Adds a floating image in HTML canvas on top of the map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>class FloatText(MacroElement):\n\"\"\"Adds a floating image in HTML canvas on top of the map.\"\"\"\n\n    _template = Template(\n\"\"\"\n            {% macro header(this,kwargs) %}\n                &lt;style&gt;\n                    #{{this.get_name()}} {\n                        position:absolute;\n                        bottom:{{this.bottom}}%;\n                        left:{{this.left}}%;\n                        }\n                &lt;/style&gt;\n            {% endmacro %}\n\n            {% macro html(this, kwargs) %}\n\n            &lt;!doctype html&gt;\n            &lt;html lang=\"en\"&gt;\n            &lt;head&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n\n            &lt;div id='{{this.get_name()}}' class='{{this.get_name()}}'\n                style='position: absolute; z-index:9999; border:2px solid grey; background-color:rgba(255, 255, 255, 0.8);\n                border-radius:5px; padding: 5px; font-size:14px; '&gt;\n\n            &lt;div class='text'&gt;{{this.text}}&lt;/div&gt;\n            &lt;/div&gt;\n\n            &lt;/body&gt;\n            &lt;/html&gt;\n\n            &lt;style type='text/css'&gt;\n            .{{this.get_name()}} .text {\n                text-align: left;\n                margin-bottom: 0px;\n                font-size: 90%;\n                float: left;\n                }\n            &lt;/style&gt;\n            {% endmacro %}\n            \"\"\"\n    )\n\n    def __init__(self, text, bottom=75, left=75):\n        super(FloatText, self).__init__()\n        self._name = \"FloatText\"\n        self.text = text\n        self.bottom = bottom\n        self.left = left\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map","title":"<code> Map            (Map)         </code>","text":"<p>The Map class inherits from folium.Map. By default, the Map will add Google Maps as the basemap. Set add_google_map = False to use OpenStreetMap as the basemap.</p> <p>Returns:</p> Type Description <code>object</code> <p>folium map object.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>class Map(folium.Map):\n\"\"\"The Map class inherits from folium.Map. By default, the Map will add Google Maps as the basemap. Set add_google_map = False to use OpenStreetMap as the basemap.\n\n    Returns:\n        object: folium map object.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        import logging\n\n        logging.getLogger(\"googleapiclient.discovery_cache\").setLevel(logging.ERROR)\n\n        if \"ee_initialize\" not in kwargs.keys():\n            kwargs[\"ee_initialize\"] = True\n\n        if kwargs[\"ee_initialize\"]:\n            ee_initialize()\n\n        # Default map center location and zoom level\n        latlon = [20, 0]\n        zoom = 2\n\n        # Interchangeable parameters between ipyleaflet and folium\n        if \"center\" in kwargs.keys():\n            kwargs[\"location\"] = kwargs[\"center\"]\n            kwargs.pop(\"center\")\n        if \"location\" in kwargs.keys():\n            latlon = kwargs[\"location\"]\n        else:\n            kwargs[\"location\"] = latlon\n\n        if \"zoom\" in kwargs.keys():\n            kwargs[\"zoom_start\"] = kwargs[\"zoom\"]\n            kwargs.pop(\"zoom\")\n        if \"zoom_start\" in kwargs.keys():\n            zoom = kwargs[\"zoom_start\"]\n        else:\n            kwargs[\"zoom_start\"] = zoom\n        if \"max_zoom\" not in kwargs.keys():\n            kwargs[\"max_zoom\"] = 30\n\n        if \"add_google_map\" not in kwargs.keys() and \"basemap\" not in kwargs.keys():\n            kwargs[\"add_google_map\"] = True\n        if \"plugin_LatLngPopup\" not in kwargs.keys():\n            kwargs[\"plugin_LatLngPopup\"] = False\n        if \"plugin_Fullscreen\" not in kwargs.keys():\n            kwargs[\"plugin_Fullscreen\"] = True\n        if \"plugin_Draw\" not in kwargs.keys():\n            kwargs[\"plugin_Draw\"] = True\n        if \"Draw_export\" not in kwargs.keys():\n            kwargs[\"Draw_export\"] = False\n        if \"plugin_MiniMap\" not in kwargs.keys():\n            kwargs[\"plugin_MiniMap\"] = False\n        # if \"plugin_LayerControl\" not in kwargs.keys():\n        #     kwargs[\"plugin_LayerControl\"] = False\n        if \"locate_control\" not in kwargs:\n            kwargs[\"locate_control\"] = False\n        if \"search_control\" not in kwargs:\n            kwargs[\"search_control\"] = True\n        if \"scale_control\" in kwargs:\n            kwargs[\"scale\"] = kwargs[\"scale_control\"]\n            kwargs.pop(\"scale_control\")\n\n        if (\n            \"width\" in kwargs\n            and isinstance(kwargs[\"width\"], str)\n            and (\"%\" not in kwargs[\"width\"])\n        ):\n            kwargs[\"width\"] = float(kwargs[\"width\"].replace(\"px\", \"\"))\n\n        height = None\n        width = None\n\n        if \"height\" in kwargs:\n            height = kwargs.pop(\"height\")\n        else:\n            height = 600\n\n        if \"width\" in kwargs:\n            width = kwargs.pop(\"width\")\n        else:\n            width = \"100%\"\n\n        super().__init__(**kwargs)\n        self.baseclass = \"folium\"\n\n        # The number of shapes drawn by the user using the DrawControl\n        self.draw_count = 0\n        # The list of Earth Engine Geometry objects converted from geojson\n        self.draw_features = []\n        # The Earth Engine Geometry object converted from the last drawn feature\n        self.draw_last_feature = None\n        self.draw_layer = None\n        self.draw_last_json = None\n        self.draw_last_bounds = None\n        self.user_roi = None\n        self.user_rois = None\n        self.last_ee_data = None\n        self.last_ee_layer = None\n        self.search_locations = None\n        self.search_loc_marker = None\n        self.search_loc_geom = None\n\n        if (height is not None) or (width is not None):\n            f = folium.Figure(width=width, height=height)\n            self.add_to(f)\n\n        if kwargs.get(\"add_google_map\"):\n            basemaps[\"ROADMAP\"].add_to(self)\n        if kwargs.get(\"basemap\"):\n            basemaps[kwargs.get(\"basemap\")].add_to(self)\n        if kwargs.get(\"plugin_LatLngPopup\"):\n            folium.LatLngPopup().add_to(self)\n        if kwargs.get(\"plugin_Fullscreen\"):\n            plugins.Fullscreen().add_to(self)\n        if kwargs.get(\"plugin_Draw\"):\n            plugins.Draw(export=kwargs.get(\"Draw_export\")).add_to(self)\n        if kwargs.get(\"plugin_MiniMap\"):\n            plugins.MiniMap().add_to(self)\n        if kwargs.get(\"plugin_LayerControl\"):\n            folium.LayerControl().add_to(self)\n        if kwargs[\"locate_control\"]:\n            plugins.LocateControl().add_to(self)\n        if kwargs[\"search_control\"]:\n            plugins.Geocoder(collapsed=True, position=\"topleft\").add_to(self)\n\n        if \"plugin_LayerControl\" not in kwargs:\n            self.options[\"layersControl\"] = True\n        else:\n            self.options[\"layersControl\"] = kwargs[\"plugin_LayerControl\"]\n\n        self.fit_bounds([latlon, latlon], max_zoom=zoom)\n\n    def setOptions(self, mapTypeId=\"HYBRID\", styles={}, types=[]):\n\"\"\"Adds Google basemap to the map.\n\n        Args:\n            mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.\n            styles ([type], optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.\n            types ([type], optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.\n        \"\"\"\n        try:\n            basemaps[mapTypeId].add_to(self)\n        except Exception:\n            raise Exception(\n                \"Basemap can only be one of the following: {}\".format(\n                    \", \".join(basemaps.keys())\n                )\n            )\n\n    set_options = setOptions\n\n    def add_basemap(self, basemap=\"HYBRID\"):\n\"\"\"Adds a basemap to the map.\n\n        Args:\n            basemap (str, optional): Can be one of string from ee_basemaps. Defaults to 'HYBRID'.\n        \"\"\"\n        try:\n            basemaps[basemap].add_to(self)\n        except Exception:\n            raise Exception(\n                \"Basemap can only be one of the following: {}\".format(\n                    \", \".join(basemaps.keys())\n                )\n            )\n\n    def add_layer(\n        self,\n        ee_object,\n        vis_params={},\n        name=\"Layer untitled\",\n        shown=True,\n        opacity=1.0,\n        **kwargs,\n    ):\n\"\"\"Adds a given EE object to the map as a layer.\n\n        Args:\n            ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n            vis_params (dict, optional): The visualization parameters. Defaults to {}.\n            name (str, optional): The name of the layer. Defaults to 'Layer untitled'.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n        \"\"\"\n\n        from box import Box\n\n        image = None\n        if vis_params is None:\n            vis_params = {}\n\n        if (\n            not isinstance(ee_object, ee.Image)\n            and not isinstance(ee_object, ee.ImageCollection)\n            and not isinstance(ee_object, ee.FeatureCollection)\n            and not isinstance(ee_object, ee.Feature)\n            and not isinstance(ee_object, ee.Geometry)\n        ):\n            err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n            raise AttributeError(err_str)\n\n        if (\n            isinstance(ee_object, ee.geometry.Geometry)\n            or isinstance(ee_object, ee.feature.Feature)\n            or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n        ):\n            features = ee.FeatureCollection(ee_object)\n\n            width = 2\n\n            if \"width\" in vis_params:\n                width = vis_params[\"width\"]\n\n            color = \"000000\"\n\n            if \"color\" in vis_params:\n                color = vis_params[\"color\"]\n\n            image_fill = features.style(**{\"fillColor\": color}).updateMask(\n                ee.Image.constant(0.5)\n            )\n            image_outline = features.style(\n                **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n            )\n\n            image = image_fill.blend(image_outline)\n        elif isinstance(ee_object, ee.image.Image):\n            image = ee_object\n        elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n            image = ee_object.mosaic()\n\n        if \"palette\" in vis_params:\n            if isinstance(vis_params[\"palette\"], tuple):\n                vis_params[\"palette\"] = list(vis_params[\"palette\"])\n            if isinstance(vis_params[\"palette\"], Box):\n                try:\n                    vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n                except Exception as e:\n                    print(\"The provided palette is invalid.\")\n                    raise Exception(e)\n            elif isinstance(vis_params[\"palette\"], str):\n                vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n            elif not isinstance(vis_params[\"palette\"], list):\n                raise ValueError(\n                    \"The palette must be a list of colors or a string or a Box object.\"\n                )\n\n        map_id_dict = ee.Image(image).getMapId(vis_params)\n\n        # if a layer starts with a number, add \"Layer\" to name.\n        if name[0].isdigit():\n            name = \"Layer \" + name\n\n        url = map_id_dict[\"tile_fetcher\"].url_format\n        folium.raster_layers.TileLayer(\n            tiles=url,\n            attr=\"Google Earth Engine\",\n            name=name,\n            overlay=True,\n            control=True,\n            show=shown,\n            opacity=opacity,\n            max_zoom=24,\n            **kwargs,\n        ).add_to(self)\n\n        arc_add_layer(url, name, shown, opacity)\n\n    addLayer = add_layer\n\n    def _repr_mimebundle_(self, **kwargs):\n\"\"\"Adds Layer control to the map. Reference: https://ipython.readthedocs.io/en/stable/config/integrating.html#MyObject._repr_mimebundle_\"\"\"\n        if self.options[\"layersControl\"]:\n            self.add_layer_control()\n\n    def set_center(self, lon, lat, zoom=10):\n\"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n        Args:\n            lon (float): The longitude of the center, in degrees.\n            lat (float): The latitude of the center, in degrees.\n            zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10.\n        \"\"\"\n        self.fit_bounds([[lat, lon], [lat, lon]], max_zoom=zoom)\n\n        if is_arcpy():\n            arc_zoom_to_extent(lon, lat, lon, lat)\n\n    setCenter = set_center\n\n    def zoom_to_bounds(self, bounds):\n\"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n        Args:\n            bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n        \"\"\"\n        #  The folium fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def zoom_to_gdf(self, gdf):\n\"\"\"Zooms to the bounding box of a GeoPandas GeoDataFrame.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        \"\"\"\n        bounds = gdf.total_bounds\n        self.zoom_to_bounds(bounds)\n\n    def center_object(self, ee_object, zoom=None):\n\"\"\"Centers the map view on a given object.\n\n        Args:\n            ee_object (Element|Geometry): An Earth Engine object to center on a geometry, image or feature.\n            zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n        \"\"\"\n\n        maxError = 0.001\n        if isinstance(ee_object, ee.Geometry):\n            geometry = ee_object.transform(maxError=maxError)\n        else:\n            try:\n                geometry = ee_object.geometry(maxError=maxError).transform(\n                    maxError=maxError\n                )\n            except Exception:\n                raise Exception(\n                    \"ee_object must be an instance of one of ee.Geometry, ee.FeatureCollection, ee.Image, or ee.ImageCollection.\"\n                )\n\n        if zoom is not None:\n            if not isinstance(zoom, int):\n                raise Exception(\"Zoom must be an integer.\")\n            else:\n                centroid = geometry.centroid(maxError=maxError).getInfo()[\"coordinates\"]\n                lat = centroid[1]\n                lon = centroid[0]\n                self.set_center(lon, lat, zoom)\n\n                if is_arcpy():\n                    arc_zoom_to_extent(lon, lat, lon, lat)\n\n        else:\n            coordinates = geometry.bounds(maxError).getInfo()[\"coordinates\"][0]\n            x = [c[0] for c in coordinates]\n            y = [c[1] for c in coordinates]\n            xmin = min(x)\n            xmax = max(x)\n            ymin = min(y)\n            ymax = max(y)\n            bounds = [[ymin, xmin], [ymax, xmax]]\n            self.fit_bounds(bounds)\n\n            if is_arcpy():\n                arc_zoom_to_extent(xmin, ymin, xmax, ymax)\n\n    centerObject = center_object\n\n    def set_control_visibility(\n        self, layerControl=True, fullscreenControl=True, latLngPopup=True\n    ):\n\"\"\"Sets the visibility of the controls on the map.\n\n        Args:\n            layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True.\n            fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True.\n            latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.\n        \"\"\"\n        if layerControl:\n            folium.LayerControl().add_to(self)\n        if fullscreenControl:\n            plugins.Fullscreen().add_to(self)\n        if latLngPopup:\n            folium.LatLngPopup().add_to(self)\n\n    setControlVisibility = set_control_visibility\n\n    def add_layer_control(self):\n\"\"\"Adds layer control to the map.\"\"\"\n        layer_ctrl = False\n        for item in self.to_dict()[\"children\"]:\n            if item.startswith(\"layer_control\"):\n                layer_ctrl = True\n                break\n        if not layer_ctrl:\n            folium.LayerControl().add_to(self)\n\n    addLayerControl = add_layer_control\n\n    def add_marker(\n        self, location, popup=None, tooltip=None, icon=None, draggable=False, **kwargs\n    ):\n\"\"\"Adds a marker to the map. More info about marker options at https://python-visualization.github.io/folium/modules.html#folium.map.Marker.\n\n        Args:\n            location (list | tuple): The location of the marker in the format of [lat, lng].\n            popup (str, optional): The popup text. Defaults to None.\n            tooltip (str, optional): The tooltip text. Defaults to None.\n            icon (str, optional): The icon to use. Defaults to None.\n            draggable (bool, optional): Whether the marker is draggable. Defaults to False.\n        \"\"\"\n        if isinstance(location, list):\n            location = tuple(location)\n        if isinstance(location, tuple):\n            folium.Marker(\n                location=location,\n                popup=popup,\n                tooltip=tooltip,\n                icon=icon,\n                draggable=draggable,\n                **kwargs,\n            ).add_to(self)\n\n        else:\n            raise TypeError(\"The location must be a list or a tuple.\")\n\n    def add_wms_layer(\n        self,\n        url,\n        layers,\n        name=None,\n        attribution=\"\",\n        overlay=True,\n        control=True,\n        shown=True,\n        format=\"image/png\",\n        transparent=True,\n        version=\"1.1.1\",\n        styles=\"\",\n        **kwargs,\n    ):\n\"\"\"Add a WMS layer to the map.\n\n        Args:\n            url (str): The URL of the WMS web service.\n            layers (str): Comma-separated list of WMS layers to show.\n            name (str, optional): The layer name to use on the layer control. Defaults to None.\n            attribution (str, optional): The attribution of the data layer. Defaults to ''.\n            overlay (str, optional): Allows overlay. Defaults to True.\n            control (str, optional): Adds the layer to the layer control. Defaults to True.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.\n            transparent (bool, optional): Whether the layer shall allow transparency. Defaults to True.\n            version (str, optional): Version of the WMS service to use. Defaults to \"1.1.1\".\n            styles (str, optional): Comma-separated list of WMS styles. Defaults to \"\".\n        \"\"\"\n        try:\n            folium.raster_layers.WmsTileLayer(\n                url=url,\n                layers=layers,\n                name=name,\n                attr=attribution,\n                overlay=overlay,\n                control=control,\n                show=shown,\n                styles=styles,\n                fmt=format,\n                transparent=transparent,\n                version=version,\n                **kwargs,\n            ).add_to(self)\n        except Exception:\n            raise Exception(\"Failed to add the specified WMS TileLayer.\")\n\n    def add_tile_layer(\n        self,\n        tiles=\"OpenStreetMap\",\n        name=\"Untitled\",\n        attribution=\".\",\n        overlay=True,\n        control=True,\n        shown=True,\n        opacity=1.0,\n        API_key=None,\n        **kwargs,\n    ):\n\"\"\"Add a XYZ tile layer to the map.\n\n        Args:\n            tiles (str): The URL of the XYZ tile service.\n            name (str, optional): The layer name to use on the layer control. Defaults to 'Untitled'.\n            attribution (str, optional): The attribution of the data layer. Defaults to '.'.\n            overlay (str, optional): Allows overlay. Defaults to True.\n            control (str, optional): Adds the layer to the layer control. Defaults to True.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            opacity (float, optional): Sets the opacity for the layer.\n            API_key (str, optional): \u2013 API key for Cloudmade or Mapbox tiles. Defaults to True.\n        \"\"\"\n\n        if \"max_zoom\" not in kwargs:\n            kwargs[\"max_zoom\"] = 100\n        if \"max_native_zoom\" not in kwargs:\n            kwargs[\"max_native_zoom\"] = 100\n\n        try:\n            folium.raster_layers.TileLayer(\n                tiles=tiles,\n                name=name,\n                attr=attribution,\n                overlay=overlay,\n                control=control,\n                show=shown,\n                opacity=opacity,\n                API_key=API_key,\n                **kwargs,\n            ).add_to(self)\n        except Exception:\n            raise Exception(\"Failed to add the specified TileLayer.\")\n\n    def add_cog_layer(\n        self,\n        url,\n        name=\"Untitled\",\n        attribution=\".\",\n        opacity=1.0,\n        shown=True,\n        bands=None,\n        titiler_endpoint=None,\n        **kwargs,\n    ):\n\"\"\"Adds a COG TileLayer to the map.\n\n        Args:\n            url (str): The URL of the COG tile layer.\n            name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n            attribution (str, optional): The attribution to use. Defaults to '.'.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            bands (list, optional): A list of bands to use. Defaults to None.\n            titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        \"\"\"\n        tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n        bounds = cog_bounds(url, titiler_endpoint)\n        self.add_tile_layer(\n            tiles=tile_url,\n            name=name,\n            attribution=attribution,\n            opacity=opacity,\n            shown=shown,\n        )\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_cog_mosaic(self, **kwargs):\n        raise NotImplementedError(\n            \"This function is no longer supported.See https://github.com/giswqs/leafmap/issues/180.\"\n        )\n\n    def add_stac_layer(\n        self,\n        url=None,\n        collection=None,\n        item=None,\n        assets=None,\n        bands=None,\n        titiler_endpoint=None,\n        name=\"STAC Layer\",\n        attribution=\".\",\n        opacity=1.0,\n        shown=True,\n        **kwargs,\n    ):\n\"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n            collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n            item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n            assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n            bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        \"\"\"\n        tile_url = stac_tile(\n            url, collection, item, assets, bands, titiler_endpoint, **kwargs\n        )\n        bounds = stac_bounds(url, collection, item, titiler_endpoint)\n        self.add_tile_layer(\n            url=tile_url,\n            name=name,\n            attribution=attribution,\n            opacity=opacity,\n            shown=shown,\n        )\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_raster(\n        self,\n        source,\n        band=None,\n        palette=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=\"Local COG\",\n        **kwargs,\n    ):\n\"\"\"Add a local raster dataset to the map.\n\n            If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\n            running the following two lines before calling this function:\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n        Args:\n            source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n            band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n            palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to 'Local COG'.\n        \"\"\"\n\n        if in_colab_shell():\n            print(\"This add_raster() function is not supported in Colab.\")\n            return\n\n        tile_layer, tile_client = get_local_tile_layer(\n            source,\n            band=band,\n            palette=palette,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            tile_format=\"folium\",\n            layer_name=layer_name,\n            return_client=True,\n            **kwargs,\n        )\n        self.add_layer(tile_layer)\n\n        bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n        bounds = (\n            bounds[2],\n            bounds[0],\n            bounds[3],\n            bounds[1],\n        )  # [minx, miny, maxx, maxy]\n        self.zoom_to_bounds(bounds)\n\n    dd_local_tile = add_raster\n\n    def add_remote_tile(\n        self,\n        source,\n        band=None,\n        palette=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=None,\n        **kwargs,\n    ):\n\"\"\"Add a remote Cloud Optimized GeoTIFF (COG) to the map.\n\n        Args:\n            source (str): The path to the remote Cloud Optimized GeoTIFF.\n            band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n            palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to None.\n        \"\"\"\n        if isinstance(source, str) and source.startswith(\"http\"):\n            self.add_local_tile(\n                source,\n                band=band,\n                palette=palette,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attribution=attribution,\n                layer_name=layer_name,\n                **kwargs,\n            )\n        else:\n            raise Exception(\"The source must be a URL.\")\n\n    def add_heatmap(\n        self,\n        data,\n        latitude=\"latitude\",\n        longitude=\"longitude\",\n        value=\"value\",\n        name=\"Heat map\",\n        radius=25,\n        **kwargs,\n    ):\n\"\"\"Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617\n\n        Args:\n            data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/world_cities.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            value (str, optional): The column name of values. Defaults to \"value\".\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n        Raises:\n            ValueError: If data is not a list.\n        \"\"\"\n        import pandas as pd\n\n        try:\n            if isinstance(data, str):\n                df = pd.read_csv(data)\n                data = df[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, pd.DataFrame):\n                data = data[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, list):\n                pass\n            else:\n                raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n            plugins.HeatMap(data, name=name, radius=radius, **kwargs).add_to(\n                folium.FeatureGroup(name=name).add_to(self)\n            )\n        except Exception as e:\n            raise Exception(e)\n\n    def add_legend(\n        self,\n        title=\"Legend\",\n        labels=None,\n        colors=None,\n        legend_dict=None,\n        builtin_legend=None,\n        opacity=1.0,\n        position=\"bottomright\",\n        draggable=True,\n        style={},\n    ):\n\"\"\"Adds a customized legend to the map. Reference: https://bit.ly/3oV6vnH.\n            If you want to add multiple legends to the map, you need to set the `draggable` argument to False.\n\n        Args:\n            title (str, optional): Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".\n            colors (list, optional): A list of legend colors. Defaults to None.\n            labels (list, optional): A list of legend labels. Defaults to None.\n            legend_dict (dict, optional): A dictionary containing legend items as keys and color as values.\n                If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n            builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n            opacity (float, optional): The opacity of the legend. Defaults to 1.0.\n            position (str, optional): The position of the legend, can be one of the following:\n                \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n            draggable (bool, optional): If True, the legend can be dragged to a new position. Defaults to True.\n            style: Additional keyword arguments to style the legend, such as position, bottom, right, z-index,\n                border, background-color, border-radius, padding, font-size, etc. The default style is:\n                style = {\n                    'position': 'fixed',\n                    'z-index': '9999',\n                    'border': '2px solid grey',\n                    'background-color': 'rgba(255, 255, 255, 0.8)',\n                    'border-radius': '5px',\n                    'padding': '10px',\n                    'font-size': '14px',\n                    'bottom': '20px',\n                    'right': '5px'\n                }\n\n        \"\"\"\n        content = create_legend(\n            title,\n            labels,\n            colors,\n            legend_dict,\n            builtin_legend,\n            opacity,\n            position,\n            draggable,\n            style=style,\n        )\n        if draggable:\n            from branca.element import Template, MacroElement\n\n            content = (\n                '\"\"\"\\n{% macro html(this, kwargs) %}\\n'\n                + content\n                + '\\n{% endmacro %}\"\"\"'\n            )\n\n            macro = MacroElement()\n            macro._template = Template(content)\n\n            self.get_root().add_child(macro)\n        else:\n            self.add_html(content, position=position)\n\n    def add_colorbar(\n        self,\n        vis_params,\n        index=None,\n        label=\"\",\n        categorical=False,\n        step=None,\n        background_color=None,\n        **kwargs,\n    ):\n\"\"\"Add a colorbar to the map.\n\n        Args:\n            colors (list): The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)\n            vmin (int, optional): The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.\n            vmax (float, optional): The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.\n            index (list, optional):The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.\n            label (str, optional): The caption for the colormap. Defaults to \"\".\n            categorical (bool, optional): Whether or not to create a categorical colormap. Defaults to False.\n            step (int, optional): The step to split the LinearColormap into a StepColormap. Defaults to None.\n        \"\"\"\n        from box import Box\n        from branca.colormap import LinearColormap\n\n        if not isinstance(vis_params, dict):\n            raise ValueError(\"vis_params must be a dictionary.\")\n\n        if \"palette\" not in vis_params:\n            raise ValueError(\"vis_params must contain a palette.\")\n\n        if \"min\" not in vis_params:\n            vis_params[\"min\"] = 0\n        if \"max\" not in vis_params:\n            vis_params[\"max\"] = 1\n\n        colors = to_hex_colors(check_cmap(vis_params[\"palette\"]))\n        vmin = vis_params[\"min\"]\n        vmax = vis_params[\"max\"]\n\n        if isinstance(colors, Box):\n            try:\n                colors = list(colors[\"default\"])\n            except Exception as e:\n                print(\"The provided color list is invalid.\")\n                raise Exception(e)\n\n        if all(len(color) == 6 for color in colors):\n            colors = [\"#\" + color for color in colors]\n\n        colormap = LinearColormap(\n            colors=colors, index=index, vmin=vmin, vmax=vmax, caption=label\n        )\n\n        if categorical:\n            if step is not None:\n                colormap = colormap.to_step(step)\n            elif index is not None:\n                colormap = colormap.to_step(len(index) - 1)\n            else:\n                colormap = colormap.to_step(3)\n\n        if background_color is not None:\n            svg_style = (\n                \"&lt;style&gt;svg {background-color: \" + background_color + \";}&lt;/style&gt;\"\n            )\n\n            self.get_root().header.add_child(folium.Element(svg_style))\n\n        self.add_child(colormap)\n\n    add_colorbar_branca = add_colorbar\n\n    def add_colormap(\n        self,\n        width=4.0,\n        height=0.3,\n        vmin=0,\n        vmax=1.0,\n        palette=None,\n        vis_params=None,\n        cmap=\"gray\",\n        discrete=False,\n        label=None,\n        label_size=10,\n        label_weight=\"normal\",\n        tick_size=8,\n        bg_color=\"white\",\n        orientation=\"horizontal\",\n        dpi=\"figure\",\n        transparent=False,\n        position=(70, 5),\n        **kwargs,\n    ):\n\"\"\"Add a colorbar to the map. Under the hood, it uses matplotlib to generate the colorbar, save it as a png file, and add it to the map using m.add_image().\n\n        Args:\n            width (float): Width of the colorbar in inches. Default is 4.0.\n            height (float): Height of the colorbar in inches. Default is 0.3.\n            vmin (float): Minimum value of the colorbar. Default is 0.\n            vmax (float): Maximum value of the colorbar. Default is 1.0.\n            palette (list): List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.\n            vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n            cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n            discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n            label (str, optional): Label for the colorbar. Defaults to None.\n            label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n            label_weight (str, optional): Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".\n            tick_size (int, optional): Font size for the colorbar tick labels. Defaults to 10.\n            bg_color (str, optional): Background color for the colorbar. Defaults to \"white\".\n            orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n            dpi (float | str, optional): The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".\n            transparent (bool, optional): Whether to make the background transparent. Defaults to False.\n            position (tuple, optional): The position of the colormap in the format of (x, y),\n                the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).\n            **kwargs: Other keyword arguments to pass to matplotlib.pyplot.savefig().\n\n        Returns:\n            str: Path to the output image.\n        \"\"\"\n\n        colorbar = save_colorbar(\n            None,\n            width,\n            height,\n            vmin,\n            vmax,\n            palette,\n            vis_params,\n            cmap,\n            discrete,\n            label,\n            label_size,\n            label_weight,\n            tick_size,\n            bg_color,\n            orientation,\n            dpi,\n            transparent,\n            show_colorbar=False,\n            **kwargs,\n        )\n\n        self.add_image(colorbar, position=position)\n\n    def add_styled_vector(\n        self, ee_object, column, palette, layer_name=\"Untitled\", **kwargs\n    ):\n\"\"\"Adds a styled vector to the map.\n\n        Args:\n            ee_object (object): An ee.FeatureCollection.\n            column (str): The column name to use for styling.\n            palette (list | dict): The palette (e.g., list of colors or a dict containing label and color pairs) to use for styling.\n            layer_name (str, optional): The name to be used for the new layer. Defaults to \"Untitled\".\n        \"\"\"\n        styled_vector = vector_styling(ee_object, column, palette, **kwargs)\n        self.addLayer(styled_vector.style(**{\"styleProperty\": \"style\"}), {}, layer_name)\n\n    def add_shapefile(self, in_shp, layer_name=\"Untitled\", **kwargs):\n\"\"\"Adds a shapefile to the map. See https://python-visualization.github.io/folium/modules.html#folium.features.GeoJson for more info about setting style.\n\n        Args:\n            in_shp (str): The input file path to the shapefile.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n\n        Raises:\n            FileNotFoundError: The provided shapefile could not be found.\n        \"\"\"\n        in_shp = os.path.abspath(in_shp)\n        if not os.path.exists(in_shp):\n            raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n        data = shp_to_geojson(in_shp)\n\n        geo_json = folium.GeoJson(data=data, name=layer_name, **kwargs)\n        geo_json.add_to(self)\n\n    def add_geojson(\n        self,\n        in_geojson,\n        layer_name=\"Untitled\",\n        encoding=\"utf-8\",\n        info_mode=\"on_hover\",\n        fields=None,\n        **kwargs,\n    ):\n\"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            in_geojson (str): The input file path to the GeoJSON.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n            encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            fields (list, optional): The fields to be displayed in the popup. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided GeoJSON file could not be found.\n        \"\"\"\n        import json\n        import requests\n        import random\n\n        try:\n            if isinstance(in_geojson, str):\n                if in_geojson.startswith(\"http\"):\n                    in_geojson = github_raw_url(in_geojson)\n                    data = requests.get(in_geojson).json()\n                else:\n                    in_geojson = os.path.abspath(in_geojson)\n                    if not os.path.exists(in_geojson):\n                        raise FileNotFoundError(\n                            \"The provided GeoJSON file could not be found.\"\n                        )\n\n                    with open(in_geojson, encoding=encoding) as f:\n                        data = json.load(f)\n            elif isinstance(in_geojson, dict):\n                data = in_geojson\n            else:\n                raise TypeError(\"The input geojson must be a type of str or dict.\")\n        except Exception as e:\n            raise Exception(e)\n\n        # interchangeable parameters between ipyleaflet and folium.\n        if \"style_function\" not in kwargs:\n            if \"style\" in kwargs:\n                style_dict = kwargs[\"style\"]\n                if isinstance(kwargs[\"style\"], dict) and len(kwargs[\"style\"]) &gt; 0:\n                    kwargs[\"style_function\"] = lambda x: style_dict\n                kwargs.pop(\"style\")\n            else:\n                style_dict = {\n                    # \"stroke\": True,\n                    \"color\": \"#000000\",\n                    \"weight\": 1,\n                    \"opacity\": 1,\n                    # \"fill\": True,\n                    # \"fillColor\": \"#ffffff\",\n                    \"fillOpacity\": 0.1,\n                    # \"dashArray\": \"9\"\n                    # \"clickable\": True,\n                }\n                kwargs[\"style_function\"] = lambda x: style_dict\n\n        if \"style_callback\" in kwargs:\n            kwargs.pop(\"style_callback\")\n\n        if \"hover_style\" in kwargs:\n            kwargs.pop(\"hover_style\")\n\n        if \"fill_colors\" in kwargs:\n            fill_colors = kwargs[\"fill_colors\"]\n\n            def random_color(feature):\n                style_dict[\"fillColor\"] = random.choice(fill_colors)\n                return style_dict\n\n            kwargs[\"style_function\"] = random_color\n            kwargs.pop(\"fill_colors\")\n\n        if \"highlight_function\" not in kwargs:\n            kwargs[\"highlight_function\"] = lambda feat: {\n                \"weight\": 2,\n                \"fillOpacity\": 0.5,\n            }\n\n        tooltip = None\n        popup = None\n        if info_mode is not None:\n            if fields is None:\n                fields = list(data[\"features\"][0][\"properties\"].keys())\n            if info_mode == \"on_hover\":\n                tooltip = folium.GeoJsonTooltip(fields=fields)\n            elif info_mode == \"on_click\":\n                popup = folium.GeoJsonPopup(fields=fields)\n\n        geojson = folium.GeoJson(\n            data=data, name=layer_name, tooltip=tooltip, popup=popup, **kwargs\n        )\n        geojson.add_to(self)\n\n    def add_kml(\n        self, in_kml, layer_name=\"Untitled\", info_mode=\"on_hover\", fields=None, **kwargs\n    ):\n\"\"\"Adds a KML file to the map.\n\n        Args:\n            in_kml (str): The input file path to the KML.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click.\n                Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            fields (list, optional): The fields to be displayed in the popup. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided KML file could not be found.\n        \"\"\"\n\n        if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n            out_dir = os.path.abspath(\"./cache\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            download_from_url(in_kml, out_dir=out_dir, unzip=False, verbose=False)\n            in_kml = os.path.join(out_dir, os.path.basename(in_kml))\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n        else:\n            in_kml = os.path.abspath(in_kml)\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The provided KML could not be found.\")\n\n        data = kml_to_geojson(in_kml)\n\n        self.add_geojson(\n            data, layer_name=layer_name, info_mode=info_mode, fields=fields, **kwargs\n        )\n\n    def add_gdf(\n        self,\n        gdf,\n        layer_name=\"Untitled\",\n        zoom_to_layer=True,\n        info_mode=\"on_hover\",\n        fields=None,\n        **kwargs,\n    ):\n\"\"\"Adds a GeoPandas GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer.\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click.\n                Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            fields (list, optional): The fields to be displayed in the popup. Defaults to None.\n\n        \"\"\"\n\n        data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n        self.add_geojson(\n            data, layer_name=layer_name, info_mode=info_mode, fields=fields, **kwargs\n        )\n\n        if zoom_to_layer:\n            import numpy as np\n\n            bounds = gdf.to_crs(epsg=\"4326\").bounds\n            west = np.min(bounds[\"minx\"])\n            south = np.min(bounds[\"miny\"])\n            east = np.max(bounds[\"maxx\"])\n            north = np.max(bounds[\"maxy\"])\n            self.fit_bounds([[south, east], [north, west]])\n\n    def add_gdf_from_postgis(\n        self, sql, con, layer_name=\"Untitled\", zoom_to_layer=True, **kwargs\n    ):\n\"\"\"Adds a GeoPandas GeoDataFrameto the map.\n\n        Args:\n            sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n            con (sqlalchemy.engine.Engine): Active connection to the database to query.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer.\n\n        \"\"\"\n        if \"fill_colors\" in kwargs:\n            kwargs.pop(\"fill_colors\")\n        gdf = read_postgis(sql, con, **kwargs)\n        data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n        self.add_geojson(data, layer_name=layer_name, **kwargs)\n\n        if zoom_to_layer:\n            import numpy as np\n\n            bounds = gdf.to_crs(epsg=\"4326\").bounds\n            west = np.min(bounds[\"minx\"])\n            south = np.min(bounds[\"miny\"])\n            east = np.max(bounds[\"maxx\"])\n            north = np.max(bounds[\"maxy\"])\n            self.fit_bounds([[south, east], [north, west]])\n\n    def add_osm(\n        self,\n        query,\n        layer_name=\"Untitled\",\n        which_result=None,\n        by_osmid=False,\n        buffer_dist=None,\n        to_ee=False,\n        geodesic=True,\n        **kwargs,\n    ):\n\"\"\"Adds OSM data to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            to_ee (bool, optional): Whether to convert the csv to an ee.FeatureCollection.\n            geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.\n\n        \"\"\"\n\n        gdf = osm_to_gdf(\n            query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n        )\n        geojson = gdf.__geo_interface__\n\n        if to_ee:\n            fc = geojson_to_ee(geojson, geodesic=geodesic)\n            self.addLayer(fc, {}, layer_name)\n            self.centerObject(fc)\n        else:\n            self.add_geojson(geojson, layer_name=layer_name, **kwargs)\n            bounds = gdf.bounds.iloc[0]\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_osm_from_geocode(\n        self,\n        query,\n        which_result=None,\n        by_osmid=False,\n        buffer_dist=None,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM data of place(s) by name or ID to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n\n        gdf = osm_gdf_from_geocode(\n            query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n        )\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_address(\n        self,\n        address,\n        tags,\n        dist=1000,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within some distance N, S, E, W of address to the map.\n\n        Args:\n            address (str): The address to geocode and use as the central point around which to get the geometries.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            dist (int, optional): Distance in meters. Defaults to 1000.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_address(address, tags, dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_place(\n        self,\n        query,\n        tags,\n        which_result=None,\n        buffer_dist=None,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within boundaries of geocodable place(s) to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_point(\n        self,\n        center_point,\n        tags,\n        dist=1000,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within some distance N, S, E, W of a point to the map.\n\n        Args:\n            center_point (tuple): The (lat, lng) center point around which to get the geometries.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            dist (int, optional): Distance in meters. Defaults to 1000.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_point(center_point, tags, dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_polygon(\n        self,\n        polygon,\n        tags,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within boundaries of a (multi)polygon to the map.\n\n        Args:\n            polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_polygon(polygon, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_bbox(\n        self,\n        north,\n        south,\n        east,\n        west,\n        tags,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within a N, S, E, W bounding box to the map.\n\n\n        Args:\n            north (float): Northern latitude of bounding box.\n            south (float): Southern latitude of bounding box.\n            east (float): Eastern longitude of bounding box.\n            west (float): Western longitude of bounding box.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_points_from_xy(\n        self,\n        data,\n        x=\"longitude\",\n        y=\"latitude\",\n        popup=None,\n        min_width=100,\n        max_width=200,\n        layer_name=\"Marker Cluster\",\n        color_column=None,\n        marker_colors=None,\n        icon_colors=[\"white\"],\n        icon_names=[\"info\"],\n        angle=0,\n        prefix=\"fa\",\n        add_legend=True,\n        **kwargs,\n    ):\n\"\"\"Adds a marker cluster to the map.\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"longitude\".\n            y (str, optional): The column name for the y values. Defaults to \"latitude\".\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n            min_width (int, optional): The minimum width of the popup. Defaults to 100.\n            max_width (int, optional): The maximum width of the popup. Defaults to 200.\n            layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n            color_column (str, optional): The column name for the color values. Defaults to None.\n            marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n            icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n            icon_names (list, optional): A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons or https://getbootstrap.com/docs/3.3/components/?utm_source=pocket_mylist. Defaults to ['info'].\n            angle (int, optional): The angle of the icon. Defaults to 0.\n            prefix (str, optional): The prefix states the source of the icon. 'fa' for font-awesome or 'glyphicon' for bootstrap 3. Defaults to 'fa'.\n            add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n        \"\"\"\n        import pandas as pd\n\n        color_options = [\n            \"red\",\n            \"blue\",\n            \"green\",\n            \"purple\",\n            \"orange\",\n            \"darkred\",\n            \"lightred\",\n            \"beige\",\n            \"darkblue\",\n            \"darkgreen\",\n            \"cadetblue\",\n            \"darkpurple\",\n            \"white\",\n            \"pink\",\n            \"lightblue\",\n            \"lightgreen\",\n            \"gray\",\n            \"black\",\n            \"lightgray\",\n        ]\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data)\n\n        col_names = df.columns.values.tolist()\n\n        if color_column is not None and color_column not in col_names:\n            raise ValueError(\n                f\"The color column {color_column} does not exist in the dataframe.\"\n            )\n\n        if color_column is not None:\n            items = list(set(df[color_column]))\n        else:\n            items = None\n\n        if color_column is not None and marker_colors is None:\n            if len(items) &gt; len(color_options):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n                )\n            else:\n                marker_colors = color_options[: len(items)]\n        elif color_column is not None and marker_colors is not None:\n            if len(items) != len(marker_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if items is not None:\n            if len(icon_colors) == 1:\n                icon_colors = icon_colors * len(items)\n            elif len(items) != len(icon_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n            if len(icon_names) == 1:\n                icon_names = icon_names * len(items)\n            elif len(items) != len(icon_names):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if popup is None:\n            popup = col_names\n\n        if x not in col_names:\n            raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n        if y not in col_names:\n            raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n        marker_cluster = plugins.MarkerCluster(name=layer_name).add_to(self)\n\n        for row in df.itertuples():\n            html = \"\"\n            for p in popup:\n                html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(getattr(row, p)) + \"&lt;br&gt;\"\n            popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n            if items is not None:\n                index = items.index(getattr(row, color_column))\n                marker_icon = folium.Icon(\n                    color=marker_colors[index],\n                    icon_color=icon_colors[index],\n                    icon=icon_names[index],\n                    angle=angle,\n                    prefix=prefix,\n                )\n            else:\n                marker_icon = None\n\n            folium.Marker(\n                location=[getattr(row, y), getattr(row, x)],\n                popup=popup_html,\n                icon=marker_icon,\n            ).add_to(marker_cluster)\n\n        if items is not None and add_legend:\n            marker_colors = [check_color(c) for c in marker_colors]\n            self.add_legend(\n                title=color_column.title(), colors=marker_colors, labels=items\n            )\n\n    def add_circle_markers_from_xy(\n        self,\n        data,\n        x=\"longitude\",\n        y=\"latitude\",\n        radius=10,\n        popup=None,\n        tooltip=None,\n        min_width=100,\n        max_width=200,\n        **kwargs,\n    ):\n\"\"\"Adds a marker cluster to the map.\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"longitude\".\n            y (str, optional): The column name for the y values. Defaults to \"latitude\".\n            radius (int, optional): The radius of the circle. Defaults to 10.\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n            tooltip (list, optional): A list of column names to be used as the tooltip. Defaults to None.\n            min_width (int, optional): The minimum width of the popup. Defaults to 100.\n            max_width (int, optional): The maximum width of the popup. Defaults to 200.\n\n        \"\"\"\n        import pandas as pd\n\n        data = github_raw_url(data)\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data)\n\n        col_names = df.columns.values.tolist()\n\n        if \"color\" not in kwargs:\n            kwargs[\"color\"] = None\n        if \"fill\" not in kwargs:\n            kwargs[\"fill\"] = True\n        if \"fill_color\" not in kwargs:\n            kwargs[\"fill_color\"] = \"blue\"\n        if \"fill_opacity\" not in kwargs:\n            kwargs[\"fill_opacity\"] = 0.7\n\n        if popup is None:\n            popup = col_names\n\n        if not isinstance(popup, list):\n            popup = [popup]\n\n        if tooltip is not None:\n            if not isinstance(tooltip, list):\n                tooltip = [tooltip]\n\n        if x not in col_names:\n            raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n        if y not in col_names:\n            raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n        for _ in df.itertuples():\n            html = \"\"\n            for p in popup:\n                html = (\n                    html\n                    + \"&lt;b&gt;\"\n                    + p\n                    + \"&lt;/b&gt;\"\n                    + \": \"\n                    + str(eval(str(\"row.\" + p)))\n                    + \"&lt;br&gt;\"\n                )\n            popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n            if tooltip is not None:\n                html = \"\"\n                for p in tooltip:\n                    html = (\n                        html\n                        + \"&lt;b&gt;\"\n                        + p\n                        + \"&lt;/b&gt;\"\n                        + \": \"\n                        + str(eval(str(\"row.\" + p)))\n                        + \"&lt;br&gt;\"\n                    )\n\n                tooltip_str = folium.Tooltip(html)\n            else:\n                tooltip_str = None\n\n            folium.CircleMarker(\n                location=[eval(f\"row.{y}\"), eval(f\"row.{x}\")],\n                radius=radius,\n                popup=popup_html,\n                tooltip=tooltip_str,\n                **kwargs,\n            ).add_to(self)\n\n    def add_markers_from_xy(\n        self,\n        data,\n        x=\"longitude\",\n        y=\"latitude\",\n        popup=None,\n        min_width=100,\n        max_width=200,\n        layer_name=\"Marker Cluster\",\n        color_column=None,\n        marker_colors=None,\n        icon_colors=[\"white\"],\n        icon_names=[\"info\"],\n        angle=0,\n        prefix=\"fa\",\n        add_legend=True,\n        **kwargs,\n    ):\n\"\"\"Adds a marker cluster to the map.\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"longitude\".\n            y (str, optional): The column name for the y values. Defaults to \"latitude\".\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n            min_width (int, optional): The minimum width of the popup. Defaults to 100.\n            max_width (int, optional): The maximum width of the popup. Defaults to 200.\n            layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n            color_column (str, optional): The column name for the color values. Defaults to None.\n            marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n            icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n            icon_names (list, optional): A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons or https://getbootstrap.com/docs/3.3/components/?utm_source=pocket_mylist. Defaults to ['info'].\n            angle (int, optional): The angle of the icon. Defaults to 0.\n            prefix (str, optional): The prefix states the source of the icon. 'fa' for font-awesome or 'glyphicon' for bootstrap 3. Defaults to 'fa'.\n            add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n        \"\"\"\n        import pandas as pd\n        from folium.plugins import BeautifyIcon\n\n        color_options = [\n            \"red\",\n            \"blue\",\n            \"green\",\n            \"purple\",\n            \"orange\",\n            \"darkred\",\n            \"lightred\",\n            \"beige\",\n            \"darkblue\",\n            \"darkgreen\",\n            \"cadetblue\",\n            \"darkpurple\",\n            \"white\",\n            \"pink\",\n            \"lightblue\",\n            \"lightgreen\",\n            \"gray\",\n            \"black\",\n            \"lightgray\",\n        ]\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data)\n\n        col_names = df.columns.values.tolist()\n\n        if color_column is not None and color_column not in col_names:\n            raise ValueError(\n                f\"The color column {color_column} does not exist in the dataframe.\"\n            )\n\n        if color_column is not None:\n            items = list(set(df[color_column]))\n        else:\n            items = None\n\n        if color_column is not None and marker_colors is None:\n            if len(items) &gt; len(color_options):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n                )\n            else:\n                marker_colors = color_options[: len(items)]\n        elif color_column is not None and marker_colors is not None:\n            if len(items) != len(marker_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if items is not None:\n            if len(icon_colors) == 1:\n                icon_colors = icon_colors * len(items)\n            elif len(items) != len(icon_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n            if len(icon_names) == 1:\n                icon_names = icon_names * len(items)\n            elif len(items) != len(icon_names):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if popup is None:\n            popup = col_names\n\n        if x not in col_names:\n            raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n        if y not in col_names:\n            raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n        # marker_cluster = plugins.MarkerCluster(name=layer_name).add_to(self)\n        for row in df.itertuples():\n            html = \"\"\n            for p in popup:\n                html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(getattr(row, p)) + \"&lt;br&gt;\"\n            popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n            if items is not None:\n                index = items.index(getattr(row, color_column))\n                marker_icon = folium.Icon(\n                    color=marker_colors[index],\n                    icon_color=icon_colors[index],\n                    icon=icon_names[index],\n                    angle=angle,\n                    prefix=prefix,\n                )\n            else:\n                marker_icon = None\n\n            icon_square = BeautifyIcon(\n                icon_shape=\"rectangle-dot\",\n                border_color=\"red\",\n                border_width=10,\n            )\n\n            icon_circle = BeautifyIcon(\n                icon_shape=\"circle-dot\",\n                border_color=\"green\",\n                border_width=10,\n            )\n            icon_star = BeautifyIcon(\n                icon=\"star\",\n                inner_icon_style=\"color:blue;font-size:20px;\",\n                background_color=\"transparent\",\n                border_color=\"transparent\",\n            )\n\n            folium.Marker(\n                location=[getattr(row, y), getattr(row, x)],\n                popup=popup_html,\n                icon=icon_star,\n            ).add_to(self)\n\n        # folium.Marker([50, -70], tooltip=\"square\", icon=icon, name=\"marker\").add_to(\n        #     self\n        # )\n        # folium.Marker([50, 70], tooltip=\"square\", icon=icon2).add_to(self)\n        if items is not None and add_legend:\n            marker_colors = [check_color(c) for c in marker_colors]\n            self.add_legend(\n                title=color_column.title(), colors=marker_colors, labels=items\n            )\n\n    def add_planet_by_month(\n        self, year=2016, month=1, name=None, api_key=None, token_name=\"PLANET_API_KEY\"\n    ):\n\"\"\"Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n            name (str, optional): The layer name to use. Defaults to None.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        \"\"\"\n        layer = planet_tile_by_month(\n            year, month, name, api_key, token_name, tile_format=\"folium\"\n        )\n        layer.add_to(self)\n\n    def add_planet_by_quarter(\n        self, year=2016, quarter=1, name=None, api_key=None, token_name=\"PLANET_API_KEY\"\n    ):\n\"\"\"Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            quarter (int, optional): The quarter of Planet global mosaic, must be 1-12. Defaults to 1.\n            name (str, optional): The layer name to use. Defaults to None.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        \"\"\"\n        layer = planet_tile_by_quarter(\n            year, quarter, name, api_key, token_name, tile_format=\"folium\"\n        )\n        layer.add_to(self)\n\n    def publish(\n        self,\n        name=\"Folium Map\",\n        description=\"\",\n        source_url=\"\",\n        tags=None,\n        source_file=None,\n        open=True,\n        formatting=None,\n        token=None,\n        **kwargs,\n    ):\n\"\"\"Publish the map to datapane.com\n\n        Args:\n            name (str, optional): The document name - can include spaces, caps, symbols, etc., e.g. \"Profit &amp; Loss 2020\". Defaults to \"Folium Map\".\n            description (str, optional): A high-level description for the document, this is displayed in searches and thumbnails. Defaults to ''.\n            source_url (str, optional): A URL pointing to the source code for the document, e.g. a GitHub repo or a Colab notebook. Defaults to ''.\n            tags (bool, optional): A list of tags (as strings) used to categorise your document. Defaults to None.\n            source_file (str, optional): Path of jupyter notebook file to upload. Defaults to None.\n            open (bool, optional): Whether to open the map. Defaults to True.\n            formatting (ReportFormatting, optional): Set the basic styling for your report.\n            token (str, optional): The token to use to datapane to publish the map. See https://docs.datapane.com/tut-getting-started. Defaults to None.\n        \"\"\"\n        import webbrowser\n        import warnings\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:\n            return\n\n        warnings.filterwarnings(\"ignore\")\n        try:\n            import datapane as dp\n        except Exception:\n            webbrowser.open_new_tab(\"https://docs.datapane.com/\")\n            raise ImportError(\n                \"The datapane Python package is not installed. You need to install and authenticate datapane first.\"\n            )\n\n        if token is None:\n            try:\n                _ = dp.ping(verbose=False)\n            except Exception as e:\n                if os.environ.get(\"DP_TOKEN\") is not None:\n                    dp.login(token=os.environ.get(\"DP_TOKEN\"))\n                else:\n                    raise Exception(e)\n        else:\n            dp.login(token)\n\n        try:\n            dp.upload_report(\n                dp.Plot(self),\n                name=name,\n                description=description,\n                source_url=source_url,\n                tags=tags,\n                source_file=source_file,\n                open=open,\n                formatting=formatting,\n                **kwargs,\n            )\n\n        except Exception as e:\n            raise Exception(e)\n\n    def to_html(self, filename=None, **kwargs):\n\"\"\"Exports a map as an HTML file.\n\n        Args:\n            filename (str, optional): File path to the output HTML. Defaults to None.\n\n        Raises:\n            ValueError: If it is an invalid HTML file.\n\n        Returns:\n            str: A string containing the HTML code.\n        \"\"\"\n\n        if self.options[\"layersControl\"]:\n            self.add_layer_control()\n\n        if filename is not None:\n            if not filename.endswith(\".html\"):\n                raise ValueError(\"The output file extension must be html.\")\n            filename = os.path.abspath(filename)\n            out_dir = os.path.dirname(filename)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            self.save(filename, **kwargs)\n        else:\n            filename = os.path.abspath(random_string() + \".html\")\n            self.save(filename, **kwargs)\n            out_html = \"\"\n            with open(filename) as f:\n                lines = f.readlines()\n                out_html = \"\".join(lines)\n            os.remove(filename)\n            return out_html\n\n    def to_streamlit(\n        self,\n        width=None,\n        height=600,\n        scrolling=False,\n        add_layer_control=True,\n        bidirectional=False,\n        **kwargs,\n    ):\n\"\"\"Renders `folium.Figure` or `folium.Map` in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n        Args:\n            width (int, optional): Width of the map. Defaults to None.\n            height (int, optional): Height of the map. Defaults to 600.\n            scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n            add_layer_control (bool, optional): Whether to add the layer control. Defaults to True.\n            bidirectional (bool, optional): Whether to add bidirectional functionality to the map. The streamlit-folium package is required to use the bidirectional functionality. Defaults to False.\n\n        Raises:\n            ImportError: If streamlit is not installed.\n\n        Returns:\n            streamlit.components: components.html object.\n        \"\"\"\n\n        try:\n            import streamlit.components.v1 as components\n\n            if add_layer_control:\n                self.add_layer_control()\n\n            if bidirectional:\n                from streamlit_folium import st_folium\n\n                output = st_folium(self, width=width, height=height)\n                return output\n            else:\n                # if responsive:\n                #     make_map_responsive = \"\"\"\n                #     &lt;style&gt;\n                #     [title~=\"st.iframe\"] { width: 100%}\n                #     &lt;/style&gt;\n                #     \"\"\"\n                #     st.markdown(make_map_responsive, unsafe_allow_html=True)\n                return components.html(\n                    self.to_html(), width=width, height=height, scrolling=scrolling\n                )\n\n        except Exception as e:\n            raise Exception(e)\n\n    def st_map_center(self, st_component):\n\"\"\"Get the center of the map.\n\n        Args:\n            st_folium (streamlit-folium): The streamlit component.\n\n        Returns:\n            tuple: The center of the map.\n        \"\"\"\n\n        bounds = st_component[\"bounds\"]\n        west = bounds[\"_southWest\"][\"lng\"]\n        south = bounds[\"_southWest\"][\"lat\"]\n        east = bounds[\"_northEast\"][\"lng\"]\n        north = bounds[\"_northEast\"][\"lat\"]\n        return (south + (north - south) / 2, west + (east - west) / 2)\n\n    def st_map_bounds(self, st_component):\n\"\"\"Get the bounds of the map in the format of (miny, minx, maxy, maxx).\n\n        Args:\n            st_folium (streamlit-folium): The streamlit component.\n\n        Returns:\n            tuple: The bounds of the map.\n        \"\"\"\n\n        bounds = st_component[\"bounds\"]\n        south = bounds[\"_southWest\"][\"lat\"]\n        west = bounds[\"_southWest\"][\"lng\"]\n        north = bounds[\"_northEast\"][\"lat\"]\n        east = bounds[\"_northEast\"][\"lng\"]\n\n        bounds = [[south, west], [north, east]]\n        return bounds\n\n    def st_fit_bounds(self):\n\"\"\"Fit the map to the bounds of the map.\n\n        Returns:\n            folium.Map: The map.\n        \"\"\"\n\n        try:\n            import streamlit as st\n\n            if \"map_bounds\" in st.session_state:\n                bounds = st.session_state[\"map_bounds\"]\n\n                self.fit_bounds(bounds)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def st_last_draw(self, st_component):\n\"\"\"Get the last draw feature of the map.\n\n        Args:\n            st_folium (streamlit-folium): The streamlit component.\n\n        Returns:\n            str: The last draw of the map.\n        \"\"\"\n\n        return st_component[\"last_active_drawing\"]\n\n    def st_last_click(self, st_component):\n\"\"\"Get the last click feature of the map.\n\n        Args:\n            st_folium (streamlit-folium): The streamlit component.\n\n        Returns:\n            str: The last click of the map.\n        \"\"\"\n\n        coords = st_component[\"last_clicked\"]\n        return (coords[\"lat\"], coords[\"lng\"])\n\n    def st_draw_features(self, st_component):\n\"\"\"Get the draw features of the map.\n\n        Args:\n            st_folium (streamlit-folium): The streamlit component.\n\n        Returns:\n            list: The draw features of the map.\n        \"\"\"\n\n        return st_component[\"all_drawings\"]\n\n    def add_census_data(self, wms, layer, census_dict=None, **kwargs):\n\"\"\"Adds a census data layer to the map.\n\n        Args:\n            wms (str): The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html\n            layer (str): The layer name to add to the map.\n            census_dict (dict, optional): A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.\n        \"\"\"\n\n        try:\n            if census_dict is None:\n                census_dict = get_census_dict()\n\n            if wms not in census_dict.keys():\n                raise ValueError(\n                    f\"The provided WMS is invalid. It must be one of {census_dict.keys()}\"\n                )\n\n            layers = census_dict[wms][\"layers\"]\n            if layer not in layers:\n                raise ValueError(\n                    f\"The layer name is not valid. It must be one of {layers}\"\n                )\n\n            url = census_dict[wms][\"url\"]\n            if \"name\" not in kwargs:\n                kwargs[\"name\"] = layer\n            if \"attribution\" not in kwargs:\n                kwargs[\"attribution\"] = \"U.S. Census Bureau\"\n            if \"format\" not in kwargs:\n                kwargs[\"format\"] = \"image/png\"\n            if \"transparent\" not in kwargs:\n                kwargs[\"transparent\"] = True\n\n            self.add_wms_layer(url, layer, **kwargs)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_xyz_service(self, provider, **kwargs):\n\"\"\"Add a XYZ tile layer to the map.\n\n        Args:\n            provider (str): A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,\n\n        Raises:\n            ValueError: The provider is not valid. It must start with xyz or qms.\n        \"\"\"\n        import xyzservices.providers as xyz\n        from xyzservices import TileProvider\n\n        if provider.startswith(\"xyz\"):\n            name = provider[4:]\n            xyz_provider = xyz.flatten()[name]\n            url = xyz_provider.build_url()\n            attribution = xyz_provider.attribution\n            if attribution.strip() == \"\":\n                attribution = \" \"\n            self.add_tile_layer(url, name, attribution)\n        elif provider.startswith(\"qms\"):\n            name = provider[4:]\n            qms_provider = TileProvider.from_qms(name)\n            url = qms_provider.build_url()\n            attribution = qms_provider.attribution\n            if attribution.strip() == \"\":\n                attribution = \" \"\n            self.add_tile_layer(url=url, name=name, attribution=attribution)\n        else:\n            raise ValueError(\n                f\"The provider {provider} is not valid. It must start with xyz or qms.\"\n            )\n\n    def add_labels(\n        self,\n        data,\n        column,\n        font_size=\"12pt\",\n        font_color=\"black\",\n        font_family=\"arial\",\n        font_weight=\"normal\",\n        x=\"longitude\",\n        y=\"latitude\",\n        draggable=True,\n        layer_name=\"Labels\",\n        **kwargs,\n    ):\n\"\"\"Adds a label layer to the map. Reference: https://python-visualization.github.io/folium/modules.html#folium.features.DivIcon\n\n        Args:\n            data (pd.DataFrame | ee.FeatureCollection): The input data to label.\n            column (str): The column name of the data to label.\n            font_size (str, optional): The font size of the labels. Defaults to \"12pt\".\n            font_color (str, optional): The font color of the labels. Defaults to \"black\".\n            font_family (str, optional): The font family of the labels. Defaults to \"arial\".\n            font_weight (str, optional): The font weight of the labels, can be normal, bold. Defaults to \"normal\".\n            x (str, optional): The column name of the longitude. Defaults to \"longitude\".\n            y (str, optional): The column name of the latitude. Defaults to \"latitude\".\n            draggable (bool, optional): Whether the labels are draggable. Defaults to True.\n            layer_name (str, optional): The name of the layer. Defaults to \"Labels\".\n\n        \"\"\"\n        import warnings\n        import pandas as pd\n        from folium.features import DivIcon\n\n        warnings.filterwarnings(\"ignore\")\n\n        if isinstance(data, ee.FeatureCollection):\n            centroids = vector_centroids(data)\n            df = ee_to_df(centroids)\n        elif isinstance(data, pd.DataFrame):\n            df = data\n        elif isinstance(data, str):\n            ext = os.path.splitext(data)[1]\n            if ext == \".csv\":\n                df = pd.read_csv(data)\n            elif ext in [\".geojson\", \".json\", \".shp\", \".gpkg\"]:\n                try:\n                    import geopandas as gpd\n\n                    df = gpd.read_file(data)\n                    df[x] = df.centroid.x\n                    df[y] = df.centroid.y\n                except Exception as e:\n                    print(\"geopandas is required to read geojson.\")\n                    print(e)\n                    return\n        else:\n            raise ValueError(\"data must be a DataFrame or an ee.FeatureCollection.\")\n\n        if column not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n        if x not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n        if y not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n\n        try:\n            size = int(font_size.replace(\"pt\", \"\"))\n        except Exception as _:\n            raise ValueError(\"font_size must be something like '10pt'\")\n\n        layer_group = folium.FeatureGroup(name=layer_name)\n        for index in df.index:\n            html = f'&lt;div style=\"font-size: {font_size};color:{font_color};font-family:{font_family};font-weight: {font_weight}\"&gt;{df[column][index]}&lt;/div&gt;'\n            folium.Marker(\n                location=[df[y][index], df[x][index]],\n                icon=DivIcon(\n                    icon_size=(1, 1),\n                    icon_anchor=(size, size),\n                    html=html,\n                    **kwargs,\n                ),\n                draggable=draggable,\n            ).add_to(layer_group)\n\n        layer_group.add_to(self)\n\n    def split_map(\n        self,\n        left_layer=\"TERRAIN\",\n        right_layer=\"OpenTopoMap\",\n        left_args={},\n        right_args={},\n        left_label=None,\n        right_label=None,\n        left_position=\"bottomleft\",\n        right_position=\"bottomright\",\n        **kwargs,\n    ):\n\"\"\"Adds a split-panel map.\n\n        Args:\n            left_layer (str, optional): The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.\n            right_layer (str, optional): The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.\n            left_args (dict, optional): The arguments for the left tile layer. Defaults to {}.\n            right_args (dict, optional): The arguments for the right tile layer. Defaults to {}.\n        \"\"\"\n        if \"max_zoom\" not in left_args:\n            left_args[\"max_zoom\"] = 100\n        if \"max_native_zoom\" not in left_args:\n            left_args[\"max_native_zoom\"] = 100\n\n        if \"max_zoom\" not in right_args:\n            right_args[\"max_zoom\"] = 100\n        if \"max_native_zoom\" not in right_args:\n            right_args[\"max_native_zoom\"] = 100\n\n        if \"layer_name\" not in left_args:\n            left_args[\"layer_name\"] = \"Left Layer\"\n\n        if \"layer_name\" not in right_args:\n            right_args[\"layer_name\"] = \"Right Layer\"\n\n        bounds = None\n\n        try:\n            if left_label is not None:\n                left_name = left_label\n            else:\n                left_name = \"Left Layer\"\n\n            if right_label is not None:\n                right_name = right_label\n            else:\n                right_name = \"Right Layer\"\n\n            if left_layer in basemaps.keys():\n                left_layer = basemaps[left_layer]\n            elif isinstance(left_layer, str):\n                if left_layer.startswith(\"http\") and left_layer.endswith(\".tif\"):\n                    url = cog_tile(left_layer, **left_args)\n                    bbox = cog_bounds(left_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    left_layer = folium.raster_layers.TileLayer(\n                        tiles=url,\n                        name=left_name,\n                        attr=\" \",\n                        overlay=True,\n                    )\n                elif os.path.exists(left_layer):\n                    left_layer, left_client = get_local_tile_layer(\n                        left_layer,\n                        tile_format=\"folium\",\n                        return_client=True,\n                        **left_args,\n                    )\n                    bounds = image_bounds(left_client)\n\n                else:\n                    left_layer = folium.raster_layers.TileLayer(\n                        tiles=left_layer,\n                        name=left_name,\n                        attr=\" \",\n                        overlay=True,\n                        **left_args,\n                    )\n            elif isinstance(left_layer, folium.raster_layers.TileLayer) or isinstance(\n                left_layer, folium.WmsTileLayer\n            ):\n                pass\n            else:\n                raise ValueError(\n                    f\"left_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n                )\n\n            if right_layer in basemaps.keys():\n                right_layer = basemaps[right_layer]\n            elif isinstance(right_layer, str):\n                if right_layer.startswith(\"http\") and right_layer.endswith(\".tif\"):\n                    url = cog_tile(right_layer, **right_args)\n                    bbox = cog_bounds(right_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    right_layer = folium.raster_layers.TileLayer(\n                        tiles=url,\n                        name=right_name,\n                        attr=\" \",\n                        overlay=True,\n                    )\n                elif os.path.exists(right_layer):\n                    right_layer, right_client = get_local_tile_layer(\n                        right_layer,\n                        tile_format=\"folium\",\n                        return_client=True,\n                        **right_args,\n                    )\n                    bounds = image_bounds(right_client)\n                else:\n                    right_layer = folium.raster_layers.TileLayer(\n                        tiles=right_layer,\n                        name=right_name,\n                        attr=\" \",\n                        overlay=True,\n                        **right_args,\n                    )\n            elif isinstance(right_layer, folium.raster_layers.TileLayer) or isinstance(\n                left_layer, folium.WmsTileLayer\n            ):\n                pass\n            else:\n                raise ValueError(\n                    f\"right_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n                )\n\n            control = SideBySideLayers(layer_left=left_layer, layer_right=right_layer)\n            left_layer.add_to(self)\n            right_layer.add_to(self)\n            control.add_to(self)\n\n            if left_label is not None:\n                if \"&lt;\" not in left_label:\n                    left_label = f\"&lt;h4&gt;{left_label}&lt;/h4&gt;\"\n                self.add_html(left_label, position=left_position)\n\n            if right_label is not None:\n                if \"&lt;\" not in right_label:\n                    right_label = f\"&lt;h4&gt;{right_label}&lt;/h4&gt;\"\n                self.add_html(right_label, position=right_position)\n            if bounds is not None:\n                self.fit_bounds(bounds)\n\n        except Exception as e:\n            print(\"The provided layers are invalid!\")\n            raise ValueError(e)\n\n    def add_netcdf(\n        self,\n        filename,\n        variables=None,\n        palette=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=\"NetCDF layer\",\n        shift_lon=True,\n        lat=\"lat\",\n        lon=\"lon\",\n        **kwargs,\n    ):\n\"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n            If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n            try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n        Args:\n            filename (str): File path or HTTP URL to the netCDF file.\n            variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n            port (str, optional): The port to use for the server. Defaults to \"default\".\n            palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to \"netCDF layer\".\n            shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n            lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n            lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n        \"\"\"\n\n        if in_colab_shell():\n            print(\"The add_netcdf() function is not supported in Colab.\")\n            return\n\n        tif, vars = netcdf_to_tif(\n            filename, shift_lon=shift_lon, lat=lat, lon=lon, return_vars=True\n        )\n\n        if variables is None:\n            if len(vars) &gt;= 3:\n                band_idx = [1, 2, 3]\n            else:\n                band_idx = [1]\n        else:\n            if not set(variables).issubset(set(vars)):\n                raise ValueError(f\"The variables must be a subset of {vars}.\")\n            else:\n                band_idx = [vars.index(v) + 1 for v in variables]\n\n        self.add_local_tile(\n            tif,\n            band=band_idx,\n            palette=palette,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            **kwargs,\n        )\n\n    def add_data(\n        self,\n        data,\n        column,\n        colors=None,\n        labels=None,\n        cmap=None,\n        scheme=\"Quantiles\",\n        k=5,\n        add_legend=True,\n        legend_title=None,\n        legend_kwds=None,\n        classification_kwds=None,\n        style_function=None,\n        highlight_function=None,\n        layer_name=\"Untitled\",\n        info_mode=\"on_hover\",\n        encoding=\"utf-8\",\n        **kwargs,\n    ):\n\"\"\"Add vector data to the map with a variety of classification schemes.\n\n        Args:\n            data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n            column (str): The column to classify.\n            cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n            colors (list, optional): A list of colors to use for the classification. Defaults to None.\n            labels (list, optional): A list of labels to use for the legend. Defaults to None.\n            scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n                Name of a choropleth classification scheme (requires mapclassify).\n                A mapclassify.MapClassifier object will be used\n                under the hood. Supported are all schemes provided by mapclassify (e.g.\n                'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n                'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n                'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n                'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n                'UserDefined'). Arguments can be passed in classification_kwds.\n            k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n            legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n                Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n                Additional accepted keywords when `scheme` is specified:\n                fmt : string\n                    A formatting specification for the bin edges of the classes in the\n                    legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n                labels : list-like\n                    A list of legend labels to override the auto-generated labblels.\n                    Needs to have the same number of elements as the number of\n                    classes (`k`).\n                interval : boolean (default False)\n                    An option to control brackets from mapclassify legend.\n                    If True, open/closed interval brackets are shown in the legend.\n            classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style_function (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n                style_callback is a function that takes the feature as argument and should return a dictionary of the following form:\n                style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n                style is a dictionary of the following form:\n                    style = {\n                    \"stroke\": False,\n                    \"color\": \"#ff0000\",\n                    \"weight\": 1,\n                    \"opacity\": 1,\n                    \"fill\": True,\n                    \"fillColor\": \"#ffffff\",\n                    \"fillOpacity\": 1.0,\n                    \"dashArray\": \"9\"\n                    \"clickable\": True,\n                }\n            hightlight_function (function, optional): Highlighting function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n                highlight_function is a function that takes the feature as argument and should return a dictionary of the following form:\n                highlight_function = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n        \"\"\"\n\n        import warnings\n\n        gdf, legend_dict = classify(\n            data=data,\n            column=column,\n            cmap=cmap,\n            colors=colors,\n            labels=labels,\n            scheme=scheme,\n            k=k,\n            legend_kwds=legend_kwds,\n            classification_kwds=classification_kwds,\n        )\n\n        if legend_title is None:\n            legend_title = column\n\n        if \"style\" in kwargs:\n            warnings.warn(\n                \"The style arguments is for ipyleaflet only. \",\n                UserWarning,\n            )\n            kwargs.pop(\"style\")\n\n        if \"hover_style\" in kwargs:\n            warnings.warn(\n                \"The hover_style arguments is for ipyleaflet only. \",\n                UserWarning,\n            )\n            kwargs.pop(\"hover_style\")\n\n        if \"style_callback\" in kwargs:\n            warnings.warn(\n                \"The style_callback arguments is for ipyleaflet only. \",\n                UserWarning,\n            )\n            kwargs.pop(\"style_callback\")\n\n        if style_function is None:\n            style_function = lambda feat: {\n                # \"stroke\": False,\n                # \"color\": \"#ff0000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 1.0,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n                \"fillColor\": feat[\"properties\"][\"color\"],\n            }\n\n        if highlight_function is None:\n            highlight_function = lambda feat: {\n                \"weight\": 2,\n                \"fillOpacity\": 0.5,\n            }\n\n        self.add_gdf(\n            gdf,\n            layer_name=layer_name,\n            style_function=style_function,\n            highlight_function=highlight_function,\n            info_mode=info_mode,\n            encoding=encoding,\n            **kwargs,\n        )\n        if add_legend:\n            self.add_legend(title=legend_title, legend_dict=legend_dict)\n\n    def add_image(self, image, position=(0, 0), **kwargs):\n\"\"\"Add an image to the map.\n\n        Args:\n            image (str | ipywidgets.Image): The image to add.\n            position (tuple, optional): The position of the image in the format of (x, y),\n                the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).\n        \"\"\"\n        import base64\n\n        if isinstance(image, str):\n            if image.startswith(\"http\"):\n                html = f'&lt;img src=\"{image}\"&gt;'\n                if isinstance(position, tuple):\n                    position = \"bottomright\"\n                self.add_html(html, position=position, **kwargs)\n\n            elif os.path.exists(image):\n                if position == \"bottomleft\":\n                    position = (5, 5)\n                elif position == \"bottomright\":\n                    position = (80, 5)\n                elif position == \"topleft\":\n                    position = (5, 60)\n                elif position == \"topright\":\n                    position = (80, 60)\n\n                with open(image, \"rb\") as lf:\n                    # open in binary mode, read bytes, encode, decode obtained bytes as utf-8 string\n                    b64_content = base64.b64encode(lf.read()).decode(\"utf-8\")\n                    widget = plugins.FloatImage(\n                        \"data:image/png;base64,{}\".format(b64_content),\n                        bottom=position[1],\n                        left=position[0],\n                    )\n                    widget.add_to(self)\n\n        else:\n            raise Exception(\"Invalid image\")\n\n    def add_widget(self, content, position=\"bottomright\", **kwargs):\n\"\"\"Add a widget (e.g., text, HTML, figure) to the map.\n\n        Args:\n            content (str): The widget to add.\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        \"\"\"\n\n        from matplotlib import figure\n        import base64\n        from io import BytesIO\n\n        allowed_positions = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n\n        if position not in allowed_positions:\n            raise Exception(f\"position must be one of {allowed_positions}\")\n\n        try:\n            if isinstance(content, str):\n                widget = CustomControl(content, position=position)\n                widget.add_to(self)\n            elif isinstance(content, figure.Figure):\n                buf = BytesIO()\n                content.savefig(buf, format=\"png\")\n                buf.seek(0)\n                b64_content = base64.b64encode(buf.read()).decode(\"utf-8\")\n                widget = CustomControl(\n                    f\"\"\"&lt;img src=\"data:image/png;base64,{b64_content}\"&gt;\"\"\",\n                    position=position,\n                )\n                widget.add_to(self)\n            else:\n                raise Exception(\"The content must be a string or a matplotlib figure\")\n\n        except Exception as e:\n            raise Exception(f\"Error adding widget: {e}\")\n\n    def add_html(self, html, position=\"bottomright\", **kwargs):\n\"\"\"Add HTML to the map.\n\n        Args:\n            html (str): The HTML to add.\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        \"\"\"\n\n        self.add_widget(html, position=position, **kwargs)\n\n    def add_text(\n        self,\n        text,\n        fontsize=20,\n        fontcolor=\"black\",\n        bold=False,\n        padding=\"5px\",\n        background=True,\n        bg_color=\"white\",\n        border_radius=\"5px\",\n        position=\"bottomright\",\n        **kwargs,\n    ):\n\"\"\"Add text to the map.\n\n        Args:\n            text (str): The text to add.\n            fontsize (int, optional): The font size. Defaults to 20.\n            fontcolor (str, optional): The font color. Defaults to \"black\".\n            bold (bool, optional): Whether to use bold font. Defaults to False.\n            padding (str, optional): The padding. Defaults to \"5px\".\n            background (bool, optional): Whether to use background. Defaults to True.\n            bg_color (str, optional): The background color. Defaults to \"white\".\n            border_radius (str, optional): The border radius. Defaults to \"5px\".\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        \"\"\"\n\n        if background:\n            text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'}; \n            padding: {padding}; background-color: {bg_color}; \n            border-radius: {border_radius};\"&gt;{text}&lt;/div&gt;\"\"\"\n        else:\n            text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'}; \n            padding: {padding};\"&gt;{text}&lt;/div&gt;\"\"\"\n\n        self.add_html(text, position=position, **kwargs)\n\n    def to_gradio(self, width=\"100%\", height=\"500px\", **kwargs):\n\"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n            attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n        Args:\n            width (str, optional): The width of the map. Defaults to '100%'.\n            height (str, optional): The height of the map. Defaults to '500px'.\n\n        Returns:\n            str: The HTML string to use in Gradio.\n        \"\"\"\n\n        if isinstance(width, int):\n            width = f\"{width}px\"\n        if isinstance(height, int):\n            height = f\"{height}px\"\n\n        html = self.to_html()\n        lines = html.split(\"\\n\")\n        output = []\n        skipped_lines = []\n        for index, line in enumerate(lines):\n            if index in skipped_lines:\n                continue\n            if line.lstrip().startswith('{\"attribution\":'):\n                continue\n            elif \"on(L.Draw.Event.CREATED, function(e)\" in line:\n                for i in range(14):\n                    skipped_lines.append(index + i)\n            elif \"L.Control.geocoder\" in line:\n                for i in range(5):\n                    skipped_lines.append(index + i)\n            elif \"function(e)\" in line:\n                print(\n                    f\"Warning: The folium plotting backend does not support functions in code blocks. Please delete line {index + 1}.\"\n                )\n            else:\n                output.append(line + \"\\n\")\n\n        return f\"\"\"&lt;iframe style=\"width: {width}; height: {height}\" name=\"result\" allow=\"midi; geolocation; microphone; camera; \n        display-capture; encrypted-media;\" sandbox=\"allow-modals allow-forms \n        allow-scripts allow-same-origin allow-popups \n        allow-top-navigation-by-user-activation allow-downloads\" allowfullscreen=\"\" \n        allowpaymentrequest=\"\" frameborder=\"0\" srcdoc='{\"\".join(output)}'&gt;&lt;/iframe&gt;\"\"\"\n\n    def remove_labels(self, **kwargs):\n\"\"\"Removes a layer from the map.\"\"\"\n        print(\"The folium plotting backend does not support removing labels.\")\n\n    def basemap_demo(self):\n\"\"\"A demo for using geemap basemaps.\"\"\"\n        print(\"The folium plotting backend does not support this function.\")\n\n    def set_plot_options(\n        self,\n        **kwargs,\n    ):\n\"\"\"Sets plotting options.\"\"\"\n        print(\"The folium plotting backend does not support this function.\")\n\n    def ts_inspector(\n        self,\n        left_ts,\n        right_ts,\n        left_names,\n        right_names,\n        left_vis={},\n        right_vis={},\n        width=\"130px\",\n        **kwargs,\n    ):\n        print(\"The folium plotting backend does not support this function.\")\n\n    def add_time_slider(\n        self,\n        ee_object,\n        vis_params={},\n        region=None,\n        layer_name=\"Time series\",\n        labels=None,\n        time_interval=1,\n        position=\"bottomright\",\n        slider_length=\"150px\",\n        date_format=\"YYYY-MM-dd\",\n        opacity=1.0,\n        **kwargs,\n    ):\n        print(\"The folium plotting backend does not support this function.\")\n\n    def extract_values_to_points(self, filename):\n        print(\"The folium plotting backend does not support this function.\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.addLayer","title":"<code>addLayer(self, ee_object, vis_params={}, name='Layer untitled', shown=True, opacity=1.0, **kwargs)</code>","text":"<p>Adds a given EE object to the map as a layer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer untitled'.</p> <code>'Layer untitled'</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_layer(\n    self,\n    ee_object,\n    vis_params={},\n    name=\"Layer untitled\",\n    shown=True,\n    opacity=1.0,\n    **kwargs,\n):\n\"\"\"Adds a given EE object to the map as a layer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer untitled'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n\n    from box import Box\n\n    image = None\n    if vis_params is None:\n        vis_params = {}\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], tuple):\n            vis_params[\"palette\"] = list(vis_params[\"palette\"])\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n\n    # if a layer starts with a number, add \"Layer\" to name.\n    if name[0].isdigit():\n        name = \"Layer \" + name\n\n    url = map_id_dict[\"tile_fetcher\"].url_format\n    folium.raster_layers.TileLayer(\n        tiles=url,\n        attr=\"Google Earth Engine\",\n        name=name,\n        overlay=True,\n        control=True,\n        show=shown,\n        opacity=opacity,\n        max_zoom=24,\n        **kwargs,\n    ).add_to(self)\n\n    arc_add_layer(url, name, shown, opacity)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.addLayerControl","title":"<code>addLayerControl(self)</code>","text":"<p>Adds layer control to the map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_layer_control(self):\n\"\"\"Adds layer control to the map.\"\"\"\n    layer_ctrl = False\n    for item in self.to_dict()[\"children\"]:\n        if item.startswith(\"layer_control\"):\n            layer_ctrl = True\n            break\n    if not layer_ctrl:\n        folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_basemap","title":"<code>add_basemap(self, basemap='HYBRID')</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Can be one of string from ee_basemaps. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_basemap(self, basemap=\"HYBRID\"):\n\"\"\"Adds a basemap to the map.\n\n    Args:\n        basemap (str, optional): Can be one of string from ee_basemaps. Defaults to 'HYBRID'.\n    \"\"\"\n    try:\n        basemaps[basemap].add_to(self)\n    except Exception:\n        raise Exception(\n            \"Basemap can only be one of the following: {}\".format(\n                \", \".join(basemaps.keys())\n            )\n        )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_census_data","title":"<code>add_census_data(self, wms, layer, census_dict=None, **kwargs)</code>","text":"<p>Adds a census data layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>wms</code> <code>str</code> <p>The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html</p> required <code>layer</code> <code>str</code> <p>The layer name to add to the map.</p> required <code>census_dict</code> <code>dict</code> <p>A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_census_data(self, wms, layer, census_dict=None, **kwargs):\n\"\"\"Adds a census data layer to the map.\n\n    Args:\n        wms (str): The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html\n        layer (str): The layer name to add to the map.\n        census_dict (dict, optional): A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.\n    \"\"\"\n\n    try:\n        if census_dict is None:\n            census_dict = get_census_dict()\n\n        if wms not in census_dict.keys():\n            raise ValueError(\n                f\"The provided WMS is invalid. It must be one of {census_dict.keys()}\"\n            )\n\n        layers = census_dict[wms][\"layers\"]\n        if layer not in layers:\n            raise ValueError(\n                f\"The layer name is not valid. It must be one of {layers}\"\n            )\n\n        url = census_dict[wms][\"url\"]\n        if \"name\" not in kwargs:\n            kwargs[\"name\"] = layer\n        if \"attribution\" not in kwargs:\n            kwargs[\"attribution\"] = \"U.S. Census Bureau\"\n        if \"format\" not in kwargs:\n            kwargs[\"format\"] = \"image/png\"\n        if \"transparent\" not in kwargs:\n            kwargs[\"transparent\"] = True\n\n        self.add_wms_layer(url, layer, **kwargs)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_circle_markers_from_xy","title":"<code>add_circle_markers_from_xy(self, data, x='longitude', y='latitude', radius=10, popup=None, tooltip=None, min_width=100, max_width=200, **kwargs)</code>","text":"<p>Adds a marker cluster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>radius</code> <code>int</code> <p>The radius of the circle. Defaults to 10.</p> <code>10</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>list</code> <p>A list of column names to be used as the tooltip. Defaults to None.</p> <code>None</code> <code>min_width</code> <code>int</code> <p>The minimum width of the popup. Defaults to 100.</p> <code>100</code> <code>max_width</code> <code>int</code> <p>The maximum width of the popup. Defaults to 200.</p> <code>200</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_circle_markers_from_xy(\n    self,\n    data,\n    x=\"longitude\",\n    y=\"latitude\",\n    radius=10,\n    popup=None,\n    tooltip=None,\n    min_width=100,\n    max_width=200,\n    **kwargs,\n):\n\"\"\"Adds a marker cluster to the map.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        radius (int, optional): The radius of the circle. Defaults to 10.\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        tooltip (list, optional): A list of column names to be used as the tooltip. Defaults to None.\n        min_width (int, optional): The minimum width of the popup. Defaults to 100.\n        max_width (int, optional): The maximum width of the popup. Defaults to 200.\n\n    \"\"\"\n    import pandas as pd\n\n    data = github_raw_url(data)\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    else:\n        df = pd.read_csv(data)\n\n    col_names = df.columns.values.tolist()\n\n    if \"color\" not in kwargs:\n        kwargs[\"color\"] = None\n    if \"fill\" not in kwargs:\n        kwargs[\"fill\"] = True\n    if \"fill_color\" not in kwargs:\n        kwargs[\"fill_color\"] = \"blue\"\n    if \"fill_opacity\" not in kwargs:\n        kwargs[\"fill_opacity\"] = 0.7\n\n    if popup is None:\n        popup = col_names\n\n    if not isinstance(popup, list):\n        popup = [popup]\n\n    if tooltip is not None:\n        if not isinstance(tooltip, list):\n            tooltip = [tooltip]\n\n    if x not in col_names:\n        raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n    if y not in col_names:\n        raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n    for _ in df.itertuples():\n        html = \"\"\n        for p in popup:\n            html = (\n                html\n                + \"&lt;b&gt;\"\n                + p\n                + \"&lt;/b&gt;\"\n                + \": \"\n                + str(eval(str(\"row.\" + p)))\n                + \"&lt;br&gt;\"\n            )\n        popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n        if tooltip is not None:\n            html = \"\"\n            for p in tooltip:\n                html = (\n                    html\n                    + \"&lt;b&gt;\"\n                    + p\n                    + \"&lt;/b&gt;\"\n                    + \": \"\n                    + str(eval(str(\"row.\" + p)))\n                    + \"&lt;br&gt;\"\n                )\n\n            tooltip_str = folium.Tooltip(html)\n        else:\n            tooltip_str = None\n\n        folium.CircleMarker(\n            location=[eval(f\"row.{y}\"), eval(f\"row.{x}\")],\n            radius=radius,\n            popup=popup_html,\n            tooltip=tooltip_str,\n            **kwargs,\n        ).add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_cog_layer","title":"<code>add_cog_layer(self, url, name='Untitled', attribution='.', opacity=1.0, shown=True, bands=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Adds a COG TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the COG tile layer.</p> required <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Untitled'.</p> <code>'Untitled'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to '.'.</p> <code>'.'</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>bands</code> <code>list</code> <p>A list of bands to use. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_cog_layer(\n    self,\n    url,\n    name=\"Untitled\",\n    attribution=\".\",\n    opacity=1.0,\n    shown=True,\n    bands=None,\n    titiler_endpoint=None,\n    **kwargs,\n):\n\"\"\"Adds a COG TileLayer to the map.\n\n    Args:\n        url (str): The URL of the COG tile layer.\n        name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n        attribution (str, optional): The attribution to use. Defaults to '.'.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        bands (list, optional): A list of bands to use. Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n    \"\"\"\n    tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n    bounds = cog_bounds(url, titiler_endpoint)\n    self.add_tile_layer(\n        tiles=tile_url,\n        name=name,\n        attribution=attribution,\n        opacity=opacity,\n        shown=shown,\n    )\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_colorbar","title":"<code>add_colorbar(self, vis_params, index=None, label='', categorical=False, step=None, background_color=None, **kwargs)</code>","text":"<p>Add a colorbar to the map.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)</p> required <code>vmin</code> <code>int</code> <p>The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.</p> required <code>vmax</code> <code>float</code> <p>The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.</p> required <code>index</code> <code>list</code> <p>The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.</p> <code>None</code> <code>label</code> <code>str</code> <p>The caption for the colormap. Defaults to \"\".</p> <code>''</code> <code>categorical</code> <code>bool</code> <p>Whether or not to create a categorical colormap. Defaults to False.</p> <code>False</code> <code>step</code> <code>int</code> <p>The step to split the LinearColormap into a StepColormap. Defaults to None.</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_colorbar(\n    self,\n    vis_params,\n    index=None,\n    label=\"\",\n    categorical=False,\n    step=None,\n    background_color=None,\n    **kwargs,\n):\n\"\"\"Add a colorbar to the map.\n\n    Args:\n        colors (list): The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)\n        vmin (int, optional): The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.\n        vmax (float, optional): The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.\n        index (list, optional):The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.\n        label (str, optional): The caption for the colormap. Defaults to \"\".\n        categorical (bool, optional): Whether or not to create a categorical colormap. Defaults to False.\n        step (int, optional): The step to split the LinearColormap into a StepColormap. Defaults to None.\n    \"\"\"\n    from box import Box\n    from branca.colormap import LinearColormap\n\n    if not isinstance(vis_params, dict):\n        raise ValueError(\"vis_params must be a dictionary.\")\n\n    if \"palette\" not in vis_params:\n        raise ValueError(\"vis_params must contain a palette.\")\n\n    if \"min\" not in vis_params:\n        vis_params[\"min\"] = 0\n    if \"max\" not in vis_params:\n        vis_params[\"max\"] = 1\n\n    colors = to_hex_colors(check_cmap(vis_params[\"palette\"]))\n    vmin = vis_params[\"min\"]\n    vmax = vis_params[\"max\"]\n\n    if isinstance(colors, Box):\n        try:\n            colors = list(colors[\"default\"])\n        except Exception as e:\n            print(\"The provided color list is invalid.\")\n            raise Exception(e)\n\n    if all(len(color) == 6 for color in colors):\n        colors = [\"#\" + color for color in colors]\n\n    colormap = LinearColormap(\n        colors=colors, index=index, vmin=vmin, vmax=vmax, caption=label\n    )\n\n    if categorical:\n        if step is not None:\n            colormap = colormap.to_step(step)\n        elif index is not None:\n            colormap = colormap.to_step(len(index) - 1)\n        else:\n            colormap = colormap.to_step(3)\n\n    if background_color is not None:\n        svg_style = (\n            \"&lt;style&gt;svg {background-color: \" + background_color + \";}&lt;/style&gt;\"\n        )\n\n        self.get_root().header.add_child(folium.Element(svg_style))\n\n    self.add_child(colormap)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_colorbar_branca","title":"<code>add_colorbar_branca(self, vis_params, index=None, label='', categorical=False, step=None, background_color=None, **kwargs)</code>","text":"<p>Add a colorbar to the map.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)</p> required <code>vmin</code> <code>int</code> <p>The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.</p> required <code>vmax</code> <code>float</code> <p>The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.</p> required <code>index</code> <code>list</code> <p>The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.</p> <code>None</code> <code>label</code> <code>str</code> <p>The caption for the colormap. Defaults to \"\".</p> <code>''</code> <code>categorical</code> <code>bool</code> <p>Whether or not to create a categorical colormap. Defaults to False.</p> <code>False</code> <code>step</code> <code>int</code> <p>The step to split the LinearColormap into a StepColormap. Defaults to None.</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_colorbar(\n    self,\n    vis_params,\n    index=None,\n    label=\"\",\n    categorical=False,\n    step=None,\n    background_color=None,\n    **kwargs,\n):\n\"\"\"Add a colorbar to the map.\n\n    Args:\n        colors (list): The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)\n        vmin (int, optional): The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.\n        vmax (float, optional): The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.\n        index (list, optional):The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.\n        label (str, optional): The caption for the colormap. Defaults to \"\".\n        categorical (bool, optional): Whether or not to create a categorical colormap. Defaults to False.\n        step (int, optional): The step to split the LinearColormap into a StepColormap. Defaults to None.\n    \"\"\"\n    from box import Box\n    from branca.colormap import LinearColormap\n\n    if not isinstance(vis_params, dict):\n        raise ValueError(\"vis_params must be a dictionary.\")\n\n    if \"palette\" not in vis_params:\n        raise ValueError(\"vis_params must contain a palette.\")\n\n    if \"min\" not in vis_params:\n        vis_params[\"min\"] = 0\n    if \"max\" not in vis_params:\n        vis_params[\"max\"] = 1\n\n    colors = to_hex_colors(check_cmap(vis_params[\"palette\"]))\n    vmin = vis_params[\"min\"]\n    vmax = vis_params[\"max\"]\n\n    if isinstance(colors, Box):\n        try:\n            colors = list(colors[\"default\"])\n        except Exception as e:\n            print(\"The provided color list is invalid.\")\n            raise Exception(e)\n\n    if all(len(color) == 6 for color in colors):\n        colors = [\"#\" + color for color in colors]\n\n    colormap = LinearColormap(\n        colors=colors, index=index, vmin=vmin, vmax=vmax, caption=label\n    )\n\n    if categorical:\n        if step is not None:\n            colormap = colormap.to_step(step)\n        elif index is not None:\n            colormap = colormap.to_step(len(index) - 1)\n        else:\n            colormap = colormap.to_step(3)\n\n    if background_color is not None:\n        svg_style = (\n            \"&lt;style&gt;svg {background-color: \" + background_color + \";}&lt;/style&gt;\"\n        )\n\n        self.get_root().header.add_child(folium.Element(svg_style))\n\n    self.add_child(colormap)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_colormap","title":"<code>add_colormap(self, width=4.0, height=0.3, vmin=0, vmax=1.0, palette=None, vis_params=None, cmap='gray', discrete=False, label=None, label_size=10, label_weight='normal', tick_size=8, bg_color='white', orientation='horizontal', dpi='figure', transparent=False, position=(70, 5), **kwargs)</code>","text":"<p>Add a colorbar to the map. Under the hood, it uses matplotlib to generate the colorbar, save it as a png file, and add it to the map using m.add_image().</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the colorbar in inches. Default is 4.0.</p> <code>4.0</code> <code>height</code> <code>float</code> <p>Height of the colorbar in inches. Default is 0.3.</p> <code>0.3</code> <code>vmin</code> <code>float</code> <p>Minimum value of the colorbar. Default is 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value of the colorbar. Default is 1.0.</p> <code>1.0</code> <code>palette</code> <code>list</code> <p>List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>label_size</code> <code>int</code> <p>Font size for the colorbar label. Defaults to 12.</p> <code>10</code> <code>label_weight</code> <code>str</code> <p>Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".</p> <code>'normal'</code> <code>tick_size</code> <code>int</code> <p>Font size for the colorbar tick labels. Defaults to 10.</p> <code>8</code> <code>bg_color</code> <code>str</code> <p>Background color for the colorbar. Defaults to \"white\".</p> <code>'white'</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>dpi</code> <code>float | str</code> <p>The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".</p> <code>'figure'</code> <code>transparent</code> <code>bool</code> <p>Whether to make the background transparent. Defaults to False.</p> <code>False</code> <code>position</code> <code>tuple</code> <p>The position of the colormap in the format of (x, y), the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).</p> <code>(70, 5)</code> <code>**kwargs</code> <p>Other keyword arguments to pass to matplotlib.pyplot.savefig().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the output image.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_colormap(\n    self,\n    width=4.0,\n    height=0.3,\n    vmin=0,\n    vmax=1.0,\n    palette=None,\n    vis_params=None,\n    cmap=\"gray\",\n    discrete=False,\n    label=None,\n    label_size=10,\n    label_weight=\"normal\",\n    tick_size=8,\n    bg_color=\"white\",\n    orientation=\"horizontal\",\n    dpi=\"figure\",\n    transparent=False,\n    position=(70, 5),\n    **kwargs,\n):\n\"\"\"Add a colorbar to the map. Under the hood, it uses matplotlib to generate the colorbar, save it as a png file, and add it to the map using m.add_image().\n\n    Args:\n        width (float): Width of the colorbar in inches. Default is 4.0.\n        height (float): Height of the colorbar in inches. Default is 0.3.\n        vmin (float): Minimum value of the colorbar. Default is 0.\n        vmax (float): Maximum value of the colorbar. Default is 1.0.\n        palette (list): List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.\n        vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n        label_weight (str, optional): Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".\n        tick_size (int, optional): Font size for the colorbar tick labels. Defaults to 10.\n        bg_color (str, optional): Background color for the colorbar. Defaults to \"white\".\n        orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n        dpi (float | str, optional): The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".\n        transparent (bool, optional): Whether to make the background transparent. Defaults to False.\n        position (tuple, optional): The position of the colormap in the format of (x, y),\n            the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).\n        **kwargs: Other keyword arguments to pass to matplotlib.pyplot.savefig().\n\n    Returns:\n        str: Path to the output image.\n    \"\"\"\n\n    colorbar = save_colorbar(\n        None,\n        width,\n        height,\n        vmin,\n        vmax,\n        palette,\n        vis_params,\n        cmap,\n        discrete,\n        label,\n        label_size,\n        label_weight,\n        tick_size,\n        bg_color,\n        orientation,\n        dpi,\n        transparent,\n        show_colorbar=False,\n        **kwargs,\n    )\n\n    self.add_image(colorbar, position=position)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_data","title":"<code>add_data(self, data, column, colors=None, labels=None, cmap=None, scheme='Quantiles', k=5, add_legend=True, legend_title=None, legend_kwds=None, classification_kwds=None, style_function=None, highlight_function=None, layer_name='Untitled', info_mode='on_hover', encoding='utf-8', **kwargs)</code>","text":"<p>Add vector data to the map with a variety of classification schemes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame | gpd.GeoDataFrame</code> <p>The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.</p> required <code>column</code> <code>str</code> <p>The column to classify.</p> required <code>cmap</code> <code>str</code> <p>The name of a colormap recognized by matplotlib. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of colors to use for the classification. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of labels to use for the legend. Defaults to None.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>Name of a choropleth classification scheme (requires mapclassify). Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if scheme is None or if column is categorical). Default to 5.</p> <code>5</code> <code>legend_kwds</code> <code>dict</code> <p>Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or <code>matplotlib.pyplot.colorbar</code>. Defaults to None. Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or Additional accepted keywords when <code>scheme</code> is specified: fmt : string     A formatting specification for the bin edges of the classes in the     legend. For example, to have no decimals: <code>{\"fmt\": \"{:.0f}\"}</code>. labels : list-like     A list of legend labels to override the auto-generated labblels.     Needs to have the same number of elements as the number of     classes (<code>k</code>). interval : boolean (default False)     An option to control brackets from mapclassify legend.     If True, open/closed interval brackets are shown in the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Keyword arguments to pass to mapclassify. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style_function</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None. style_callback is a function that takes the feature as argument and should return a dictionary of the following form: style_callback = lambda feat: {\"fillColor\": feat\"properties\"} style is a dictionary of the following form:     style = {     \"stroke\": False,     \"color\": \"#ff0000\",     \"weight\": 1,     \"opacity\": 1,     \"fill\": True,     \"fillColor\": \"#ffffff\",     \"fillOpacity\": 1.0,     \"dashArray\": \"9\"     \"clickable\": True, }</p> <code>None</code> <code>hightlight_function</code> <code>function</code> <p>Highlighting function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None. highlight_function is a function that takes the feature as argument and should return a dictionary of the following form: highlight_function = lambda feat: {\"fillColor\": feat\"properties\"}</p> required <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_data(\n    self,\n    data,\n    column,\n    colors=None,\n    labels=None,\n    cmap=None,\n    scheme=\"Quantiles\",\n    k=5,\n    add_legend=True,\n    legend_title=None,\n    legend_kwds=None,\n    classification_kwds=None,\n    style_function=None,\n    highlight_function=None,\n    layer_name=\"Untitled\",\n    info_mode=\"on_hover\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n\"\"\"Add vector data to the map with a variety of classification schemes.\n\n    Args:\n        data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n        column (str): The column to classify.\n        cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n        colors (list, optional): A list of colors to use for the classification. Defaults to None.\n        labels (list, optional): A list of labels to use for the legend. Defaults to None.\n        scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n        legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n            Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n            Additional accepted keywords when `scheme` is specified:\n            fmt : string\n                A formatting specification for the bin edges of the classes in the\n                legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n            labels : list-like\n                A list of legend labels to override the auto-generated labblels.\n                Needs to have the same number of elements as the number of\n                classes (`k`).\n            interval : boolean (default False)\n                An option to control brackets from mapclassify legend.\n                If True, open/closed interval brackets are shown in the legend.\n        classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style_function (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            style_callback is a function that takes the feature as argument and should return a dictionary of the following form:\n            style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n            style is a dictionary of the following form:\n                style = {\n                \"stroke\": False,\n                \"color\": \"#ff0000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                \"fill\": True,\n                \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 1.0,\n                \"dashArray\": \"9\"\n                \"clickable\": True,\n            }\n        hightlight_function (function, optional): Highlighting function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            highlight_function is a function that takes the feature as argument and should return a dictionary of the following form:\n            highlight_function = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n    \"\"\"\n\n    import warnings\n\n    gdf, legend_dict = classify(\n        data=data,\n        column=column,\n        cmap=cmap,\n        colors=colors,\n        labels=labels,\n        scheme=scheme,\n        k=k,\n        legend_kwds=legend_kwds,\n        classification_kwds=classification_kwds,\n    )\n\n    if legend_title is None:\n        legend_title = column\n\n    if \"style\" in kwargs:\n        warnings.warn(\n            \"The style arguments is for ipyleaflet only. \",\n            UserWarning,\n        )\n        kwargs.pop(\"style\")\n\n    if \"hover_style\" in kwargs:\n        warnings.warn(\n            \"The hover_style arguments is for ipyleaflet only. \",\n            UserWarning,\n        )\n        kwargs.pop(\"hover_style\")\n\n    if \"style_callback\" in kwargs:\n        warnings.warn(\n            \"The style_callback arguments is for ipyleaflet only. \",\n            UserWarning,\n        )\n        kwargs.pop(\"style_callback\")\n\n    if style_function is None:\n        style_function = lambda feat: {\n            # \"stroke\": False,\n            # \"color\": \"#ff0000\",\n            \"weight\": 1,\n            \"opacity\": 1,\n            # \"fill\": True,\n            # \"fillColor\": \"#ffffff\",\n            \"fillOpacity\": 1.0,\n            # \"dashArray\": \"9\"\n            # \"clickable\": True,\n            \"fillColor\": feat[\"properties\"][\"color\"],\n        }\n\n    if highlight_function is None:\n        highlight_function = lambda feat: {\n            \"weight\": 2,\n            \"fillOpacity\": 0.5,\n        }\n\n    self.add_gdf(\n        gdf,\n        layer_name=layer_name,\n        style_function=style_function,\n        highlight_function=highlight_function,\n        info_mode=info_mode,\n        encoding=encoding,\n        **kwargs,\n    )\n    if add_legend:\n        self.add_legend(title=legend_title, legend_dict=legend_dict)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_gdf","title":"<code>add_gdf(self, gdf, layer_name='Untitled', zoom_to_layer=True, info_mode='on_hover', fields=None, **kwargs)</code>","text":"<p>Adds a GeoPandas GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer.</p> <code>True</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>fields</code> <code>list</code> <p>The fields to be displayed in the popup. Defaults to None.</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_gdf(\n    self,\n    gdf,\n    layer_name=\"Untitled\",\n    zoom_to_layer=True,\n    info_mode=\"on_hover\",\n    fields=None,\n    **kwargs,\n):\n\"\"\"Adds a GeoPandas GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer.\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click.\n            Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        fields (list, optional): The fields to be displayed in the popup. Defaults to None.\n\n    \"\"\"\n\n    data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n    self.add_geojson(\n        data, layer_name=layer_name, info_mode=info_mode, fields=fields, **kwargs\n    )\n\n    if zoom_to_layer:\n        import numpy as np\n\n        bounds = gdf.to_crs(epsg=\"4326\").bounds\n        west = np.min(bounds[\"minx\"])\n        south = np.min(bounds[\"miny\"])\n        east = np.max(bounds[\"maxx\"])\n        north = np.max(bounds[\"maxy\"])\n        self.fit_bounds([[south, east], [north, west]])\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_gdf_from_postgis","title":"<code>add_gdf_from_postgis(self, sql, con, layer_name='Untitled', zoom_to_layer=True, **kwargs)</code>","text":"<p>Adds a GeoPandas GeoDataFrameto the map.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer.</p> <code>True</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_gdf_from_postgis(\n    self, sql, con, layer_name=\"Untitled\", zoom_to_layer=True, **kwargs\n):\n\"\"\"Adds a GeoPandas GeoDataFrameto the map.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer.\n\n    \"\"\"\n    if \"fill_colors\" in kwargs:\n        kwargs.pop(\"fill_colors\")\n    gdf = read_postgis(sql, con, **kwargs)\n    data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n    self.add_geojson(data, layer_name=layer_name, **kwargs)\n\n    if zoom_to_layer:\n        import numpy as np\n\n        bounds = gdf.to_crs(epsg=\"4326\").bounds\n        west = np.min(bounds[\"minx\"])\n        south = np.min(bounds[\"miny\"])\n        east = np.max(bounds[\"maxx\"])\n        north = np.max(bounds[\"maxy\"])\n        self.fit_bounds([[south, east], [north, west]])\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_geojson","title":"<code>add_geojson(self, in_geojson, layer_name='Untitled', encoding='utf-8', info_mode='on_hover', fields=None, **kwargs)</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str</code> <p>The input file path to the GeoJSON.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>fields</code> <code>list</code> <p>The fields to be displayed in the popup. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided GeoJSON file could not be found.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_geojson(\n    self,\n    in_geojson,\n    layer_name=\"Untitled\",\n    encoding=\"utf-8\",\n    info_mode=\"on_hover\",\n    fields=None,\n    **kwargs,\n):\n\"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        in_geojson (str): The input file path to the GeoJSON.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        fields (list, optional): The fields to be displayed in the popup. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided GeoJSON file could not be found.\n    \"\"\"\n    import json\n    import requests\n    import random\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                in_geojson = github_raw_url(in_geojson)\n                data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n    except Exception as e:\n        raise Exception(e)\n\n    # interchangeable parameters between ipyleaflet and folium.\n    if \"style_function\" not in kwargs:\n        if \"style\" in kwargs:\n            style_dict = kwargs[\"style\"]\n            if isinstance(kwargs[\"style\"], dict) and len(kwargs[\"style\"]) &gt; 0:\n                kwargs[\"style_function\"] = lambda x: style_dict\n            kwargs.pop(\"style\")\n        else:\n            style_dict = {\n                # \"stroke\": True,\n                \"color\": \"#000000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 0.1,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n            }\n            kwargs[\"style_function\"] = lambda x: style_dict\n\n    if \"style_callback\" in kwargs:\n        kwargs.pop(\"style_callback\")\n\n    if \"hover_style\" in kwargs:\n        kwargs.pop(\"hover_style\")\n\n    if \"fill_colors\" in kwargs:\n        fill_colors = kwargs[\"fill_colors\"]\n\n        def random_color(feature):\n            style_dict[\"fillColor\"] = random.choice(fill_colors)\n            return style_dict\n\n        kwargs[\"style_function\"] = random_color\n        kwargs.pop(\"fill_colors\")\n\n    if \"highlight_function\" not in kwargs:\n        kwargs[\"highlight_function\"] = lambda feat: {\n            \"weight\": 2,\n            \"fillOpacity\": 0.5,\n        }\n\n    tooltip = None\n    popup = None\n    if info_mode is not None:\n        if fields is None:\n            fields = list(data[\"features\"][0][\"properties\"].keys())\n        if info_mode == \"on_hover\":\n            tooltip = folium.GeoJsonTooltip(fields=fields)\n        elif info_mode == \"on_click\":\n            popup = folium.GeoJsonPopup(fields=fields)\n\n    geojson = folium.GeoJson(\n        data=data, name=layer_name, tooltip=tooltip, popup=popup, **kwargs\n    )\n    geojson.add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', value='value', name='Heat map', radius=25, **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | list | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/world_cities.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>value</code> <code>str</code> <p>The column name of values. Defaults to \"value\".</p> <code>'value'</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>25</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data is not a list.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_heatmap(\n    self,\n    data,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"value\",\n    name=\"Heat map\",\n    radius=25,\n    **kwargs,\n):\n\"\"\"Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617\n\n    Args:\n        data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/world_cities.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        value (str, optional): The column name of values. Defaults to \"value\".\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n    Raises:\n        ValueError: If data is not a list.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n            data = df[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, pd.DataFrame):\n            data = data[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, list):\n            pass\n        else:\n            raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n        plugins.HeatMap(data, name=name, radius=radius, **kwargs).add_to(\n            folium.FeatureGroup(name=name).add_to(self)\n        )\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_html","title":"<code>add_html(self, html, position='bottomright', **kwargs)</code>","text":"<p>Add HTML to the map.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML to add.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_html(self, html, position=\"bottomright\", **kwargs):\n\"\"\"Add HTML to the map.\n\n    Args:\n        html (str): The HTML to add.\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n    \"\"\"\n\n    self.add_widget(html, position=position, **kwargs)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_image","title":"<code>add_image(self, image, position=(0, 0), **kwargs)</code>","text":"<p>Add an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | ipywidgets.Image</code> <p>The image to add.</p> required <code>position</code> <code>tuple</code> <p>The position of the image in the format of (x, y), the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).</p> <code>(0, 0)</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_image(self, image, position=(0, 0), **kwargs):\n\"\"\"Add an image to the map.\n\n    Args:\n        image (str | ipywidgets.Image): The image to add.\n        position (tuple, optional): The position of the image in the format of (x, y),\n            the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).\n    \"\"\"\n    import base64\n\n    if isinstance(image, str):\n        if image.startswith(\"http\"):\n            html = f'&lt;img src=\"{image}\"&gt;'\n            if isinstance(position, tuple):\n                position = \"bottomright\"\n            self.add_html(html, position=position, **kwargs)\n\n        elif os.path.exists(image):\n            if position == \"bottomleft\":\n                position = (5, 5)\n            elif position == \"bottomright\":\n                position = (80, 5)\n            elif position == \"topleft\":\n                position = (5, 60)\n            elif position == \"topright\":\n                position = (80, 60)\n\n            with open(image, \"rb\") as lf:\n                # open in binary mode, read bytes, encode, decode obtained bytes as utf-8 string\n                b64_content = base64.b64encode(lf.read()).decode(\"utf-8\")\n                widget = plugins.FloatImage(\n                    \"data:image/png;base64,{}\".format(b64_content),\n                    bottom=position[1],\n                    left=position[0],\n                )\n                widget.add_to(self)\n\n    else:\n        raise Exception(\"Invalid image\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_kml","title":"<code>add_kml(self, in_kml, layer_name='Untitled', info_mode='on_hover', fields=None, **kwargs)</code>","text":"<p>Adds a KML file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The input file path to the KML.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>fields</code> <code>list</code> <p>The fields to be displayed in the popup. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided KML file could not be found.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_kml(\n    self, in_kml, layer_name=\"Untitled\", info_mode=\"on_hover\", fields=None, **kwargs\n):\n\"\"\"Adds a KML file to the map.\n\n    Args:\n        in_kml (str): The input file path to the KML.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click.\n            Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        fields (list, optional): The fields to be displayed in the popup. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided KML file could not be found.\n    \"\"\"\n\n    if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n        out_dir = os.path.abspath(\"./cache\")\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        download_from_url(in_kml, out_dir=out_dir, unzip=False, verbose=False)\n        in_kml = os.path.join(out_dir, os.path.basename(in_kml))\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n    else:\n        in_kml = os.path.abspath(in_kml)\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The provided KML could not be found.\")\n\n    data = kml_to_geojson(in_kml)\n\n    self.add_geojson(\n        data, layer_name=layer_name, info_mode=info_mode, fields=fields, **kwargs\n    )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_labels","title":"<code>add_labels(self, data, column, font_size='12pt', font_color='black', font_family='arial', font_weight='normal', x='longitude', y='latitude', draggable=True, layer_name='Labels', **kwargs)</code>","text":"<p>Adds a label layer to the map. Reference: https://python-visualization.github.io/folium/modules.html#folium.features.DivIcon</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame | ee.FeatureCollection</code> <p>The input data to label.</p> required <code>column</code> <code>str</code> <p>The column name of the data to label.</p> required <code>font_size</code> <code>str</code> <p>The font size of the labels. Defaults to \"12pt\".</p> <code>'12pt'</code> <code>font_color</code> <code>str</code> <p>The font color of the labels. Defaults to \"black\".</p> <code>'black'</code> <code>font_family</code> <code>str</code> <p>The font family of the labels. Defaults to \"arial\".</p> <code>'arial'</code> <code>font_weight</code> <code>str</code> <p>The font weight of the labels, can be normal, bold. Defaults to \"normal\".</p> <code>'normal'</code> <code>x</code> <code>str</code> <p>The column name of the longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name of the latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>draggable</code> <code>bool</code> <p>Whether the labels are draggable. Defaults to True.</p> <code>True</code> <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"Labels\".</p> <code>'Labels'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_labels(\n    self,\n    data,\n    column,\n    font_size=\"12pt\",\n    font_color=\"black\",\n    font_family=\"arial\",\n    font_weight=\"normal\",\n    x=\"longitude\",\n    y=\"latitude\",\n    draggable=True,\n    layer_name=\"Labels\",\n    **kwargs,\n):\n\"\"\"Adds a label layer to the map. Reference: https://python-visualization.github.io/folium/modules.html#folium.features.DivIcon\n\n    Args:\n        data (pd.DataFrame | ee.FeatureCollection): The input data to label.\n        column (str): The column name of the data to label.\n        font_size (str, optional): The font size of the labels. Defaults to \"12pt\".\n        font_color (str, optional): The font color of the labels. Defaults to \"black\".\n        font_family (str, optional): The font family of the labels. Defaults to \"arial\".\n        font_weight (str, optional): The font weight of the labels, can be normal, bold. Defaults to \"normal\".\n        x (str, optional): The column name of the longitude. Defaults to \"longitude\".\n        y (str, optional): The column name of the latitude. Defaults to \"latitude\".\n        draggable (bool, optional): Whether the labels are draggable. Defaults to True.\n        layer_name (str, optional): The name of the layer. Defaults to \"Labels\".\n\n    \"\"\"\n    import warnings\n    import pandas as pd\n    from folium.features import DivIcon\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(data, ee.FeatureCollection):\n        centroids = vector_centroids(data)\n        df = ee_to_df(centroids)\n    elif isinstance(data, pd.DataFrame):\n        df = data\n    elif isinstance(data, str):\n        ext = os.path.splitext(data)[1]\n        if ext == \".csv\":\n            df = pd.read_csv(data)\n        elif ext in [\".geojson\", \".json\", \".shp\", \".gpkg\"]:\n            try:\n                import geopandas as gpd\n\n                df = gpd.read_file(data)\n                df[x] = df.centroid.x\n                df[y] = df.centroid.y\n            except Exception as e:\n                print(\"geopandas is required to read geojson.\")\n                print(e)\n                return\n    else:\n        raise ValueError(\"data must be a DataFrame or an ee.FeatureCollection.\")\n\n    if column not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n    if x not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n    if y not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n\n    try:\n        size = int(font_size.replace(\"pt\", \"\"))\n    except Exception as _:\n        raise ValueError(\"font_size must be something like '10pt'\")\n\n    layer_group = folium.FeatureGroup(name=layer_name)\n    for index in df.index:\n        html = f'&lt;div style=\"font-size: {font_size};color:{font_color};font-family:{font_family};font-weight: {font_weight}\"&gt;{df[column][index]}&lt;/div&gt;'\n        folium.Marker(\n            location=[df[y][index], df[x][index]],\n            icon=DivIcon(\n                icon_size=(1, 1),\n                icon_anchor=(size, size),\n                html=html,\n                **kwargs,\n            ),\n            draggable=draggable,\n        ).add_to(layer_group)\n\n    layer_group.add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_layer","title":"<code>add_layer(self, ee_object, vis_params={}, name='Layer untitled', shown=True, opacity=1.0, **kwargs)</code>","text":"<p>Adds a given EE object to the map as a layer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer untitled'.</p> <code>'Layer untitled'</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_layer(\n    self,\n    ee_object,\n    vis_params={},\n    name=\"Layer untitled\",\n    shown=True,\n    opacity=1.0,\n    **kwargs,\n):\n\"\"\"Adds a given EE object to the map as a layer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer untitled'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n\n    from box import Box\n\n    image = None\n    if vis_params is None:\n        vis_params = {}\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], tuple):\n            vis_params[\"palette\"] = list(vis_params[\"palette\"])\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n\n    # if a layer starts with a number, add \"Layer\" to name.\n    if name[0].isdigit():\n        name = \"Layer \" + name\n\n    url = map_id_dict[\"tile_fetcher\"].url_format\n    folium.raster_layers.TileLayer(\n        tiles=url,\n        attr=\"Google Earth Engine\",\n        name=name,\n        overlay=True,\n        control=True,\n        show=shown,\n        opacity=opacity,\n        max_zoom=24,\n        **kwargs,\n    ).add_to(self)\n\n    arc_add_layer(url, name, shown, opacity)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds layer control to the map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_layer_control(self):\n\"\"\"Adds layer control to the map.\"\"\"\n    layer_ctrl = False\n    for item in self.to_dict()[\"children\"]:\n        if item.startswith(\"layer_control\"):\n            layer_ctrl = True\n            break\n    if not layer_ctrl:\n        folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_legend","title":"<code>add_legend(self, title='Legend', labels=None, colors=None, legend_dict=None, builtin_legend=None, opacity=1.0, position='bottomright', draggable=True, style={})</code>","text":"<p>Adds a customized legend to the map. Reference: https://bit.ly/3oV6vnH.     If you want to add multiple legends to the map, you need to set the <code>draggable</code> argument to False.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".</p> <code>'Legend'</code> <code>colors</code> <code>list</code> <p>A list of legend colors. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of legend labels. Defaults to None.</p> <code>None</code> <code>legend_dict</code> <code>dict</code> <p>A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.</p> <code>None</code> <code>builtin_legend</code> <code>str</code> <p>Name of the builtin legend to add to the map. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the legend. Defaults to 1.0.</p> <code>1.0</code> <code>position</code> <code>str</code> <p>The position of the legend, can be one of the following: \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>draggable</code> <code>bool</code> <p>If True, the legend can be dragged to a new position. Defaults to True.</p> <code>True</code> <code>style</code> <p>Additional keyword arguments to style the legend, such as position, bottom, right, z-index, border, background-color, border-radius, padding, font-size, etc. The default style is: style = {     'position': 'fixed',     'z-index': '9999',     'border': '2px solid grey',     'background-color': 'rgba(255, 255, 255, 0.8)',     'border-radius': '5px',     'padding': '10px',     'font-size': '14px',     'bottom': '20px',     'right': '5px' }</p> <code>{}</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_legend(\n    self,\n    title=\"Legend\",\n    labels=None,\n    colors=None,\n    legend_dict=None,\n    builtin_legend=None,\n    opacity=1.0,\n    position=\"bottomright\",\n    draggable=True,\n    style={},\n):\n\"\"\"Adds a customized legend to the map. Reference: https://bit.ly/3oV6vnH.\n        If you want to add multiple legends to the map, you need to set the `draggable` argument to False.\n\n    Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".\n        colors (list, optional): A list of legend colors. Defaults to None.\n        labels (list, optional): A list of legend labels. Defaults to None.\n        legend_dict (dict, optional): A dictionary containing legend items as keys and color as values.\n            If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n        builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n        opacity (float, optional): The opacity of the legend. Defaults to 1.0.\n        position (str, optional): The position of the legend, can be one of the following:\n            \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n        draggable (bool, optional): If True, the legend can be dragged to a new position. Defaults to True.\n        style: Additional keyword arguments to style the legend, such as position, bottom, right, z-index,\n            border, background-color, border-radius, padding, font-size, etc. The default style is:\n            style = {\n                'position': 'fixed',\n                'z-index': '9999',\n                'border': '2px solid grey',\n                'background-color': 'rgba(255, 255, 255, 0.8)',\n                'border-radius': '5px',\n                'padding': '10px',\n                'font-size': '14px',\n                'bottom': '20px',\n                'right': '5px'\n            }\n\n    \"\"\"\n    content = create_legend(\n        title,\n        labels,\n        colors,\n        legend_dict,\n        builtin_legend,\n        opacity,\n        position,\n        draggable,\n        style=style,\n    )\n    if draggable:\n        from branca.element import Template, MacroElement\n\n        content = (\n            '\"\"\"\\n{% macro html(this, kwargs) %}\\n'\n            + content\n            + '\\n{% endmacro %}\"\"\"'\n        )\n\n        macro = MacroElement()\n        macro._template = Template(content)\n\n        self.get_root().add_child(macro)\n    else:\n        self.add_html(content, position=position)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_marker","title":"<code>add_marker(self, location, popup=None, tooltip=None, icon=None, draggable=False, **kwargs)</code>","text":"<p>Adds a marker to the map. More info about marker options at https://python-visualization.github.io/folium/modules.html#folium.map.Marker.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>list | tuple</code> <p>The location of the marker in the format of [lat, lng].</p> required <code>popup</code> <code>str</code> <p>The popup text. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>str</code> <p>The tooltip text. Defaults to None.</p> <code>None</code> <code>icon</code> <code>str</code> <p>The icon to use. Defaults to None.</p> <code>None</code> <code>draggable</code> <code>bool</code> <p>Whether the marker is draggable. Defaults to False.</p> <code>False</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_marker(\n    self, location, popup=None, tooltip=None, icon=None, draggable=False, **kwargs\n):\n\"\"\"Adds a marker to the map. More info about marker options at https://python-visualization.github.io/folium/modules.html#folium.map.Marker.\n\n    Args:\n        location (list | tuple): The location of the marker in the format of [lat, lng].\n        popup (str, optional): The popup text. Defaults to None.\n        tooltip (str, optional): The tooltip text. Defaults to None.\n        icon (str, optional): The icon to use. Defaults to None.\n        draggable (bool, optional): Whether the marker is draggable. Defaults to False.\n    \"\"\"\n    if isinstance(location, list):\n        location = tuple(location)\n    if isinstance(location, tuple):\n        folium.Marker(\n            location=location,\n            popup=popup,\n            tooltip=tooltip,\n            icon=icon,\n            draggable=draggable,\n            **kwargs,\n        ).add_to(self)\n\n    else:\n        raise TypeError(\"The location must be a list or a tuple.\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_markers_from_xy","title":"<code>add_markers_from_xy(self, data, x='longitude', y='latitude', popup=None, min_width=100, max_width=200, layer_name='Marker Cluster', color_column=None, marker_colors=None, icon_colors=['white'], icon_names=['info'], angle=0, prefix='fa', add_legend=True, **kwargs)</code>","text":"<p>Adds a marker cluster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>min_width</code> <code>int</code> <p>The minimum width of the popup. Defaults to 100.</p> <code>100</code> <code>max_width</code> <code>int</code> <p>The maximum width of the popup. Defaults to 200.</p> <code>200</code> <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"Marker Cluster\".</p> <code>'Marker Cluster'</code> <code>color_column</code> <code>str</code> <p>The column name for the color values. Defaults to None.</p> <code>None</code> <code>marker_colors</code> <code>list</code> <p>A list of colors to be used for the markers. Defaults to None.</p> <code>None</code> <code>icon_colors</code> <code>list</code> <p>A list of colors to be used for the icons. Defaults to ['white'].</p> <code>['white']</code> <code>icon_names</code> <code>list</code> <p>A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons or https://getbootstrap.com/docs/3.3/components/?utm_source=pocket_mylist. Defaults to ['info'].</p> <code>['info']</code> <code>angle</code> <code>int</code> <p>The angle of the icon. Defaults to 0.</p> <code>0</code> <code>prefix</code> <code>str</code> <p>The prefix states the source of the icon. 'fa' for font-awesome or 'glyphicon' for bootstrap 3. Defaults to 'fa'.</p> <code>'fa'</code> <code>add_legend</code> <code>bool</code> <p>If True, a legend will be added to the map. Defaults to True.</p> <code>True</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_markers_from_xy(\n    self,\n    data,\n    x=\"longitude\",\n    y=\"latitude\",\n    popup=None,\n    min_width=100,\n    max_width=200,\n    layer_name=\"Marker Cluster\",\n    color_column=None,\n    marker_colors=None,\n    icon_colors=[\"white\"],\n    icon_names=[\"info\"],\n    angle=0,\n    prefix=\"fa\",\n    add_legend=True,\n    **kwargs,\n):\n\"\"\"Adds a marker cluster to the map.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        min_width (int, optional): The minimum width of the popup. Defaults to 100.\n        max_width (int, optional): The maximum width of the popup. Defaults to 200.\n        layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n        color_column (str, optional): The column name for the color values. Defaults to None.\n        marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n        icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n        icon_names (list, optional): A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons or https://getbootstrap.com/docs/3.3/components/?utm_source=pocket_mylist. Defaults to ['info'].\n        angle (int, optional): The angle of the icon. Defaults to 0.\n        prefix (str, optional): The prefix states the source of the icon. 'fa' for font-awesome or 'glyphicon' for bootstrap 3. Defaults to 'fa'.\n        add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n    \"\"\"\n    import pandas as pd\n    from folium.plugins import BeautifyIcon\n\n    color_options = [\n        \"red\",\n        \"blue\",\n        \"green\",\n        \"purple\",\n        \"orange\",\n        \"darkred\",\n        \"lightred\",\n        \"beige\",\n        \"darkblue\",\n        \"darkgreen\",\n        \"cadetblue\",\n        \"darkpurple\",\n        \"white\",\n        \"pink\",\n        \"lightblue\",\n        \"lightgreen\",\n        \"gray\",\n        \"black\",\n        \"lightgray\",\n    ]\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    else:\n        df = pd.read_csv(data)\n\n    col_names = df.columns.values.tolist()\n\n    if color_column is not None and color_column not in col_names:\n        raise ValueError(\n            f\"The color column {color_column} does not exist in the dataframe.\"\n        )\n\n    if color_column is not None:\n        items = list(set(df[color_column]))\n    else:\n        items = None\n\n    if color_column is not None and marker_colors is None:\n        if len(items) &gt; len(color_options):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n            )\n        else:\n            marker_colors = color_options[: len(items)]\n    elif color_column is not None and marker_colors is not None:\n        if len(items) != len(marker_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if items is not None:\n        if len(icon_colors) == 1:\n            icon_colors = icon_colors * len(items)\n        elif len(items) != len(icon_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n        if len(icon_names) == 1:\n            icon_names = icon_names * len(items)\n        elif len(items) != len(icon_names):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if popup is None:\n        popup = col_names\n\n    if x not in col_names:\n        raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n    if y not in col_names:\n        raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n    # marker_cluster = plugins.MarkerCluster(name=layer_name).add_to(self)\n    for row in df.itertuples():\n        html = \"\"\n        for p in popup:\n            html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(getattr(row, p)) + \"&lt;br&gt;\"\n        popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n        if items is not None:\n            index = items.index(getattr(row, color_column))\n            marker_icon = folium.Icon(\n                color=marker_colors[index],\n                icon_color=icon_colors[index],\n                icon=icon_names[index],\n                angle=angle,\n                prefix=prefix,\n            )\n        else:\n            marker_icon = None\n\n        icon_square = BeautifyIcon(\n            icon_shape=\"rectangle-dot\",\n            border_color=\"red\",\n            border_width=10,\n        )\n\n        icon_circle = BeautifyIcon(\n            icon_shape=\"circle-dot\",\n            border_color=\"green\",\n            border_width=10,\n        )\n        icon_star = BeautifyIcon(\n            icon=\"star\",\n            inner_icon_style=\"color:blue;font-size:20px;\",\n            background_color=\"transparent\",\n            border_color=\"transparent\",\n        )\n\n        folium.Marker(\n            location=[getattr(row, y), getattr(row, x)],\n            popup=popup_html,\n            icon=icon_star,\n        ).add_to(self)\n\n    # folium.Marker([50, -70], tooltip=\"square\", icon=icon, name=\"marker\").add_to(\n    #     self\n    # )\n    # folium.Marker([50, 70], tooltip=\"square\", icon=icon2).add_to(self)\n    if items is not None and add_legend:\n        marker_colors = [check_color(c) for c in marker_colors]\n        self.add_legend(\n            title=color_column.title(), colors=marker_colors, labels=items\n        )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_netcdf","title":"<code>add_netcdf(self, filename, variables=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='NetCDF layer', shift_lon=True, lat='lat', lon='lon', **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a netCDF file.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),     try adding to following two lines to the beginning of the notebook if the raster does not render properly.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netCDF file.</p> required <code>variables</code> <code>int</code> <p>The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> required <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"netCDF layer\".</p> <code>'NetCDF layer'</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_netcdf(\n    self,\n    filename,\n    variables=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=\"NetCDF layer\",\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    **kwargs,\n):\n\"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n        try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n    Args:\n        filename (str): File path or HTTP URL to the netCDF file.\n        variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to \"netCDF layer\".\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n    \"\"\"\n\n    if in_colab_shell():\n        print(\"The add_netcdf() function is not supported in Colab.\")\n        return\n\n    tif, vars = netcdf_to_tif(\n        filename, shift_lon=shift_lon, lat=lat, lon=lon, return_vars=True\n    )\n\n    if variables is None:\n        if len(vars) &gt;= 3:\n            band_idx = [1, 2, 3]\n        else:\n            band_idx = [1]\n    else:\n        if not set(variables).issubset(set(vars)):\n            raise ValueError(f\"The variables must be a subset of {vars}.\")\n        else:\n            band_idx = [vars.index(v) + 1 for v in variables]\n\n    self.add_local_tile(\n        tif,\n        band=band_idx,\n        palette=palette,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_osm","title":"<code>add_osm(self, query, layer_name='Untitled', which_result=None, by_osmid=False, buffer_dist=None, to_ee=False, geodesic=True, **kwargs)</code>","text":"<p>Adds OSM data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> required <code>which_result</code> <code>INT</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>to_ee</code> <code>bool</code> <p>Whether to convert the csv to an ee.FeatureCollection.</p> <code>False</code> <code>geodesic</code> <code>bool</code> <p>Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.</p> <code>True</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_osm(\n    self,\n    query,\n    layer_name=\"Untitled\",\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n    to_ee=False,\n    geodesic=True,\n    **kwargs,\n):\n\"\"\"Adds OSM data to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        to_ee (bool, optional): Whether to convert the csv to an ee.FeatureCollection.\n        geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.\n\n    \"\"\"\n\n    gdf = osm_to_gdf(\n        query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n    )\n    geojson = gdf.__geo_interface__\n\n    if to_ee:\n        fc = geojson_to_ee(geojson, geodesic=geodesic)\n        self.addLayer(fc, {}, layer_name)\n        self.centerObject(fc)\n    else:\n        self.add_geojson(geojson, layer_name=layer_name, **kwargs)\n        bounds = gdf.bounds.iloc[0]\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_osm_from_address","title":"<code>add_osm_from_address(self, address, tags, dist=1000, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within some distance N, S, E, W of address to the map.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_osm_from_address(\n    self,\n    address,\n    tags,\n    dist=1000,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within some distance N, S, E, W of address to the map.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_address(address, tags, dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_osm_from_bbox","title":"<code>add_osm_from_bbox(self, north, south, east, west, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within a N, S, E, W bounding box to the map.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_osm_from_bbox(\n    self,\n    north,\n    south,\n    east,\n    west,\n    tags,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within a N, S, E, W bounding box to the map.\n\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_osm_from_geocode","title":"<code>add_osm_from_geocode(self, query, which_result=None, by_osmid=False, buffer_dist=None, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM data of place(s) by name or ID to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_osm_from_geocode(\n    self,\n    query,\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM data of place(s) by name or ID to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n\n    gdf = osm_gdf_from_geocode(\n        query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n    )\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_osm_from_place","title":"<code>add_osm_from_place(self, query, tags, which_result=None, buffer_dist=None, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within boundaries of geocodable place(s) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_osm_from_place(\n    self,\n    query,\n    tags,\n    which_result=None,\n    buffer_dist=None,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within boundaries of geocodable place(s) to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_osm_from_point","title":"<code>add_osm_from_point(self, center_point, tags, dist=1000, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within some distance N, S, E, W of a point to the map.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_osm_from_point(\n    self,\n    center_point,\n    tags,\n    dist=1000,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within some distance N, S, E, W of a point to the map.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_point(center_point, tags, dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_osm_from_polygon","title":"<code>add_osm_from_polygon(self, polygon, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within boundaries of a (multi)polygon to the map.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_osm_from_polygon(\n    self,\n    polygon,\n    tags,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within boundaries of a (multi)polygon to the map.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_polygon(polygon, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_planet_by_month","title":"<code>add_planet_by_month(self, year=2016, month=1, name=None, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_planet_by_month(\n    self, year=2016, month=1, name=None, api_key=None, token_name=\"PLANET_API_KEY\"\n):\n\"\"\"Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n    \"\"\"\n    layer = planet_tile_by_month(\n        year, month, name, api_key, token_name, tile_format=\"folium\"\n    )\n    layer.add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_planet_by_quarter","title":"<code>add_planet_by_quarter(self, year=2016, quarter=1, name=None, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_planet_by_quarter(\n    self, year=2016, quarter=1, name=None, api_key=None, token_name=\"PLANET_API_KEY\"\n):\n\"\"\"Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-12. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n    \"\"\"\n    layer = planet_tile_by_quarter(\n        year, quarter, name, api_key, token_name, tile_format=\"folium\"\n    )\n    layer.add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_points_from_xy","title":"<code>add_points_from_xy(self, data, x='longitude', y='latitude', popup=None, min_width=100, max_width=200, layer_name='Marker Cluster', color_column=None, marker_colors=None, icon_colors=['white'], icon_names=['info'], angle=0, prefix='fa', add_legend=True, **kwargs)</code>","text":"<p>Adds a marker cluster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>min_width</code> <code>int</code> <p>The minimum width of the popup. Defaults to 100.</p> <code>100</code> <code>max_width</code> <code>int</code> <p>The maximum width of the popup. Defaults to 200.</p> <code>200</code> <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"Marker Cluster\".</p> <code>'Marker Cluster'</code> <code>color_column</code> <code>str</code> <p>The column name for the color values. Defaults to None.</p> <code>None</code> <code>marker_colors</code> <code>list</code> <p>A list of colors to be used for the markers. Defaults to None.</p> <code>None</code> <code>icon_colors</code> <code>list</code> <p>A list of colors to be used for the icons. Defaults to ['white'].</p> <code>['white']</code> <code>icon_names</code> <code>list</code> <p>A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons or https://getbootstrap.com/docs/3.3/components/?utm_source=pocket_mylist. Defaults to ['info'].</p> <code>['info']</code> <code>angle</code> <code>int</code> <p>The angle of the icon. Defaults to 0.</p> <code>0</code> <code>prefix</code> <code>str</code> <p>The prefix states the source of the icon. 'fa' for font-awesome or 'glyphicon' for bootstrap 3. Defaults to 'fa'.</p> <code>'fa'</code> <code>add_legend</code> <code>bool</code> <p>If True, a legend will be added to the map. Defaults to True.</p> <code>True</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_points_from_xy(\n    self,\n    data,\n    x=\"longitude\",\n    y=\"latitude\",\n    popup=None,\n    min_width=100,\n    max_width=200,\n    layer_name=\"Marker Cluster\",\n    color_column=None,\n    marker_colors=None,\n    icon_colors=[\"white\"],\n    icon_names=[\"info\"],\n    angle=0,\n    prefix=\"fa\",\n    add_legend=True,\n    **kwargs,\n):\n\"\"\"Adds a marker cluster to the map.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        min_width (int, optional): The minimum width of the popup. Defaults to 100.\n        max_width (int, optional): The maximum width of the popup. Defaults to 200.\n        layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n        color_column (str, optional): The column name for the color values. Defaults to None.\n        marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n        icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n        icon_names (list, optional): A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons or https://getbootstrap.com/docs/3.3/components/?utm_source=pocket_mylist. Defaults to ['info'].\n        angle (int, optional): The angle of the icon. Defaults to 0.\n        prefix (str, optional): The prefix states the source of the icon. 'fa' for font-awesome or 'glyphicon' for bootstrap 3. Defaults to 'fa'.\n        add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n    \"\"\"\n    import pandas as pd\n\n    color_options = [\n        \"red\",\n        \"blue\",\n        \"green\",\n        \"purple\",\n        \"orange\",\n        \"darkred\",\n        \"lightred\",\n        \"beige\",\n        \"darkblue\",\n        \"darkgreen\",\n        \"cadetblue\",\n        \"darkpurple\",\n        \"white\",\n        \"pink\",\n        \"lightblue\",\n        \"lightgreen\",\n        \"gray\",\n        \"black\",\n        \"lightgray\",\n    ]\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    else:\n        df = pd.read_csv(data)\n\n    col_names = df.columns.values.tolist()\n\n    if color_column is not None and color_column not in col_names:\n        raise ValueError(\n            f\"The color column {color_column} does not exist in the dataframe.\"\n        )\n\n    if color_column is not None:\n        items = list(set(df[color_column]))\n    else:\n        items = None\n\n    if color_column is not None and marker_colors is None:\n        if len(items) &gt; len(color_options):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n            )\n        else:\n            marker_colors = color_options[: len(items)]\n    elif color_column is not None and marker_colors is not None:\n        if len(items) != len(marker_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if items is not None:\n        if len(icon_colors) == 1:\n            icon_colors = icon_colors * len(items)\n        elif len(items) != len(icon_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n        if len(icon_names) == 1:\n            icon_names = icon_names * len(items)\n        elif len(items) != len(icon_names):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if popup is None:\n        popup = col_names\n\n    if x not in col_names:\n        raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n    if y not in col_names:\n        raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n    marker_cluster = plugins.MarkerCluster(name=layer_name).add_to(self)\n\n    for row in df.itertuples():\n        html = \"\"\n        for p in popup:\n            html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(getattr(row, p)) + \"&lt;br&gt;\"\n        popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n        if items is not None:\n            index = items.index(getattr(row, color_column))\n            marker_icon = folium.Icon(\n                color=marker_colors[index],\n                icon_color=icon_colors[index],\n                icon=icon_names[index],\n                angle=angle,\n                prefix=prefix,\n            )\n        else:\n            marker_icon = None\n\n        folium.Marker(\n            location=[getattr(row, y), getattr(row, x)],\n            popup=popup_html,\n            icon=marker_icon,\n        ).add_to(marker_cluster)\n\n    if items is not None and add_legend:\n        marker_colors = [check_color(c) for c in marker_colors]\n        self.add_legend(\n            title=color_column.title(), colors=marker_colors, labels=items\n        )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_raster","title":"<code>add_raster(self, source, band=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='Local COG', **kwargs)</code>","text":"<p>Add a local raster dataset to the map.</p> <pre><code>If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\nrunning the following two lines before calling this function:\n\nimport os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>band</code> <code>int</code> <p>The band to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Local COG'.</p> <code>'Local COG'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_raster(\n    self,\n    source,\n    band=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=\"Local COG\",\n    **kwargs,\n):\n\"\"\"Add a local raster dataset to the map.\n\n        If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\n        running the following two lines before calling this function:\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Local COG'.\n    \"\"\"\n\n    if in_colab_shell():\n        print(\"This add_raster() function is not supported in Colab.\")\n        return\n\n    tile_layer, tile_client = get_local_tile_layer(\n        source,\n        band=band,\n        palette=palette,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        tile_format=\"folium\",\n        layer_name=layer_name,\n        return_client=True,\n        **kwargs,\n    )\n    self.add_layer(tile_layer)\n\n    bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n    bounds = (\n        bounds[2],\n        bounds[0],\n        bounds[3],\n        bounds[1],\n    )  # [minx, miny, maxx, maxy]\n    self.zoom_to_bounds(bounds)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_remote_tile","title":"<code>add_remote_tile(self, source, band=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name=None, **kwargs)</code>","text":"<p>Add a remote Cloud Optimized GeoTIFF (COG) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the remote Cloud Optimized GeoTIFF.</p> required <code>band</code> <code>int</code> <p>The band to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_remote_tile(\n    self,\n    source,\n    band=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=None,\n    **kwargs,\n):\n\"\"\"Add a remote Cloud Optimized GeoTIFF (COG) to the map.\n\n    Args:\n        source (str): The path to the remote Cloud Optimized GeoTIFF.\n        band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n    \"\"\"\n    if isinstance(source, str) and source.startswith(\"http\"):\n        self.add_local_tile(\n            source,\n            band=band,\n            palette=palette,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            **kwargs,\n        )\n    else:\n        raise Exception(\"The source must be a URL.\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_shapefile","title":"<code>add_shapefile(self, in_shp, layer_name='Untitled', **kwargs)</code>","text":"<p>Adds a shapefile to the map. See https://python-visualization.github.io/folium/modules.html#folium.features.GeoJson for more info about setting style.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input file path to the shapefile.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shapefile could not be found.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_shapefile(self, in_shp, layer_name=\"Untitled\", **kwargs):\n\"\"\"Adds a shapefile to the map. See https://python-visualization.github.io/folium/modules.html#folium.features.GeoJson for more info about setting style.\n\n    Args:\n        in_shp (str): The input file path to the shapefile.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n\n    Raises:\n        FileNotFoundError: The provided shapefile could not be found.\n    \"\"\"\n    in_shp = os.path.abspath(in_shp)\n    if not os.path.exists(in_shp):\n        raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n    data = shp_to_geojson(in_shp)\n\n    geo_json = folium.GeoJson(data=data, name=layer_name, **kwargs)\n    geo_json.add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_stac_layer","title":"<code>add_stac_layer(self, url=None, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, name='STAC Layer', attribution='.', opacity=1.0, shown=True, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'STAC Layer'.</p> <code>'STAC Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>'.'</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_stac_layer(\n    self,\n    url=None,\n    collection=None,\n    item=None,\n    assets=None,\n    bands=None,\n    titiler_endpoint=None,\n    name=\"STAC Layer\",\n    attribution=\".\",\n    opacity=1.0,\n    shown=True,\n    **kwargs,\n):\n\"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n    \"\"\"\n    tile_url = stac_tile(\n        url, collection, item, assets, bands, titiler_endpoint, **kwargs\n    )\n    bounds = stac_bounds(url, collection, item, titiler_endpoint)\n    self.add_tile_layer(\n        url=tile_url,\n        name=name,\n        attribution=attribution,\n        opacity=opacity,\n        shown=shown,\n    )\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_styled_vector","title":"<code>add_styled_vector(self, ee_object, column, palette, layer_name='Untitled', **kwargs)</code>","text":"<p>Adds a styled vector to the map.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>An ee.FeatureCollection.</p> required <code>column</code> <code>str</code> <p>The column name to use for styling.</p> required <code>palette</code> <code>list | dict</code> <p>The palette (e.g., list of colors or a dict containing label and color pairs) to use for styling.</p> required <code>layer_name</code> <code>str</code> <p>The name to be used for the new layer. Defaults to \"Untitled\".</p> <code>'Untitled'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_styled_vector(\n    self, ee_object, column, palette, layer_name=\"Untitled\", **kwargs\n):\n\"\"\"Adds a styled vector to the map.\n\n    Args:\n        ee_object (object): An ee.FeatureCollection.\n        column (str): The column name to use for styling.\n        palette (list | dict): The palette (e.g., list of colors or a dict containing label and color pairs) to use for styling.\n        layer_name (str, optional): The name to be used for the new layer. Defaults to \"Untitled\".\n    \"\"\"\n    styled_vector = vector_styling(ee_object, column, palette, **kwargs)\n    self.addLayer(styled_vector.style(**{\"styleProperty\": \"style\"}), {}, layer_name)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_text","title":"<code>add_text(self, text, fontsize=20, fontcolor='black', bold=False, padding='5px', background=True, bg_color='white', border_radius='5px', position='bottomright', **kwargs)</code>","text":"<p>Add text to the map.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to add.</p> required <code>fontsize</code> <code>int</code> <p>The font size. Defaults to 20.</p> <code>20</code> <code>fontcolor</code> <code>str</code> <p>The font color. Defaults to \"black\".</p> <code>'black'</code> <code>bold</code> <code>bool</code> <p>Whether to use bold font. Defaults to False.</p> <code>False</code> <code>padding</code> <code>str</code> <p>The padding. Defaults to \"5px\".</p> <code>'5px'</code> <code>background</code> <code>bool</code> <p>Whether to use background. Defaults to True.</p> <code>True</code> <code>bg_color</code> <code>str</code> <p>The background color. Defaults to \"white\".</p> <code>'white'</code> <code>border_radius</code> <code>str</code> <p>The border radius. Defaults to \"5px\".</p> <code>'5px'</code> <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_text(\n    self,\n    text,\n    fontsize=20,\n    fontcolor=\"black\",\n    bold=False,\n    padding=\"5px\",\n    background=True,\n    bg_color=\"white\",\n    border_radius=\"5px\",\n    position=\"bottomright\",\n    **kwargs,\n):\n\"\"\"Add text to the map.\n\n    Args:\n        text (str): The text to add.\n        fontsize (int, optional): The font size. Defaults to 20.\n        fontcolor (str, optional): The font color. Defaults to \"black\".\n        bold (bool, optional): Whether to use bold font. Defaults to False.\n        padding (str, optional): The padding. Defaults to \"5px\".\n        background (bool, optional): Whether to use background. Defaults to True.\n        bg_color (str, optional): The background color. Defaults to \"white\".\n        border_radius (str, optional): The border radius. Defaults to \"5px\".\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n    \"\"\"\n\n    if background:\n        text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'}; \n        padding: {padding}; background-color: {bg_color}; \n        border-radius: {border_radius};\"&gt;{text}&lt;/div&gt;\"\"\"\n    else:\n        text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'}; \n        padding: {padding};\"&gt;{text}&lt;/div&gt;\"\"\"\n\n    self.add_html(text, position=position, **kwargs)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_tile_layer","title":"<code>add_tile_layer(self, tiles='OpenStreetMap', name='Untitled', attribution='.', overlay=True, control=True, shown=True, opacity=1.0, API_key=None, **kwargs)</code>","text":"<p>Add a XYZ tile layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>tiles</code> <code>str</code> <p>The URL of the XYZ tile service.</p> <code>'OpenStreetMap'</code> <code>name</code> <code>str</code> <p>The layer name to use on the layer control. Defaults to 'Untitled'.</p> <code>'Untitled'</code> <code>attribution</code> <code>str</code> <p>The attribution of the data layer. Defaults to '.'.</p> <code>'.'</code> <code>overlay</code> <code>str</code> <p>Allows overlay. Defaults to True.</p> <code>True</code> <code>control</code> <code>str</code> <p>Adds the layer to the layer control. Defaults to True.</p> <code>True</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Sets the opacity for the layer.</p> <code>1.0</code> <code>API_key</code> <code>str</code> <p>\u2013 API key for Cloudmade or Mapbox tiles. Defaults to True.</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_tile_layer(\n    self,\n    tiles=\"OpenStreetMap\",\n    name=\"Untitled\",\n    attribution=\".\",\n    overlay=True,\n    control=True,\n    shown=True,\n    opacity=1.0,\n    API_key=None,\n    **kwargs,\n):\n\"\"\"Add a XYZ tile layer to the map.\n\n    Args:\n        tiles (str): The URL of the XYZ tile service.\n        name (str, optional): The layer name to use on the layer control. Defaults to 'Untitled'.\n        attribution (str, optional): The attribution of the data layer. Defaults to '.'.\n        overlay (str, optional): Allows overlay. Defaults to True.\n        control (str, optional): Adds the layer to the layer control. Defaults to True.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): Sets the opacity for the layer.\n        API_key (str, optional): \u2013 API key for Cloudmade or Mapbox tiles. Defaults to True.\n    \"\"\"\n\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 100\n    if \"max_native_zoom\" not in kwargs:\n        kwargs[\"max_native_zoom\"] = 100\n\n    try:\n        folium.raster_layers.TileLayer(\n            tiles=tiles,\n            name=name,\n            attr=attribution,\n            overlay=overlay,\n            control=control,\n            show=shown,\n            opacity=opacity,\n            API_key=API_key,\n            **kwargs,\n        ).add_to(self)\n    except Exception:\n        raise Exception(\"Failed to add the specified TileLayer.\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_widget","title":"<code>add_widget(self, content, position='bottomright', **kwargs)</code>","text":"<p>Add a widget (e.g., text, HTML, figure) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_widget(self, content, position=\"bottomright\", **kwargs):\n\"\"\"Add a widget (e.g., text, HTML, figure) to the map.\n\n    Args:\n        content (str): The widget to add.\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n    \"\"\"\n\n    from matplotlib import figure\n    import base64\n    from io import BytesIO\n\n    allowed_positions = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n\n    if position not in allowed_positions:\n        raise Exception(f\"position must be one of {allowed_positions}\")\n\n    try:\n        if isinstance(content, str):\n            widget = CustomControl(content, position=position)\n            widget.add_to(self)\n        elif isinstance(content, figure.Figure):\n            buf = BytesIO()\n            content.savefig(buf, format=\"png\")\n            buf.seek(0)\n            b64_content = base64.b64encode(buf.read()).decode(\"utf-8\")\n            widget = CustomControl(\n                f\"\"\"&lt;img src=\"data:image/png;base64,{b64_content}\"&gt;\"\"\",\n                position=position,\n            )\n            widget.add_to(self)\n        else:\n            raise Exception(\"The content must be a string or a matplotlib figure\")\n\n    except Exception as e:\n        raise Exception(f\"Error adding widget: {e}\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name=None, attribution='', overlay=True, control=True, shown=True, format='image/png', transparent=True, version='1.1.1', styles='', **kwargs)</code>","text":"<p>Add a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the WMS web service.</p> required <code>layers</code> <code>str</code> <p>Comma-separated list of WMS layers to show.</p> required <code>name</code> <code>str</code> <p>The layer name to use on the layer control. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution of the data layer. Defaults to ''.</p> <code>''</code> <code>overlay</code> <code>str</code> <p>Allows overlay. Defaults to True.</p> <code>True</code> <code>control</code> <code>str</code> <p>Adds the layer to the layer control. Defaults to True.</p> <code>True</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>format</code> <code>str</code> <p>WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether the layer shall allow transparency. Defaults to True.</p> <code>True</code> <code>version</code> <code>str</code> <p>Version of the WMS service to use. Defaults to \"1.1.1\".</p> <code>'1.1.1'</code> <code>styles</code> <code>str</code> <p>Comma-separated list of WMS styles. Defaults to \"\".</p> <code>''</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_wms_layer(\n    self,\n    url,\n    layers,\n    name=None,\n    attribution=\"\",\n    overlay=True,\n    control=True,\n    shown=True,\n    format=\"image/png\",\n    transparent=True,\n    version=\"1.1.1\",\n    styles=\"\",\n    **kwargs,\n):\n\"\"\"Add a WMS layer to the map.\n\n    Args:\n        url (str): The URL of the WMS web service.\n        layers (str): Comma-separated list of WMS layers to show.\n        name (str, optional): The layer name to use on the layer control. Defaults to None.\n        attribution (str, optional): The attribution of the data layer. Defaults to ''.\n        overlay (str, optional): Allows overlay. Defaults to True.\n        control (str, optional): Adds the layer to the layer control. Defaults to True.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.\n        transparent (bool, optional): Whether the layer shall allow transparency. Defaults to True.\n        version (str, optional): Version of the WMS service to use. Defaults to \"1.1.1\".\n        styles (str, optional): Comma-separated list of WMS styles. Defaults to \"\".\n    \"\"\"\n    try:\n        folium.raster_layers.WmsTileLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            attr=attribution,\n            overlay=overlay,\n            control=control,\n            show=shown,\n            styles=styles,\n            fmt=format,\n            transparent=transparent,\n            version=version,\n            **kwargs,\n        ).add_to(self)\n    except Exception:\n        raise Exception(\"Failed to add the specified WMS TileLayer.\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.add_xyz_service","title":"<code>add_xyz_service(self, provider, **kwargs)</code>","text":"<p>Add a XYZ tile layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The provider is not valid. It must start with xyz or qms.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_xyz_service(self, provider, **kwargs):\n\"\"\"Add a XYZ tile layer to the map.\n\n    Args:\n        provider (str): A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,\n\n    Raises:\n        ValueError: The provider is not valid. It must start with xyz or qms.\n    \"\"\"\n    import xyzservices.providers as xyz\n    from xyzservices import TileProvider\n\n    if provider.startswith(\"xyz\"):\n        name = provider[4:]\n        xyz_provider = xyz.flatten()[name]\n        url = xyz_provider.build_url()\n        attribution = xyz_provider.attribution\n        if attribution.strip() == \"\":\n            attribution = \" \"\n        self.add_tile_layer(url, name, attribution)\n    elif provider.startswith(\"qms\"):\n        name = provider[4:]\n        qms_provider = TileProvider.from_qms(name)\n        url = qms_provider.build_url()\n        attribution = qms_provider.attribution\n        if attribution.strip() == \"\":\n            attribution = \" \"\n        self.add_tile_layer(url=url, name=name, attribution=attribution)\n    else:\n        raise ValueError(\n            f\"The provider {provider} is not valid. It must start with xyz or qms.\"\n        )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.basemap_demo","title":"<code>basemap_demo(self)</code>","text":"<p>A demo for using geemap basemaps.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def basemap_demo(self):\n\"\"\"A demo for using geemap basemaps.\"\"\"\n    print(\"The folium plotting backend does not support this function.\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.centerObject","title":"<code>centerObject(self, ee_object, zoom=None)</code>","text":"<p>Centers the map view on a given object.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Element|Geometry</code> <p>An Earth Engine object to center on a geometry, image or feature.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to None.</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def center_object(self, ee_object, zoom=None):\n\"\"\"Centers the map view on a given object.\n\n    Args:\n        ee_object (Element|Geometry): An Earth Engine object to center on a geometry, image or feature.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n    \"\"\"\n\n    maxError = 0.001\n    if isinstance(ee_object, ee.Geometry):\n        geometry = ee_object.transform(maxError=maxError)\n    else:\n        try:\n            geometry = ee_object.geometry(maxError=maxError).transform(\n                maxError=maxError\n            )\n        except Exception:\n            raise Exception(\n                \"ee_object must be an instance of one of ee.Geometry, ee.FeatureCollection, ee.Image, or ee.ImageCollection.\"\n            )\n\n    if zoom is not None:\n        if not isinstance(zoom, int):\n            raise Exception(\"Zoom must be an integer.\")\n        else:\n            centroid = geometry.centroid(maxError=maxError).getInfo()[\"coordinates\"]\n            lat = centroid[1]\n            lon = centroid[0]\n            self.set_center(lon, lat, zoom)\n\n            if is_arcpy():\n                arc_zoom_to_extent(lon, lat, lon, lat)\n\n    else:\n        coordinates = geometry.bounds(maxError).getInfo()[\"coordinates\"][0]\n        x = [c[0] for c in coordinates]\n        y = [c[1] for c in coordinates]\n        xmin = min(x)\n        xmax = max(x)\n        ymin = min(y)\n        ymax = max(y)\n        bounds = [[ymin, xmin], [ymax, xmax]]\n        self.fit_bounds(bounds)\n\n        if is_arcpy():\n            arc_zoom_to_extent(xmin, ymin, xmax, ymax)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.center_object","title":"<code>center_object(self, ee_object, zoom=None)</code>","text":"<p>Centers the map view on a given object.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Element|Geometry</code> <p>An Earth Engine object to center on a geometry, image or feature.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to None.</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def center_object(self, ee_object, zoom=None):\n\"\"\"Centers the map view on a given object.\n\n    Args:\n        ee_object (Element|Geometry): An Earth Engine object to center on a geometry, image or feature.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n    \"\"\"\n\n    maxError = 0.001\n    if isinstance(ee_object, ee.Geometry):\n        geometry = ee_object.transform(maxError=maxError)\n    else:\n        try:\n            geometry = ee_object.geometry(maxError=maxError).transform(\n                maxError=maxError\n            )\n        except Exception:\n            raise Exception(\n                \"ee_object must be an instance of one of ee.Geometry, ee.FeatureCollection, ee.Image, or ee.ImageCollection.\"\n            )\n\n    if zoom is not None:\n        if not isinstance(zoom, int):\n            raise Exception(\"Zoom must be an integer.\")\n        else:\n            centroid = geometry.centroid(maxError=maxError).getInfo()[\"coordinates\"]\n            lat = centroid[1]\n            lon = centroid[0]\n            self.set_center(lon, lat, zoom)\n\n            if is_arcpy():\n                arc_zoom_to_extent(lon, lat, lon, lat)\n\n    else:\n        coordinates = geometry.bounds(maxError).getInfo()[\"coordinates\"][0]\n        x = [c[0] for c in coordinates]\n        y = [c[1] for c in coordinates]\n        xmin = min(x)\n        xmax = max(x)\n        ymin = min(y)\n        ymax = max(y)\n        bounds = [[ymin, xmin], [ymax, xmax]]\n        self.fit_bounds(bounds)\n\n        if is_arcpy():\n            arc_zoom_to_extent(xmin, ymin, xmax, ymax)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.dd_local_tile","title":"<code>dd_local_tile(self, source, band=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='Local COG', **kwargs)</code>","text":"<p>Add a local raster dataset to the map.</p> <pre><code>If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\nrunning the following two lines before calling this function:\n\nimport os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>band</code> <code>int</code> <p>The band to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Local COG'.</p> <code>'Local COG'</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def add_raster(\n    self,\n    source,\n    band=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=\"Local COG\",\n    **kwargs,\n):\n\"\"\"Add a local raster dataset to the map.\n\n        If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\n        running the following two lines before calling this function:\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Local COG'.\n    \"\"\"\n\n    if in_colab_shell():\n        print(\"This add_raster() function is not supported in Colab.\")\n        return\n\n    tile_layer, tile_client = get_local_tile_layer(\n        source,\n        band=band,\n        palette=palette,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        tile_format=\"folium\",\n        layer_name=layer_name,\n        return_client=True,\n        **kwargs,\n    )\n    self.add_layer(tile_layer)\n\n    bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n    bounds = (\n        bounds[2],\n        bounds[0],\n        bounds[3],\n        bounds[1],\n    )  # [minx, miny, maxx, maxy]\n    self.zoom_to_bounds(bounds)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.publish","title":"<code>publish(self, name='Folium Map', description='', source_url='', tags=None, source_file=None, open=True, formatting=None, token=None, **kwargs)</code>","text":"<p>Publish the map to datapane.com</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The document name - can include spaces, caps, symbols, etc., e.g. \"Profit &amp; Loss 2020\". Defaults to \"Folium Map\".</p> <code>'Folium Map'</code> <code>description</code> <code>str</code> <p>A high-level description for the document, this is displayed in searches and thumbnails. Defaults to ''.</p> <code>''</code> <code>source_url</code> <code>str</code> <p>A URL pointing to the source code for the document, e.g. a GitHub repo or a Colab notebook. Defaults to ''.</p> <code>''</code> <code>tags</code> <code>bool</code> <p>A list of tags (as strings) used to categorise your document. Defaults to None.</p> <code>None</code> <code>source_file</code> <code>str</code> <p>Path of jupyter notebook file to upload. Defaults to None.</p> <code>None</code> <code>open</code> <code>bool</code> <p>Whether to open the map. Defaults to True.</p> <code>True</code> <code>formatting</code> <code>ReportFormatting</code> <p>Set the basic styling for your report.</p> <code>None</code> <code>token</code> <code>str</code> <p>The token to use to datapane to publish the map. See https://docs.datapane.com/tut-getting-started. Defaults to None.</p> <code>None</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def publish(\n    self,\n    name=\"Folium Map\",\n    description=\"\",\n    source_url=\"\",\n    tags=None,\n    source_file=None,\n    open=True,\n    formatting=None,\n    token=None,\n    **kwargs,\n):\n\"\"\"Publish the map to datapane.com\n\n    Args:\n        name (str, optional): The document name - can include spaces, caps, symbols, etc., e.g. \"Profit &amp; Loss 2020\". Defaults to \"Folium Map\".\n        description (str, optional): A high-level description for the document, this is displayed in searches and thumbnails. Defaults to ''.\n        source_url (str, optional): A URL pointing to the source code for the document, e.g. a GitHub repo or a Colab notebook. Defaults to ''.\n        tags (bool, optional): A list of tags (as strings) used to categorise your document. Defaults to None.\n        source_file (str, optional): Path of jupyter notebook file to upload. Defaults to None.\n        open (bool, optional): Whether to open the map. Defaults to True.\n        formatting (ReportFormatting, optional): Set the basic styling for your report.\n        token (str, optional): The token to use to datapane to publish the map. See https://docs.datapane.com/tut-getting-started. Defaults to None.\n    \"\"\"\n    import webbrowser\n    import warnings\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    warnings.filterwarnings(\"ignore\")\n    try:\n        import datapane as dp\n    except Exception:\n        webbrowser.open_new_tab(\"https://docs.datapane.com/\")\n        raise ImportError(\n            \"The datapane Python package is not installed. You need to install and authenticate datapane first.\"\n        )\n\n    if token is None:\n        try:\n            _ = dp.ping(verbose=False)\n        except Exception as e:\n            if os.environ.get(\"DP_TOKEN\") is not None:\n                dp.login(token=os.environ.get(\"DP_TOKEN\"))\n            else:\n                raise Exception(e)\n    else:\n        dp.login(token)\n\n    try:\n        dp.upload_report(\n            dp.Plot(self),\n            name=name,\n            description=description,\n            source_url=source_url,\n            tags=tags,\n            source_file=source_file,\n            open=open,\n            formatting=formatting,\n            **kwargs,\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.remove_labels","title":"<code>remove_labels(self, **kwargs)</code>","text":"<p>Removes a layer from the map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def remove_labels(self, **kwargs):\n\"\"\"Removes a layer from the map.\"\"\"\n    print(\"The folium plotting backend does not support removing labels.\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.setCenter","title":"<code>setCenter(self, lon, lat, zoom=10)</code>","text":"<p>Centers the map view at a given coordinates with the given zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>The longitude of the center, in degrees.</p> required <code>lat</code> <code>float</code> <p>The latitude of the center, in degrees.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to 10.</p> <code>10</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def set_center(self, lon, lat, zoom=10):\n\"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n    Args:\n        lon (float): The longitude of the center, in degrees.\n        lat (float): The latitude of the center, in degrees.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10.\n    \"\"\"\n    self.fit_bounds([[lat, lon], [lat, lon]], max_zoom=zoom)\n\n    if is_arcpy():\n        arc_zoom_to_extent(lon, lat, lon, lat)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.setControlVisibility","title":"<code>setControlVisibility(self, layerControl=True, fullscreenControl=True, latLngPopup=True)</code>","text":"<p>Sets the visibility of the controls on the map.</p> <p>Parameters:</p> Name Type Description Default <code>layerControl</code> <code>bool</code> <p>Whether to show the control that allows the user to toggle layers on/off. Defaults to True.</p> <code>True</code> <code>fullscreenControl</code> <code>bool</code> <p>Whether to show the control that allows the user to make the map full-screen. Defaults to True.</p> <code>True</code> <code>latLngPopup</code> <code>bool</code> <p>Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.</p> <code>True</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def set_control_visibility(\n    self, layerControl=True, fullscreenControl=True, latLngPopup=True\n):\n\"\"\"Sets the visibility of the controls on the map.\n\n    Args:\n        layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True.\n        fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True.\n        latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.\n    \"\"\"\n    if layerControl:\n        folium.LayerControl().add_to(self)\n    if fullscreenControl:\n        plugins.Fullscreen().add_to(self)\n    if latLngPopup:\n        folium.LatLngPopup().add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.setOptions","title":"<code>setOptions(self, mapTypeId='HYBRID', styles={}, types=[])</code>","text":"<p>Adds Google basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>mapTypeId</code> <code>str</code> <p>A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>styles</code> <code>[type]</code> <p>A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.</p> <code>{}</code> <code>types</code> <code>[type]</code> <p>A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.</p> <code>[]</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def setOptions(self, mapTypeId=\"HYBRID\", styles={}, types=[]):\n\"\"\"Adds Google basemap to the map.\n\n    Args:\n        mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.\n        styles ([type], optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.\n        types ([type], optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.\n    \"\"\"\n    try:\n        basemaps[mapTypeId].add_to(self)\n    except Exception:\n        raise Exception(\n            \"Basemap can only be one of the following: {}\".format(\n                \", \".join(basemaps.keys())\n            )\n        )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.set_center","title":"<code>set_center(self, lon, lat, zoom=10)</code>","text":"<p>Centers the map view at a given coordinates with the given zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>The longitude of the center, in degrees.</p> required <code>lat</code> <code>float</code> <p>The latitude of the center, in degrees.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to 10.</p> <code>10</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def set_center(self, lon, lat, zoom=10):\n\"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n    Args:\n        lon (float): The longitude of the center, in degrees.\n        lat (float): The latitude of the center, in degrees.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10.\n    \"\"\"\n    self.fit_bounds([[lat, lon], [lat, lon]], max_zoom=zoom)\n\n    if is_arcpy():\n        arc_zoom_to_extent(lon, lat, lon, lat)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.set_control_visibility","title":"<code>set_control_visibility(self, layerControl=True, fullscreenControl=True, latLngPopup=True)</code>","text":"<p>Sets the visibility of the controls on the map.</p> <p>Parameters:</p> Name Type Description Default <code>layerControl</code> <code>bool</code> <p>Whether to show the control that allows the user to toggle layers on/off. Defaults to True.</p> <code>True</code> <code>fullscreenControl</code> <code>bool</code> <p>Whether to show the control that allows the user to make the map full-screen. Defaults to True.</p> <code>True</code> <code>latLngPopup</code> <code>bool</code> <p>Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.</p> <code>True</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def set_control_visibility(\n    self, layerControl=True, fullscreenControl=True, latLngPopup=True\n):\n\"\"\"Sets the visibility of the controls on the map.\n\n    Args:\n        layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True.\n        fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True.\n        latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.\n    \"\"\"\n    if layerControl:\n        folium.LayerControl().add_to(self)\n    if fullscreenControl:\n        plugins.Fullscreen().add_to(self)\n    if latLngPopup:\n        folium.LatLngPopup().add_to(self)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.set_options","title":"<code>set_options(self, mapTypeId='HYBRID', styles={}, types=[])</code>","text":"<p>Adds Google basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>mapTypeId</code> <code>str</code> <p>A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>styles</code> <code>[type]</code> <p>A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.</p> <code>{}</code> <code>types</code> <code>[type]</code> <p>A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.</p> <code>[]</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def setOptions(self, mapTypeId=\"HYBRID\", styles={}, types=[]):\n\"\"\"Adds Google basemap to the map.\n\n    Args:\n        mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.\n        styles ([type], optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.\n        types ([type], optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.\n    \"\"\"\n    try:\n        basemaps[mapTypeId].add_to(self)\n    except Exception:\n        raise Exception(\n            \"Basemap can only be one of the following: {}\".format(\n                \", \".join(basemaps.keys())\n            )\n        )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.set_plot_options","title":"<code>set_plot_options(self, **kwargs)</code>","text":"<p>Sets plotting options.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def set_plot_options(\n    self,\n    **kwargs,\n):\n\"\"\"Sets plotting options.\"\"\"\n    print(\"The folium plotting backend does not support this function.\")\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.split_map","title":"<code>split_map(self, left_layer='TERRAIN', right_layer='OpenTopoMap', left_args={}, right_args={}, left_label=None, right_label=None, left_position='bottomleft', right_position='bottomright', **kwargs)</code>","text":"<p>Adds a split-panel map.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.</p> <code>'TERRAIN'</code> <code>right_layer</code> <code>str</code> <p>The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.</p> <code>'OpenTopoMap'</code> <code>left_args</code> <code>dict</code> <p>The arguments for the left tile layer. Defaults to {}.</p> <code>{}</code> <code>right_args</code> <code>dict</code> <p>The arguments for the right tile layer. Defaults to {}.</p> <code>{}</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def split_map(\n    self,\n    left_layer=\"TERRAIN\",\n    right_layer=\"OpenTopoMap\",\n    left_args={},\n    right_args={},\n    left_label=None,\n    right_label=None,\n    left_position=\"bottomleft\",\n    right_position=\"bottomright\",\n    **kwargs,\n):\n\"\"\"Adds a split-panel map.\n\n    Args:\n        left_layer (str, optional): The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.\n        right_layer (str, optional): The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.\n        left_args (dict, optional): The arguments for the left tile layer. Defaults to {}.\n        right_args (dict, optional): The arguments for the right tile layer. Defaults to {}.\n    \"\"\"\n    if \"max_zoom\" not in left_args:\n        left_args[\"max_zoom\"] = 100\n    if \"max_native_zoom\" not in left_args:\n        left_args[\"max_native_zoom\"] = 100\n\n    if \"max_zoom\" not in right_args:\n        right_args[\"max_zoom\"] = 100\n    if \"max_native_zoom\" not in right_args:\n        right_args[\"max_native_zoom\"] = 100\n\n    if \"layer_name\" not in left_args:\n        left_args[\"layer_name\"] = \"Left Layer\"\n\n    if \"layer_name\" not in right_args:\n        right_args[\"layer_name\"] = \"Right Layer\"\n\n    bounds = None\n\n    try:\n        if left_label is not None:\n            left_name = left_label\n        else:\n            left_name = \"Left Layer\"\n\n        if right_label is not None:\n            right_name = right_label\n        else:\n            right_name = \"Right Layer\"\n\n        if left_layer in basemaps.keys():\n            left_layer = basemaps[left_layer]\n        elif isinstance(left_layer, str):\n            if left_layer.startswith(\"http\") and left_layer.endswith(\".tif\"):\n                url = cog_tile(left_layer, **left_args)\n                bbox = cog_bounds(left_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                left_layer = folium.raster_layers.TileLayer(\n                    tiles=url,\n                    name=left_name,\n                    attr=\" \",\n                    overlay=True,\n                )\n            elif os.path.exists(left_layer):\n                left_layer, left_client = get_local_tile_layer(\n                    left_layer,\n                    tile_format=\"folium\",\n                    return_client=True,\n                    **left_args,\n                )\n                bounds = image_bounds(left_client)\n\n            else:\n                left_layer = folium.raster_layers.TileLayer(\n                    tiles=left_layer,\n                    name=left_name,\n                    attr=\" \",\n                    overlay=True,\n                    **left_args,\n                )\n        elif isinstance(left_layer, folium.raster_layers.TileLayer) or isinstance(\n            left_layer, folium.WmsTileLayer\n        ):\n            pass\n        else:\n            raise ValueError(\n                f\"left_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n\n        if right_layer in basemaps.keys():\n            right_layer = basemaps[right_layer]\n        elif isinstance(right_layer, str):\n            if right_layer.startswith(\"http\") and right_layer.endswith(\".tif\"):\n                url = cog_tile(right_layer, **right_args)\n                bbox = cog_bounds(right_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                right_layer = folium.raster_layers.TileLayer(\n                    tiles=url,\n                    name=right_name,\n                    attr=\" \",\n                    overlay=True,\n                )\n            elif os.path.exists(right_layer):\n                right_layer, right_client = get_local_tile_layer(\n                    right_layer,\n                    tile_format=\"folium\",\n                    return_client=True,\n                    **right_args,\n                )\n                bounds = image_bounds(right_client)\n            else:\n                right_layer = folium.raster_layers.TileLayer(\n                    tiles=right_layer,\n                    name=right_name,\n                    attr=\" \",\n                    overlay=True,\n                    **right_args,\n                )\n        elif isinstance(right_layer, folium.raster_layers.TileLayer) or isinstance(\n            left_layer, folium.WmsTileLayer\n        ):\n            pass\n        else:\n            raise ValueError(\n                f\"right_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n\n        control = SideBySideLayers(layer_left=left_layer, layer_right=right_layer)\n        left_layer.add_to(self)\n        right_layer.add_to(self)\n        control.add_to(self)\n\n        if left_label is not None:\n            if \"&lt;\" not in left_label:\n                left_label = f\"&lt;h4&gt;{left_label}&lt;/h4&gt;\"\n            self.add_html(left_label, position=left_position)\n\n        if right_label is not None:\n            if \"&lt;\" not in right_label:\n                right_label = f\"&lt;h4&gt;{right_label}&lt;/h4&gt;\"\n            self.add_html(right_label, position=right_position)\n        if bounds is not None:\n            self.fit_bounds(bounds)\n\n    except Exception as e:\n        print(\"The provided layers are invalid!\")\n        raise ValueError(e)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.st_draw_features","title":"<code>st_draw_features(self, st_component)</code>","text":"<p>Get the draw features of the map.</p> <p>Parameters:</p> Name Type Description Default <code>st_folium</code> <code>streamlit-folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The draw features of the map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def st_draw_features(self, st_component):\n\"\"\"Get the draw features of the map.\n\n    Args:\n        st_folium (streamlit-folium): The streamlit component.\n\n    Returns:\n        list: The draw features of the map.\n    \"\"\"\n\n    return st_component[\"all_drawings\"]\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.st_fit_bounds","title":"<code>st_fit_bounds(self)</code>","text":"<p>Fit the map to the bounds of the map.</p> <p>Returns:</p> Type Description <code>folium.Map</code> <p>The map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def st_fit_bounds(self):\n\"\"\"Fit the map to the bounds of the map.\n\n    Returns:\n        folium.Map: The map.\n    \"\"\"\n\n    try:\n        import streamlit as st\n\n        if \"map_bounds\" in st.session_state:\n            bounds = st.session_state[\"map_bounds\"]\n\n            self.fit_bounds(bounds)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.st_last_click","title":"<code>st_last_click(self, st_component)</code>","text":"<p>Get the last click feature of the map.</p> <p>Parameters:</p> Name Type Description Default <code>st_folium</code> <code>streamlit-folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The last click of the map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def st_last_click(self, st_component):\n\"\"\"Get the last click feature of the map.\n\n    Args:\n        st_folium (streamlit-folium): The streamlit component.\n\n    Returns:\n        str: The last click of the map.\n    \"\"\"\n\n    coords = st_component[\"last_clicked\"]\n    return (coords[\"lat\"], coords[\"lng\"])\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.st_last_draw","title":"<code>st_last_draw(self, st_component)</code>","text":"<p>Get the last draw feature of the map.</p> <p>Parameters:</p> Name Type Description Default <code>st_folium</code> <code>streamlit-folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The last draw of the map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def st_last_draw(self, st_component):\n\"\"\"Get the last draw feature of the map.\n\n    Args:\n        st_folium (streamlit-folium): The streamlit component.\n\n    Returns:\n        str: The last draw of the map.\n    \"\"\"\n\n    return st_component[\"last_active_drawing\"]\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.st_map_bounds","title":"<code>st_map_bounds(self, st_component)</code>","text":"<p>Get the bounds of the map in the format of (miny, minx, maxy, maxx).</p> <p>Parameters:</p> Name Type Description Default <code>st_folium</code> <code>streamlit-folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The bounds of the map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def st_map_bounds(self, st_component):\n\"\"\"Get the bounds of the map in the format of (miny, minx, maxy, maxx).\n\n    Args:\n        st_folium (streamlit-folium): The streamlit component.\n\n    Returns:\n        tuple: The bounds of the map.\n    \"\"\"\n\n    bounds = st_component[\"bounds\"]\n    south = bounds[\"_southWest\"][\"lat\"]\n    west = bounds[\"_southWest\"][\"lng\"]\n    north = bounds[\"_northEast\"][\"lat\"]\n    east = bounds[\"_northEast\"][\"lng\"]\n\n    bounds = [[south, west], [north, east]]\n    return bounds\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.st_map_center","title":"<code>st_map_center(self, st_component)</code>","text":"<p>Get the center of the map.</p> <p>Parameters:</p> Name Type Description Default <code>st_folium</code> <code>streamlit-folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The center of the map.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def st_map_center(self, st_component):\n\"\"\"Get the center of the map.\n\n    Args:\n        st_folium (streamlit-folium): The streamlit component.\n\n    Returns:\n        tuple: The center of the map.\n    \"\"\"\n\n    bounds = st_component[\"bounds\"]\n    west = bounds[\"_southWest\"][\"lng\"]\n    south = bounds[\"_southWest\"][\"lat\"]\n    east = bounds[\"_northEast\"][\"lng\"]\n    north = bounds[\"_northEast\"][\"lat\"]\n    return (south + (north - south) / 2, west + (east - west) / 2)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.to_gradio","title":"<code>to_gradio(self, width='100%', height='500px', **kwargs)</code>","text":"<p>Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as     attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>The width of the map. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map. Defaults to '500px'.</p> <code>'500px'</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML string to use in Gradio.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def to_gradio(self, width=\"100%\", height=\"500px\", **kwargs):\n\"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n        attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n    Args:\n        width (str, optional): The width of the map. Defaults to '100%'.\n        height (str, optional): The height of the map. Defaults to '500px'.\n\n    Returns:\n        str: The HTML string to use in Gradio.\n    \"\"\"\n\n    if isinstance(width, int):\n        width = f\"{width}px\"\n    if isinstance(height, int):\n        height = f\"{height}px\"\n\n    html = self.to_html()\n    lines = html.split(\"\\n\")\n    output = []\n    skipped_lines = []\n    for index, line in enumerate(lines):\n        if index in skipped_lines:\n            continue\n        if line.lstrip().startswith('{\"attribution\":'):\n            continue\n        elif \"on(L.Draw.Event.CREATED, function(e)\" in line:\n            for i in range(14):\n                skipped_lines.append(index + i)\n        elif \"L.Control.geocoder\" in line:\n            for i in range(5):\n                skipped_lines.append(index + i)\n        elif \"function(e)\" in line:\n            print(\n                f\"Warning: The folium plotting backend does not support functions in code blocks. Please delete line {index + 1}.\"\n            )\n        else:\n            output.append(line + \"\\n\")\n\n    return f\"\"\"&lt;iframe style=\"width: {width}; height: {height}\" name=\"result\" allow=\"midi; geolocation; microphone; camera; \n    display-capture; encrypted-media;\" sandbox=\"allow-modals allow-forms \n    allow-scripts allow-same-origin allow-popups \n    allow-top-navigation-by-user-activation allow-downloads\" allowfullscreen=\"\" \n    allowpaymentrequest=\"\" frameborder=\"0\" srcdoc='{\"\".join(output)}'&gt;&lt;/iframe&gt;\"\"\"\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.to_html","title":"<code>to_html(self, filename=None, **kwargs)</code>","text":"<p>Exports a map as an HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path to the output HTML. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If it is an invalid HTML file.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the HTML code.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def to_html(self, filename=None, **kwargs):\n\"\"\"Exports a map as an HTML file.\n\n    Args:\n        filename (str, optional): File path to the output HTML. Defaults to None.\n\n    Raises:\n        ValueError: If it is an invalid HTML file.\n\n    Returns:\n        str: A string containing the HTML code.\n    \"\"\"\n\n    if self.options[\"layersControl\"]:\n        self.add_layer_control()\n\n    if filename is not None:\n        if not filename.endswith(\".html\"):\n            raise ValueError(\"The output file extension must be html.\")\n        filename = os.path.abspath(filename)\n        out_dir = os.path.dirname(filename)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        self.save(filename, **kwargs)\n    else:\n        filename = os.path.abspath(random_string() + \".html\")\n        self.save(filename, **kwargs)\n        out_html = \"\"\n        with open(filename) as f:\n            lines = f.readlines()\n            out_html = \"\".join(lines)\n        os.remove(filename)\n        return out_html\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.to_streamlit","title":"<code>to_streamlit(self, width=None, height=600, scrolling=False, add_layer_control=True, bidirectional=False, **kwargs)</code>","text":"<p>Renders <code>folium.Figure</code> or <code>folium.Map</code> in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the map. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <code>add_layer_control</code> <code>bool</code> <p>Whether to add the layer control. Defaults to True.</p> <code>True</code> <code>bidirectional</code> <code>bool</code> <p>Whether to add bidirectional functionality to the map. The streamlit-folium package is required to use the bidirectional functionality. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If streamlit is not installed.</p> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def to_streamlit(\n    self,\n    width=None,\n    height=600,\n    scrolling=False,\n    add_layer_control=True,\n    bidirectional=False,\n    **kwargs,\n):\n\"\"\"Renders `folium.Figure` or `folium.Map` in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n    Args:\n        width (int, optional): Width of the map. Defaults to None.\n        height (int, optional): Height of the map. Defaults to 600.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n        add_layer_control (bool, optional): Whether to add the layer control. Defaults to True.\n        bidirectional (bool, optional): Whether to add bidirectional functionality to the map. The streamlit-folium package is required to use the bidirectional functionality. Defaults to False.\n\n    Raises:\n        ImportError: If streamlit is not installed.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    try:\n        import streamlit.components.v1 as components\n\n        if add_layer_control:\n            self.add_layer_control()\n\n        if bidirectional:\n            from streamlit_folium import st_folium\n\n            output = st_folium(self, width=width, height=height)\n            return output\n        else:\n            # if responsive:\n            #     make_map_responsive = \"\"\"\n            #     &lt;style&gt;\n            #     [title~=\"st.iframe\"] { width: 100%}\n            #     &lt;/style&gt;\n            #     \"\"\"\n            #     st.markdown(make_map_responsive, unsafe_allow_html=True)\n            return components.html(\n                self.to_html(), width=width, height=height, scrolling=scrolling\n            )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.zoom_to_bounds","title":"<code>zoom_to_bounds(self, bounds)</code>","text":"<p>Zooms to a bounding box in the form of [minx, miny, maxx, maxy].</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list | tuple</code> <p>A list/tuple containing minx, miny, maxx, maxy values for the bounds.</p> required Source code in <code>geemap/foliumap.py</code> <pre><code>def zoom_to_bounds(self, bounds):\n\"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n    Args:\n        bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n    \"\"\"\n    #  The folium fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.Map.zoom_to_gdf","title":"<code>zoom_to_gdf(self, gdf)</code>","text":"<p>Zooms to the bounding box of a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required Source code in <code>geemap/foliumap.py</code> <pre><code>def zoom_to_gdf(self, gdf):\n\"\"\"Zooms to the bounding box of a GeoPandas GeoDataFrame.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n    \"\"\"\n    bounds = gdf.total_bounds\n    self.zoom_to_bounds(bounds)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.SideBySideLayers","title":"<code> SideBySideLayers            (JSCSSMixin, Layer)         </code>","text":"<p>Creates a SideBySideLayers that takes two Layers and adds a sliding control with the leaflet-side-by-side plugin. Uses the Leaflet leaflet-side-by-side plugin https://github.com/digidem/leaflet-side-by-side. Adopted from https://github.com/python-visualization/folium/pull/1292/files. Parameters</p> <p>Layer.</p> <p>The left Layer within the side by side control. Must be created and added to the map before being passed to this class.</p> <p>Layer.</p> <p>The right Layer within the side by side control. Must be created and added to the map before being passed to this class.</p>"},{"location":"foliumap/#geemap.foliumap.SideBySideLayers--examples","title":"Examples","text":"<p>sidebyside = SideBySideLayers(layer_left, layer_right) sidebyside.add_to(m)</p> Source code in <code>geemap/foliumap.py</code> <pre><code>class SideBySideLayers(JSCSSMixin, Layer):\n\"\"\"\n    Creates a SideBySideLayers that takes two Layers and adds a sliding\n    control with the leaflet-side-by-side plugin.\n    Uses the Leaflet leaflet-side-by-side plugin https://github.com/digidem/leaflet-side-by-side.\n    Adopted from https://github.com/python-visualization/folium/pull/1292/files.\n    Parameters\n    ----------\n    layer_left: Layer.\n        The left Layer within the side by side control.\n        Must be created and added to the map before being passed to this class.\n    layer_right: Layer.\n        The right Layer within the side by side control.\n        Must be created and added to the map before being passed to this class.\n    Examples\n    --------\n    &gt;&gt;&gt; sidebyside = SideBySideLayers(layer_left, layer_right)\n    &gt;&gt;&gt; sidebyside.add_to(m)\n    \"\"\"\n\n    _template = Template(\n\"\"\"\n        {% macro script(this, kwargs) %}\n            var {{ this.get_name() }} = L.control.sideBySide(\n                {{ this.layer_left.get_name() }}, {{ this.layer_right.get_name() }}\n            ).addTo({{ this._parent.get_name() }});\n        {% endmacro %}\n        \"\"\"\n    )\n\n    default_js = [\n        (\n            \"leaflet.sidebyside\",\n            \"https://cdn.jsdelivr.net/gh/digidem/leaflet-side-by-side@gh-pages/leaflet-side-by-side.min.js\",\n        ),\n    ]\n\n    def __init__(self, layer_left, layer_right):\n        super().__init__(control=False)\n        self._name = \"SideBySideLayers\"\n        self.layer_left = layer_left\n        self.layer_right = layer_right\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.SplitControl","title":"<code> SplitControl            (Layer)         </code>","text":"<p>Creates a SplitControl that takes two Layers and adds a sliding control with the leaflet-side-by-side plugin. Uses the Leaflet leaflet-side-by-side plugin https://github.com/digidem/leaflet-side-by-side Parameters. The source code is adapted from https://github.com/python-visualization/folium/pull/1292</p> <p>Layer.</p> <p>The left Layer within the side by side control. Must  be created and added to the map before being passed to this class.</p> <p>Layer.</p> <p>The right Layer within the side by side control. Must  be created and added to the map before being passed to this class.</p> <p>name : string, default None     The name of the Layer, as it will appear in LayerControls. overlay : bool, default True     Adds the layer as an optional overlay (True) or the base layer (False). control : bool, default True     Whether the Layer will be included in LayerControls.</p> <p>bool, default True</p> <p>Whether the layer will be shown on opening (only for overlays).</p>"},{"location":"foliumap/#geemap.foliumap.SplitControl--examples","title":"Examples","text":"<p>sidebyside = SideBySideLayers(layer_left, layer_right) sidebyside.add_to(m)</p> Source code in <code>geemap/foliumap.py</code> <pre><code>class SplitControl(Layer):\n\"\"\"\n    Creates a SplitControl that takes two Layers and adds a sliding control with the leaflet-side-by-side plugin.\n    Uses the Leaflet leaflet-side-by-side plugin https://github.com/digidem/leaflet-side-by-side Parameters.\n    The source code is adapted from https://github.com/python-visualization/folium/pull/1292\n    ----------\n    layer_left: Layer.\n        The left Layer within the side by side control.\n        Must  be created and added to the map before being passed to this class.\n    layer_right: Layer.\n        The right Layer within the side by side control.\n        Must  be created and added to the map before being passed to this class.\n    name : string, default None\n        The name of the Layer, as it will appear in LayerControls.\n    overlay : bool, default True\n        Adds the layer as an optional overlay (True) or the base layer (False).\n    control : bool, default True\n        Whether the Layer will be included in LayerControls.\n    show: bool, default True\n        Whether the layer will be shown on opening (only for overlays).\n    Examples\n    --------\n    &gt;&gt;&gt; sidebyside = SideBySideLayers(layer_left, layer_right)\n    &gt;&gt;&gt; sidebyside.add_to(m)\n    \"\"\"\n\n    _template = Template(\n\"\"\"\n        {% macro script(this, kwargs) %}\n            var {{ this.get_name() }} = L.control.sideBySide(\n                {{ this.layer_left.get_name() }}, {{ this.layer_right.get_name() }}\n            ).addTo({{ this._parent.get_name() }});\n        {% endmacro %}\n        \"\"\"\n    )\n\n    def __init__(\n        self, layer_left, layer_right, name=None, overlay=True, control=False, show=True\n    ):\n        super(SplitControl, self).__init__(\n            name=name, overlay=overlay, control=control, show=show\n        )\n        self._name = \"SplitControl\"\n        self.layer_left = layer_left\n        self.layer_right = layer_right\n\n    def render(self, **kwargs):\n        super(SplitControl, self).render()\n\n        figure = self.get_root()\n        assert isinstance(figure, Figure), (\n            \"You cannot render this Element \" \"if it is not in a Figure.\"\n        )\n\n        figure.header.add_child(\n            JavascriptLink(\n                \"https://raw.githack.com/digidem/leaflet-side-by-side/gh-pages/leaflet-side-by-side.js\"\n            ),  # noqa\n            name=\"leaflet.sidebyside\",\n        )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.SplitControl.render","title":"<code>render(self, **kwargs)</code>","text":"<p>Renders the HTML representation of the element.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def render(self, **kwargs):\n    super(SplitControl, self).render()\n\n    figure = self.get_root()\n    assert isinstance(figure, Figure), (\n        \"You cannot render this Element \" \"if it is not in a Figure.\"\n    )\n\n    figure.header.add_child(\n        JavascriptLink(\n            \"https://raw.githack.com/digidem/leaflet-side-by-side/gh-pages/leaflet-side-by-side.js\"\n        ),  # noqa\n        name=\"leaflet.sidebyside\",\n    )\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.delete_dp_report","title":"<code>delete_dp_report(name)</code>","text":"<p>Deletes a datapane report.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the report to delete.</p> required Source code in <code>geemap/foliumap.py</code> <pre><code>def delete_dp_report(name):\n\"\"\"Deletes a datapane report.\n\n    Args:\n        name (str): Name of the report to delete.\n    \"\"\"\n    try:\n        import datapane as dp\n\n        reports = dp.Report.list()\n        items = list(reports)\n        names = list(map(lambda item: item[\"name\"], items))\n        if name in names:\n            report = dp.Report.get(name)\n            url = report.blocks[0][\"url\"]\n            # print(f'Deleting {url}...')\n            dp.Report.delete(dp.Report.by_id(url))\n    except Exception as e:\n        print(e)\n        return\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.delete_dp_reports","title":"<code>delete_dp_reports()</code>","text":"<p>Deletes all datapane reports.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def delete_dp_reports():\n\"\"\"Deletes all datapane reports.\"\"\"\n    try:\n        import datapane as dp\n\n        reports = dp.Report.list()\n        for item in reports:\n            print(item[\"name\"])\n            report = dp.Report.get(item[\"name\"])\n            url = report.blocks[0][\"url\"]\n            print(f\"Deleting {url}...\")\n            dp.Report.delete(dp.Report.by_id(url))\n    except Exception as e:\n        print(e)\n        return\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.ee_tile_layer","title":"<code>ee_tile_layer(ee_object, vis_params={}, name='Layer untitled', shown=True, opacity=1.0, **kwargs)</code>","text":"<p>Converts and Earth Engine layer to ipyleaflet TileLayer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer untitled'.</p> <code>'Layer untitled'</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/foliumap.py</code> <pre><code>def ee_tile_layer(\n    ee_object, vis_params={}, name=\"Layer untitled\", shown=True, opacity=1.0, **kwargs\n):\n\"\"\"Converts and Earth Engine layer to ipyleaflet TileLayer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer untitled'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n\n    image = None\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n    tile_layer = folium.raster_layers.TileLayer(\n        tiles=map_id_dict[\"tile_fetcher\"].url_format,\n        attr=\"Google Earth Engine\",\n        name=name,\n        overlay=True,\n        control=True,\n        opacity=opacity,\n        show=shown,\n        max_zoom=24,\n        **kwargs,\n    )\n    return tile_layer\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.st_map_center","title":"<code>st_map_center(lat, lon)</code>","text":"<p>Returns the map center coordinates for a given latitude and longitude. If the system variable 'map_center' exists, it is used. Otherwise, the default is returned.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>lon</code> <code>float</code> <p>Longitude.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>If streamlit is not installed.</p> <p>Returns:</p> Type Description <code>list</code> <p>The map center coordinates.</p> Source code in <code>geemap/foliumap.py</code> <pre><code>def st_map_center(lat, lon):\n\"\"\"Returns the map center coordinates for a given latitude and longitude. If the system variable 'map_center' exists, it is used. Otherwise, the default is returned.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n\n    Raises:\n        Exception: If streamlit is not installed.\n\n    Returns:\n        list: The map center coordinates.\n    \"\"\"\n    try:\n        import streamlit as st\n\n        if \"map_center\" in st.session_state:\n            return st.session_state[\"map_center\"]\n        else:\n            return [lat, lon]\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#geemap.foliumap.st_save_bounds","title":"<code>st_save_bounds(st_component)</code>","text":"<p>Saves the map bounds to the session state.</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <code>folium.folium.Map</code> <p>The map to save the bounds from.</p> required Source code in <code>geemap/foliumap.py</code> <pre><code>def st_save_bounds(st_component):\n\"\"\"Saves the map bounds to the session state.\n\n    Args:\n        map (folium.folium.Map): The map to save the bounds from.\n    \"\"\"\n    try:\n        import streamlit as st\n\n        if st_component is not None:\n            bounds = st_component[\"bounds\"]\n            south = bounds[\"_southWest\"][\"lat\"]\n            west = bounds[\"_southWest\"][\"lng\"]\n            north = bounds[\"_northEast\"][\"lat\"]\n            east = bounds[\"_northEast\"][\"lng\"]\n\n            bounds = [[south, west], [north, east]]\n            center = [south + (north - south) / 2, west + (east - west) / 2]\n\n            st.session_state[\"map_bounds\"] = bounds\n            st.session_state[\"map_center\"] = center\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/","title":"geemap module","text":"<p>Main module for interactive mapping using Google Earth Engine Python API and ipyleaflet. Keep in mind that Earth Engine functions use both camel case and snake case, such as setOptions(), setCenter(), centerObject(), addLayer(). ipyleaflet functions use snake case, such as add_tile_layer(), add_wms_layer(), add_minimap().</p>"},{"location":"geemap/#geemap.geemap.ImageOverlay","title":"<code> ImageOverlay            (ImageOverlay)         </code>","text":"<p>ImageOverlay class.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>http URL or local file path to the image.</p> required <code>bounds</code> <code>tuple</code> <p>bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).</p> required <code>name</code> <code>str</code> <p>The name of the layer.</p> required Source code in <code>geemap/geemap.py</code> <pre><code>class ImageOverlay(ipyleaflet.ImageOverlay):\n\"\"\"ImageOverlay class.\n\n    Args:\n        url (str): http URL or local file path to the image.\n        bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n        name (str): The name of the layer.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        from base64 import b64encode\n        from PIL import Image, ImageSequence\n        from io import BytesIO\n\n        try:\n            url = kwargs.get(\"url\")\n            if not url.startswith(\"http\"):\n                url = os.path.abspath(url)\n                if not os.path.exists(url):\n                    raise FileNotFoundError(\"The provided file does not exist.\")\n\n                ext = os.path.splitext(url)[1][1:]  # file extension\n                image = Image.open(url)\n\n                f = BytesIO()\n                if ext.lower() == \"gif\":\n                    frames = []\n                    # Loop over each frame in the animated image\n                    for frame in ImageSequence.Iterator(image):\n                        frame = frame.convert(\"RGBA\")\n                        b = BytesIO()\n                        frame.save(b, format=\"gif\")\n                        frame = Image.open(b)\n                        frames.append(frame)\n                    frames[0].save(\n                        f,\n                        format=\"GIF\",\n                        save_all=True,\n                        append_images=frames[1:],\n                        loop=0,\n                    )\n                else:\n                    image.save(f, ext)\n\n                data = b64encode(f.getvalue())\n                data = data.decode(\"ascii\")\n                url = \"data:image/{};base64,\".format(ext) + data\n                kwargs[\"url\"] = url\n        except Exception as e:\n            raise Exception(e)\n\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map","title":"<code> Map            (Map)         </code>","text":"<p>The Map class inherits from ipyleaflet.Map. The arguments you can pass to the Map can be found at https://ipyleaflet.readthedocs.io/en/latest/map_and_basemaps/map.html. By default, the Map will add Google Maps as the basemap. Set add_google_map = False to use OpenStreetMap as the basemap.</p> <p>Returns:</p> Type Description <code>object</code> <p>ipyleaflet map object.</p> Source code in <code>geemap/geemap.py</code> <pre><code>class Map(ipyleaflet.Map):\n\"\"\"The Map class inherits from ipyleaflet.Map. The arguments you can pass to the Map can be found at https://ipyleaflet.readthedocs.io/en/latest/map_and_basemaps/map.html. By default, the Map will add Google Maps as the basemap. Set add_google_map = False to use OpenStreetMap as the basemap.\n\n    Returns:\n        object: ipyleaflet map object.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        import warnings\n\n        warnings.filterwarnings(\"ignore\")\n\n        # Authenticates Earth Engine and initializes an Earth Engine session\n        if \"ee_initialize\" not in kwargs.keys():\n            kwargs[\"ee_initialize\"] = True\n\n        if kwargs[\"ee_initialize\"]:\n            ee_initialize()\n\n        # Default map center location (lat, lon) and zoom level\n        latlon = [20, 0]\n        zoom = 2\n\n        # Interchangeable parameters between ipyleaflet and folium\n        if \"height\" not in kwargs.keys():\n            kwargs[\"height\"] = \"600px\"\n        elif isinstance(kwargs[\"height\"], int):\n            kwargs[\"height\"] = str(kwargs[\"height\"]) + \"px\"\n        if \"width\" in kwargs.keys() and isinstance(kwargs[\"width\"], int):\n            kwargs[\"width\"] = str(kwargs[\"width\"]) + \"px\"\n\n        if \"location\" in kwargs.keys():\n            kwargs[\"center\"] = kwargs[\"location\"]\n            kwargs.pop(\"location\")\n        if \"center\" not in kwargs.keys():\n            kwargs[\"center\"] = latlon\n\n        if \"zoom_start\" in kwargs.keys():\n            kwargs[\"zoom\"] = kwargs[\"zoom_start\"]\n            kwargs.pop(\"zoom_start\")\n        if \"zoom\" not in kwargs.keys():\n            kwargs[\"zoom\"] = zoom\n        if \"max_zoom\" not in kwargs.keys():\n            kwargs[\"max_zoom\"] = 24\n\n        if \"add_google_map\" not in kwargs.keys() and \"basemap\" not in kwargs.keys():\n            kwargs[\"add_google_map\"] = True\n        if \"scroll_wheel_zoom\" not in kwargs.keys():\n            kwargs[\"scroll_wheel_zoom\"] = True\n\n        if \"lite_mode\" not in kwargs.keys():\n            kwargs[\"lite_mode\"] = False\n\n        if kwargs[\"lite_mode\"]:\n            kwargs[\"data_ctrl\"] = False\n            kwargs[\"zoom_ctrl\"] = True\n            kwargs[\"fullscreen_ctrl\"] = False\n            kwargs[\"draw_ctrl\"] = False\n            kwargs[\"search_ctrl\"] = False\n            kwargs[\"measure_ctrl\"] = False\n            kwargs[\"scale_ctrl\"] = False\n            kwargs[\"layer_ctrl\"] = False\n            kwargs[\"toolbar_ctrl\"] = False\n            kwargs[\"attribution_ctrl\"] = False\n\n        if \"data_ctrl\" not in kwargs.keys():\n            kwargs[\"data_ctrl\"] = True\n        if \"zoom_ctrl\" not in kwargs.keys():\n            kwargs[\"zoom_ctrl\"] = True\n        if \"fullscreen_ctrl\" not in kwargs.keys():\n            kwargs[\"fullscreen_ctrl\"] = True\n        if \"draw_ctrl\" not in kwargs.keys():\n            kwargs[\"draw_ctrl\"] = True\n        if \"search_ctrl\" not in kwargs.keys():\n            kwargs[\"search_ctrl\"] = False\n        if \"measure_ctrl\" not in kwargs.keys():\n            kwargs[\"measure_ctrl\"] = True\n        if \"scale_ctrl\" not in kwargs.keys():\n            kwargs[\"scale_ctrl\"] = True\n        if \"layer_ctrl\" not in kwargs.keys():\n            kwargs[\"layer_ctrl\"] = False\n        if \"toolbar_ctrl\" not in kwargs.keys():\n            kwargs[\"toolbar_ctrl\"] = True\n        if \"attribution_ctrl\" not in kwargs.keys():\n            kwargs[\"attribution_ctrl\"] = True\n        if \"use_voila\" not in kwargs.keys():\n            kwargs[\"use_voila\"] = False\n\n        if (\n            \"basemap\" in kwargs.keys()\n            and isinstance(kwargs[\"basemap\"], str)\n            and kwargs[\"basemap\"] in basemaps.keys()\n        ):\n            kwargs[\"basemap\"] = basemaps[kwargs[\"basemap\"]]\n\n        if os.environ.get(\"USE_VOILA\") is not None:\n            kwargs[\"use_voila\"] = True\n\n        # Inherits the ipyleaflet Map class\n        super().__init__(**kwargs)\n        self.baseclass = \"ipyleaflet\"\n        self.layout.height = kwargs[\"height\"]\n        if \"width\" in kwargs:\n            self.layout.width = kwargs[\"width\"]\n\n        # sandbox path for Voila app to restrict access to system directories.\n        if \"sandbox_path\" not in kwargs:\n            if os.environ.get(\"USE_VOILA\") is not None:\n                self.sandbox_path = os.getcwd()\n            else:\n                self.sandbox_path = None\n        else:\n            if os.path.exists(os.path.abspath(kwargs[\"sandbox_path\"])):\n                self.sandbox_path = kwargs[\"sandbox_path\"]\n            else:\n                print(\"The sandbox path is invalid.\")\n                self.sandbox_path = None\n\n        self.clear_controls()\n\n        # The number of shapes drawn by the user using the DrawControl\n        self.draw_count = 0\n        # The list of Earth Engine Geometry objects converted from geojson\n        self.draw_features = []\n        # The Earth Engine Geometry object converted from the last drawn feature\n        self.draw_last_feature = None\n        self.draw_layer = None\n        self.draw_last_json = None\n        self.draw_last_bounds = None\n        self.user_roi = None\n        self.user_rois = None\n        self.last_ee_data = None\n        self.last_ee_layer = None\n        self.geojson_layers = []\n\n        self.roi_start = False\n        self.roi_end = False\n        if kwargs[\"ee_initialize\"]:\n            self.roi_reducer = ee.Reducer.mean()\n        self.roi_reducer_scale = None\n\n        # List for storing pixel values and locations based on user-drawn geometries.\n        self.chart_points = []\n        self.chart_values = []\n        self.chart_labels = None\n\n        self.plot_widget = None  # The plot widget for plotting Earth Engine data\n        self.plot_control = None  # The plot control for interacting plotting\n        self.random_marker = None\n\n        self.legend_widget = None\n        self.legend = None\n        self.colorbar = None\n\n        self.ee_layers = []\n        self.ee_layer_names = []\n        self.ee_raster_layers = []\n        self.ee_raster_layer_names = []\n        self.ee_vector_layers = []\n        self.ee_vector_layer_names = []\n        self.ee_layer_dict = {}\n\n        self.search_locations = None\n        self.search_loc_marker = None\n        self.search_loc_geom = None\n        self.search_datasets = None\n        self.screenshot = None\n        self.toolbar = None\n        self.toolbar_button = None\n        self.vis_control = None\n        self.vis_widget = None\n        self.colorbar_ctrl = None\n        self.colorbar_widget = None\n        self.tool_output = None\n        self.tool_output_ctrl = None\n        self.layer_control = None\n        self.convert_ctrl = None\n        self.toolbar_ctrl = None\n        self._expand_point = False\n        self._expand_pixels = True\n        self._expand_objects = False\n\n        # Adds search button and search box\n        search_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Search location/data\",\n            icon=\"globe\",\n            layout=widgets.Layout(\n                width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"\n            ),\n        )\n\n        search_type = widgets.ToggleButtons(\n            options=[\"name/address\", \"lat-lon\", \"data\"],\n            tooltips=[\n                \"Search by place name or address\",\n                \"Search by lat-lon coordinates\",\n                \"Search Earth Engine data catalog\",\n            ],\n        )\n        search_type.style.button_width = \"110px\"\n\n        search_box = widgets.Text(\n            placeholder=\"Search by place name or address\",\n            tooltip=\"Search location\",\n            layout=widgets.Layout(width=\"340px\"),\n        )\n\n        search_output = widgets.Output(\n            layout={\n                \"max_width\": \"340px\",\n                \"max_height\": \"350px\",\n                \"overflow\": \"scroll\",\n            }\n        )\n\n        search_results = widgets.RadioButtons()\n\n        assets_dropdown = widgets.Dropdown(\n            options=[],\n            layout=widgets.Layout(min_width=\"279px\", max_width=\"279px\"),\n        )\n\n        import_btn = widgets.Button(\n            description=\"import\",\n            button_style=\"primary\",\n            tooltip=\"Click to import the selected asset\",\n            layout=widgets.Layout(min_width=\"57px\", max_width=\"57px\"),\n        )\n\n        def get_ee_example(asset_id):\n            try:\n                pkg_dir = os.path.dirname(\n                    pkg_resources.resource_filename(\"geemap\", \"geemap.py\")\n                )\n                with open(\n                    os.path.join(pkg_dir, \"data/gee_f.json\"), encoding=\"utf-8\"\n                ) as f:\n                    functions = json.load(f)\n                details = [\n                    dataset[\"code\"]\n                    for x in functions[\"examples\"]\n                    for dataset in x[\"contents\"]\n                    if x[\"name\"] == \"Datasets\"\n                    if dataset[\"name\"] == asset_id.replace(\"/\", \"_\")\n                ]\n\n                return js_snippet_to_py(\n                    details[0],\n                    add_new_cell=False,\n                    import_ee=False,\n                    import_geemap=False,\n                    show_map=False,\n                )\n\n            except Exception as e:\n                pass\n            return\n\n        def import_btn_clicked(b):\n            if assets_dropdown.value is not None:\n                datasets = self.search_datasets\n                dataset = datasets[assets_dropdown.index]\n                id_ = dataset[\"id\"]\n                code = get_ee_example(id_)\n\n                if not code:\n                    dataset_uid = \"dataset_\" + random_string(string_length=3)\n                    translate = {\n                        \"image_collection\": \"ImageCollection\",\n                        \"image\": \"Image\",\n                        \"table\": \"FeatureCollection\",\n                        \"table_collection\": \"FeatureCollection\",\n                    }\n                    datatype = translate[dataset[\"type\"]]\n                    id_ = dataset[\"id\"]\n                    line1 = \"{} = ee.{}('{}')\".format(dataset_uid, datatype, id_)\n                    action = {\n                        \"image_collection\": f\"\\nMap.addLayer({dataset_uid}, {{}}, '{id_}')\",\n                        \"image\": f\"\\nMap.addLayer({dataset_uid}, {{}}, '{id_}')\",\n                        \"table\": f\"\\nMap.addLayer({dataset_uid}, {{}}, '{id_}')\",\n                        \"table_collection\": f\"\\nMap.addLayer({dataset_uid}, {{}}, '{id_}')\",\n                    }\n                    line2 = action[dataset[\"type\"]]\n                    code = [line1, line2]\n\n                contents = \"\".join(code).strip()\n                # create_code_cell(contents)\n                with search_output:\n                    search_output.clear_output(wait=True)\n                    print(\n                        \"# The code has been copied to the clipboard. \\n# Press Ctrl+V in a new cell to paste it.\\n\"\n                    )\n                    print(contents)\n\n        import_btn.on_click(import_btn_clicked)\n\n        html_widget = widgets.HTML()\n\n        def dropdown_change(change):\n            dropdown_index = assets_dropdown.index\n            if dropdown_index is not None and dropdown_index &gt;= 0:\n                with search_output:\n                    search_output.clear_output(wait=True)\n                    print(\"Loading ...\")\n                    datasets = self.search_datasets\n                    dataset = datasets[dropdown_index]\n                    dataset_html = ee_data_html(dataset)\n                    html_widget.value = dataset_html\n                    search_output.clear_output(wait=True)\n                    display(html_widget)\n\n        assets_dropdown.observe(dropdown_change, names=\"value\")\n\n        assets_combo = widgets.HBox()\n        assets_combo.children = [import_btn, assets_dropdown]\n\n        def search_result_change(change):\n            result_index = search_results.index\n            locations = self.search_locations\n            location = locations[result_index]\n            latlon = (location.lat, location.lng)\n            self.search_loc_geom = ee.Geometry.Point(location.lng, location.lat)\n            marker = self.search_loc_marker\n            marker.location = latlon\n            self.center = latlon\n\n        search_results.observe(search_result_change, names=\"value\")\n\n        def search_btn_click(change):\n            if change[\"new\"]:\n                search_widget.children = [search_button, search_result_widget]\n                search_type.value = \"name/address\"\n            else:\n                search_widget.children = [search_button]\n                search_result_widget.children = [search_type, search_box]\n\n        search_button.observe(search_btn_click, \"value\")\n\n        def search_type_changed(change):\n            search_box.value = \"\"\n            search_output.clear_output()\n            if change[\"new\"] == \"data\":\n                search_box.placeholder = (\n                    \"Search GEE data catalog by keywords, e.g., elevation\"\n                )\n                search_result_widget.children = [\n                    search_type,\n                    search_box,\n                    assets_combo,\n                    search_output,\n                ]\n            elif change[\"new\"] == \"lat-lon\":\n                search_box.placeholder = \"Search by lat-lon, e.g., 40, -100\"\n                assets_dropdown.options = []\n                search_result_widget.children = [\n                    search_type,\n                    search_box,\n                    search_output,\n                ]\n            elif change[\"new\"] == \"name/address\":\n                search_box.placeholder = \"Search by place name or address, e.g., Paris\"\n                assets_dropdown.options = []\n                search_result_widget.children = [\n                    search_type,\n                    search_box,\n                    search_output,\n                ]\n\n        search_type.observe(search_type_changed, names=\"value\")\n\n        def search_box_callback(text):\n            if text.value != \"\":\n                if search_type.value == \"name/address\":\n                    g = geocode(text.value)\n                elif search_type.value == \"lat-lon\":\n                    g = geocode(text.value, reverse=True)\n                    if g is None and latlon_from_text(text.value):\n                        search_output.clear_output()\n                        latlon = latlon_from_text(text.value)\n                        self.search_loc_geom = ee.Geometry.Point(latlon[1], latlon[0])\n                        if self.search_loc_marker is None:\n                            marker = ipyleaflet.Marker(\n                                location=latlon,\n                                draggable=False,\n                                name=\"Search location\",\n                            )\n                            self.search_loc_marker = marker\n                            self.add_layer(marker)\n                            self.center = latlon\n                        else:\n                            marker = self.search_loc_marker\n                            marker.location = latlon\n                            self.center = latlon\n                        with search_output:\n                            print(f\"No address found for {latlon}\")\n                        return\n                elif search_type.value == \"data\":\n                    search_output.clear_output()\n                    with search_output:\n                        print(\"Searching ...\")\n                    self.default_style = {\"cursor\": \"wait\"}\n                    ee_assets = search_ee_data(text.value, source=\"all\")\n                    self.search_datasets = ee_assets\n                    asset_titles = [x[\"title\"] for x in ee_assets]\n                    assets_dropdown.options = asset_titles\n                    search_output.clear_output()\n                    if len(ee_assets) &gt; 0:\n                        assets_dropdown.index = 0\n                        html_widget.value = ee_data_html(ee_assets[0])\n                    else:\n                        html_widget.value = \"No results found.\"\n                    with search_output:\n                        display(html_widget)\n                    self.default_style = {\"cursor\": \"default\"}\n\n                    return\n\n                self.search_locations = g\n                if g is not None and len(g) &gt; 0:\n                    top_loc = g[0]\n                    latlon = (top_loc.lat, top_loc.lng)\n                    self.search_loc_geom = ee.Geometry.Point(top_loc.lng, top_loc.lat)\n                    if self.search_loc_marker is None:\n                        marker = ipyleaflet.Marker(\n                            location=latlon,\n                            draggable=False,\n                            name=\"Search location\",\n                        )\n                        self.search_loc_marker = marker\n                        self.add_layer(marker)\n                        self.center = latlon\n                    else:\n                        marker = self.search_loc_marker\n                        marker.location = latlon\n                        self.center = latlon\n                    search_results.options = [x.address for x in g]\n                    search_result_widget.children = [\n                        search_type,\n                        search_box,\n                        search_output,\n                    ]\n                    with search_output:\n                        search_output.clear_output(wait=True)\n                        display(search_results)\n                else:\n                    with search_output:\n                        search_output.clear_output()\n                        print(\"No results could be found.\")\n\n        search_box.on_submit(search_box_callback)\n\n        search_result_widget = widgets.VBox([search_type, search_box])\n        search_widget = widgets.HBox([search_button])\n\n        search_event = ipyevents.Event(\n            source=search_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n        )\n\n        def handle_search_event(event):\n            if event[\"type\"] == \"mouseenter\":\n                search_widget.children = [search_button, search_result_widget]\n                # search_type.value = \"name/address\"\n            elif event[\"type\"] == \"mouseleave\":\n                if not search_button.value:\n                    search_widget.children = [search_button]\n                    search_result_widget.children = [search_type, search_box]\n\n        search_event.on_dom_event(handle_search_event)\n\n        data_control = ipyleaflet.WidgetControl(\n            widget=search_widget, position=\"topleft\"\n        )\n\n        if kwargs.get(\"data_ctrl\"):\n            self.add_control(control=data_control)\n\n        search_marker = ipyleaflet.Marker(\n            icon=ipyleaflet.AwesomeIcon(\n                name=\"check\", marker_color=\"green\", icon_color=\"darkgreen\"\n            )\n        )\n        search = ipyleaflet.SearchControl(\n            position=\"topleft\",\n            url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\",\n            zoom=5,\n            property_name=\"display_name\",\n            marker=search_marker,\n        )\n        if kwargs.get(\"search_ctrl\"):\n            self.add_control(search)\n\n        if kwargs.get(\"zoom_ctrl\"):\n            self.add_control(ipyleaflet.ZoomControl(position=\"topleft\"))\n\n        if kwargs.get(\"layer_ctrl\"):\n            layer_control = ipyleaflet.LayersControl(position=\"topright\")\n            self.layer_control = layer_control\n            self.add_control(layer_control)\n\n        if kwargs.get(\"scale_ctrl\"):\n            scale = ipyleaflet.ScaleControl(position=\"bottomleft\")\n            self.scale_control = scale\n            self.add_control(scale)\n\n        if kwargs.get(\"fullscreen_ctrl\"):\n            fullscreen = ipyleaflet.FullScreenControl()\n            self.fullscreen_control = fullscreen\n            self.add_control(fullscreen)\n\n        if kwargs.get(\"measure_ctrl\"):\n            measure = ipyleaflet.MeasureControl(\n                position=\"bottomleft\",\n                active_color=\"orange\",\n                primary_length_unit=\"kilometers\",\n            )\n            self.measure_control = measure\n            self.add_control(measure)\n\n        if kwargs.get(\"add_google_map\"):\n            self.add_layer(basemaps[\"ROADMAP\"])\n\n        if kwargs.get(\"attribution_ctrl\"):\n            self.add_control(ipyleaflet.AttributionControl(position=\"bottomright\"))\n\n        draw_control = ipyleaflet.DrawControl(\n            marker={\"shapeOptions\": {\"color\": \"#3388ff\"}},\n            rectangle={\"shapeOptions\": {\"color\": \"#3388ff\"}},\n            circle={\"shapeOptions\": {\"color\": \"#3388ff\"}},\n            circlemarker={},\n            edit=True,\n            remove=True,\n        )\n\n        draw_control_lite = ipyleaflet.DrawControl(\n            marker={},\n            rectangle={\"shapeOptions\": {\"color\": \"#3388ff\"}},\n            circle={\"shapeOptions\": {\"color\": \"#3388ff\"}},\n            circlemarker={},\n            polyline={},\n            polygon={},\n            edit=False,\n            remove=False,\n        )\n\n        # Handles draw events\n        def handle_draw(target, action, geo_json):\n            try:\n                self.roi_start = True\n                geom = geojson_to_ee(geo_json, False)\n                self.user_roi = geom\n                feature = ee.Feature(geom)\n                self.draw_last_json = geo_json\n                self.draw_last_feature = feature\n                if action == \"deleted\" and len(self.draw_features) &gt; 0:\n                    self.draw_features.remove(feature)\n                    self.draw_count -= 1\n                else:\n                    self.draw_features.append(feature)\n                    self.draw_count += 1\n                collection = ee.FeatureCollection(self.draw_features)\n                self.user_rois = collection\n                ee_draw_layer = ee_tile_layer(\n                    collection, {\"color\": \"blue\"}, \"Drawn Features\", False, 0.5\n                )\n                draw_layer_index = self.find_layer_index(\"Drawn Features\")\n\n                if draw_layer_index == -1:\n                    self.add_layer(ee_draw_layer)\n                    self.draw_layer = ee_draw_layer\n                else:\n                    self.substitute_layer(self.draw_layer, ee_draw_layer)\n                    self.draw_layer = ee_draw_layer\n                self.roi_end = True\n                self.roi_start = False\n            except Exception as e:\n                self.draw_count = 0\n                self.draw_features = []\n                self.draw_last_feature = None\n                self.draw_layer = None\n                self.user_roi = None\n                self.roi_start = False\n                self.roi_end = False\n                print(\"There was an error creating Earth Engine Feature.\")\n                raise Exception(e)\n\n        draw_control.on_draw(handle_draw)\n        if kwargs.get(\"draw_ctrl\"):\n            self.add_control(draw_control)\n        self.draw_control = draw_control\n        self.draw_control_lite = draw_control_lite\n\n        # Dropdown widget for plotting\n        self.plot_dropdown_control = None\n        self.plot_dropdown_widget = None\n        self.plot_options = {}\n        self.plot_marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n        self.plot_coordinates = []\n        self.plot_markers = []\n        self.plot_last_click = []\n        self.plot_all_clicks = []\n        self.plot_checked = False\n        self.inspector_checked = False\n\n        inspector_output = widgets.Output(\n            layout={\n                \"border\": \"1px solid black\",\n                \"max_width\": \"600px\",\n                \"max_height\": \"530px\",\n                \"overflow\": \"auto\",\n            }\n        )\n        inspector_output_control = ipyleaflet.WidgetControl(\n            widget=inspector_output,\n            position=\"topright\",\n        )\n        tool_output = widgets.Output()\n        self.tool_output = tool_output\n        tool_output.clear_output(wait=True)\n        save_map_widget = widgets.VBox()\n\n        save_type = widgets.ToggleButtons(\n            options=[\"HTML\", \"PNG\", \"JPG\"],\n            tooltips=[\n                \"Save the map as an HTML file\",\n                \"Take a screenshot and save as a PNG file\",\n                \"Take a screenshot and save as a JPG file\",\n            ],\n        )\n\n        file_chooser = FileChooser(os.getcwd(), sandbox_path=self.sandbox_path)\n        file_chooser.default_filename = \"my_map.html\"\n        file_chooser.use_dir_icons = True\n\n        ok_cancel = widgets.ToggleButtons(\n            value=None,\n            options=[\"OK\", \"Cancel\"],\n            tooltips=[\"OK\", \"Cancel\"],\n            button_style=\"primary\",\n        )\n\n        def save_type_changed(change):\n            ok_cancel.value = None\n            # file_chooser.reset()\n            file_chooser.default_path = os.getcwd()\n            if change[\"new\"] == \"HTML\":\n                file_chooser.default_filename = \"my_map.html\"\n            elif change[\"new\"] == \"PNG\":\n                file_chooser.default_filename = \"my_map.png\"\n            elif change[\"new\"] == \"JPG\":\n                file_chooser.default_filename = \"my_map.jpg\"\n            save_map_widget.children = [save_type, file_chooser]\n\n        def chooser_callback(chooser):\n            save_map_widget.children = [save_type, file_chooser, ok_cancel]\n\n        def ok_cancel_clicked(change):\n            if change[\"new\"] == \"OK\":\n                file_path = file_chooser.selected\n                ext = os.path.splitext(file_path)[1]\n                if save_type.value == \"HTML\" and ext.upper() == \".HTML\":\n                    tool_output.clear_output()\n                    self.to_html(file_path)\n                elif save_type.value == \"PNG\" and ext.upper() == \".PNG\":\n                    tool_output.clear_output()\n                    self.toolbar_button.value = False\n                    time.sleep(1)\n                    screen_capture(filename=file_path)\n                elif save_type.value == \"JPG\" and ext.upper() == \".JPG\":\n                    tool_output.clear_output()\n                    self.toolbar_button.value = False\n                    time.sleep(1)\n                    screen_capture(filename=file_path)\n                else:\n                    label = widgets.Label(\n                        value=\"The selected file extension does not match the selected exporting type.\"\n                    )\n                    save_map_widget.children = [save_type, file_chooser, label]\n                self.toolbar_reset()\n            elif change[\"new\"] == \"Cancel\":\n                tool_output.clear_output()\n                self.toolbar_reset()\n\n        save_type.observe(save_type_changed, names=\"value\")\n        ok_cancel.observe(ok_cancel_clicked, names=\"value\")\n\n        file_chooser.register_callback(chooser_callback)\n\n        save_map_widget.children = [save_type, file_chooser]\n\n        tools = {\n            \"info\": {\"name\": \"inspector\", \"tooltip\": \"Inspector\"},\n            \"bar-chart\": {\"name\": \"plotting\", \"tooltip\": \"Plotting\"},\n            \"camera\": {\n                \"name\": \"to_image\",\n                \"tooltip\": \"Save map as HTML or image\",\n            },\n            \"eraser\": {\n                \"name\": \"eraser\",\n                \"tooltip\": \"Remove all drawn features\",\n            },\n            \"folder-open\": {\n                \"name\": \"open_data\",\n                \"tooltip\": \"Open local vector/raster data\",\n            },\n            # \"cloud-download\": {\n            #     \"name\": \"export_data\",\n            #     \"tooltip\": \"Export Earth Engine data\",\n            # },\n            \"retweet\": {\n                \"name\": \"convert_js\",\n                \"tooltip\": \"Convert Earth Engine JavaScript to Python\",\n            },\n            \"gears\": {\n                \"name\": \"whitebox\",\n                \"tooltip\": \"WhiteboxTools for local geoprocessing\",\n            },\n            \"google\": {\n                \"name\": \"geetoolbox\",\n                \"tooltip\": \"GEE Toolbox for cloud computing\",\n            },\n            \"map\": {\n                \"name\": \"basemap\",\n                \"tooltip\": \"Change basemap\",\n            },\n            \"globe\": {\n                \"name\": \"timelapse\",\n                \"tooltip\": \"Create timelapse\",\n            },\n            \"fast-forward\": {\n                \"name\": \"timeslider\",\n                \"tooltip\": \"Activate timeslider\",\n            },\n            \"hand-o-up\": {\n                \"name\": \"draw\",\n                \"tooltip\": \"Collect training samples\",\n            },\n            \"line-chart\": {\n                \"name\": \"transect\",\n                \"tooltip\": \"Creating and plotting transects\",\n            },\n            \"random\": {\n                \"name\": \"sankee\",\n                \"tooltip\": \"Sankey plots\",\n            },\n            \"adjust\": {\n                \"name\": \"planet\",\n                \"tooltip\": \"Planet imagery\",\n            },\n            \"info-circle\": {\n                \"name\": \"cog-inspector\",\n                \"tooltip\": \"Get COG/STAC pixel value\",\n            },\n            \"spinner\": {\n                \"name\": \"placehold2\",\n                \"tooltip\": \"This is a placehold\",\n            },\n            \"question\": {\n                \"name\": \"help\",\n                \"tooltip\": \"Get help\",\n            },\n        }\n\n        # if kwargs[\"use_voila\"]:\n        #     voila_tools = [\"camera\", \"folder-open\", \"cloud-download\", \"gears\"]\n\n        #     for item in voila_tools:\n        #         if item in tools.keys():\n        #             del tools[item]\n\n        icons = list(tools.keys())\n        tooltips = [item[\"tooltip\"] for item in list(tools.values())]\n\n        icon_width = \"32px\"\n        icon_height = \"32px\"\n        n_cols = 3\n        n_rows = math.ceil(len(icons) / n_cols)\n\n        toolbar_grid = widgets.GridBox(\n            children=[\n                widgets.ToggleButton(\n                    layout=widgets.Layout(\n                        width=\"auto\", height=\"auto\", padding=\"0px 0px 0px 4px\"\n                    ),\n                    button_style=\"primary\",\n                    icon=icons[i],\n                    tooltip=tooltips[i],\n                )\n                for i in range(len(icons))\n            ],\n            layout=widgets.Layout(\n                width=\"109px\",\n                grid_template_columns=(icon_width + \" \") * n_cols,\n                grid_template_rows=(icon_height + \" \") * n_rows,\n                grid_gap=\"1px 1px\",\n                padding=\"5px\",\n            ),\n        )\n        self.toolbar = toolbar_grid\n\n        def tool_callback(change):\n            if change[\"new\"]:\n                current_tool = change[\"owner\"]\n                for tool in toolbar_grid.children:\n                    if tool is not current_tool:\n                        tool.value = False\n                tool = change[\"owner\"]\n                tool_name = tools[tool.icon][\"name\"]\n                if tool_name == \"to_image\":\n                    if tool_output_control not in self.controls:\n                        self.add_control(tool_output_control)\n                    with tool_output:\n                        tool_output.clear_output()\n                        display(save_map_widget)\n                elif tool_name == \"eraser\":\n                    self.remove_drawn_features()\n                    tool.value = False\n                elif tool_name == \"inspector\":\n                    self.inspector_checked = tool.value\n                    if not self.inspector_checked:\n                        inspector_output.clear_output()\n                elif tool_name == \"plotting\":\n                    self.plot_checked = True\n                    plot_dropdown_widget = widgets.Dropdown(\n                        options=list(self.ee_raster_layer_names),\n                    )\n                    plot_dropdown_widget.layout.width = \"18ex\"\n                    self.plot_dropdown_widget = plot_dropdown_widget\n                    plot_dropdown_control = ipyleaflet.WidgetControl(\n                        widget=plot_dropdown_widget, position=\"topright\"\n                    )\n                    self.plot_dropdown_control = plot_dropdown_control\n                    self.add_control(plot_dropdown_control)\n                    if self.draw_control in self.controls:\n                        self.remove_control(self.draw_control)\n                    self.add_control(self.draw_control_lite)\n                elif tool_name == \"open_data\":\n                    from .toolbar import open_data_widget\n\n                    open_data_widget(self)\n                elif tool_name == \"convert_js\":\n                    from .toolbar import convert_js2py\n\n                    convert_js2py(self)\n                elif tool_name == \"whitebox\":\n                    import whiteboxgui.whiteboxgui as wbt\n\n                    tools_dict = wbt.get_wbt_dict()\n                    wbt_toolbox = wbt.build_toolbox(\n                        tools_dict,\n                        max_width=\"800px\",\n                        max_height=\"500px\",\n                        sandbox_path=self.sandbox_path,\n                    )\n                    wbt_control = ipyleaflet.WidgetControl(\n                        widget=wbt_toolbox, position=\"bottomright\"\n                    )\n                    self.whitebox = wbt_control\n                    self.add_control(wbt_control)\n                elif tool_name == \"geetoolbox\":\n                    from .toolbar import build_toolbox, get_tools_dict\n\n                    tools_dict = get_tools_dict()\n                    gee_toolbox = build_toolbox(\n                        tools_dict, max_width=\"800px\", max_height=\"500px\"\n                    )\n                    geetoolbox_control = ipyleaflet.WidgetControl(\n                        widget=gee_toolbox, position=\"bottomright\"\n                    )\n                    self.geetoolbox = geetoolbox_control\n                    self.add_control(geetoolbox_control)\n\n                elif tool_name == \"basemap\":\n                    from .toolbar import change_basemap\n\n                    change_basemap(self)\n                elif tool_name == \"timelapse\":\n                    from .toolbar import timelapse_gui\n\n                    timelapse_gui(self)\n                    self.toolbar_reset()\n                elif tool_name == \"timeslider\":\n                    from .toolbar import time_slider\n\n                    time_slider(self)\n                    self.toolbar_reset()\n                elif tool_name == \"draw\":\n                    from .toolbar import collect_samples\n\n                    self.training_ctrl = None\n                    collect_samples(self)\n                elif tool_name == \"transect\":\n                    from .toolbar import plot_transect\n\n                    plot_transect(self)\n                elif tool_name == \"sankee\":\n                    from .toolbar import sankee_gui\n\n                    sankee_gui(self)\n                elif tool_name == \"planet\":\n                    from .toolbar import split_basemaps\n\n                    split_basemaps(self, layers_dict=planet_tiles())\n                    self.toolbar_reset()\n                elif tool_name == \"cog-inspector\":\n                    from .toolbar import inspector_gui\n\n                    inspector_gui(self)\n\n                elif tool_name == \"help\":\n                    import webbrowser\n\n                    webbrowser.open_new_tab(\"https://geemap.org\")\n                    current_tool.value = False\n            else:\n                tool = change[\"owner\"]\n                tool_name = tools[tool.icon][\"name\"]\n                if tool_name == \"to_image\":\n                    tool_output.clear_output()\n                    save_map_widget.children = [save_type, file_chooser]\n                    if tool_output_control in self.controls:\n                        self.remove_control(tool_output_control)\n                if tool_name == \"inspector\":\n                    inspector_output.clear_output()\n                    self.inspector_checked = False\n                    if inspector_output_control in self.controls:\n                        self.remove_control(inspector_output_control)\n                elif tool_name == \"plotting\":\n                    self.plot_checked = False\n                    plot_dropdown_widget = self.plot_dropdown_widget\n                    plot_dropdown_control = self.plot_dropdown_control\n                    if plot_dropdown_control in self.controls:\n                        self.remove_control(plot_dropdown_control)\n                    del plot_dropdown_widget\n                    del plot_dropdown_control\n                    if self.plot_control in self.controls:\n                        plot_control = self.plot_control\n                        plot_widget = self.plot_widget\n                        self.remove_control(plot_control)\n                        self.plot_control = None\n                        self.plot_widget = None\n                        del plot_control\n                        del plot_widget\n                    if (\n                        self.plot_marker_cluster is not None\n                        and self.plot_marker_cluster in self.layers\n                    ):\n                        self.remove_layer(self.plot_marker_cluster)\n                    if self.draw_control_lite in self.controls:\n                        self.remove_control(self.draw_control_lite)\n                    self.add_control(self.draw_control)\n                elif tool_name == \"whitebox\":\n                    if self.whitebox is not None and self.whitebox in self.controls:\n                        self.remove_control(self.whitebox)\n                elif tool_name == \"convert_js\":\n                    if (\n                        self.convert_ctrl is not None\n                        and self.convert_ctrl in self.controls\n                    ):\n                        self.remove_control(self.convert_ctrl)\n\n        for tool in toolbar_grid.children:\n            tool.observe(tool_callback, \"value\")\n\n        toolbar_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Toolbar\",\n            icon=\"wrench\",\n            layout=widgets.Layout(\n                width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"\n            ),\n        )\n        self.toolbar_button = toolbar_button\n\n        layers_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Layers\",\n            icon=\"server\",\n            layout=widgets.Layout(height=\"28px\", width=\"72px\"),\n        )\n\n        toolbar_widget = widgets.VBox()\n        toolbar_widget.children = [toolbar_button]\n        toolbar_header = widgets.HBox()\n        toolbar_header.children = [layers_button, toolbar_button]\n        toolbar_footer = widgets.VBox()\n        toolbar_footer.children = [toolbar_grid]\n\n        toolbar_event = ipyevents.Event(\n            source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n        )\n\n        def handle_toolbar_event(event):\n            if event[\"type\"] == \"mouseenter\":\n                toolbar_widget.children = [toolbar_header, toolbar_footer]\n            elif event[\"type\"] == \"mouseleave\":\n                if not toolbar_button.value:\n                    toolbar_widget.children = [toolbar_button]\n                    toolbar_button.value = False\n                    layers_button.value = False\n\n        toolbar_event.on_dom_event(handle_toolbar_event)\n\n        def toolbar_btn_click(change):\n            if change[\"new\"]:\n                layers_button.value = False\n                toolbar_widget.children = [toolbar_header, toolbar_footer]\n            else:\n                if not layers_button.value:\n                    toolbar_widget.children = [toolbar_button]\n\n        toolbar_button.observe(toolbar_btn_click, \"value\")\n\n        def layers_btn_click(change):\n            if change[\"new\"]:\n                layers_hbox = []\n                all_layers_chk = widgets.Checkbox(\n                    value=False,\n                    description=\"All layers on/off\",\n                    indent=False,\n                    layout=widgets.Layout(height=\"18px\", padding=\"0px 8px 25px 8px\"),\n                )\n                all_layers_chk.layout.width = \"30ex\"\n                layers_hbox.append(all_layers_chk)\n\n                def all_layers_chk_changed(change):\n                    if change[\"new\"]:\n                        for layer in self.layers:\n                            if hasattr(layer, \"visible\"):\n                                layer.visible = True\n                    else:\n                        for layer in self.layers:\n                            if hasattr(layer, \"visible\"):\n                                layer.visible = False\n\n                all_layers_chk.observe(all_layers_chk_changed, \"value\")\n\n                layers = [\n                    lyr\n                    for lyr in self.layers[1:]\n                    # if (\n                    #     isinstance(lyr, ipyleaflet.TileLayer)\n                    #     or isinstance(lyr, ipyleaflet.WMSLayer)\n                    # )\n                ]\n\n                # if the layers contain unsupported layers (e.g., GeoJSON, GeoData), adds the ipyleaflet built-in LayerControl\n                if len(layers) &lt; (len(self.layers) - 1):\n                    if self.layer_control is None:\n                        layer_control = ipyleaflet.LayersControl(position=\"topright\")\n                        self.layer_control = layer_control\n                    if self.layer_control not in self.controls:\n                        self.add_control(self.layer_control)\n\n                # for non-TileLayer, use layer.style={'opacity':0, 'fillOpacity': 0} to turn layer off.\n                for layer in layers:\n                    visible = True\n                    if hasattr(layer, \"visible\"):\n                        visible = layer.visible\n                    layer_chk = widgets.Checkbox(\n                        value=visible,\n                        description=layer.name,\n                        indent=False,\n                        layout=widgets.Layout(height=\"18px\"),\n                    )\n                    layer_chk.layout.width = \"25ex\"\n\n                    if layer in self.geojson_layers:\n                        try:\n                            opacity = max(\n                                layer.style[\"opacity\"], layer.style[\"fillOpacity\"]\n                            )\n                        except KeyError:\n                            opacity = 1.0\n                    else:\n                        if hasattr(layer, \"opacity\"):\n                            opacity = layer.opacity\n\n                    layer_opacity = widgets.FloatSlider(\n                        value=opacity,\n                        min=0,\n                        max=1,\n                        step=0.01,\n                        readout=False,\n                        layout=widgets.Layout(width=\"80px\"),\n                    )\n                    layer_settings = widgets.ToggleButton(\n                        icon=\"gear\",\n                        tooltip=layer.name,\n                        layout=widgets.Layout(\n                            width=\"25px\", height=\"25px\", padding=\"0px 0px 0px 5px\"\n                        ),\n                    )\n\n                    def layer_opacity_changed(change):\n                        if change[\"new\"]:\n                            layer.style = {\n                                \"opacity\": change[\"new\"],\n                                \"fillOpacity\": change[\"new\"],\n                            }\n\n                    def layer_vis_on_click(change):\n                        if change[\"new\"]:\n                            layer_name = change[\"owner\"].tooltip\n                            # if layer_name in self.ee_raster_layer_names:\n                            if layer_name in self.ee_layer_names:\n                                layer_dict = self.ee_layer_dict[layer_name]\n\n                                if self.vis_widget is not None:\n                                    self.vis_widget = None\n                                self.vis_widget = self.create_vis_widget(layer_dict)\n                                if self.vis_control in self.controls:\n                                    self.remove_control(self.vis_control)\n                                    self.vis_control = None\n                                vis_control = ipyleaflet.WidgetControl(\n                                    widget=self.vis_widget, position=\"topright\"\n                                )\n                                self.add_control((vis_control))\n                                self.vis_control = vis_control\n                            else:\n                                if self.vis_widget is not None:\n                                    self.vis_widget = None\n                                if self.vis_control is not None:\n                                    if self.vis_control in self.controls:\n                                        self.remove_control(self.vis_control)\n                                    self.vis_control = None\n                            change[\"owner\"].value = False\n\n                    layer_settings.observe(layer_vis_on_click, \"value\")\n\n                    def layer_chk_changed(change):\n                        layer_name = change[\"owner\"].description\n                        if layer_name in self.ee_layer_names:\n                            if change[\"new\"]:\n                                if \"legend\" in self.ee_layer_dict[layer_name].keys():\n                                    legend = self.ee_layer_dict[layer_name][\"legend\"]\n                                    if legend not in self.controls:\n                                        self.add_control(legend)\n                                if \"colorbar\" in self.ee_layer_dict[layer_name].keys():\n                                    colorbar = self.ee_layer_dict[layer_name][\n                                        \"colorbar\"\n                                    ]\n                                    if colorbar not in self.controls:\n                                        self.add_control(colorbar)\n                            else:\n                                if \"legend\" in self.ee_layer_dict[layer_name].keys():\n                                    legend = self.ee_layer_dict[layer_name][\"legend\"]\n                                    if legend in self.controls:\n                                        self.remove_control(legend)\n                                if \"colorbar\" in self.ee_layer_dict[layer_name].keys():\n                                    colorbar = self.ee_layer_dict[layer_name][\n                                        \"colorbar\"\n                                    ]\n                                    if colorbar in self.controls:\n                                        self.remove_control(colorbar)\n\n                    layer_chk.observe(layer_chk_changed, \"value\")\n\n                    if hasattr(layer, \"visible\"):\n                        widgets.jslink((layer_chk, \"value\"), (layer, \"visible\"))\n\n                    if layer in self.geojson_layers:\n                        layer_opacity.observe(layer_opacity_changed, \"value\")\n                    elif hasattr(layer, \"opacity\"):\n                        widgets.jsdlink((layer_opacity, \"value\"), (layer, \"opacity\"))\n                    hbox = widgets.HBox(\n                        [layer_chk, layer_settings, layer_opacity],\n                        layout=widgets.Layout(padding=\"0px 8px 0px 8px\"),\n                    )\n                    layers_hbox.append(hbox)\n\n                toolbar_footer.children = layers_hbox\n                toolbar_button.value = False\n            else:\n                toolbar_footer.children = [toolbar_grid]\n\n        layers_button.observe(layers_btn_click, \"value\")\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if kwargs.get(\"toolbar_ctrl\"):\n            self.add_control(toolbar_control)\n            self.toolbar_ctrl = toolbar_control\n\n        tool_output_control = ipyleaflet.WidgetControl(\n            widget=tool_output, position=\"topright\"\n        )\n        # self.add_control(tool_output_control)\n\n        expand_label = widgets.Label(\n            \"Expand   \",\n            layout=widgets.Layout(padding=\"0px 0px 0px 4px\"),\n        )\n\n        expand_point = widgets.Checkbox(\n            description=\"Point\",\n            indent=False,\n            value=self._expand_point,\n            layout=widgets.Layout(width=\"65px\"),\n        )\n\n        expand_pixels = widgets.Checkbox(\n            description=\"Pixels\",\n            indent=False,\n            value=self._expand_pixels,\n            layout=widgets.Layout(width=\"65px\"),\n        )\n\n        expand_objects = widgets.Checkbox(\n            description=\"Objects\",\n            indent=False,\n            value=self._expand_objects,\n            layout=widgets.Layout(width=\"70px\"),\n        )\n\n        def expand_point_changed(change):\n            self._expand_point = change[\"new\"]\n\n        def expand_pixels_changed(change):\n            self._expand_pixels = change[\"new\"]\n\n        def expand_objects_changed(change):\n            self._expand_objects = change[\"new\"]\n\n        expand_point.observe(expand_point_changed, \"value\")\n        expand_pixels.observe(expand_pixels_changed, \"value\")\n        expand_objects.observe(expand_objects_changed, \"value\")\n\n        inspector_checks = widgets.HBox()\n        inspector_checks.children = [\n            expand_label,\n            widgets.Label(\"\"),\n            expand_point,\n            expand_pixels,\n            expand_objects,\n        ]\n\n        def handle_interaction(**kwargs):\n            latlon = kwargs.get(\"coordinates\")\n            if kwargs.get(\"type\") == \"click\" and self.inspector_checked:\n                self.default_style = {\"cursor\": \"wait\"}\n                if inspector_output_control not in self.controls:\n                    self.add_control(inspector_output_control)\n                sample_scale = self.getScale()\n                layers = self.ee_layers\n\n                with inspector_output:\n                    inspector_output.clear_output(wait=True)\n                    display(inspector_checks)\n                    display(self.inspector(latlon))\n\n                self.default_style = {\"cursor\": \"crosshair\"}\n            if (\n                kwargs.get(\"type\") == \"click\"\n                and self.plot_checked\n                and len(self.ee_raster_layers) &gt; 0\n            ):\n                plot_layer_name = self.plot_dropdown_widget.value\n                layer_names = self.ee_raster_layer_names\n                layers = self.ee_raster_layers\n                index = layer_names.index(plot_layer_name)\n                ee_object = layers[index]\n\n                if isinstance(ee_object, ee.ImageCollection):\n                    ee_object = ee_object.mosaic()\n\n                try:\n                    self.default_style = {\"cursor\": \"wait\"}\n                    plot_options = self.plot_options\n                    sample_scale = self.getScale()\n                    if \"sample_scale\" in plot_options.keys() and (\n                        plot_options[\"sample_scale\"] is not None\n                    ):\n                        sample_scale = plot_options[\"sample_scale\"]\n                    if \"title\" not in plot_options.keys():\n                        plot_options[\"title\"] = plot_layer_name\n                    if (\"add_marker_cluster\" in plot_options.keys()) and plot_options[\n                        \"add_marker_cluster\"\n                    ]:\n                        plot_coordinates = self.plot_coordinates\n                        markers = self.plot_markers\n                        marker_cluster = self.plot_marker_cluster\n                        plot_coordinates.append(latlon)\n                        self.plot_last_click = latlon\n                        self.plot_all_clicks = plot_coordinates\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        marker_cluster.markers = markers\n                        self.plot_marker_cluster = marker_cluster\n\n                    band_names = ee_object.bandNames().getInfo()\n                    if any(len(name) &gt; 3 for name in band_names):\n                        band_names = list(range(1, len(band_names) + 1))\n\n                    self.chart_labels = band_names\n\n                    if self.roi_end:\n                        if self.roi_reducer_scale is None:\n                            scale = ee_object.select(0).projection().nominalScale()\n                        else:\n                            scale = self.roi_reducer_scale\n                        dict_values_tmp = ee_object.reduceRegion(\n                            reducer=self.roi_reducer,\n                            geometry=self.user_roi,\n                            scale=scale,\n                            bestEffort=True,\n                        ).getInfo()\n                        b_names = ee_object.bandNames().getInfo()\n                        dict_values = dict(\n                            zip(b_names, [dict_values_tmp[b] for b in b_names])\n                        )\n                        self.chart_points.append(\n                            self.user_roi.centroid(1).coordinates().getInfo()\n                        )\n                    else:\n                        xy = ee.Geometry.Point(latlon[::-1])\n                        dict_values_tmp = (\n                            ee_object.sample(xy, scale=sample_scale)\n                            .first()\n                            .toDictionary()\n                            .getInfo()\n                        )\n                        b_names = ee_object.bandNames().getInfo()\n                        dict_values = dict(\n                            zip(b_names, [dict_values_tmp[b] for b in b_names])\n                        )\n                        self.chart_points.append(xy.coordinates().getInfo())\n                    band_values = list(dict_values.values())\n                    self.chart_values.append(band_values)\n                    self.plot(band_names, band_values, **plot_options)\n                    if plot_options[\"title\"] == plot_layer_name:\n                        del plot_options[\"title\"]\n                    self.default_style = {\"cursor\": \"crosshair\"}\n                    self.roi_end = False\n                except Exception as e:\n                    if self.plot_widget is not None:\n                        with self.plot_widget:\n                            self.plot_widget.clear_output()\n                            print(\"No data for the clicked location.\")\n                    else:\n                        print(e)\n                    self.default_style = {\"cursor\": \"crosshair\"}\n                    self.roi_end = False\n\n        self.on_interaction(handle_interaction)\n\n    def set_options(self, mapTypeId=\"HYBRID\", styles=None, types=None):\n\"\"\"Adds Google basemap and controls to the ipyleaflet map.\n\n        Args:\n            mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.\n            styles (object, optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.\n            types (list, optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.\n        \"\"\"\n        self.clear_layers()\n        self.clear_controls()\n        self.scroll_wheel_zoom = True\n        self.add_control(ipyleaflet.ZoomControl(position=\"topleft\"))\n        self.add_control(ipyleaflet.LayersControl(position=\"topright\"))\n        self.add_control(ipyleaflet.ScaleControl(position=\"bottomleft\"))\n        self.add_control(ipyleaflet.FullScreenControl())\n        self.add_control(ipyleaflet.DrawControl())\n\n        measure = ipyleaflet.MeasureControl(\n            position=\"bottomleft\",\n            active_color=\"orange\",\n            primary_length_unit=\"kilometers\",\n        )\n        self.add_control(measure)\n\n        try:\n            self.add_layer(basemaps[mapTypeId])\n        except Exception:\n            raise ValueError(\n                'Google basemaps can only be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\".'\n            )\n\n    setOptions = set_options\n\n    def add_ee_layer(\n        self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0\n    ):\n\"\"\"Adds a given EE object to the map as a layer.\n\n        Args:\n            ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n            vis_params (dict, optional): The visualization parameters. Defaults to {}.\n            name (str, optional): The name of the layer. Defaults to 'Layer N'.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n        \"\"\"\n\n        image = None\n\n        if vis_params is None:\n            vis_params = {}\n\n        if name is None:\n            layer_count = len(self.layers)\n            name = \"Layer \" + str(layer_count + 1)\n\n        if (\n            not isinstance(ee_object, ee.Image)\n            and not isinstance(ee_object, ee.ImageCollection)\n            and not isinstance(ee_object, ee.FeatureCollection)\n            and not isinstance(ee_object, ee.Feature)\n            and not isinstance(ee_object, ee.Geometry)\n        ):\n            err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n            raise AttributeError(err_str)\n\n        if (\n            isinstance(ee_object, ee.geometry.Geometry)\n            or isinstance(ee_object, ee.feature.Feature)\n            or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n        ):\n            features = ee.FeatureCollection(ee_object)\n\n            width = 2\n\n            if \"width\" in vis_params:\n                width = vis_params[\"width\"]\n\n            color = \"000000\"\n\n            if \"color\" in vis_params:\n                color = vis_params[\"color\"]\n\n            image_fill = features.style(**{\"fillColor\": color}).updateMask(\n                ee.Image.constant(0.5)\n            )\n            image_outline = features.style(\n                **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n            )\n\n            image = image_fill.blend(image_outline)\n        elif isinstance(ee_object, ee.image.Image):\n            image = ee_object\n        elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n            image = ee_object.mosaic()\n\n        if \"palette\" in vis_params:\n            if isinstance(vis_params[\"palette\"], tuple):\n                vis_params[\"palette\"] = list(vis_params[\"palette\"])\n            if isinstance(vis_params[\"palette\"], Box):\n                try:\n                    vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n                except Exception as e:\n                    print(\"The provided palette is invalid.\")\n                    raise Exception(e)\n            elif isinstance(vis_params[\"palette\"], str):\n                vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n            elif not isinstance(vis_params[\"palette\"], list):\n                raise ValueError(\n                    \"The palette must be a list of colors or a string or a Box object.\"\n                )\n\n        map_id_dict = ee.Image(image).getMapId(vis_params)\n        url = map_id_dict[\"tile_fetcher\"].url_format\n        tile_layer = ipyleaflet.TileLayer(\n            url=url,\n            attribution=\"Google Earth Engine\",\n            name=name,\n            opacity=opacity,\n            visible=shown,\n            max_zoom=24,\n        )\n\n        layer = self.find_layer(name=name)\n        if layer is not None:\n            existing_object = self.ee_layer_dict[name][\"ee_object\"]\n\n            if isinstance(existing_object, ee.Image) or isinstance(\n                existing_object, ee.ImageCollection\n            ):\n                self.ee_raster_layers.remove(existing_object)\n                self.ee_raster_layer_names.remove(name)\n                if self.plot_dropdown_widget is not None:\n                    self.plot_dropdown_widget.options = list(self.ee_raster_layer_names)\n            elif (\n                isinstance(ee_object, ee.Geometry)\n                or isinstance(ee_object, ee.Feature)\n                or isinstance(ee_object, ee.FeatureCollection)\n            ):\n                self.ee_vector_layers.remove(existing_object)\n                self.ee_vector_layer_names.remove(name)\n\n            self.ee_layers.remove(existing_object)\n            self.ee_layer_names.remove(name)\n            self.remove_layer(layer)\n\n        self.ee_layers.append(ee_object)\n        if name not in self.ee_layer_names:\n            self.ee_layer_names.append(name)\n        self.ee_layer_dict[name] = {\n            \"ee_object\": ee_object,\n            \"ee_layer\": tile_layer,\n            \"vis_params\": vis_params,\n        }\n\n        self.add_layer(tile_layer)\n        self.last_ee_layer = self.ee_layer_dict[name]\n        self.last_ee_data = self.ee_layer_dict[name][\"ee_object\"]\n\n        if isinstance(ee_object, ee.Image) or isinstance(ee_object, ee.ImageCollection):\n            self.ee_raster_layers.append(ee_object)\n            self.ee_raster_layer_names.append(name)\n            if self.plot_dropdown_widget is not None:\n                self.plot_dropdown_widget.options = list(self.ee_raster_layer_names)\n        elif (\n            isinstance(ee_object, ee.Geometry)\n            or isinstance(ee_object, ee.Feature)\n            or isinstance(ee_object, ee.FeatureCollection)\n        ):\n            self.ee_vector_layers.append(ee_object)\n            self.ee_vector_layer_names.append(name)\n\n        arc_add_layer(url, name, shown, opacity)\n\n    addLayer = add_ee_layer\n\n    def remove_ee_layer(self, name):\n\"\"\"Removes an Earth Engine layer.\n\n        Args:\n            name (str): The name of the Earth Engine layer to remove.\n        \"\"\"\n        if name in self.ee_layer_dict:\n            ee_object = self.ee_layer_dict[name][\"ee_object\"]\n            ee_layer = self.ee_layer_dict[name][\"ee_layer\"]\n            if name in self.ee_raster_layer_names:\n                self.ee_raster_layer_names.remove(name)\n                self.ee_raster_layers.remove(ee_object)\n            elif name in self.ee_vector_layer_names:\n                self.ee_vector_layer_names.remove(name)\n                self.ee_vector_layers.remove(ee_object)\n            self.ee_layers.remove(ee_object)\n            self.ee_layer_names.remove(name)\n            if ee_layer in self.layers:\n                self.remove_layer(ee_layer)\n\n    def draw_layer_on_top(self):\n\"\"\"Move user-drawn feature layer to the top of all layers.\"\"\"\n        draw_layer_index = self.find_layer_index(name=\"Drawn Features\")\n        if draw_layer_index &gt; -1 and draw_layer_index &lt; (len(self.layers) - 1):\n            layers = list(self.layers)\n            layers = (\n                layers[0:draw_layer_index]\n                + layers[(draw_layer_index + 1) :]\n                + [layers[draw_layer_index]]\n            )\n            self.layers = layers\n\n    def set_center(self, lon, lat, zoom=None):\n\"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n        Args:\n            lon (float): The longitude of the center, in degrees.\n            lat (float): The latitude of the center, in degrees.\n            zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n        \"\"\"\n        self.center = (lat, lon)\n        if zoom is not None:\n            self.zoom = zoom\n\n        if is_arcpy():\n            arc_zoom_to_extent(lon, lat, lon, lat)\n\n    setCenter = set_center\n\n    def center_object(self, ee_object, zoom=None):\n\"\"\"Centers the map view on a given object.\n\n        Args:\n            ee_object (Element|Geometry): An Earth Engine object to center on a geometry, image or feature.\n            zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n        \"\"\"\n        maxError = 0.001\n        if isinstance(ee_object, ee.Geometry):\n            geometry = ee_object.transform(maxError=maxError)\n        else:\n            try:\n                geometry = ee_object.geometry(maxError=maxError).transform(\n                    maxError=maxError\n                )\n            except Exception:\n                raise Exception(\n                    \"ee_object must be an instance of one of ee.Geometry, ee.FeatureCollection, ee.Image, or ee.ImageCollection.\"\n                )\n\n        if zoom is not None:\n            if not isinstance(zoom, int):\n                raise Exception(\"Zoom must be an integer.\")\n            else:\n                centroid = geometry.centroid(maxError=maxError).getInfo()[\"coordinates\"]\n                lat = centroid[1]\n                lon = centroid[0]\n                self.set_center(lon, lat, zoom)\n\n                if is_arcpy():\n                    arc_zoom_to_extent(lon, lat, lon, lat)\n\n        else:\n            coordinates = geometry.bounds(maxError).getInfo()[\"coordinates\"][0]\n            x = [c[0] for c in coordinates]\n            y = [c[1] for c in coordinates]\n            xmin = min(x)\n            xmax = max(x)\n            ymin = min(y)\n            ymax = max(y)\n            bounds = [[ymin, xmin], [ymax, xmax]]\n            self.fit_bounds(bounds)\n\n            if is_arcpy():\n                arc_zoom_to_extent(xmin, ymin, xmax, ymax)\n\n    centerObject = center_object\n\n    def zoom_to_me(self, zoom=14, add_marker=True):\n\"\"\"Zoom to the current device location.\n\n        Args:\n            zoom (int, optional): Zoom level. Defaults to 14.\n            add_marker (bool, optional): Whether to add a marker of the current device location. Defaults to True.\n        \"\"\"\n        lat, lon = get_current_latlon()\n        self.set_center(lon, lat, zoom)\n\n        if add_marker:\n            marker = ipyleaflet.Marker(\n                location=(lat, lon),\n                draggable=False,\n                name=\"Device location\",\n            )\n            self.add_layer(marker)\n\n    def zoom_to_bounds(self, bounds):\n\"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n        Args:\n            bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n        \"\"\"\n        #  The ipyleaflet fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def zoom_to_gdf(self, gdf):\n\"\"\"Zooms to the bounding box of a GeoPandas GeoDataFrame.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        \"\"\"\n        bounds = gdf.total_bounds\n        self.zoom_to_bounds(bounds)\n\n    def get_scale(self):\n\"\"\"Returns the approximate pixel scale of the current map view, in meters.\n\n        Returns:\n            float: Map resolution in meters.\n        \"\"\"\n        zoom_level = self.zoom\n        # Reference: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution\n        resolution = 156543.04 * math.cos(0) / math.pow(2, zoom_level)\n        return resolution\n\n    getScale = get_scale\n\n    def get_bounds(self, asGeoJSON=False):\n\"\"\"Returns the bounds of the current map view, as a list in the format [west, south, east, north] in degrees.\n\n        Args:\n            asGeoJSON (bool, optional): If true, returns map bounds as GeoJSON. Defaults to False.\n\n        Returns:\n            list | dict: A list in the format [west, south, east, north] in degrees.\n        \"\"\"\n        bounds = self.bounds\n        coords = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n\n        if asGeoJSON:\n            return ee.Geometry.BBox(\n                bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]\n            ).getInfo()\n        else:\n            return coords\n\n    getBounds = get_bounds\n\n    def add_basemap(self, basemap=\"HYBRID\"):\n\"\"\"Adds a basemap to the map.\n\n        Args:\n            basemap (str, optional): Can be one of string from basemaps. Defaults to 'HYBRID'.\n        \"\"\"\n        try:\n            if basemap in basemaps.keys() and basemaps[basemap] not in self.layers:\n                self.add_layer(basemaps[basemap])\n\n                if is_arcpy():\n                    arc_add_layer(basemaps[basemap].url, basemap)\n\n        except Exception:\n            raise ValueError(\n                \"Basemap can only be one of the following:\\n  {}\".format(\n                    \"\\n  \".join(basemaps.keys())\n                )\n            )\n\n    def add_marker(self, location, **kwargs):\n\"\"\"Adds a marker to the map. More info about marker at https://ipyleaflet.readthedocs.io/en/latest/api_reference/marker.html.\n\n        Args:\n            location (list | tuple): The location of the marker in the format of [lat, lng].\n\n            **kwargs: Keyword arguments for the marker.\n        \"\"\"\n        if isinstance(location, list):\n            location = tuple(location)\n        if isinstance(location, tuple):\n            marker = ipyleaflet.Marker(location=location, **kwargs)\n            self.add_layer(marker)\n        else:\n            raise TypeError(\"The location must be a list or a tuple.\")\n\n    def find_layer(self, name):\n\"\"\"Finds layer by name\n\n        Args:\n            name (str): Name of the layer to find.\n\n        Returns:\n            object: ipyleaflet layer object.\n        \"\"\"\n        layers = self.layers\n\n        for layer in layers:\n            if layer.name == name:\n                return layer\n\n        return None\n\n    def show_layer(self, name, show=True):\n\"\"\"Shows or hides a layer on the map.\n\n        Args:\n            name (str): Name of the layer to show/hide.\n            show (bool, optional): Whether to show or hide the layer. Defaults to True.\n        \"\"\"\n        layer = self.find_layer(name)\n\n        if layer is not None:\n            layer.visible = show\n\n    def find_layer_index(self, name):\n\"\"\"Finds layer index by name\n\n        Args:\n            name (str): Name of the layer to find.\n\n        Returns:\n            int: Index of the layer with the specified name\n        \"\"\"\n        layers = self.layers\n\n        for index, layer in enumerate(layers):\n            if layer.name == name:\n                return index\n\n        return -1\n\n    def layer_opacity(self, name, opacity=1.0):\n\"\"\"Changes layer opacity.\n\n        Args:\n            name (str): The name of the layer to change opacity.\n            opacity (float, optional): The opacity value to set. Defaults to 1.0.\n        \"\"\"\n        layer = self.find_layer(name)\n        try:\n            layer.opacity = opacity\n        except Exception as e:\n            raise Exception(e)\n\n    def add_wms_layer(\n        self,\n        url,\n        layers,\n        name=None,\n        attribution=\"\",\n        format=\"image/png\",\n        transparent=True,\n        opacity=1.0,\n        shown=True,\n        **kwargs,\n    ):\n\"\"\"Add a WMS layer to the map.\n\n        Args:\n            url (str): The URL of the WMS web service.\n            layers (str): Comma-separated list of WMS layers to show.\n            name (str, optional): The layer name to use on the layer control. Defaults to None.\n            attribution (str, optional): The attribution of the data layer. Defaults to ''.\n            format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.\n            transparent (bool, optional): If True, the WMS service will return images with transparency. Defaults to True.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        \"\"\"\n\n        if name is None:\n            name = str(layers)\n\n        try:\n            wms_layer = ipyleaflet.WMSLayer(\n                url=url,\n                layers=layers,\n                name=name,\n                attribution=attribution,\n                format=format,\n                transparent=transparent,\n                opacity=opacity,\n                visible=shown,\n                **kwargs,\n            )\n            self.add_layer(wms_layer)\n\n        except Exception as e:\n            print(\"Failed to add the specified WMS TileLayer.\")\n            raise Exception(e)\n\n    def add_tile_layer(\n        self,\n        url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        name=\"Untitled\",\n        attribution=\"\",\n        opacity=1.0,\n        shown=True,\n        **kwargs,\n    ):\n\"\"\"Adds a TileLayer to the map.\n\n        Args:\n            url (str, optional): The URL of the tile layer. Defaults to 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'.\n            name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        \"\"\"\n\n        if \"max_zoom\" not in kwargs:\n            kwargs[\"max_zoom\"] = 100\n        if \"max_native_zoom\" not in kwargs:\n            kwargs[\"max_native_zoom\"] = 100\n\n        try:\n            tile_layer = ipyleaflet.TileLayer(\n                url=url,\n                name=name,\n                attribution=attribution,\n                opacity=opacity,\n                visible=shown,\n                **kwargs,\n            )\n            self.add_layer(tile_layer)\n\n        except Exception as e:\n            print(\"Failed to add the specified TileLayer.\")\n            raise Exception(e)\n\n    def add_cog_layer(\n        self,\n        url,\n        name=\"Untitled\",\n        attribution=\"\",\n        opacity=1.0,\n        shown=True,\n        bands=None,\n        titiler_endpoint=None,\n        **kwargs,\n    ):\n\"\"\"Adds a COG TileLayer to the map.\n\n        Args:\n            url (str): The URL of the COG tile layer.\n            name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            bands (list, optional): A list of bands to use for the layer. Defaults to None.\n            titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n            **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]\n        \"\"\"\n        tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n        bounds = cog_bounds(url, titiler_endpoint)\n        self.add_tile_layer(tile_url, name, attribution, opacity, shown)\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n        if not hasattr(self, \"cog_layer_dict\"):\n            self.cog_layer_dict = {}\n\n        params = {\n            \"url\": url,\n            \"titizer_endpoint\": titiler_endpoint,\n            \"bounds\": bounds,\n            \"type\": \"COG\",\n        }\n        self.cog_layer_dict[name] = params\n\n    def add_cog_mosaic(self, **kwargs):\n        raise NotImplementedError(\n            \"This function is no longer supported.See https://github.com/giswqs/leafmap/issues/180.\"\n        )\n\n    def add_stac_layer(\n        self,\n        url=None,\n        collection=None,\n        item=None,\n        assets=None,\n        bands=None,\n        titiler_endpoint=None,\n        name=\"STAC Layer\",\n        attribution=\"\",\n        opacity=1.0,\n        shown=True,\n        **kwargs,\n    ):\n\"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n            collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n            item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n            assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n            bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        \"\"\"\n        tile_url = stac_tile(\n            url, collection, item, assets, bands, titiler_endpoint, **kwargs\n        )\n        bounds = stac_bounds(url, collection, item, titiler_endpoint)\n        self.add_tile_layer(tile_url, name, attribution, opacity, shown)\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n        if not hasattr(self, \"cog_layer_dict\"):\n            self.cog_layer_dict = {}\n\n        if assets is None and bands is not None:\n            assets = bands\n\n        params = {\n            \"url\": url,\n            \"collection\": collection,\n            \"item\": item,\n            \"assets\": assets,\n            \"bounds\": bounds,\n            \"titiler_endpoint\": titiler_endpoint,\n            \"type\": \"STAC\",\n        }\n\n        self.cog_layer_dict[name] = params\n\n    def add_minimap(self, zoom=5, position=\"bottomright\"):\n\"\"\"Adds a minimap (overview) to the ipyleaflet map.\n\n        Args:\n            zoom (int, optional): Initial map zoom level. Defaults to 5.\n            position (str, optional): Position of the minimap. Defaults to \"bottomright\".\n        \"\"\"\n        minimap = ipyleaflet.Map(\n            zoom_control=False,\n            attribution_control=False,\n            zoom=zoom,\n            center=self.center,\n            layers=[basemaps[\"ROADMAP\"]],\n        )\n        minimap.layout.width = \"150px\"\n        minimap.layout.height = \"150px\"\n        ipyleaflet.link((minimap, \"center\"), (self, \"center\"))\n        minimap_control = ipyleaflet.WidgetControl(widget=minimap, position=position)\n        self.add_control(minimap_control)\n\n    def marker_cluster(self):\n\"\"\"Adds a marker cluster to the map and returns a list of ee.Feature, which can be accessed using Map.ee_marker_cluster.\n\n        Returns:\n            object: a list of ee.Feature\n        \"\"\"\n        coordinates = []\n        markers = []\n        marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n        self.last_click = []\n        self.all_clicks = []\n        self.ee_markers = []\n        self.add_layer(marker_cluster)\n\n        def handle_interaction(**kwargs):\n            latlon = kwargs.get(\"coordinates\")\n            if kwargs.get(\"type\") == \"click\":\n                coordinates.append(latlon)\n                geom = ee.Geometry.Point(latlon[1], latlon[0])\n                feature = ee.Feature(geom)\n                self.ee_markers.append(feature)\n                self.last_click = latlon\n                self.all_clicks = coordinates\n                markers.append(ipyleaflet.Marker(location=latlon))\n                marker_cluster.markers = markers\n            elif kwargs.get(\"type\") == \"mousemove\":\n                pass\n\n        # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp\n        self.default_style = {\"cursor\": \"crosshair\"}\n        self.on_interaction(handle_interaction)\n\n    def set_plot_options(\n        self,\n        add_marker_cluster=False,\n        sample_scale=None,\n        plot_type=None,\n        overlay=False,\n        position=\"bottomright\",\n        min_width=None,\n        max_width=None,\n        min_height=None,\n        max_height=None,\n        **kwargs,\n    ):\n\"\"\"Sets plotting options.\n\n        Args:\n            add_marker_cluster (bool, optional): Whether to add a marker cluster. Defaults to False.\n            sample_scale (float, optional):  A nominal scale in meters of the projection to sample in . Defaults to None.\n            plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.\n            overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False.\n            position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.\n            min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n\n        \"\"\"\n        plot_options_dict = {}\n        plot_options_dict[\"add_marker_cluster\"] = add_marker_cluster\n        plot_options_dict[\"sample_scale\"] = sample_scale\n        plot_options_dict[\"plot_type\"] = plot_type\n        plot_options_dict[\"overlay\"] = overlay\n        plot_options_dict[\"position\"] = position\n        plot_options_dict[\"min_width\"] = min_width\n        plot_options_dict[\"max_width\"] = max_width\n        plot_options_dict[\"min_height\"] = min_height\n        plot_options_dict[\"max_height\"] = max_height\n\n        for key in kwargs.keys():\n            plot_options_dict[key] = kwargs[key]\n\n        self.plot_options = plot_options_dict\n\n        if add_marker_cluster and (self.plot_marker_cluster not in self.layers):\n            self.add_layer(self.plot_marker_cluster)\n\n    def plot(\n        self,\n        x,\n        y,\n        plot_type=None,\n        overlay=False,\n        position=\"bottomright\",\n        min_width=None,\n        max_width=None,\n        min_height=None,\n        max_height=None,\n        **kwargs,\n    ):\n\"\"\"Creates a plot based on x-array and y-array data.\n\n        Args:\n            x (numpy.ndarray or list): The x-coordinates of the plotted line.\n            y (numpy.ndarray or list): The y-coordinates of the plotted line.\n            plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.\n            overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False.\n            position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.\n            min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n\n        \"\"\"\n        if self.plot_widget is not None:\n            plot_widget = self.plot_widget\n        else:\n            plot_widget = widgets.Output(layout={\"border\": \"1px solid black\"})\n            plot_control = ipyleaflet.WidgetControl(\n                widget=plot_widget,\n                position=position,\n                min_width=min_width,\n                max_width=max_width,\n                min_height=min_height,\n                max_height=max_height,\n            )\n            self.plot_widget = plot_widget\n            self.plot_control = plot_control\n            self.add_control(plot_control)\n\n        if max_width is None:\n            max_width = 500\n        if max_height is None:\n            max_height = 300\n\n        if (plot_type is None) and (\"markers\" not in kwargs.keys()):\n            kwargs[\"markers\"] = \"circle\"\n\n        with plot_widget:\n            try:\n                fig = plt.figure(1, **kwargs)\n                if max_width is not None:\n                    fig.layout.width = str(max_width) + \"px\"\n                if max_height is not None:\n                    fig.layout.height = str(max_height) + \"px\"\n\n                plot_widget.clear_output(wait=True)\n                if not overlay:\n                    plt.clear()\n\n                if plot_type is None:\n                    if \"marker\" not in kwargs.keys():\n                        kwargs[\"marker\"] = \"circle\"\n                    plt.plot(x, y, **kwargs)\n                elif plot_type == \"bar\":\n                    plt.bar(x, y, **kwargs)\n                elif plot_type == \"scatter\":\n                    plt.scatter(x, y, **kwargs)\n                elif plot_type == \"hist\":\n                    plt.hist(y, **kwargs)\n                plt.show()\n\n            except Exception as e:\n                print(\"Failed to create plot.\")\n                raise Exception(e)\n\n    def plot_demo(\n        self,\n        iterations=20,\n        plot_type=None,\n        overlay=False,\n        position=\"bottomright\",\n        min_width=None,\n        max_width=None,\n        min_height=None,\n        max_height=None,\n        **kwargs,\n    ):\n\"\"\"A demo of interactive plotting using random pixel coordinates.\n\n        Args:\n            iterations (int, optional): How many iterations to run for the demo. Defaults to 20.\n            plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.\n            overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False.\n            position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.\n            min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        \"\"\"\n\n        import numpy as np\n\n        if self.random_marker is not None:\n            self.remove_layer(self.random_marker)\n\n        image = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\").select([0, 1, 2, 3, 4, 6])\n        self.addLayer(\n            image,\n            {\"bands\": [\"B4\", \"B3\", \"B2\"], \"gamma\": 1.4},\n            \"LANDSAT/LE7_TOA_5YEAR/1999_2003\",\n        )\n        self.setCenter(-50.078877, 25.190030, 3)\n        band_names = image.bandNames().getInfo()\n        # band_count = len(band_names)\n\n        latitudes = np.random.uniform(30, 48, size=iterations)\n        longitudes = np.random.uniform(-121, -76, size=iterations)\n\n        marker = ipyleaflet.Marker(location=(0, 0))\n        self.random_marker = marker\n        self.add_layer(marker)\n\n        for i in range(iterations):\n            try:\n                coordinate = ee.Geometry.Point([longitudes[i], latitudes[i]])\n                dict_values = image.sample(coordinate).first().toDictionary().getInfo()\n                band_values = list(dict_values.values())\n                title = \"{}/{}: Spectral signature at ({}, {})\".format(\n                    i + 1,\n                    iterations,\n                    round(latitudes[i], 2),\n                    round(longitudes[i], 2),\n                )\n                marker.location = (latitudes[i], longitudes[i])\n                self.plot(\n                    band_names,\n                    band_values,\n                    plot_type=plot_type,\n                    overlay=overlay,\n                    min_width=min_width,\n                    max_width=max_width,\n                    min_height=min_height,\n                    max_height=max_height,\n                    title=title,\n                    **kwargs,\n                )\n                time.sleep(0.3)\n            except Exception as e:\n                raise Exception(e)\n\n    def plot_raster(\n        self,\n        ee_object=None,\n        sample_scale=None,\n        plot_type=None,\n        overlay=False,\n        position=\"bottomright\",\n        min_width=None,\n        max_width=None,\n        min_height=None,\n        max_height=None,\n        **kwargs,\n    ):\n\"\"\"Interactive plotting of Earth Engine data by clicking on the map.\n\n        Args:\n            ee_object (object, optional): The ee.Image or ee.ImageCollection to sample. Defaults to None.\n            sample_scale (float, optional): A nominal scale in meters of the projection to sample in. Defaults to None.\n            plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.\n            overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False.\n            position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.\n            min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n            max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n\n        \"\"\"\n        if self.plot_control is not None:\n            del self.plot_widget\n            if self.plot_control in self.controls:\n                self.remove_control(self.plot_control)\n\n        if self.random_marker is not None:\n            self.remove_layer(self.random_marker)\n\n        plot_widget = widgets.Output(layout={\"border\": \"1px solid black\"})\n        plot_control = ipyleaflet.WidgetControl(\n            widget=plot_widget,\n            position=position,\n            min_width=min_width,\n            max_width=max_width,\n            min_height=min_height,\n            max_height=max_height,\n        )\n        self.plot_widget = plot_widget\n        self.plot_control = plot_control\n        self.add_control(plot_control)\n\n        self.default_style = {\"cursor\": \"crosshair\"}\n        msg = \"The plot function can only be used on ee.Image or ee.ImageCollection with more than one band.\"\n        if (ee_object is None) and len(self.ee_raster_layers) &gt; 0:\n            ee_object = self.ee_raster_layers[-1]\n            if isinstance(ee_object, ee.ImageCollection):\n                ee_object = ee_object.mosaic()\n        elif isinstance(ee_object, ee.ImageCollection):\n            ee_object = ee_object.mosaic()\n        elif not isinstance(ee_object, ee.Image):\n            print(msg)\n            return\n\n        if sample_scale is None:\n            sample_scale = self.getScale()\n\n        if max_width is None:\n            max_width = 500\n\n        band_names = ee_object.bandNames().getInfo()\n\n        coordinates = []\n        markers = []\n        marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n        self.last_click = []\n        self.all_clicks = []\n        self.add_layer(marker_cluster)\n\n        def handle_interaction(**kwargs2):\n            latlon = kwargs2.get(\"coordinates\")\n\n            if kwargs2.get(\"type\") == \"click\":\n                try:\n                    coordinates.append(latlon)\n                    self.last_click = latlon\n                    self.all_clicks = coordinates\n                    markers.append(ipyleaflet.Marker(location=latlon))\n                    marker_cluster.markers = markers\n                    self.default_style = {\"cursor\": \"wait\"}\n                    xy = ee.Geometry.Point(latlon[::-1])\n                    dict_values = (\n                        ee_object.sample(xy, scale=sample_scale)\n                        .first()\n                        .toDictionary()\n                        .getInfo()\n                    )\n                    band_values = list(dict_values.values())\n                    self.plot(\n                        band_names,\n                        band_values,\n                        plot_type=plot_type,\n                        overlay=overlay,\n                        min_width=min_width,\n                        max_width=max_width,\n                        min_height=min_height,\n                        max_height=max_height,\n                        **kwargs,\n                    )\n                    self.default_style = {\"cursor\": \"crosshair\"}\n                except Exception as e:\n                    if self.plot_widget is not None:\n                        with self.plot_widget:\n                            self.plot_widget.clear_output()\n                            print(\"No data for the clicked location.\")\n                    else:\n                        print(e)\n                    self.default_style = {\"cursor\": \"crosshair\"}\n\n        self.on_interaction(handle_interaction)\n\n    def add_marker_cluster(self, event=\"click\", add_marker=True):\n\"\"\"Captures user inputs and add markers to the map.\n\n        Args:\n            event (str, optional): [description]. Defaults to 'click'.\n            add_marker (bool, optional): If True, add markers to the map. Defaults to True.\n\n        Returns:\n            object: a marker cluster.\n        \"\"\"\n        coordinates = []\n        markers = []\n        marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n        self.last_click = []\n        self.all_clicks = []\n        if add_marker:\n            self.add_layer(marker_cluster)\n\n        def handle_interaction(**kwargs):\n            latlon = kwargs.get(\"coordinates\")\n\n            if event == \"click\" and kwargs.get(\"type\") == \"click\":\n                coordinates.append(latlon)\n                self.last_click = latlon\n                self.all_clicks = coordinates\n                if add_marker:\n                    markers.append(ipyleaflet.Marker(location=latlon))\n                    marker_cluster.markers = markers\n            elif kwargs.get(\"type\") == \"mousemove\":\n                pass\n\n        # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp\n        self.default_style = {\"cursor\": \"crosshair\"}\n        self.on_interaction(handle_interaction)\n\n    def set_control_visibility(\n        self, layerControl=True, fullscreenControl=True, latLngPopup=True\n    ):\n\"\"\"Sets the visibility of the controls on the map.\n\n        Args:\n            layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True.\n            fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True.\n            latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.\n        \"\"\"\n        pass\n\n    setControlVisibility = set_control_visibility\n\n    def add_layer_control(self):\n\"\"\"Adds the layer control to the map.\"\"\"\n        if self.layer_control is None:\n            layer_control = ipyleaflet.LayersControl(position=\"topright\")\n            self.layer_control = layer_control\n            self.add_control(layer_control)\n\n    addLayerControl = add_layer_control\n\n    def split_map(\n        self,\n        left_layer=\"HYBRID\",\n        right_layer=\"ROADMAP\",\n        zoom_control=True,\n        fullscreen_control=True,\n        layer_control=True,\n        add_close_button=False,\n        left_label=None,\n        right_label=None,\n        left_position=\"bottomleft\",\n        right_position=\"bottomright\",\n        widget_layout=None,\n        **kwargs,\n    ):\n\"\"\"Adds split map.\n\n        Args:\n            left_layer (str, optional): The layer tile layer. Defaults to 'HYBRID'.\n            right_layer (str, optional): The right tile layer. Defaults to 'ROADMAP'.\n            zoom_control (bool, optional): Whether to show the zoom control. Defaults to True.\n            fullscreen_control (bool, optional): Whether to show the full screen control. Defaults to True.\n            layer_control (bool, optional): Whether to show the layer control. Defaults to True.\n            add_close_button (bool, optional): Whether to add a close button. Defaults to False.\n            left_label (str, optional): The label for the left map. Defaults to None.\n            right_label (str, optional): The label for the right map. Defaults to None.\n            left_position (str, optional): The position of the left label. Defaults to 'bottomleft'.\n            right_position (str, optional): The position of the right label. Defaults to 'bottomright'.\n            widget_layout (str, optional): The layout of the label widget, such as ipywidgets.Layout(padding=\"0px 4px 0px 4px\"). Defaults to None.\n            kwargs: Other arguments for ipyleaflet.TileLayer.\n        \"\"\"\n        if \"max_zoom\" not in kwargs:\n            kwargs[\"max_zoom\"] = 100\n        if \"max_native_zoom\" not in kwargs:\n            kwargs[\"max_native_zoom\"] = 100\n        try:\n            controls = self.controls\n            layers = self.layers\n            self.clear_controls()\n\n            if zoom_control:\n                self.add_control(ipyleaflet.ZoomControl())\n            if fullscreen_control:\n                self.add_control(ipyleaflet.FullScreenControl())\n\n            if left_label is not None:\n                left_name = left_label\n            else:\n                left_name = \"Left Layer\"\n\n            if right_label is not None:\n                right_name = right_label\n            else:\n                right_name = \"Right Layer\"\n\n            if \"attribution\" not in kwargs:\n                kwargs[\"attribution\"] = \" \"\n\n            if left_layer in basemaps.keys():\n                left_layer = basemaps[left_layer]\n            elif isinstance(left_layer, str):\n                if left_layer.startswith(\"http\") and left_layer.endswith(\".tif\"):\n                    url = cog_tile(left_layer)\n                    left_layer = ipyleaflet.TileLayer(\n                        url=url,\n                        name=left_name,\n                        **kwargs,\n                    )\n                else:\n                    left_layer = ipyleaflet.TileLayer(\n                        url=left_layer,\n                        name=left_name,\n                        **kwargs,\n                    )\n            elif isinstance(left_layer, ipyleaflet.TileLayer):\n                pass\n            else:\n                raise ValueError(\n                    f\"left_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n                )\n\n            if right_layer in basemaps.keys():\n                right_layer = basemaps[right_layer]\n            elif isinstance(right_layer, str):\n                if right_layer.startswith(\"http\") and right_layer.endswith(\".tif\"):\n                    url = cog_tile(right_layer)\n                    right_layer = ipyleaflet.TileLayer(\n                        url=url,\n                        name=right_name,\n                        **kwargs,\n                    )\n                else:\n                    right_layer = ipyleaflet.TileLayer(\n                        url=right_layer,\n                        name=right_name,\n                        **kwargs,\n                    )\n            elif isinstance(right_layer, ipyleaflet.TileLayer):\n                pass\n            else:\n                raise ValueError(\n                    f\"right_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n                )\n\n            control = ipyleaflet.SplitMapControl(\n                left_layer=left_layer, right_layer=right_layer\n            )\n\n            self.add_control(control)\n\n            if left_label is not None:\n                if widget_layout is None:\n                    widget_layout = widgets.Layout(padding=\"0px 4px 0px 4px\")\n                left_widget = widgets.HTML(value=left_label, layout=widget_layout)\n\n                left_control = ipyleaflet.WidgetControl(\n                    widget=left_widget, position=left_position\n                )\n                self.add_control(left_control)\n\n            if right_label is not None:\n                if widget_layout is None:\n                    widget_layout = widgets.Layout(padding=\"0px 4px 0px 4px\")\n                right_widget = widgets.HTML(value=right_label, layout=widget_layout)\n                right_control = ipyleaflet.WidgetControl(\n                    widget=right_widget, position=right_position\n                )\n                self.add_control(right_control)\n\n            close_button = widgets.ToggleButton(\n                value=False,\n                tooltip=\"Close split-panel map\",\n                icon=\"times\",\n                layout=widgets.Layout(\n                    height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n                ),\n            )\n\n            def close_btn_click(change):\n                if change[\"new\"]:\n                    self.controls = controls\n                    self.layers = layers[:-1]\n                    self.add_layer(layers[-1])\n\n                if left_label is not None:\n                    self.remove_control(left_control)\n\n                if right_label is not None:\n                    self.remove_control(right_control)\n\n            close_button.observe(close_btn_click, \"value\")\n            close_control = ipyleaflet.WidgetControl(\n                widget=close_button, position=\"bottomright\"\n            )\n\n            if add_close_button:\n                self.add_control(close_control)\n\n            if layer_control:\n                self.addLayerControl()\n\n        except Exception as e:\n            print(\"The provided layers are invalid!\")\n            raise ValueError(e)\n\n    def ts_inspector(\n        self,\n        left_ts,\n        left_names=None,\n        left_vis={},\n        left_index=0,\n        right_ts=None,\n        right_names=None,\n        right_vis=None,\n        right_index=-1,\n        width=\"130px\",\n        date_format=\"YYYY-MM-dd\",\n        add_close_button=False,\n        **kwargs,\n    ):\n\"\"\"Creates a split-panel map for inspecting timeseries images.\n\n        Args:\n            left_ts (object): An ee.ImageCollection to show on the left panel.\n            left_names (list): A list of names to show under the left dropdown.\n            left_vis (dict, optional): Visualization parameters for the left layer. Defaults to {}.\n            left_index (int, optional): The index of the left layer to show. Defaults to 0.\n            right_ts (object): An ee.ImageCollection to show on the right panel.\n            right_names (list): A list of names to show under the right dropdown.\n            right_vis (dict, optional): Visualization parameters for the right layer. Defaults to {}.\n            right_index (int, optional): The index of the right layer to show. Defaults to -1.\n            width (str, optional): The width of the dropdown list. Defaults to '130px'.\n            date_format (str, optional): The date format to show in the dropdown. Defaults to 'YYYY-MM-dd'.\n            add_close_button (bool, optional): Whether to show the close button. Defaults to False.\n        \"\"\"\n        controls = self.controls\n        layers = self.layers\n\n        if left_names is None:\n            left_names = image_dates(left_ts, date_format=date_format).getInfo()\n\n        if right_ts is None:\n            right_ts = left_ts\n\n        if right_names is None:\n            right_names = left_names\n\n        if right_vis is None:\n            right_vis = left_vis\n\n        left_count = int(left_ts.size().getInfo())\n        right_count = int(right_ts.size().getInfo())\n\n        if left_count != len(left_names):\n            print(\n                \"The number of images in left_ts must match the number of layer names in left_names.\"\n            )\n            return\n        if right_count != len(right_names):\n            print(\n                \"The number of images in right_ts must match the number of layer names in right_names.\"\n            )\n            return\n\n        left_layer = ipyleaflet.TileLayer(\n            url=\"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n            attribution=\"Google\",\n            name=\"Google Maps\",\n        )\n        right_layer = ipyleaflet.TileLayer(\n            url=\"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n            attribution=\"Google\",\n            name=\"Google Maps\",\n        )\n\n        self.clear_controls()\n        left_dropdown = widgets.Dropdown(options=left_names, value=None)\n        right_dropdown = widgets.Dropdown(options=right_names, value=None)\n        left_dropdown.layout.max_width = width\n        right_dropdown.layout.max_width = width\n\n        left_control = ipyleaflet.WidgetControl(\n            widget=left_dropdown, position=\"topleft\"\n        )\n        right_control = ipyleaflet.WidgetControl(\n            widget=right_dropdown, position=\"topright\"\n        )\n\n        self.add_control(control=left_control)\n        self.add_control(control=right_control)\n\n        self.add_control(ipyleaflet.ZoomControl(position=\"topleft\"))\n        self.add_control(ipyleaflet.ScaleControl(position=\"bottomleft\"))\n        self.add_control(ipyleaflet.FullScreenControl())\n\n        def left_dropdown_change(change):\n            left_dropdown_index = left_dropdown.index\n            if left_dropdown_index is not None and left_dropdown_index &gt;= 0:\n                try:\n                    if isinstance(left_ts, ee.ImageCollection):\n                        left_image = left_ts.toList(left_ts.size()).get(\n                            left_dropdown_index\n                        )\n                    elif isinstance(left_ts, ee.List):\n                        left_image = left_ts.get(left_dropdown_index)\n                    else:\n                        print(\"The left_ts argument must be an ImageCollection.\")\n                        return\n\n                    if isinstance(left_image, ee.ImageCollection):\n                        left_image = ee.Image(left_image.mosaic())\n                    elif isinstance(left_image, ee.Image):\n                        pass\n                    else:\n                        left_image = ee.Image(left_image)\n\n                    left_image = ee_tile_layer(\n                        left_image, left_vis, left_names[left_dropdown_index]\n                    )\n                    left_layer.url = left_image.url\n                except Exception as e:\n                    print(e)\n                    return\n\n        left_dropdown.observe(left_dropdown_change, names=\"value\")\n\n        def right_dropdown_change(change):\n            right_dropdown_index = right_dropdown.index\n            if right_dropdown_index is not None and right_dropdown_index &gt;= 0:\n                try:\n                    if isinstance(right_ts, ee.ImageCollection):\n                        right_image = right_ts.toList(left_ts.size()).get(\n                            right_dropdown_index\n                        )\n                    elif isinstance(right_ts, ee.List):\n                        right_image = right_ts.get(right_dropdown_index)\n                    else:\n                        print(\"The left_ts argument must be an ImageCollection.\")\n                        return\n\n                    if isinstance(right_image, ee.ImageCollection):\n                        right_image = ee.Image(right_image.mosaic())\n                    elif isinstance(right_image, ee.Image):\n                        pass\n                    else:\n                        right_image = ee.Image(right_image)\n\n                    right_image = ee_tile_layer(\n                        right_image,\n                        right_vis,\n                        right_names[right_dropdown_index],\n                    )\n                    right_layer.url = right_image.url\n                except Exception as e:\n                    print(e)\n                    return\n\n        right_dropdown.observe(right_dropdown_change, names=\"value\")\n\n        if left_index is not None:\n            left_dropdown.value = left_names[left_index]\n        if right_index is not None:\n            right_dropdown.value = right_names[right_index]\n\n        close_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Close the tool\",\n            icon=\"times\",\n            # button_style=\"primary\",\n            layout=widgets.Layout(\n                height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n            ),\n        )\n\n        def close_btn_click(change):\n            if change[\"new\"]:\n                self.controls = controls\n                self.clear_layers()\n                self.layers = layers\n\n        close_button.observe(close_btn_click, \"value\")\n        close_control = ipyleaflet.WidgetControl(\n            widget=close_button, position=\"bottomright\"\n        )\n\n        try:\n            split_control = ipyleaflet.SplitMapControl(\n                left_layer=left_layer, right_layer=right_layer\n            )\n            self.add_control(split_control)\n\n            if add_close_button:\n                self.add_control(close_control)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def basemap_demo(self):\n\"\"\"A demo for using geemap basemaps.\"\"\"\n        dropdown = widgets.Dropdown(\n            options=list(basemaps.keys()),\n            value=\"HYBRID\",\n            description=\"Basemaps\",\n        )\n\n        def on_click(change):\n            basemap_name = change[\"new\"]\n            old_basemap = self.layers[-1]\n            self.substitute_layer(old_basemap, basemaps[basemap_name])\n\n        dropdown.observe(on_click, \"value\")\n        basemap_control = ipyleaflet.WidgetControl(widget=dropdown, position=\"topright\")\n        self.add_control(basemap_control)\n\n    def add_legend(\n        self,\n        title=\"Legend\",\n        legend_dict=None,\n        labels=None,\n        colors=None,\n        position=\"bottomright\",\n        builtin_legend=None,\n        layer_name=None,\n        **kwargs,\n    ):\n\"\"\"Adds a customized basemap to the map.\n\n        Args:\n            title (str, optional): Title of the legend. Defaults to 'Legend'.\n            legend_dict (dict, optional): A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n            labels (list, optional): A list of legend keys. Defaults to None.\n            colors (list, optional): A list of legend colors. Defaults to None.\n            position (str, optional): Position of the legend. Defaults to 'bottomright'.\n            builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n            layer_name (str, optional): Layer name of the legend to be associated with. Defaults to None.\n\n        \"\"\"\n        from IPython.display import display\n\n        pkg_dir = os.path.dirname(\n            pkg_resources.resource_filename(\"geemap\", \"geemap.py\")\n        )\n        legend_template = os.path.join(pkg_dir, \"data/template/legend.html\")\n\n        if \"min_width\" not in kwargs.keys():\n            min_width = None\n        if \"max_width\" not in kwargs.keys():\n            max_width = None\n        else:\n            max_width = kwargs[\"max_width\"]\n        if \"min_height\" not in kwargs.keys():\n            min_height = None\n        else:\n            min_height = kwargs[\"min_height\"]\n        if \"max_height\" not in kwargs.keys():\n            max_height = None\n        else:\n            max_height = kwargs[\"max_height\"]\n        if \"height\" not in kwargs.keys():\n            height = None\n        else:\n            height = kwargs[\"height\"]\n        if \"width\" not in kwargs.keys():\n            width = None\n        else:\n            width = kwargs[\"width\"]\n\n        if width is None:\n            max_width = \"300px\"\n        if height is None:\n            max_height = \"400px\"\n\n        if not os.path.exists(legend_template):\n            print(\"The legend template does not exist.\")\n            return\n\n        if labels is not None:\n            if not isinstance(labels, list):\n                print(\"The legend keys must be a list.\")\n                return\n        else:\n            labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n\n        if colors is not None:\n            if not isinstance(colors, list):\n                print(\"The legend colors must be a list.\")\n                return\n            elif all(isinstance(item, tuple) for item in colors):\n                try:\n                    colors = [rgb_to_hex(x) for x in colors]\n                except Exception as e:\n                    print(e)\n            elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n                pass\n            elif all((len(item) == 6) for item in colors):\n                pass\n            else:\n                print(\"The legend colors must be a list of tuples.\")\n                return\n        else:\n            colors = [\n                \"#8DD3C7\",\n                \"#FFFFB3\",\n                \"#BEBADA\",\n                \"#FB8072\",\n                \"#80B1D3\",\n            ]\n\n        if len(labels) != len(colors):\n            print(\"The legend keys and values must be the same length.\")\n            return\n\n        allowed_builtin_legends = builtin_legends.keys()\n        if builtin_legend is not None:\n            if builtin_legend not in allowed_builtin_legends:\n                print(\n                    \"The builtin legend must be one of the following: {}\".format(\n                        \", \".join(allowed_builtin_legends)\n                    )\n                )\n                return\n            else:\n                legend_dict = builtin_legends[builtin_legend]\n                labels = list(legend_dict.keys())\n                colors = list(legend_dict.values())\n\n        if legend_dict is not None:\n            if not isinstance(legend_dict, dict):\n                print(\"The legend dict must be a dictionary.\")\n                return\n            else:\n                labels = list(legend_dict.keys())\n                colors = list(legend_dict.values())\n                if all(isinstance(item, tuple) for item in colors):\n                    try:\n                        colors = [rgb_to_hex(x) for x in colors]\n                    except Exception as e:\n                        print(e)\n\n        allowed_positions = [\n            \"topleft\",\n            \"topright\",\n            \"bottomleft\",\n            \"bottomright\",\n        ]\n        if position not in allowed_positions:\n            print(\n                \"The position must be one of the following: {}\".format(\n                    \", \".join(allowed_positions)\n                )\n            )\n            return\n\n        header = []\n        content = []\n        footer = []\n\n        with open(legend_template) as f:\n            lines = f.readlines()\n            lines[3] = lines[3].replace(\"Legend\", title)\n            header = lines[:6]\n            footer = lines[11:]\n\n        for index, key in enumerate(labels):\n            color = colors[index]\n            if not color.startswith(\"#\"):\n                color = \"#\" + color\n            item = \"      &lt;li&gt;&lt;span style='background:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n                color, key\n            )\n            content.append(item)\n\n        legend_html = header + content + footer\n        legend_text = \"\".join(legend_html)\n\n        try:\n            legend_output_widget = widgets.Output(\n                layout={\n                    # \"border\": \"1px solid black\",\n                    \"max_width\": max_width,\n                    \"min_width\": min_width,\n                    \"max_height\": max_height,\n                    \"min_height\": min_height,\n                    \"height\": height,\n                    \"width\": width,\n                    \"overflow\": \"scroll\",\n                }\n            )\n            legend_control = ipyleaflet.WidgetControl(\n                widget=legend_output_widget, position=position\n            )\n            legend_widget = widgets.HTML(value=legend_text)\n            with legend_output_widget:\n                display(legend_widget)\n\n            self.legend_widget = legend_output_widget\n            self.legend_control = legend_control\n            self.add_control(legend_control)\n\n            if not hasattr(self, \"legends\"):\n                setattr(self, \"legends\", [legend_control])\n            else:\n                self.legends.append(legend_control)\n\n            if layer_name in self.ee_layer_names:\n                self.ee_layer_dict[layer_name][\"legend\"] = legend_control\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_colorbar(\n        self,\n        vis_params=None,\n        cmap=\"gray\",\n        discrete=False,\n        label=None,\n        orientation=\"horizontal\",\n        position=\"bottomright\",\n        transparent_bg=False,\n        layer_name=None,\n        font_size=9,\n        axis_off=False,\n        **kwargs,\n    ):\n\"\"\"Add a matplotlib colorbar to the map\n\n        Args:\n            vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n            cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n            discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n            label (str, optional): Label for the colorbar. Defaults to None.\n            orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n            position (str, optional): Position of the colorbar on the map. It can be one of: topleft, topright, bottomleft, and bottomright. Defaults to \"bottomright\".\n            transparent_bg (bool, optional): Whether to use transparent background. Defaults to False.\n            layer_name (str, optional): The layer name associated with the colorbar. Defaults to None.\n            font_size (int, optional): Font size for the colorbar. Defaults to 9.\n            axis_off (bool, optional): Whether to turn off the axis. Defaults to False.\n\n        Raises:\n            TypeError: If the vis_params is not a dictionary.\n            ValueError: If the orientation is not either horizontal or vertical.\n            ValueError: If the provided min value is not scalar type.\n            ValueError: If the provided max value is not scalar type.\n            ValueError: If the provided opacity value is not scalar type.\n            ValueError: If cmap or palette is not provided.\n        \"\"\"\n        import matplotlib as mpl\n        import matplotlib.pyplot as plt\n        import numpy as np\n\n        if isinstance(vis_params, list):\n            vis_params = {\"palette\": vis_params}\n        elif isinstance(vis_params, tuple):\n            vis_params = {\"palette\": list(vis_params)}\n        elif vis_params is None:\n            vis_params = {}\n\n        if \"colors\" in kwargs and isinstance(kwargs[\"colors\"], list):\n            vis_params[\"palette\"] = kwargs[\"colors\"]\n\n        if \"colors\" in kwargs and isinstance(kwargs[\"colors\"], tuple):\n            vis_params[\"palette\"] = list(kwargs[\"colors\"])\n\n        if \"vmin\" in kwargs:\n            vis_params[\"min\"] = kwargs[\"vmin\"]\n            del kwargs[\"vmin\"]\n\n        if \"vmax\" in kwargs:\n            vis_params[\"max\"] = kwargs[\"vmax\"]\n            del kwargs[\"vmax\"]\n\n        if \"caption\" in kwargs:\n            label = kwargs[\"caption\"]\n            del kwargs[\"caption\"]\n\n        if not isinstance(vis_params, dict):\n            raise TypeError(\"The vis_params must be a dictionary.\")\n\n        if orientation not in [\"horizontal\", \"vertical\"]:\n            raise ValueError(\"The orientation must be either horizontal or vertical.\")\n\n        if orientation == \"horizontal\":\n            width, height = 3.0, 0.3\n        else:\n            width, height = 0.3, 3.0\n\n        if \"width\" in kwargs:\n            width = kwargs[\"width\"]\n            kwargs.pop(\"width\")\n\n        if \"height\" in kwargs:\n            height = kwargs[\"height\"]\n            kwargs.pop(\"height\")\n\n        vis_keys = list(vis_params.keys())\n\n        if \"min\" in vis_params:\n            vmin = vis_params[\"min\"]\n            if type(vmin) not in (int, float):\n                raise ValueError(\"The provided min value must be scalar type.\")\n        else:\n            vmin = 0\n\n        if \"max\" in vis_params:\n            vmax = vis_params[\"max\"]\n            if type(vmax) not in (int, float):\n                raise ValueError(\"The provided max value must be scalar type.\")\n        else:\n            vmax = 1\n\n        if \"opacity\" in vis_params:\n            alpha = vis_params[\"opacity\"]\n            if type(alpha) not in (int, float):\n                raise ValueError(\"The provided opacity value must be type scalar.\")\n        elif \"alpha\" in kwargs:\n            alpha = kwargs[\"alpha\"]\n        else:\n            alpha = 1\n\n        if cmap is not None:\n            cmap = mpl.pyplot.get_cmap(cmap)\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n        if \"palette\" in vis_keys:\n            hexcodes = to_hex_colors(check_cmap(vis_params[\"palette\"]))\n            if discrete:\n                cmap = mpl.colors.ListedColormap(hexcodes)\n                vals = np.linspace(vmin, vmax, cmap.N + 1)\n                norm = mpl.colors.BoundaryNorm(vals, cmap.N)\n\n            else:\n                cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                    \"custom\", hexcodes, N=256\n                )\n                norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n        elif cmap is not None:\n            cmap = mpl.pyplot.get_cmap(cmap)\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n        else:\n            raise ValueError(\n                'cmap keyword or \"palette\" key in vis_params must be provided.'\n            )\n\n        _, ax = plt.subplots(figsize=(width, height))\n        cb = mpl.colorbar.ColorbarBase(\n            ax, norm=norm, alpha=alpha, cmap=cmap, orientation=orientation, **kwargs\n        )\n\n        if label is not None:\n            cb.set_label(label, fontsize=font_size)\n        elif \"bands\" in vis_keys:\n            cb.set_label(vis_params[\"bands\"], fontsize=font_size)\n\n        if axis_off:\n            ax.set_axis_off()\n        ax.tick_params(labelsize=font_size)\n\n        output = widgets.Output()\n        colormap_ctrl = ipyleaflet.WidgetControl(\n            widget=output,\n            position=position,\n            transparent_bg=transparent_bg,\n        )\n        with output:\n            output.clear_output()\n            plt.show()\n\n        self.colorbar = colormap_ctrl\n        if layer_name in self.ee_layer_names:\n            if \"colorbar\" in self.ee_layer_dict[layer_name]:\n                self.remove_control(self.ee_layer_dict[layer_name][\"colorbar\"])\n            self.ee_layer_dict[layer_name][\"colorbar\"] = colormap_ctrl\n        if not hasattr(self, \"colorbars\"):\n            self.colorbars = [colormap_ctrl]\n        else:\n            self.colorbars.append(colormap_ctrl)\n\n        self.add_control(colormap_ctrl)\n\n    def add_colorbar_branca(\n        self,\n        colors,\n        vmin=0,\n        vmax=1.0,\n        index=None,\n        caption=\"\",\n        categorical=False,\n        step=None,\n        height=\"45px\",\n        transparent_bg=False,\n        position=\"bottomright\",\n        layer_name=None,\n        **kwargs,\n    ):\n\"\"\"Add a branca colorbar to the map.\n\n        Args:\n            colors (list): The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)\n            vmin (int, optional): The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.\n            vmax (float, optional): The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.\n            index (list, optional):The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.\n            caption (str, optional): The caption for the colormap. Defaults to \"\".\n            categorical (bool, optional): Whether or not to create a categorical colormap. Defaults to False.\n            step (int, optional): The step to split the LinearColormap into a StepColormap. Defaults to None.\n            height (str, optional): The height of the colormap widget. Defaults to \"45px\".\n            transparent_bg (bool, optional): Whether to use transparent background for the colormap widget. Defaults to True.\n            position (str, optional): The position for the colormap widget. Defaults to \"bottomright\".\n            layer_name (str, optional): Layer name of the colorbar to be associated with. Defaults to None.\n\n        \"\"\"\n        from branca.colormap import LinearColormap\n\n        output = widgets.Output()\n        output.layout.height = height\n\n        if \"width\" in kwargs.keys():\n            output.layout.width = kwargs[\"width\"]\n\n        if isinstance(colors, Box):\n            try:\n                colors = list(colors[\"default\"])\n            except Exception as e:\n                print(\"The provided color list is invalid.\")\n                raise Exception(e)\n\n        if all(len(color) == 6 for color in colors):\n            colors = [\"#\" + color for color in colors]\n\n        colormap = LinearColormap(\n            colors=colors, index=index, vmin=vmin, vmax=vmax, caption=caption\n        )\n\n        if categorical:\n            if step is not None:\n                colormap = colormap.to_step(step)\n            elif index is not None:\n                colormap = colormap.to_step(len(index) - 1)\n            else:\n                colormap = colormap.to_step(3)\n\n        colormap_ctrl = ipyleaflet.WidgetControl(\n            widget=output,\n            position=position,\n            transparent_bg=transparent_bg,\n            **kwargs,\n        )\n        with output:\n            output.clear_output()\n            display(colormap)\n\n        self.colorbar = colormap_ctrl\n        self.add_control(colormap_ctrl)\n\n        if not hasattr(self, \"colorbars\"):\n            self.colorbars = [colormap_ctrl]\n        else:\n            self.colorbars.append(colormap_ctrl)\n\n        if layer_name in self.ee_layer_names:\n            self.ee_layer_dict[layer_name][\"colorbar\"] = colormap_ctrl\n\n    def remove_colorbar(self):\n\"\"\"Remove colorbar from the map.\"\"\"\n        if self.colorbar is not None:\n            self.remove_control(self.colorbar)\n\n    def remove_colorbars(self):\n\"\"\"Remove all colorbars from the map.\"\"\"\n        if hasattr(self, \"colorbars\"):\n            for colorbar in self.colorbars:\n                if colorbar in self.controls:\n                    self.remove_control(colorbar)\n\n    def remove_legend(self):\n\"\"\"Remove legend from the map.\"\"\"\n        if self.legend is not None:\n            if self.legend in self.controls:\n                self.remove_control(self.legend)\n\n    def remove_legends(self):\n\"\"\"Remove all legends from the map.\"\"\"\n        if hasattr(self, \"legends\"):\n            for legend in self.legends:\n                if legend in self.controls:\n                    self.remove_control(legend)\n\n    def image_overlay(self, url, bounds, name):\n\"\"\"Overlays an image from the Internet or locally on the map.\n\n        Args:\n            url (str): http URL or local file path to the image.\n            bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n            name (str): name of the layer to show on the layer control.\n        \"\"\"\n        from base64 import b64encode\n        from io import BytesIO\n\n        from PIL import Image, ImageSequence\n\n        try:\n            if not url.startswith(\"http\"):\n                if not os.path.exists(url):\n                    print(\"The provided file does not exist.\")\n                    return\n\n                ext = os.path.splitext(url)[1][1:]  # file extension\n                image = Image.open(url)\n\n                f = BytesIO()\n                if ext.lower() == \"gif\":\n                    frames = []\n                    # Loop over each frame in the animated image\n                    for frame in ImageSequence.Iterator(image):\n                        frame = frame.convert(\"RGBA\")\n                        b = BytesIO()\n                        frame.save(b, format=\"gif\")\n                        frame = Image.open(b)\n                        frames.append(frame)\n                    frames[0].save(\n                        f,\n                        format=\"GIF\",\n                        save_all=True,\n                        append_images=frames[1:],\n                        loop=0,\n                    )\n                else:\n                    image.save(f, ext)\n\n                data = b64encode(f.getvalue())\n                data = data.decode(\"ascii\")\n                url = \"data:image/{};base64,\".format(ext) + data\n            img = ipyleaflet.ImageOverlay(url=url, bounds=bounds, name=name)\n            self.add_layer(img)\n        except Exception as e:\n            print(e)\n\n    def video_overlay(self, url, bounds, name=\"Video\"):\n\"\"\"Overlays a video from the Internet on the map.\n\n        Args:\n            url (str): http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\"\n            bounds (tuple): bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n            name (str): name of the layer to show on the layer control.\n        \"\"\"\n        try:\n            video = ipyleaflet.VideoOverlay(url=url, bounds=bounds, name=name)\n            self.add_layer(video)\n        except Exception as e:\n            print(e)\n\n    def add_landsat_ts_gif(\n        self,\n        layer_name=\"Timelapse\",\n        roi=None,\n        label=None,\n        start_year=1984,\n        end_year=2021,\n        start_date=\"06-10\",\n        end_date=\"09-20\",\n        bands=[\"NIR\", \"Red\", \"Green\"],\n        vis_params=None,\n        dimensions=768,\n        frames_per_second=10,\n        font_size=30,\n        font_color=\"white\",\n        add_progress_bar=True,\n        progress_bar_color=\"white\",\n        progress_bar_height=5,\n        out_gif=None,\n        download=False,\n        apply_fmask=True,\n        nd_bands=None,\n        nd_threshold=0,\n        nd_palette=[\"black\", \"blue\"],\n    ):\n\"\"\"Adds a Landsat timelapse to the map.\n\n        Args:\n            layer_name (str, optional): Layer name to show under the layer control. Defaults to 'Timelapse'.\n            roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n            label (str, optional): A label to show on the GIF, such as place name. Defaults to None.\n            start_year (int, optional): Starting year for the timelapse. Defaults to 1984.\n            end_year (int, optional): Ending year for the timelapse. Defaults to 2021.\n            start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.\n            end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.\n            bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green'].\n            vis_params (dict, optional): Visualization parameters. Defaults to None.\n            dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n            frames_per_second (int, optional): Animation speed. Defaults to 10.\n            font_size (int, optional): Font size of the animated text and label. Defaults to 30.\n            font_color (str, optional): Font color of the animated text and label. Defaults to 'black'.\n            add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n            progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n            progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n            out_gif (str, optional): File path to the output animated GIF. Defaults to None.\n            download (bool, optional): Whether to download the gif. Defaults to False.\n            apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.\n            nd_bands (list, optional): A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1).\n            nd_threshold (float, optional): The threshold for extacting pixels from the normalized difference band.\n            nd_palette (str, optional): The color palette to use for displaying the normalized difference band.\n\n        \"\"\"\n        try:\n            if roi is None:\n                if self.draw_last_feature is not None:\n                    feature = self.draw_last_feature\n                    roi = feature.geometry()\n                else:\n                    roi = ee.Geometry.Polygon(\n                        [\n                            [\n                                [-115.471773, 35.892718],\n                                [-115.471773, 36.409454],\n                                [-114.271283, 36.409454],\n                                [-114.271283, 35.892718],\n                                [-115.471773, 35.892718],\n                            ]\n                        ],\n                        None,\n                        False,\n                    )\n            elif isinstance(roi, ee.Feature) or isinstance(roi, ee.FeatureCollection):\n                roi = roi.geometry()\n            elif isinstance(roi, ee.Geometry):\n                pass\n            else:\n                print(\"The provided roi is invalid. It must be an ee.Geometry\")\n                return\n\n            geojson = ee_to_geojson(roi)\n            bounds = minimum_bounding_box(geojson)\n            geojson = adjust_longitude(geojson)\n            roi = ee.Geometry(geojson)\n\n            in_gif = landsat_timelapse(\n                roi=roi,\n                out_gif=out_gif,\n                start_year=start_year,\n                end_year=end_year,\n                start_date=start_date,\n                end_date=end_date,\n                bands=bands,\n                vis_params=vis_params,\n                dimensions=dimensions,\n                frames_per_second=frames_per_second,\n                apply_fmask=apply_fmask,\n                nd_bands=nd_bands,\n                nd_threshold=nd_threshold,\n                nd_palette=nd_palette,\n                font_size=font_size,\n                font_color=font_color,\n                progress_bar_color=progress_bar_color,\n                progress_bar_height=progress_bar_height,\n            )\n            in_nd_gif = in_gif.replace(\".gif\", \"_nd.gif\")\n\n            if nd_bands is not None:\n                add_text_to_gif(\n                    in_nd_gif,\n                    in_nd_gif,\n                    xy=(\"2%\", \"2%\"),\n                    text_sequence=start_year,\n                    font_size=font_size,\n                    font_color=font_color,\n                    duration=int(1000 / frames_per_second),\n                    add_progress_bar=add_progress_bar,\n                    progress_bar_color=progress_bar_color,\n                    progress_bar_height=progress_bar_height,\n                )\n\n            if label is not None:\n                add_text_to_gif(\n                    in_gif,\n                    in_gif,\n                    xy=(\"2%\", \"90%\"),\n                    text_sequence=label,\n                    font_size=font_size,\n                    font_color=font_color,\n                    duration=int(1000 / frames_per_second),\n                    add_progress_bar=add_progress_bar,\n                    progress_bar_color=progress_bar_color,\n                    progress_bar_height=progress_bar_height,\n                )\n                # if nd_bands is not None:\n                #     add_text_to_gif(in_nd_gif, in_nd_gif, xy=('2%', '90%'), text_sequence=label,\n                #                     font_size=font_size, font_color=font_color, duration=int(1000 / frames_per_second), add_progress_bar=add_progress_bar, progress_bar_color=progress_bar_color, progress_bar_height=progress_bar_height)\n\n            if is_tool(\"ffmpeg\"):\n                reduce_gif_size(in_gif)\n                if nd_bands is not None:\n                    reduce_gif_size(in_nd_gif)\n\n            print(\"Adding GIF to the map ...\")\n            self.image_overlay(url=in_gif, bounds=bounds, name=layer_name)\n            if nd_bands is not None:\n                self.image_overlay(\n                    url=in_nd_gif, bounds=bounds, name=layer_name + \" ND\"\n                )\n            print(\"The timelapse has been added to the map.\")\n\n            if download:\n                link = create_download_link(\n                    in_gif,\n                    title=\"Click here to download the Landsat timelapse: \",\n                )\n                display(link)\n                if nd_bands is not None:\n                    link2 = create_download_link(\n                        in_nd_gif,\n                        title=\"Click here to download the Normalized Difference Index timelapse: \",\n                    )\n                    display(link2)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def to_html(\n        self,\n        filename=None,\n        title=\"My Map\",\n        width=\"100%\",\n        height=\"880px\",\n        add_layer_control=True,\n        **kwargs,\n    ):\n\"\"\"Saves the map as an HTML file.\n\n        Args:\n            filename (str, optional): The output file path to the HTML file.\n            title (str, optional): The title of the HTML file. Defaults to 'My Map'.\n            width (str, optional): The width of the map in pixels or percentage. Defaults to '100%'.\n            height (str, optional): The height of the map in pixels. Defaults to '880px'.\n            add_layer_control (bool, optional): Whether to add the LayersControl. Defaults to True.\n\n        \"\"\"\n        try:\n            save = True\n            if filename is not None:\n                if not filename.endswith(\".html\"):\n                    raise ValueError(\"The output file extension must be html.\")\n                filename = os.path.abspath(filename)\n                out_dir = os.path.dirname(filename)\n                if not os.path.exists(out_dir):\n                    os.makedirs(out_dir)\n            else:\n                filename = os.path.abspath(random_string() + \".html\")\n                save = False\n\n            if add_layer_control and self.layer_control is None:\n                layer_control = ipyleaflet.LayersControl(position=\"topright\")\n                self.layer_control = layer_control\n                self.add_control(layer_control)\n\n            before_width = self.layout.width\n            before_height = self.layout.height\n\n            if not isinstance(width, str):\n                print(\"width must be a string.\")\n                return\n            elif width.endswith(\"px\") or width.endswith(\"%\"):\n                pass\n            else:\n                print(\"width must end with px or %\")\n                return\n\n            if not isinstance(height, str):\n                print(\"height must be a string.\")\n                return\n            elif not height.endswith(\"px\"):\n                print(\"height must end with px\")\n                return\n\n            self.layout.width = width\n            self.layout.height = height\n\n            self.save(filename, title=title, **kwargs)\n\n            self.layout.width = before_width\n            self.layout.height = before_height\n\n            if not save:\n                out_html = \"\"\n                with open(filename) as f:\n                    lines = f.readlines()\n                    out_html = \"\".join(lines)\n                os.remove(filename)\n                return out_html\n\n        except Exception as e:\n            raise Exception(e)\n\n    def to_image(self, filename=None, monitor=1):\n\"\"\"Saves the map as a PNG or JPG image.\n\n        Args:\n            filename (str, optional): The output file path to the image. Defaults to None.\n            monitor (int, optional): The monitor to take the screenshot. Defaults to 1.\n        \"\"\"\n        if filename is None:\n            filename = os.path.join(os.getcwd(), \"my_map.png\")\n\n        if filename.endswith(\".png\") or filename.endswith(\".jpg\"):\n            pass\n        else:\n            print(\"The output file must be a PNG or JPG image.\")\n            return\n\n        work_dir = os.path.dirname(filename)\n        if not os.path.exists(work_dir):\n            os.makedirs(work_dir)\n\n        screenshot = screen_capture(filename, monitor)\n        self.screenshot = screenshot\n\n    def toolbar_reset(self):\n\"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n        toolbar_grid = self.toolbar\n        for tool in toolbar_grid.children:\n            tool.value = False\n\n    def add_raster(\n        self,\n        source,\n        band=None,\n        palette=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=None,\n        **kwargs,\n    ):\n\"\"\"Add a local raster dataset to the map.\n\n            If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\n            running the following two lines before calling this function:\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n        Args:\n            source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n            band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n            palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to None.\n        \"\"\"\n\n        if in_colab_shell():\n            print(\"This add_raster() function is not supported in Colab.\")\n            return\n\n        tile_layer, tile_client = get_local_tile_layer(\n            source,\n            band=band,\n            palette=palette,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            return_client=True,\n            **kwargs,\n        )\n\n        self.add_layer(tile_layer)\n\n        output = widgets.Output()\n\n        with output:\n            bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n            bounds = (\n                bounds[2],\n                bounds[0],\n                bounds[3],\n                bounds[1],\n            )  # [minx, miny, maxx, maxy]\n            self.zoom_to_bounds(bounds)\n\n        if not hasattr(self, \"cog_layer_dict\"):\n            self.cog_layer_dict = {}\n        band_names = list(tile_client.metadata()[\"bands\"].keys())\n        params = {\n            \"tile_layer\": tile_layer,\n            \"tile_client\": tile_client,\n            \"band\": band,\n            \"band_names\": band_names,\n            \"bounds\": bounds,\n            \"type\": \"LOCAL\",\n        }\n        self.cog_layer_dict[layer_name] = params\n\n    add_local_tile = add_raster\n\n    def add_remote_tile(\n        self,\n        source,\n        band=None,\n        palette=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=None,\n        **kwargs,\n    ):\n\"\"\"Add a remote Cloud Optimized GeoTIFF (COG) to the map.\n\n        Args:\n            source (str): The path to the remote Cloud Optimized GeoTIFF.\n            band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n            palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to None.\n        \"\"\"\n        if isinstance(source, str) and source.startswith(\"http\"):\n            self.add_raster(\n                source,\n                band=band,\n                palette=palette,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attribution=attribution,\n                layer_name=layer_name,\n                **kwargs,\n            )\n        else:\n            raise Exception(\"The source must be a URL.\")\n\n    def add_raster_legacy(\n        self,\n        image,\n        bands=None,\n        layer_name=None,\n        colormap=None,\n        x_dim=\"x\",\n        y_dim=\"y\",\n    ):\n\"\"\"Adds a local raster dataset to the map.\n\n        Args:\n            image (str): The image file path.\n            bands (int or list, optional): The image bands to use. It can be either a number (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None.\n            layer_name (str, optional): The layer name to use for the raster. Defaults to None.\n            colormap (str, optional): The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None.\n            x_dim (str, optional): The x dimension. Defaults to 'x'.\n            y_dim (str, optional): The y dimension. Defaults to 'y'.\n        \"\"\"\n        try:\n            import xarray_leaflet\n\n        except Exception:\n            # import platform\n            # if platform.system() != \"Windows\":\n            #     # install_from_github(\n            #     #     url='https://github.com/davidbrochart/xarray_leaflet')\n            #     check_install('xarray_leaflet')\n            #     import xarray_leaflet\n            # else:\n            raise ImportError(\n                \"You need to install xarray_leaflet first. See https://github.com/davidbrochart/xarray_leaflet\"\n            )\n\n        import warnings\n\n        # import xarray as xr\n        import matplotlib.pyplot as plt\n        import numpy as np\n        import rioxarray\n\n        warnings.simplefilter(\"ignore\")\n\n        if not os.path.exists(image):\n            print(\"The image file does not exist.\")\n            return\n\n        if colormap is None:\n            colormap = plt.cm.inferno\n\n        if layer_name is None:\n            layer_name = \"Layer_\" + random_string()\n\n        if isinstance(colormap, str):\n            colormap = plt.cm.get_cmap(name=colormap)\n\n        da = rioxarray.open_rasterio(image, masked=True)\n\n        # print(da.rio.nodata)\n\n        multi_band = False\n        if len(da.band) &gt; 1:\n            multi_band = True\n            if bands is None:\n                bands = [3, 2, 1]\n        else:\n            bands = 1\n\n        if multi_band:\n            da = da.rio.write_nodata(0)\n        else:\n            da = da.rio.write_nodata(np.nan)\n        da = da.sel(band=bands)\n\n        # crs = da.rio.crs\n        # nan = da.attrs['nodatavals'][0]\n        # da = da / da.max()\n        # # if multi_band:\n        # da = xr.where(da == nan, np.nan, da)\n        # da = da.rio.write_nodata(0)\n        # da = da.rio.write_crs(crs)\n\n        if multi_band and type(bands) == list:\n            layer = da.leaflet.plot(self, x_dim=x_dim, y_dim=y_dim, rgb_dim=\"band\")\n        else:\n            layer = da.leaflet.plot(self, x_dim=x_dim, y_dim=y_dim, colormap=colormap)\n\n        layer.name = layer_name\n\n    def remove_drawn_features(self):\n\"\"\"Removes user-drawn geometries from the map\"\"\"\n        if self.draw_layer is not None:\n            self.remove_layer(self.draw_layer)\n            self.draw_count = 0\n            self.draw_features = []\n            self.draw_last_feature = None\n            self.draw_layer = None\n            self.draw_last_json = None\n            self.draw_last_bounds = None\n            self.user_roi = None\n            self.user_rois = None\n            self.chart_values = []\n            self.chart_points = []\n            self.chart_labels = None\n        if self.draw_control is not None:\n            self.draw_control.clear()\n\n    def remove_last_drawn(self):\n\"\"\"Removes user-drawn geometries from the map\"\"\"\n        if self.draw_layer is not None:\n            collection = ee.FeatureCollection(self.draw_features[:-1])\n            ee_draw_layer = ee_tile_layer(\n                collection, {\"color\": \"blue\"}, \"Drawn Features\", True, 0.5\n            )\n            if self.draw_count == 1:\n                self.remove_drawn_features()\n            else:\n                self.substitute_layer(self.draw_layer, ee_draw_layer)\n                self.draw_layer = ee_draw_layer\n                self.draw_count -= 1\n                self.draw_features = self.draw_features[:-1]\n                self.draw_last_feature = self.draw_features[-1]\n                self.draw_layer = ee_draw_layer\n                self.draw_last_json = None\n                self.draw_last_bounds = None\n                self.user_roi = ee.Feature(\n                    collection.toList(collection.size()).get(\n                        collection.size().subtract(1)\n                    )\n                ).geometry()\n                self.user_rois = collection\n                self.chart_values = self.chart_values[:-1]\n                self.chart_points = self.chart_points[:-1]\n                # self.chart_labels = None\n\n    def extract_values_to_points(self, filename):\n\"\"\"Exports pixel values to a csv file based on user-drawn geometries.\n\n        Args:\n            filename (str): The output file path to the csv file or shapefile.\n        \"\"\"\n        import csv\n\n        filename = os.path.abspath(filename)\n        allowed_formats = [\"csv\", \"shp\"]\n        ext = filename[-3:]\n\n        if ext not in allowed_formats:\n            print(\n                \"The output file must be one of the following: {}\".format(\n                    \", \".join(allowed_formats)\n                )\n            )\n            return\n\n        out_dir = os.path.dirname(filename)\n        out_csv = filename[:-3] + \"csv\"\n        out_shp = filename[:-3] + \"shp\"\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        count = len(self.chart_points)\n        out_list = []\n        if count &gt; 0:\n            header = [\"id\", \"longitude\", \"latitude\"] + self.chart_labels\n            out_list.append(header)\n\n            for i in range(0, count):\n                id = i + 1\n                line = [id] + self.chart_points[i] + self.chart_values[i]\n                out_list.append(line)\n\n            with open(out_csv, \"w\", newline=\"\") as f:\n                writer = csv.writer(f)\n                writer.writerows(out_list)\n\n            if ext == \"csv\":\n                print(f\"The csv file has been saved to: {out_csv}\")\n            else:\n                csv_to_shp(out_csv, out_shp)\n                print(f\"The shapefile has been saved to: {out_shp}\")\n\n    def create_vis_widget(self, layer_dict):\n\"\"\"Create a GUI for changing layer visualization parameters interactively.\n\n        Args:\n            layer_dict (dict): A dict containning information about the layer. It is an element from Map.ee_layer_dict.\n\n        Returns:\n            object: An ipywidget.\n        \"\"\"\n\n        import matplotlib as mpl\n        import matplotlib.pyplot as plt\n\n        ee_object = layer_dict[\"ee_object\"]\n\n        if isinstance(ee_object, ee.Geometry) or isinstance(ee_object, ee.Feature):\n            ee_object = ee.FeatureCollection(ee_object)\n\n        ee_layer = layer_dict[\"ee_layer\"]\n        vis_params = layer_dict[\"vis_params\"]\n\n        layer_name = ee_layer.name\n        layer_opacity = ee_layer.opacity\n\n        band_names = None\n        min_value = 0\n        max_value = 100\n        sel_bands = None\n        layer_palette = []\n        layer_gamma = 1\n        left_value = 0\n        right_value = 10000\n\n        self.colorbar_widget = widgets.Output(layout=widgets.Layout(height=\"60px\"))\n        self.colorbar_ctrl = ipyleaflet.WidgetControl(\n            widget=self.colorbar_widget, position=\"bottomright\"\n        )\n        self.add_control(self.colorbar_ctrl)\n\n        # def vdir(obj):  # Get branca colormap list\n        #     return [x for x in dir(obj) if not x.startswith(\"_\")]\n\n        if isinstance(ee_object, ee.Image):\n            band_names = ee_object.bandNames().getInfo()\n            band_count = len(band_names)\n\n            if \"min\" in vis_params.keys():\n                min_value = vis_params[\"min\"]\n                if min_value &lt; left_value:\n                    left_value = min_value - max_value\n            if \"max\" in vis_params.keys():\n                max_value = vis_params[\"max\"]\n                right_value = 2 * max_value\n            if \"gamma\" in vis_params.keys():\n                layer_gamma = vis_params[\"gamma\"]\n            if \"bands\" in vis_params.keys():\n                sel_bands = vis_params[\"bands\"]\n            if \"palette\" in vis_params.keys():\n                layer_palette = [\n                    color.replace(\"#\", \"\") for color in list(vis_params[\"palette\"])\n                ]\n\n            vis_widget = widgets.VBox(\n                layout=widgets.Layout(padding=\"5px 5px 5px 8px\", width=\"330px\")\n            )\n            label = widgets.Label(value=f\"{layer_name} visualization parameters\")\n\n            radio1 = widgets.RadioButtons(\n                options=[\"1 band (Grayscale)\"], layout={\"width\": \"max-content\"}\n            )\n            radio2 = widgets.RadioButtons(\n                options=[\"3 bands (RGB)\"], layout={\"width\": \"max-content\"}\n            )\n            radio1.index = None\n            radio2.index = None\n\n            dropdown_width = \"98px\"\n            band1_dropdown = widgets.Dropdown(\n                options=band_names,\n                value=band_names[0],\n                layout=widgets.Layout(width=dropdown_width),\n            )\n            band2_dropdown = widgets.Dropdown(\n                options=band_names,\n                value=band_names[0],\n                layout=widgets.Layout(width=dropdown_width),\n            )\n            band3_dropdown = widgets.Dropdown(\n                options=band_names,\n                value=band_names[0],\n                layout=widgets.Layout(width=dropdown_width),\n            )\n\n            bands_hbox = widgets.HBox()\n\n            legend_chk = widgets.Checkbox(\n                value=False,\n                description=\"Legend\",\n                indent=False,\n                layout=widgets.Layout(width=\"70px\"),\n            )\n\n            color_picker = widgets.ColorPicker(\n                concise=False,\n                value=\"#000000\",\n                layout=widgets.Layout(width=\"116px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            add_color = widgets.Button(\n                icon=\"plus\",\n                tooltip=\"Add a hex color string to the palette\",\n                layout=widgets.Layout(width=\"32px\"),\n            )\n\n            del_color = widgets.Button(\n                icon=\"minus\",\n                tooltip=\"Remove a hex color string from the palette\",\n                layout=widgets.Layout(width=\"32px\"),\n            )\n\n            reset_color = widgets.Button(\n                icon=\"eraser\",\n                tooltip=\"Remove all color strings from the palette\",\n                layout=widgets.Layout(width=\"34px\"),\n            )\n\n            classes = widgets.Dropdown(\n                options=[\"Any\"] + [str(i) for i in range(3, 13)],\n                description=\"Classes:\",\n                layout=widgets.Layout(width=\"115px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            colormap_options = plt.colormaps()\n            colormap_options.sort()\n            colormap = widgets.Dropdown(\n                options=colormap_options,\n                value=None,\n                description=\"Colormap:\",\n                layout=widgets.Layout(width=\"181px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            def classes_changed(change):\n                if change[\"new\"]:\n                    selected = change[\"owner\"].value\n                    if colormap.value is not None:\n                        n_class = None\n                        if selected != \"Any\":\n                            n_class = int(classes.value)\n\n                        colors = plt.cm.get_cmap(colormap.value, n_class)\n                        cmap_colors = [\n                            mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n                        ]\n\n                        _, ax = plt.subplots(figsize=(6, 0.4))\n                        cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                            \"custom\", to_hex_colors(cmap_colors), N=256\n                        )\n                        norm = mpl.colors.Normalize(\n                            vmin=value_range.value[0], vmax=value_range.value[1]\n                        )\n                        mpl.colorbar.ColorbarBase(\n                            ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                        )\n\n                        palette.value = \", \".join([color for color in cmap_colors])\n\n                        if self.colorbar_widget is None:\n                            self.colorbar_widget = widgets.Output(\n                                layout=widgets.Layout(height=\"60px\")\n                            )\n\n                        if self.colorbar_ctrl is None:\n                            self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                                widget=self.colorbar_widget, position=\"bottomright\"\n                            )\n                            self.add_control(self.colorbar_ctrl)\n\n                        colorbar_output = self.colorbar_widget\n                        with colorbar_output:\n                            colorbar_output.clear_output()\n                            plt.show()\n\n                        if len(palette.value) &gt; 0 and \",\" in palette.value:\n                            labels = [\n                                f\"Class {i+1}\"\n                                for i in range(len(palette.value.split(\",\")))\n                            ]\n                            legend_labels.value = \", \".join(labels)\n\n            classes.observe(classes_changed, \"value\")\n\n            palette = widgets.Text(\n                value=\", \".join(layer_palette),\n                placeholder=\"List of hex color code (RRGGBB)\",\n                description=\"Palette:\",\n                tooltip=\"Enter a list of hex color code (RRGGBB)\",\n                layout=widgets.Layout(width=\"300px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            def add_color_clicked(b):\n                if color_picker.value is not None:\n                    if len(palette.value) == 0:\n                        palette.value = color_picker.value[1:]\n                    else:\n                        palette.value += \", \" + color_picker.value[1:]\n\n            def del_color_clicked(b):\n                if \",\" in palette.value:\n                    items = [item.strip() for item in palette.value.split(\",\")]\n                    palette.value = \", \".join(items[:-1])\n                else:\n                    palette.value = \"\"\n\n            def reset_color_clicked(b):\n                palette.value = \"\"\n\n            add_color.on_click(add_color_clicked)\n            del_color.on_click(del_color_clicked)\n            reset_color.on_click(reset_color_clicked)\n\n            spacer = widgets.Label(layout=widgets.Layout(width=\"5px\"))\n            v_spacer = widgets.Label(layout=widgets.Layout(height=\"5px\"))\n            radio_btn = widgets.HBox([radio1, spacer, spacer, spacer, radio2])\n\n            value_range = widgets.FloatRangeSlider(\n                value=[min_value, max_value],\n                min=left_value,\n                max=right_value,\n                step=0.1,\n                description=\"Range:\",\n                disabled=False,\n                continuous_update=False,\n                readout=True,\n                readout_format=\".1f\",\n                layout=widgets.Layout(width=\"300px\"),\n                style={\"description_width\": \"45px\"},\n            )\n\n            range_hbox = widgets.HBox([value_range, spacer])\n\n            opacity = widgets.FloatSlider(\n                value=layer_opacity,\n                min=0,\n                max=1,\n                step=0.01,\n                description=\"Opacity:\",\n                continuous_update=False,\n                readout=True,\n                readout_format=\".2f\",\n                layout=widgets.Layout(width=\"320px\"),\n                style={\"description_width\": \"50px\"},\n            )\n\n            gamma = widgets.FloatSlider(\n                value=layer_gamma,\n                min=0.1,\n                max=10,\n                step=0.01,\n                description=\"Gamma:\",\n                continuous_update=False,\n                readout=True,\n                readout_format=\".2f\",\n                layout=widgets.Layout(width=\"320px\"),\n                style={\"description_width\": \"50px\"},\n            )\n\n            legend_chk = widgets.Checkbox(\n                value=False,\n                description=\"Legend\",\n                indent=False,\n                layout=widgets.Layout(width=\"70px\"),\n            )\n\n            linear_chk = widgets.Checkbox(\n                value=True,\n                description=\"Linear colormap\",\n                indent=False,\n                layout=widgets.Layout(width=\"150px\"),\n            )\n\n            step_chk = widgets.Checkbox(\n                value=False,\n                description=\"Step colormap\",\n                indent=False,\n                layout=widgets.Layout(width=\"140px\"),\n            )\n\n            legend_title = widgets.Text(\n                value=\"Legend\",\n                description=\"Legend title:\",\n                tooltip=\"Enter a title for the legend\",\n                layout=widgets.Layout(width=\"300px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            legend_labels = widgets.Text(\n                value=\"Class 1, Class 2, Class 3\",\n                description=\"Legend labels:\",\n                tooltip=\"Enter a a list of labels for the legend\",\n                layout=widgets.Layout(width=\"300px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            colormap_hbox = widgets.HBox([linear_chk, step_chk])\n            legend_vbox = widgets.VBox()\n\n            def linear_chk_changed(change):\n                if change[\"new\"]:\n                    step_chk.value = False\n                    legend_vbox.children = [colormap_hbox]\n                else:\n                    step_chk.value = True\n\n            def step_chk_changed(change):\n                if change[\"new\"]:\n                    linear_chk.value = False\n                    if len(layer_palette) &gt; 0:\n                        legend_labels.value = \",\".join(\n                            [\n                                \"Class \" + str(i)\n                                for i in range(1, len(layer_palette) + 1)\n                            ]\n                        )\n                    legend_vbox.children = [\n                        colormap_hbox,\n                        legend_title,\n                        legend_labels,\n                    ]\n                else:\n                    linear_chk.value = True\n\n            linear_chk.observe(linear_chk_changed, \"value\")\n            step_chk.observe(step_chk_changed, \"value\")\n\n            def colormap_changed(change):\n                if change[\"new\"]:\n                    n_class = None\n                    if classes.value != \"Any\":\n                        n_class = int(classes.value)\n\n                    colors = plt.cm.get_cmap(colormap.value, n_class)\n                    cmap_colors = [\n                        mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n                    ]\n\n                    _, ax = plt.subplots(figsize=(6, 0.4))\n                    cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                        \"custom\", to_hex_colors(cmap_colors), N=256\n                    )\n                    norm = mpl.colors.Normalize(\n                        vmin=value_range.value[0], vmax=value_range.value[1]\n                    )\n                    mpl.colorbar.ColorbarBase(\n                        ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                    )\n\n                    palette.value = \", \".join(cmap_colors)\n\n                    if self.colorbar_widget is None:\n                        self.colorbar_widget = widgets.Output(\n                            layout=widgets.Layout(height=\"60px\")\n                        )\n\n                    if self.colorbar_ctrl is None:\n                        self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                            widget=self.colorbar_widget, position=\"bottomright\"\n                        )\n                        self.add_control(self.colorbar_ctrl)\n\n                    colorbar_output = self.colorbar_widget\n                    with colorbar_output:\n                        colorbar_output.clear_output()\n                        plt.show()\n                        # display(colorbar)\n\n                    if len(palette.value) &gt; 0 and \",\" in palette.value:\n                        labels = [\n                            f\"Class {i+1}\" for i in range(len(palette.value.split(\",\")))\n                        ]\n                        legend_labels.value = \", \".join(labels)\n\n            colormap.observe(colormap_changed, \"value\")\n\n            btn_width = \"97.5px\"\n            import_btn = widgets.Button(\n                description=\"Import\",\n                button_style=\"primary\",\n                tooltip=\"Import vis params to notebook\",\n                layout=widgets.Layout(width=btn_width),\n            )\n\n            apply_btn = widgets.Button(\n                description=\"Apply\",\n                tooltip=\"Apply vis params to the layer\",\n                layout=widgets.Layout(width=btn_width),\n            )\n\n            close_btn = widgets.Button(\n                description=\"Close\",\n                tooltip=\"Close vis params diaglog\",\n                layout=widgets.Layout(width=btn_width),\n            )\n\n            def import_btn_clicked(b):\n                vis = {}\n                if radio1.index == 0:\n                    vis[\"bands\"] = [band1_dropdown.value]\n                    if len(palette.value) &gt; 0:\n                        vis[\"palette\"] = palette.value.split(\",\")\n                else:\n                    vis[\"bands\"] = [\n                        band1_dropdown.value,\n                        band2_dropdown.value,\n                        band3_dropdown.value,\n                    ]\n\n                vis[\"min\"] = value_range.value[0]\n                vis[\"max\"] = value_range.value[1]\n                vis[\"opacity\"] = opacity.value\n                vis[\"gamma\"] = gamma.value\n\n                create_code_cell(f\"vis_params = {str(vis)}\")\n\n            def apply_btn_clicked(b):\n                vis = {}\n                if radio1.index == 0:\n                    vis[\"bands\"] = [band1_dropdown.value]\n                    if len(palette.value) &gt; 0:\n                        vis[\"palette\"] = [c.strip() for c in palette.value.split(\",\")]\n                else:\n                    vis[\"bands\"] = [\n                        band1_dropdown.value,\n                        band2_dropdown.value,\n                        band3_dropdown.value,\n                    ]\n                    vis[\"gamma\"] = gamma.value\n\n                vis[\"min\"] = value_range.value[0]\n                vis[\"max\"] = value_range.value[1]\n\n                self.addLayer(ee_object, vis, layer_name, True, opacity.value)\n                ee_layer.visible = False\n\n                if legend_chk.value:\n                    if (\n                        self.colorbar_ctrl is not None\n                        and self.colorbar_ctrl in self.controls\n                    ):\n                        self.remove_control(self.colorbar_ctrl)\n                        self.colorbar_ctrl.close()\n                        self.colorbar_widget.close()\n\n                    if (\n                        \"colorbar\" in layer_dict.keys()\n                        and layer_dict[\"colorbar\"] in self.controls\n                    ):\n                        self.remove_control(layer_dict[\"colorbar\"])\n                        layer_dict[\"colorbar\"] = None\n\n                    if linear_chk.value:\n                        if (\n                            \"legend\" in layer_dict.keys()\n                            and layer_dict[\"legend\"] in self.controls\n                        ):\n                            self.remove_control(layer_dict[\"legend\"])\n                            layer_dict[\"legend\"] = None\n\n                        if len(palette.value) &gt; 0 and \",\" in palette.value:\n                            colors = to_hex_colors(\n                                [color.strip() for color in palette.value.split(\",\")]\n                            )\n\n                            self.add_colorbar(\n                                vis_params={\n                                    \"palette\": colors,\n                                    \"min\": value_range.value[0],\n                                    \"max\": value_range.value[1],\n                                },\n                                layer_name=layer_name,\n                            )\n                    elif step_chk.value:\n                        if len(palette.value) &gt; 0 and \",\" in palette.value:\n                            colors = to_hex_colors(\n                                [color.strip() for color in palette.value.split(\",\")]\n                            )\n                            labels = [\n                                label.strip()\n                                for label in legend_labels.value.split(\",\")\n                            ]\n\n                            self.add_legend(\n                                title=legend_title.value,\n                                legend_keys=labels,\n                                legend_colors=colors,\n                                layer_name=layer_name,\n                            )\n                else:\n                    if radio1.index == 0 and \"palette\" in vis:\n                        self.colorbar_widget.clear_output()\n                        with self.colorbar_widget:\n                            _, ax = plt.subplots(figsize=(6, 0.4))\n                            colors = to_hex_colors(vis[\"palette\"])\n                            cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                                \"custom\", colors, N=256\n                            )\n                            norm = mpl.colors.Normalize(\n                                vmin=vis[\"min\"], vmax=vis[\"max\"]\n                            )\n                            mpl.colorbar.ColorbarBase(\n                                ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                            )\n                            plt.show()\n\n                        if (\n                            \"colorbar\" in layer_dict.keys()\n                            and layer_dict[\"colorbar\"] in self.controls\n                        ):\n                            self.remove_control(layer_dict[\"colorbar\"])\n                            layer_dict[\"colorbar\"] = None\n                        if (\n                            \"legend\" in layer_dict.keys()\n                            and layer_dict[\"legend\"] in self.controls\n                        ):\n                            self.remove_control(layer_dict[\"legend\"])\n                            layer_dict[\"legend\"] = None\n\n            def close_btn_clicked(b):\n                if self.vis_control in self.controls:\n                    self.remove_control(self.vis_control)\n                    self.vis_control = None\n                    self.vis_widget.close()\n\n                if (\n                    self.colorbar_ctrl is not None\n                    and self.colorbar_ctrl in self.controls\n                ):\n                    self.remove_control(self.colorbar_ctrl)\n                    self.colorbar_ctrl = None\n                    self.colorbar_widget.close()\n\n            import_btn.on_click(import_btn_clicked)\n            apply_btn.on_click(apply_btn_clicked)\n            close_btn.on_click(close_btn_clicked)\n\n            color_hbox = widgets.HBox(\n                [legend_chk, color_picker, add_color, del_color, reset_color]\n            )\n            btn_hbox = widgets.HBox([import_btn, apply_btn, close_btn])\n\n            gray_box = [\n                label,\n                radio_btn,\n                bands_hbox,\n                v_spacer,\n                range_hbox,\n                opacity,\n                gamma,\n                widgets.HBox([classes, colormap]),\n                palette,\n                color_hbox,\n                legend_vbox,\n                btn_hbox,\n            ]\n\n            rgb_box = [\n                label,\n                radio_btn,\n                bands_hbox,\n                v_spacer,\n                range_hbox,\n                opacity,\n                gamma,\n                btn_hbox,\n            ]\n\n            def legend_chk_changed(change):\n                if change[\"new\"]:\n                    linear_chk.value = True\n                    legend_vbox.children = [\n                        widgets.HBox([linear_chk, step_chk]),\n                        # legend_title,\n                        # legend_labels,\n                    ]\n                else:\n                    legend_vbox.children = []\n\n            legend_chk.observe(legend_chk_changed, \"value\")\n\n            if band_count &lt; 3:\n                radio1.index = 0\n                band1_dropdown.layout.width = \"300px\"\n                bands_hbox.children = [band1_dropdown]\n                vis_widget.children = gray_box\n                legend_chk.value = False\n\n                if len(palette.value) &gt; 0 and \",\" in palette.value:\n                    import matplotlib as mpl\n                    import matplotlib.pyplot as plt\n\n                    colors = to_hex_colors(\n                        [color.strip() for color in palette.value.split(\",\")]\n                    )\n\n                    self.colorbar_widget.clear_output()\n                    with self.colorbar_widget:\n                        _, ax = plt.subplots(figsize=(6, 0.4))\n                        cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                            \"custom\", colors, N=256\n                        )\n                        norm = mpl.colors.Normalize(\n                            vmin=value_range.value[0], vmax=value_range.value[1]\n                        )\n                        mpl.colorbar.ColorbarBase(\n                            ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                        )\n                        plt.show()\n\n            else:\n                radio2.index = 0\n                if (sel_bands is None) or (len(sel_bands) &lt; 2):\n                    sel_bands = band_names[0:3]\n                band1_dropdown.value = sel_bands[0]\n                band2_dropdown.value = sel_bands[1]\n                band3_dropdown.value = sel_bands[2]\n                bands_hbox.children = [\n                    band1_dropdown,\n                    band2_dropdown,\n                    band3_dropdown,\n                ]\n                vis_widget.children = rgb_box\n\n            def radio1_observer(sender):\n                radio2.unobserve(radio2_observer, names=[\"value\"])\n                radio2.index = None\n                radio2.observe(radio2_observer, names=[\"value\"])\n                band1_dropdown.layout.width = \"300px\"\n                bands_hbox.children = [band1_dropdown]\n                palette.value = \", \".join(layer_palette)\n                palette.disabled = False\n                color_picker.disabled = False\n                add_color.disabled = False\n                del_color.disabled = False\n                reset_color.disabled = False\n                vis_widget.children = gray_box\n\n                if len(palette.value) &gt; 0 and \",\" in palette.value:\n                    colors = [color.strip() for color in palette.value.split(\",\")]\n\n                    _, ax = plt.subplots(figsize=(6, 0.4))\n                    cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                        \"custom\", to_hex_colors(colors), N=256\n                    )\n                    norm = mpl.colors.Normalize(vmin=0, vmax=1)\n                    mpl.colorbar.ColorbarBase(\n                        ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                    )\n\n                    self.colorbar_widget = widgets.Output(\n                        layout=widgets.Layout(height=\"60px\")\n                    )\n                    self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                        widget=self.colorbar_widget, position=\"bottomright\"\n                    )\n\n                    if self.colorbar_ctrl not in self.controls:\n                        self.add_control(self.colorbar_ctrl)\n\n                    self.colorbar_widget.clear_output()\n                    with self.colorbar_widget:\n                        plt.show()\n\n            def radio2_observer(sender):\n                radio1.unobserve(radio1_observer, names=[\"value\"])\n                radio1.index = None\n                radio1.observe(radio1_observer, names=[\"value\"])\n                band1_dropdown.layout.width = dropdown_width\n                bands_hbox.children = [\n                    band1_dropdown,\n                    band2_dropdown,\n                    band3_dropdown,\n                ]\n                palette.value = \"\"\n                palette.disabled = True\n                color_picker.disabled = True\n                add_color.disabled = True\n                del_color.disabled = True\n                reset_color.disabled = True\n                vis_widget.children = rgb_box\n\n                if (\n                    self.colorbar_ctrl is not None\n                    and self.colorbar_ctrl in self.controls\n                ):\n                    self.remove_control(self.colorbar_ctrl)\n                    self.colorbar_ctrl.close()\n                    self.colorbar_widget.close()\n\n            radio1.observe(radio1_observer, names=[\"value\"])\n            radio2.observe(radio2_observer, names=[\"value\"])\n\n            return vis_widget\n\n        elif isinstance(ee_object, ee.FeatureCollection):\n            vis_widget = widgets.VBox(\n                layout=widgets.Layout(padding=\"5px 5px 5px 8px\", width=\"330px\")\n            )\n            label = widgets.Label(value=f\"{layer_name} visualization parameters\")\n\n            new_layer_name = widgets.Text(\n                value=f\"{layer_name} style\",\n                description=\"New layer name:\",\n                style={\"description_width\": \"initial\"},\n            )\n\n            color = widgets.ColorPicker(\n                concise=False,\n                value=\"#000000\",\n                description=\"Color:\",\n                layout=widgets.Layout(width=\"140px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            color_opacity = widgets.FloatSlider(\n                value=layer_opacity,\n                min=0,\n                max=1,\n                step=0.01,\n                description=\"Opacity:\",\n                continuous_update=True,\n                readout=False,\n                #             readout_format=\".2f\",\n                layout=widgets.Layout(width=\"130px\"),\n                style={\"description_width\": \"50px\"},\n            )\n\n            color_opacity_label = widgets.Label(\n                style={\"description_width\": \"initial\"},\n                layout=widgets.Layout(padding=\"0px\"),\n            )\n\n            def color_opacity_change(change):\n                color_opacity_label.value = str(change[\"new\"])\n\n            color_opacity.observe(color_opacity_change, names=\"value\")\n\n            # widgets.jslink((color_opacity, \"value\"), (color_opacity_label, \"value\"))\n\n            point_size = widgets.IntText(\n                value=3,\n                description=\"Point size:\",\n                layout=widgets.Layout(width=\"110px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            point_shape_options = [\n                \"circle\",\n                \"square\",\n                \"diamond\",\n                \"cross\",\n                \"plus\",\n                \"pentagram\",\n                \"hexagram\",\n                \"triangle\",\n                \"triangle_up\",\n                \"triangle_down\",\n                \"triangle_left\",\n                \"triangle_right\",\n                \"pentagon\",\n                \"hexagon\",\n                \"star5\",\n                \"star6\",\n            ]\n            point_shape = widgets.Dropdown(\n                options=point_shape_options,\n                value=\"circle\",\n                description=\"Point shape:\",\n                layout=widgets.Layout(width=\"185px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            line_width = widgets.IntText(\n                value=2,\n                description=\"Line width:\",\n                layout=widgets.Layout(width=\"110px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            line_type = widgets.Dropdown(\n                options=[\"solid\", \"dotted\", \"dashed\"],\n                value=\"solid\",\n                description=\"Line type:\",\n                layout=widgets.Layout(width=\"185px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            fill_color = widgets.ColorPicker(\n                concise=False,\n                value=\"#000000\",\n                description=\"Fill Color:\",\n                layout=widgets.Layout(width=\"160px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            fill_color_opacity = widgets.FloatSlider(\n                value=0.66,\n                min=0,\n                max=1,\n                step=0.01,\n                description=\"Opacity:\",\n                continuous_update=True,\n                readout=False,\n                #             readout_format=\".2f\",\n                layout=widgets.Layout(width=\"110px\"),\n                style={\"description_width\": \"50px\"},\n            )\n\n            fill_color_opacity_label = widgets.Label(\n                style={\"description_width\": \"initial\"},\n                layout=widgets.Layout(padding=\"0px\"),\n            )\n\n            def fill_color_opacity_change(change):\n                fill_color_opacity_label.value = str(change[\"new\"])\n\n            fill_color_opacity.observe(fill_color_opacity_change, names=\"value\")\n\n            # widgets.jslink(\n            #     (fill_color_opacity, \"value\"),\n            #     (fill_color_opacity_label, \"value\"),\n            # )\n\n            color_picker = widgets.ColorPicker(\n                concise=False,\n                value=\"#000000\",\n                layout=widgets.Layout(width=\"116px\"),\n                style={\"description_width\": \"initial\"},\n            )\n            add_color = widgets.Button(\n                icon=\"plus\",\n                tooltip=\"Add a hex color string to the palette\",\n                layout=widgets.Layout(width=\"32px\"),\n            )\n            del_color = widgets.Button(\n                icon=\"minus\",\n                tooltip=\"Remove a hex color string from the palette\",\n                layout=widgets.Layout(width=\"32px\"),\n            )\n            reset_color = widgets.Button(\n                icon=\"eraser\",\n                tooltip=\"Remove all color strings from the palette\",\n                layout=widgets.Layout(width=\"34px\"),\n            )\n\n            palette = widgets.Text(\n                value=\"\",\n                placeholder=\"List of hex code (RRGGBB) separated by comma\",\n                description=\"Palette:\",\n                tooltip=\"Enter a list of hex code (RRGGBB) separated by comma\",\n                layout=widgets.Layout(width=\"300px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            legend_title = widgets.Text(\n                value=\"Legend\",\n                description=\"Legend title:\",\n                tooltip=\"Enter a title for the legend\",\n                layout=widgets.Layout(width=\"300px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            legend_labels = widgets.Text(\n                value=\"Labels\",\n                description=\"Legend labels:\",\n                tooltip=\"Enter a a list of labels for the legend\",\n                layout=widgets.Layout(width=\"300px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            def add_color_clicked(b):\n                if color_picker.value is not None:\n                    if len(palette.value) == 0:\n                        palette.value = color_picker.value[1:]\n                    else:\n                        palette.value += \", \" + color_picker.value[1:]\n\n            def del_color_clicked(b):\n                if \",\" in palette.value:\n                    items = [item.strip() for item in palette.value.split(\",\")]\n                    palette.value = \", \".join(items[:-1])\n                else:\n                    palette.value = \"\"\n\n            def reset_color_clicked(b):\n                palette.value = \"\"\n\n            add_color.on_click(add_color_clicked)\n            del_color.on_click(del_color_clicked)\n            reset_color.on_click(reset_color_clicked)\n\n            field = widgets.Dropdown(\n                options=[],\n                value=None,\n                description=\"Field:\",\n                layout=widgets.Layout(width=\"140px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            field_values = widgets.Dropdown(\n                options=[],\n                value=None,\n                description=\"Values:\",\n                layout=widgets.Layout(width=\"156px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            classes = widgets.Dropdown(\n                options=[\"Any\"] + [str(i) for i in range(3, 13)],\n                description=\"Classes:\",\n                layout=widgets.Layout(width=\"115px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            colormap = widgets.Dropdown(\n                options=[\"viridis\"],\n                value=\"viridis\",\n                description=\"Colormap:\",\n                layout=widgets.Layout(width=\"181px\"),\n                style={\"description_width\": \"initial\"},\n            )\n\n            def classes_changed(change):\n                if change[\"new\"]:\n                    selected = change[\"owner\"].value\n                    if colormap.value is not None:\n                        n_class = None\n                        if selected != \"Any\":\n                            n_class = int(classes.value)\n\n                        colors = plt.cm.get_cmap(colormap.value, n_class)\n                        cmap_colors = [\n                            mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n                        ]\n\n                        _, ax = plt.subplots(figsize=(6, 0.4))\n                        cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                            \"custom\", to_hex_colors(cmap_colors), N=256\n                        )\n                        norm = mpl.colors.Normalize(vmin=0, vmax=1)\n                        mpl.colorbar.ColorbarBase(\n                            ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                        )\n\n                        palette.value = \", \".join([color for color in cmap_colors])\n\n                        if self.colorbar_widget is None:\n                            self.colorbar_widget = widgets.Output(\n                                layout=widgets.Layout(height=\"60px\")\n                            )\n\n                        if self.colorbar_ctrl is None:\n                            self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                                widget=self.colorbar_widget, position=\"bottomright\"\n                            )\n                            self.add_control(self.colorbar_ctrl)\n\n                        colorbar_output = self.colorbar_widget\n                        with colorbar_output:\n                            colorbar_output.clear_output()\n                            plt.show()\n\n                        if len(palette.value) &gt; 0 and \",\" in palette.value:\n                            labels = [\n                                f\"Class {i+1}\"\n                                for i in range(len(palette.value.split(\",\")))\n                            ]\n                            legend_labels.value = \", \".join(labels)\n\n            classes.observe(classes_changed, \"value\")\n\n            def colormap_changed(change):\n                if change[\"new\"]:\n                    n_class = None\n                    if classes.value != \"Any\":\n                        n_class = int(classes.value)\n\n                    colors = plt.cm.get_cmap(colormap.value, n_class)\n                    cmap_colors = [\n                        mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n                    ]\n\n                    _, ax = plt.subplots(figsize=(6, 0.4))\n                    cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                        \"custom\", to_hex_colors(cmap_colors), N=256\n                    )\n                    norm = mpl.colors.Normalize(vmin=0, vmax=1)\n                    mpl.colorbar.ColorbarBase(\n                        ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                    )\n\n                    palette.value = \", \".join(cmap_colors)\n\n                    if self.colorbar_widget is None:\n                        self.colorbar_widget = widgets.Output(\n                            layout=widgets.Layout(height=\"60px\")\n                        )\n\n                    if self.colorbar_ctrl is None:\n                        self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                            widget=self.colorbar_widget, position=\"bottomright\"\n                        )\n                        self.add_control(self.colorbar_ctrl)\n\n                    colorbar_output = self.colorbar_widget\n                    with colorbar_output:\n                        colorbar_output.clear_output()\n                        plt.show()\n                        # display(colorbar)\n\n                    if len(palette.value) &gt; 0 and \",\" in palette.value:\n                        labels = [\n                            f\"Class {i+1}\" for i in range(len(palette.value.split(\",\")))\n                        ]\n                        legend_labels.value = \", \".join(labels)\n\n            colormap.observe(colormap_changed, \"value\")\n\n            btn_width = \"97.5px\"\n            import_btn = widgets.Button(\n                description=\"Import\",\n                button_style=\"primary\",\n                tooltip=\"Import vis params to notebook\",\n                layout=widgets.Layout(width=btn_width),\n            )\n\n            apply_btn = widgets.Button(\n                description=\"Apply\",\n                tooltip=\"Apply vis params to the layer\",\n                layout=widgets.Layout(width=btn_width),\n            )\n\n            close_btn = widgets.Button(\n                description=\"Close\",\n                tooltip=\"Close vis params diaglog\",\n                layout=widgets.Layout(width=btn_width),\n            )\n\n            style_chk = widgets.Checkbox(\n                value=False,\n                description=\"Style by attribute\",\n                indent=False,\n                layout=widgets.Layout(width=\"140px\"),\n            )\n\n            legend_chk = widgets.Checkbox(\n                value=False,\n                description=\"Legend\",\n                indent=False,\n                layout=widgets.Layout(width=\"70px\"),\n            )\n            compute_label = widgets.Label(value=\"\")\n\n            style_vbox = widgets.VBox([widgets.HBox([style_chk, compute_label])])\n\n            def style_chk_changed(change):\n                if change[\"new\"]:\n                    if (\n                        self.colorbar_ctrl is not None\n                        and self.colorbar_ctrl in self.controls\n                    ):\n                        self.remove_control(self.colorbar_ctrl)\n                        self.colorbar_ctrl.close()\n                        self.colorbar_widget.close()\n\n                    self.colorbar_widget = widgets.Output(\n                        layout=widgets.Layout(height=\"60px\")\n                    )\n                    self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                        widget=self.colorbar_widget, position=\"bottomright\"\n                    )\n                    self.add_control(self.colorbar_ctrl)\n                    fill_color.disabled = True\n                    colormap_options = plt.colormaps()\n                    colormap_options.sort()\n                    colormap.options = colormap_options\n                    colormap.value = \"viridis\"\n                    style_vbox.children = [\n                        widgets.HBox([style_chk, compute_label]),\n                        widgets.HBox([field, field_values]),\n                        widgets.HBox([classes, colormap]),\n                        palette,\n                        widgets.HBox(\n                            [\n                                legend_chk,\n                                color_picker,\n                                add_color,\n                                del_color,\n                                reset_color,\n                            ]\n                        ),\n                    ]\n                    compute_label.value = \"Computing ...\"\n\n                    field.options = (\n                        ee.Feature(ee_object.first()).propertyNames().getInfo()\n                    )\n                    compute_label.value = \"\"\n                    classes.value = \"Any\"\n                    legend_chk.value = False\n\n                else:\n                    fill_color.disabled = False\n                    style_vbox.children = [widgets.HBox([style_chk, compute_label])]\n                    compute_label.value = \"\"\n                    if (\n                        self.colorbar_ctrl is not None\n                        and self.colorbar_ctrl in self.controls\n                    ):\n                        self.remove_control(self.colorbar_ctrl)\n                        self.colorbar_ctrl = None\n                        self.colorbar_widget = None\n                    # legend_chk.value = False\n\n            style_chk.observe(style_chk_changed, \"value\")\n\n            def legend_chk_changed(change):\n                if change[\"new\"]:\n                    style_vbox.children = list(style_vbox.children) + [\n                        widgets.VBox([legend_title, legend_labels])\n                    ]\n\n                    if len(palette.value) &gt; 0 and \",\" in palette.value:\n                        labels = [\n                            f\"Class {i+1}\" for i in range(len(palette.value.split(\",\")))\n                        ]\n                        legend_labels.value = \", \".join(labels)\n\n                else:\n                    style_vbox.children = [\n                        widgets.HBox([style_chk, compute_label]),\n                        widgets.HBox([field, field_values]),\n                        widgets.HBox([classes, colormap]),\n                        palette,\n                        widgets.HBox(\n                            [\n                                legend_chk,\n                                color_picker,\n                                add_color,\n                                del_color,\n                                reset_color,\n                            ]\n                        ),\n                    ]\n\n            legend_chk.observe(legend_chk_changed, \"value\")\n\n            def field_changed(change):\n                if change[\"new\"]:\n                    compute_label.value = \"Computing ...\"\n                    options = ee_object.aggregate_array(field.value).getInfo()\n                    if options is not None:\n                        options = list(set(options))\n                        options.sort()\n\n                    field_values.options = options\n                    compute_label.value = \"\"\n\n            field.observe(field_changed, \"value\")\n\n            def get_vis_params():\n                vis = {}\n                vis[\"color\"] = color.value[1:] + str(\n                    hex(int(color_opacity.value * 255))\n                )[2:].zfill(2)\n                if geometry_type(ee_object) in [\"Point\", \"MultiPoint\"]:\n                    vis[\"pointSize\"] = point_size.value\n                    vis[\"pointShape\"] = point_shape.value\n                vis[\"width\"] = line_width.value\n                vis[\"lineType\"] = line_type.value\n                vis[\"fillColor\"] = fill_color.value[1:] + str(\n                    hex(int(fill_color_opacity.value * 255))\n                )[2:].zfill(2)\n\n                return vis\n\n            def import_btn_clicked(b):\n                vis = get_vis_params()\n                create_code_cell(f\"vis_params = {str(vis)}\")\n\n            def apply_btn_clicked(b):\n                compute_label.value = \"Computing ...\"\n\n                if new_layer_name.value in self.ee_layer_names:\n                    old_layer = new_layer_name.value\n\n                    if \"legend\" in self.ee_layer_dict[old_layer].keys():\n                        legend = self.ee_layer_dict[old_layer][\"legend\"]\n                        if legend in self.controls:\n                            self.remove_control(legend)\n                        legend.close()\n                    if \"colorbar\" in self.ee_layer_dict[old_layer].keys():\n                        colorbar = self.ee_layer_dict[old_layer][\"colorbar\"]\n                        if colorbar in self.controls:\n                            self.remove_control(colorbar)\n                        colorbar.close()\n\n                if not style_chk.value:\n                    vis = get_vis_params()\n                    self.addLayer(ee_object.style(**vis), {}, new_layer_name.value)\n                    ee_layer.visible = False\n\n                elif (\n                    style_chk.value and len(palette.value) &gt; 0 and \",\" in palette.value\n                ):\n                    try:\n                        colors = ee.List(\n                            [\n                                color.strip()\n                                + str(hex(int(fill_color_opacity.value * 255)))[\n                                    2:\n                                ].zfill(2)\n                                for color in palette.value.split(\",\")\n                            ]\n                        )\n                        arr = ee_object.aggregate_array(field.value).distinct().sort()\n                        fc = ee_object.map(\n                            lambda f: f.set(\n                                {\"styleIndex\": arr.indexOf(f.get(field.value))}\n                            )\n                        )\n                        step = arr.size().divide(colors.size()).ceil()\n                        fc = fc.map(\n                            lambda f: f.set(\n                                {\n                                    \"style\": {\n                                        \"color\": color.value[1:]\n                                        + str(hex(int(color_opacity.value * 255)))[\n                                            2:\n                                        ].zfill(2),\n                                        \"pointSize\": point_size.value,\n                                        \"pointShape\": point_shape.value,\n                                        \"width\": line_width.value,\n                                        \"lineType\": line_type.value,\n                                        \"fillColor\": colors.get(\n                                            ee.Number(\n                                                ee.Number(f.get(\"styleIndex\")).divide(\n                                                    step\n                                                )\n                                            ).floor()\n                                        ),\n                                    }\n                                }\n                            )\n                        )\n\n                        self.addLayer(\n                            fc.style(**{\"styleProperty\": \"style\"}),\n                            {},\n                            f\"{new_layer_name.value}\",\n                        )\n\n                        if (\n                            len(palette.value)\n                            and legend_chk.value\n                            and len(legend_labels.value) &gt; 0\n                        ):\n                            legend_colors = [\n                                color.strip() for color in palette.value.split(\",\")\n                            ]\n                            legend_keys = [\n                                label.strip()\n                                for label in legend_labels.value.split(\",\")\n                            ]\n                            self.add_legend(\n                                title=legend_title.value,\n                                legend_keys=legend_keys,\n                                legend_colors=legend_colors,\n                                layer_name=new_layer_name.value,\n                            )\n                    except Exception as e:\n                        compute_label.value = \"Error: \" + str(e)\n                    ee_layer.visible = False\n                    compute_label.value = \"\"\n\n            def close_btn_clicked(b):\n                self.remove_control(self.vis_control)\n                self.vis_control.close()\n                self.vis_widget.close()\n\n                if (\n                    self.colorbar_ctrl is not None\n                    and self.colorbar_ctrl in self.controls\n                ):\n                    self.remove_control(self.colorbar_ctrl)\n                    self.colorbar_ctrl.close()\n                    self.colorbar_widget.close()\n\n            import_btn.on_click(import_btn_clicked)\n            apply_btn.on_click(apply_btn_clicked)\n            close_btn.on_click(close_btn_clicked)\n\n            vis_widget.children = [\n                label,\n                new_layer_name,\n                widgets.HBox([color, color_opacity, color_opacity_label]),\n                widgets.HBox([point_size, point_shape]),\n                widgets.HBox([line_width, line_type]),\n                widgets.HBox(\n                    [fill_color, fill_color_opacity, fill_color_opacity_label]\n                ),\n                style_vbox,\n                widgets.HBox([import_btn, apply_btn, close_btn]),\n            ]\n\n            if geometry_type(ee_object) in [\"Point\", \"MultiPoint\"]:\n                point_size.disabled = False\n                point_shape.disabled = False\n            else:\n                point_size.disabled = True\n                point_shape.disabled = True\n\n            return vis_widget\n\n    def add_styled_vector(\n        self, ee_object, column, palette, layer_name=\"Untitled\", **kwargs\n    ):\n\"\"\"Adds a styled vector to the map.\n\n        Args:\n            ee_object (object): An ee.FeatureCollection.\n            column (str): The column name to use for styling.\n            palette (list | dict): The palette (e.g., list of colors or a dict containing label and color pairs) to use for styling.\n            layer_name (str, optional): The name to be used for the new layer. Defaults to \"Untitled\".\n        \"\"\"\n        styled_vector = vector_styling(ee_object, column, palette, **kwargs)\n        self.addLayer(styled_vector.style(**{\"styleProperty\": \"style\"}), {}, layer_name)\n\n    def add_shp(\n        self,\n        in_shp,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        encoding=\"utf-8\",\n    ):\n\"\"\"Adds a shapefile to the map.\n\n        Args:\n            in_shp (str): The input file path to the shapefile.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            encoding (str, optional): The encoding of the shapefile. Defaults to \"utf-8\".\n\n        Raises:\n            FileNotFoundError: The provided shapefile could not be found.\n        \"\"\"\n        in_shp = os.path.abspath(in_shp)\n        if not os.path.exists(in_shp):\n            raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n        geojson = shp_to_geojson(in_shp)\n        self.add_geojson(\n            geojson,\n            layer_name,\n            style,\n            hover_style,\n            style_callback,\n            fill_colors,\n            info_mode,\n            encoding,\n        )\n\n    add_shapefile = add_shp\n\n    def add_geojson(\n        self,\n        in_geojson,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        encoding=\"utf-8\",\n    ):\n\"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n\n        Raises:\n            FileNotFoundError: The provided GeoJSON file could not be found.\n        \"\"\"\n        import json\n        import random\n        import requests\n        import warnings\n\n        warnings.filterwarnings(\"ignore\")\n\n        style_callback_only = False\n\n        if len(style) == 0 and style_callback is not None:\n            style_callback_only = True\n\n        try:\n            if isinstance(in_geojson, str):\n                if in_geojson.startswith(\"http\"):\n                    in_geojson = github_raw_url(in_geojson)\n                    data = requests.get(in_geojson).json()\n                else:\n                    in_geojson = os.path.abspath(in_geojson)\n                    if not os.path.exists(in_geojson):\n                        raise FileNotFoundError(\n                            \"The provided GeoJSON file could not be found.\"\n                        )\n\n                    with open(in_geojson, encoding=encoding) as f:\n                        data = json.load(f)\n            elif isinstance(in_geojson, dict):\n                data = in_geojson\n            else:\n                raise TypeError(\"The input geojson must be a type of str or dict.\")\n        except Exception as e:\n            raise Exception(e)\n\n        if not style:\n            style = {\n                # \"stroke\": True,\n                \"color\": \"#000000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 0.1,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n            }\n        elif \"weight\" not in style:\n            style[\"weight\"] = 1\n\n        if not hover_style:\n            hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n\n        def random_color(feature):\n            return {\n                \"color\": \"black\",\n                \"fillColor\": random.choice(fill_colors),\n            }\n\n        toolbar_button = widgets.ToggleButton(\n            value=True,\n            tooltip=\"Toolbar\",\n            icon=\"info\",\n            layout=widgets.Layout(\n                width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"\n            ),\n        )\n\n        close_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Close the tool\",\n            icon=\"times\",\n            # button_style=\"primary\",\n            layout=widgets.Layout(\n                height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n            ),\n        )\n\n        html = widgets.HTML()\n        html.layout.margin = \"0px 10px 0px 10px\"\n        html.layout.max_height = \"250px\"\n        html.layout.max_width = \"250px\"\n\n        output_widget = widgets.VBox(\n            [widgets.HBox([toolbar_button, close_button]), html]\n        )\n        info_control = ipyleaflet.WidgetControl(\n            widget=output_widget, position=\"bottomright\"\n        )\n\n        if info_mode in [\"on_hover\", \"on_click\"]:\n            self.add_control(info_control)\n\n        def toolbar_btn_click(change):\n            if change[\"new\"]:\n                close_button.value = False\n                output_widget.children = [\n                    widgets.VBox([widgets.HBox([toolbar_button, close_button]), html])\n                ]\n            else:\n                output_widget.children = [widgets.HBox([toolbar_button, close_button])]\n\n        toolbar_button.observe(toolbar_btn_click, \"value\")\n\n        def close_btn_click(change):\n            if change[\"new\"]:\n                toolbar_button.value = False\n                if info_control in self.controls:\n                    self.remove_control(info_control)\n                output_widget.close()\n\n        close_button.observe(close_btn_click, \"value\")\n\n        def update_html(feature, **kwargs):\n            value = [\n                \"&lt;b&gt;{}: &lt;/b&gt;{}&lt;br&gt;\".format(prop, feature[\"properties\"][prop])\n                for prop in feature[\"properties\"].keys()\n            ][:-1]\n\n            value = \"\"\"{}\"\"\".format(\"\".join(value))\n            html.value = value\n\n        if style_callback is None:\n            style_callback = random_color\n\n        if style_callback_only:\n            geojson = ipyleaflet.GeoJSON(\n                data=data,\n                hover_style=hover_style,\n                style_callback=style_callback,\n                name=layer_name,\n            )\n        else:\n            geojson = ipyleaflet.GeoJSON(\n                data=data,\n                style=style,\n                hover_style=hover_style,\n                style_callback=style_callback,\n                name=layer_name,\n            )\n\n        if info_mode == \"on_hover\":\n            geojson.on_hover(update_html)\n        elif info_mode == \"on_click\":\n            geojson.on_click(update_html)\n\n        self.add_layer(geojson)\n        self.geojson_layers.append(geojson)\n\n        if not hasattr(self, \"json_layer_dict\"):\n            self.json_layer_dict = {}\n\n        params = {\n            \"data\": geojson,\n            \"style\": style,\n            \"hover_style\": hover_style,\n            \"style_callback\": style_callback,\n        }\n        self.json_layer_dict[layer_name] = params\n\n    def add_kml(\n        self,\n        in_kml,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            in_kml (str): The input file path to the KML.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        Raises:\n            FileNotFoundError: The provided KML file could not be found.\n        \"\"\"\n\n        if isinstance(in_kml, str) and in_kml.startswith(\"http\"):\n            in_kml = github_raw_url(in_kml)\n            in_kml = download_file(in_kml)\n\n        in_kml = os.path.abspath(in_kml)\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The provided KML file could not be found.\")\n        self.add_vector(\n            in_kml,\n            layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n\n    def add_vector(\n        self,\n        filename,\n        layer_name=\"Untitled\",\n        to_ee=False,\n        bbox=None,\n        mask=None,\n        rows=None,\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        encoding=\"utf-8\",\n        **kwargs,\n    ):\n\"\"\"Adds any geopandas-supported vector dataset to the map.\n\n        Args:\n            filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n            layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n            to_ee (bool, optional): Whether to convert the GeoJSON to ee.FeatureCollection. Defaults to False.\n            bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n            mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n            rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            encoding (str, optional): The encoding to use to read the file. Defaults to \"utf-8\".\n\n        \"\"\"\n        if not filename.startswith(\"http\"):\n            filename = os.path.abspath(filename)\n        else:\n            filename = github_raw_url(filename)\n        if to_ee:\n            fc = vector_to_ee(\n                filename,\n                bbox=bbox,\n                mask=mask,\n                rows=rows,\n                geodesic=True,\n                **kwargs,\n            )\n\n            self.addLayer(fc, {}, layer_name)\n        else:\n            ext = os.path.splitext(filename)[1].lower()\n            if ext == \".shp\":\n                self.add_shapefile(\n                    filename,\n                    layer_name,\n                    style,\n                    hover_style,\n                    style_callback,\n                    fill_colors,\n                    info_mode,\n                    encoding,\n                )\n            elif ext in [\".json\", \".geojson\"]:\n                self.add_geojson(\n                    filename,\n                    layer_name,\n                    style,\n                    hover_style,\n                    style_callback,\n                    fill_colors,\n                    info_mode,\n                    encoding,\n                )\n            else:\n                geojson = vector_to_geojson(\n                    filename,\n                    bbox=bbox,\n                    mask=mask,\n                    rows=rows,\n                    epsg=\"4326\",\n                    **kwargs,\n                )\n\n                self.add_geojson(\n                    geojson,\n                    layer_name,\n                    style,\n                    hover_style,\n                    style_callback,\n                    fill_colors,\n                    info_mode,\n                    encoding,\n                )\n\n    def add_osm(\n        self,\n        query,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        which_result=None,\n        by_osmid=False,\n        buffer_dist=None,\n        to_ee=False,\n        geodesic=True,\n    ):\n\"\"\"Adds OSM data to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            to_ee (bool, optional): Whether to convert the csv to an ee.FeatureCollection.\n            geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.\n\n        \"\"\"\n\n        gdf = osm_to_gdf(\n            query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n        )\n        geojson = gdf.__geo_interface__\n\n        if to_ee:\n            fc = geojson_to_ee(geojson, geodesic=geodesic)\n            self.addLayer(fc, {}, layer_name)\n            self.zoomToObject(fc)\n        else:\n            self.add_geojson(\n                geojson,\n                layer_name=layer_name,\n                style=style,\n                hover_style=hover_style,\n                style_callback=style_callback,\n                fill_colors=fill_colors,\n                info_mode=info_mode,\n            )\n            bounds = gdf.bounds.iloc[0]\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_osm_from_geocode(\n        self,\n        query,\n        which_result=None,\n        by_osmid=False,\n        buffer_dist=None,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM data of place(s) by name or ID to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n\n        gdf = osm_gdf_from_geocode(\n            query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n        )\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_address(\n        self,\n        address,\n        tags,\n        dist=1000,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within some distance N, S, E, W of address to the map.\n\n        Args:\n            address (str): The address to geocode and use as the central point around which to get the geometries.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            dist (int, optional): Distance in meters. Defaults to 1000.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_address(address, tags, dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_place(\n        self,\n        query,\n        tags,\n        which_result=None,\n        buffer_dist=None,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within boundaries of geocodable place(s) to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_point(\n        self,\n        center_point,\n        tags,\n        dist=1000,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within some distance N, S, E, W of a point to the map.\n\n        Args:\n            center_point (tuple): The (lat, lng) center point around which to get the geometries.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            dist (int, optional): Distance in meters. Defaults to 1000.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_point(center_point, tags, dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_polygon(\n        self,\n        polygon,\n        tags,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within boundaries of a (multi)polygon to the map.\n\n        Args:\n            polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_polygon(polygon, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_bbox(\n        self,\n        north,\n        south,\n        east,\n        west,\n        tags,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within a N, S, E, W bounding box to the map.\n\n\n        Args:\n            north (float): Northern latitude of bounding box.\n            south (float): Southern latitude of bounding box.\n            east (float): Eastern longitude of bounding box.\n            west (float): Western longitude of bounding box.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_view(\n        self,\n        tags,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n\"\"\"Adds OSM entities within the current map view to the map.\n\n        Args:\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        bounds = self.bounds\n        if len(bounds) == 0:\n            bounds = (\n                (40.74824858675827, -73.98933637940563),\n                (40.75068694343106, -73.98364473187601),\n            )\n        north, south, east, west = (\n            bounds[1][0],\n            bounds[0][0],\n            bounds[1][1],\n            bounds[0][1],\n        )\n\n        gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_gdf(\n        self,\n        gdf,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        zoom_to_layer=True,\n        encoding=\"utf-8\",\n    ):\n\"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer.\n            encoding (str, optional): The encoding of the GeoDataFrame. Defaults to \"utf-8\".\n        \"\"\"\n\n        data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n        self.add_geojson(\n            data,\n            layer_name,\n            style,\n            hover_style,\n            style_callback,\n            fill_colors,\n            info_mode,\n            encoding,\n        )\n\n        if zoom_to_layer:\n            import numpy as np\n\n            bounds = gdf.to_crs(epsg=\"4326\").bounds\n            west = np.min(bounds[\"minx\"])\n            south = np.min(bounds[\"miny\"])\n            east = np.max(bounds[\"maxx\"])\n            north = np.max(bounds[\"maxy\"])\n            self.fit_bounds([[south, east], [north, west]])\n\n    def add_gdf_from_postgis(\n        self,\n        sql,\n        con,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        zoom_to_layer=True,\n        **kwargs,\n    ):\n\"\"\"Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.\n\n        Args:\n            sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n            con (sqlalchemy.engine.Engine): Active connection to the database to query.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer.\n        \"\"\"\n        gdf = read_postgis(sql, con, **kwargs)\n        gdf = gdf.to_crs(\"epsg:4326\")\n        self.add_gdf(\n            gdf,\n            layer_name,\n            style,\n            hover_style,\n            style_callback,\n            fill_colors,\n            info_mode,\n            zoom_to_layer,\n        )\n\n    def add_time_slider(\n        self,\n        ee_object,\n        vis_params={},\n        region=None,\n        layer_name=\"Time series\",\n        labels=None,\n        time_interval=1,\n        position=\"bottomright\",\n        slider_length=\"150px\",\n        date_format=\"YYYY-MM-dd\",\n        opacity=1.0,\n        **kwargs,\n    ):\n\"\"\"Adds a time slider to the map.\n\n        Args:\n            ee_object (ee.Image | ee.ImageCollection): The Image or ImageCollection to visualize.\n            vis_params (dict, optional): Visualization parameters to use for visualizing image. Defaults to {}.\n            region (ee.Geometry | ee.FeatureCollection): The region to visualize.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Time series\".\n            labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n            time_interval (int, optional): Time interval in seconds. Defaults to 1.\n            position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n            slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n            date_format (str, optional): The date format to use. Defaults to 'YYYY-MM-dd'.\n            opacity (float, optional): The opacity of layers. Defaults to 1.0.\n\n        Raises:\n            TypeError: If the ee_object is not ee.Image | ee.ImageCollection.\n        \"\"\"\n        import threading\n\n        if isinstance(ee_object, ee.Image):\n            if region is not None:\n                if isinstance(region, ee.Geometry):\n                    ee_object = ee_object.clip(region)\n                elif isinstance(region, ee.FeatureCollection):\n                    ee_object = ee_object.clipToCollection(region)\n            if layer_name not in self.ee_raster_layer_names:\n                self.addLayer(ee_object, {}, layer_name, False, opacity)\n            band_names = ee_object.bandNames()\n            ee_object = ee.ImageCollection(\n                ee_object.bandNames().map(lambda b: ee_object.select([b]))\n            )\n\n            if labels is not None:\n                if len(labels) != int(ee_object.size().getInfo()):\n                    raise ValueError(\n                        \"The length of labels must be equal to the number of bands in the image.\"\n                    )\n            else:\n                labels = band_names.getInfo()\n\n        elif isinstance(ee_object, ee.ImageCollection):\n            if region is not None:\n                if isinstance(region, ee.Geometry):\n                    ee_object = ee_object.map(lambda img: img.clip(region))\n                elif isinstance(region, ee.FeatureCollection):\n                    ee_object = ee_object.map(lambda img: img.clipToCollection(region))\n\n            if labels is not None:\n                if len(labels) != int(ee_object.size().getInfo()):\n                    raise ValueError(\n                        \"The length of labels must be equal to the number of images in the ImageCollection.\"\n                    )\n            else:\n                labels = (\n                    ee_object.aggregate_array(\"system:time_start\")\n                    .map(lambda d: ee.Date(d).format(date_format))\n                    .getInfo()\n                )\n        else:\n            raise TypeError(\"The ee_object must be an ee.Image or ee.ImageCollection\")\n\n        # if labels is not None:\n        #     size = len(labels)\n        # else:\n        #     size = ee_object.size().getInfo()\n        #     labels = [str(i) for i in range(1, size + 1)]\n\n        first = ee.Image(ee_object.first())\n\n        if layer_name not in self.ee_raster_layer_names:\n            self.addLayer(ee_object.toBands(), {}, layer_name, False, opacity)\n        self.addLayer(first, vis_params, \"Image X\", True, opacity)\n\n        slider = widgets.IntSlider(\n            min=1,\n            max=len(labels),\n            readout=False,\n            continuous_update=False,\n            layout=widgets.Layout(width=slider_length),\n        )\n        label = widgets.Label(\n            value=labels[0], layout=widgets.Layout(padding=\"0px 5px 0px 5px\")\n        )\n\n        play_btn = widgets.Button(\n            icon=\"play\",\n            tooltip=\"Play the time slider\",\n            button_style=\"primary\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n\n        pause_btn = widgets.Button(\n            icon=\"pause\",\n            tooltip=\"Pause the time slider\",\n            button_style=\"primary\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n\n        close_btn = widgets.Button(\n            icon=\"times\",\n            tooltip=\"Close the time slider\",\n            button_style=\"primary\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n\n        play_chk = widgets.Checkbox(value=False)\n\n        slider_widget = widgets.HBox([slider, label, play_btn, pause_btn, close_btn])\n\n        def play_click(b):\n            play_chk.value = True\n\n            def work(slider):\n                while play_chk.value:\n                    if slider.value &lt; len(labels):\n                        slider.value += 1\n                    else:\n                        slider.value = 1\n                    time.sleep(time_interval)\n\n            thread = threading.Thread(target=work, args=(slider,))\n            thread.start()\n\n        def pause_click(b):\n            play_chk.value = False\n\n        play_btn.on_click(play_click)\n        pause_btn.on_click(pause_click)\n\n        def slider_changed(change):\n            self.default_style = {\"cursor\": \"wait\"}\n            index = slider.value - 1\n            label.value = labels[index]\n            image = ee.Image(ee_object.toList(ee_object.size()).get(index))\n            if layer_name not in self.ee_raster_layer_names:\n                self.addLayer(ee_object.toBands(), {}, layer_name, False, opacity)\n            self.addLayer(image, vis_params, \"Image X\", True, opacity)\n            self.default_style = {\"cursor\": \"default\"}\n\n        slider.observe(slider_changed, \"value\")\n\n        def close_click(b):\n            play_chk.value = False\n            self.toolbar_reset()\n            self.remove_ee_layer(\"Image X\")\n            self.remove_ee_layer(layer_name)\n\n            if self.slider_ctrl is not None and self.slider_ctrl in self.controls:\n                self.remove_control(self.slider_ctrl)\n            slider_widget.close()\n\n        close_btn.on_click(close_click)\n\n        slider_ctrl = ipyleaflet.WidgetControl(widget=slider_widget, position=position)\n        self.add_control(slider_ctrl)\n        self.slider_ctrl = slider_ctrl\n\n    def add_xy_data(\n        self,\n        in_csv,\n        x=\"longitude\",\n        y=\"latitude\",\n        label=None,\n        layer_name=\"Marker cluster\",\n        to_ee=False,\n    ):\n\"\"\"Adds points from a CSV file containing lat/lon information and display data on the map.\n\n        Args:\n            in_csv (str): The file path to the input CSV file.\n            x (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n            y (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n            label (str, optional): The name of the column containing label information to used for marker popup. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to \"Marker cluster\".\n            to_ee (bool, optional): Whether to convert the csv to an ee.FeatureCollection.\n\n        Raises:\n            FileNotFoundError: The specified input csv does not exist.\n            ValueError: The specified x column does not exist.\n            ValueError: The specified y column does not exist.\n            ValueError: The specified label column does not exist.\n        \"\"\"\n        import pandas as pd\n\n        if not in_csv.startswith(\"http\") and (not os.path.exists(in_csv)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n\n        df = pd.read_csv(in_csv)\n        col_names = df.columns.values.tolist()\n\n        if x not in col_names:\n            raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n        if y not in col_names:\n            raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n        if label is not None and (label not in col_names):\n            raise ValueError(\n                f\"label must be one of the following: {', '.join(col_names)}\"\n            )\n\n        self.default_style = {\"cursor\": \"wait\"}\n\n        if to_ee:\n            fc = csv_to_ee(in_csv, latitude=y, longitude=x)\n            self.addLayer(fc, {}, layer_name)\n\n        else:\n            points = list(zip(df[y], df[x]))\n\n            if label is not None:\n                labels = df[label]\n                markers = [\n                    ipyleaflet.Marker(\n                        location=point,\n                        draggable=False,\n                        popup=widgets.HTML(str(labels[index])),\n                    )\n                    for index, point in enumerate(points)\n                ]\n            else:\n                markers = [\n                    ipyleaflet.Marker(location=point, draggable=False)\n                    for point in points\n                ]\n\n            marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n            self.add_layer(marker_cluster)\n\n        self.default_style = {\"cursor\": \"default\"}\n\n    def add_points_from_xy(\n        self,\n        data,\n        x=\"longitude\",\n        y=\"latitude\",\n        popup=None,\n        layer_name=\"Marker Cluster\",\n        color_column=None,\n        marker_colors=None,\n        icon_colors=[\"white\"],\n        icon_names=[\"info\"],\n        spin=False,\n        add_legend=True,\n        **kwargs,\n    ):\n\"\"\"Adds a marker cluster to the map.\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"longitude\".\n            y (str, optional): The column name for the y values. Defaults to \"latitude\".\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n            layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n            color_column (str, optional): The column name for the color values. Defaults to None.\n            marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n            icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n            icon_names (list, optional): A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons. Defaults to ['info'].\n            spin (bool, optional): If True, the icon will spin. Defaults to False.\n            add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n\n        \"\"\"\n        import pandas as pd\n\n        data = github_raw_url(data)\n\n        color_options = [\n            \"red\",\n            \"blue\",\n            \"green\",\n            \"purple\",\n            \"orange\",\n            \"darkred\",\n            \"lightred\",\n            \"beige\",\n            \"darkblue\",\n            \"darkgreen\",\n            \"cadetblue\",\n            \"darkpurple\",\n            \"white\",\n            \"pink\",\n            \"lightblue\",\n            \"lightgreen\",\n            \"gray\",\n            \"black\",\n            \"lightgray\",\n        ]\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data)\n\n        df = points_from_xy(df, x, y)\n\n        col_names = df.columns.values.tolist()\n\n        if color_column is not None and color_column not in col_names:\n            raise ValueError(\n                f\"The color column {color_column} does not exist in the dataframe.\"\n            )\n\n        if color_column is not None:\n            items = list(set(df[color_column]))\n\n        else:\n            items = None\n\n        if color_column is not None and marker_colors is None:\n            if len(items) &gt; len(color_options):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n                )\n            else:\n                marker_colors = color_options[: len(items)]\n        elif color_column is not None and marker_colors is not None:\n            if len(items) != len(marker_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if items is not None:\n            if len(icon_colors) == 1:\n                icon_colors = icon_colors * len(items)\n            elif len(items) != len(icon_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n            if len(icon_names) == 1:\n                icon_names = icon_names * len(items)\n            elif len(items) != len(icon_names):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if \"geometry\" in col_names:\n            col_names.remove(\"geometry\")\n\n        if popup is not None:\n            if isinstance(popup, str) and (popup not in col_names):\n                raise ValueError(\n                    f\"popup must be one of the following: {', '.join(col_names)}\"\n                )\n            elif isinstance(popup, list) and (\n                not all(item in col_names for item in popup)\n            ):\n                raise ValueError(\n                    f\"All popup items must be select from: {', '.join(col_names)}\"\n                )\n        else:\n            popup = col_names\n\n        df[\"x\"] = df.geometry.x\n        df[\"y\"] = df.geometry.y\n\n        points = list(zip(df[\"y\"], df[\"x\"]))\n\n        if popup is not None:\n            if isinstance(popup, str):\n                labels = df[popup]\n\n                markers = []\n                for index, point in enumerate(points):\n                    if items is not None:\n                        marker_color = marker_colors[\n                            items.index(df[color_column][index])\n                        ]\n                        icon_name = icon_names[items.index(df[color_column][index])]\n                        icon_color = icon_colors[items.index(df[color_column][index])]\n                        marker_icon = ipyleaflet.AwesomeIcon(\n                            name=icon_name,\n                            marker_color=marker_color,\n                            icon_color=icon_color,\n                            spin=spin,\n                        )\n                    else:\n                        marker_icon = None\n\n                    marker = ipyleaflet.Marker(\n                        location=point,\n                        draggable=False,\n                        popup=widgets.HTML(str(labels[index])),\n                        icon=marker_icon,\n                    )\n                    markers.append(marker)\n\n            elif isinstance(popup, list):\n                labels = []\n                for i in range(len(points)):\n                    label = \"\"\n                    for item in popup:\n                        label = (\n                            label\n                            + \"&lt;b&gt;\"\n                            + str(item)\n                            + \"&lt;/b&gt;\"\n                            + \": \"\n                            + str(df[item][i])\n                            + \"&lt;br&gt;\"\n                        )\n                    labels.append(label)\n                df[\"popup\"] = labels\n\n                markers = []\n                for index, point in enumerate(points):\n                    if items is not None:\n                        marker_color = marker_colors[\n                            items.index(df[color_column][index])\n                        ]\n                        icon_name = icon_names[items.index(df[color_column][index])]\n                        icon_color = icon_colors[items.index(df[color_column][index])]\n                        marker_icon = ipyleaflet.AwesomeIcon(\n                            name=icon_name,\n                            marker_color=marker_color,\n                            icon_color=icon_color,\n                            spin=spin,\n                        )\n                    else:\n                        marker_icon = None\n\n                    marker = ipyleaflet.Marker(\n                        location=point,\n                        draggable=False,\n                        popup=widgets.HTML(labels[index]),\n                        icon=marker_icon,\n                    )\n                    markers.append(marker)\n\n        else:\n            markers = []\n            for point in points:\n                if items is not None:\n                    marker_color = marker_colors[items.index(df[color_column][index])]\n                    icon_name = icon_names[items.index(df[color_column][index])]\n                    icon_color = icon_colors[items.index(df[color_column][index])]\n                    marker_icon = ipyleaflet.AwesomeIcon(\n                        name=icon_name,\n                        marker_color=marker_color,\n                        icon_color=icon_color,\n                        spin=spin,\n                    )\n                else:\n                    marker_icon = None\n\n                marker = ipyleaflet.Marker(\n                    location=point, draggable=False, icon=marker_icon\n                )\n                markers.append(marker)\n\n        marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n        self.add_layer(marker_cluster)\n\n        if items is not None and add_legend:\n            marker_colors = [check_color(c) for c in marker_colors]\n            self.add_legend(\n                title=color_column.title(), colors=marker_colors, labels=items\n            )\n\n        self.default_style = {\"cursor\": \"default\"}\n\n    def add_circle_markers_from_xy(\n        self,\n        data,\n        x=\"longitude\",\n        y=\"latitude\",\n        radius=10,\n        popup=None,\n        **kwargs,\n    ):\n\"\"\"Adds a marker cluster to the map. For a list of options, see https://ipyleaflet.readthedocs.io/en/latest/api_reference/circle_marker.html\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"longitude\".\n            y (str, optional): The column name for the y values. Defaults to \"latitude\".\n            radius (int, optional): The radius of the circle. Defaults to 10.\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n\n        \"\"\"\n        import pandas as pd\n\n        data = github_raw_url(data)\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data)\n\n        col_names = df.columns.values.tolist()\n\n        if popup is None:\n            popup = col_names\n\n        if not isinstance(popup, list):\n            popup = [popup]\n\n        if x not in col_names:\n            raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n        if y not in col_names:\n            raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n        for row in df.itertuples():\n            html = \"\"\n            for p in popup:\n                html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(getattr(row, p)) + \"&lt;br&gt;\"\n            popup_html = widgets.HTML(html)\n\n            marker = ipyleaflet.CircleMarker(\n                location=[getattr(row, y), getattr(row, x)],\n                radius=radius,\n                popup=popup_html,\n                **kwargs,\n            )\n            super().add_layer(marker)\n\n    def add_planet_by_month(\n        self, year=2016, month=1, name=None, api_key=None, token_name=\"PLANET_API_KEY\"\n    ):\n\"\"\"Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n            name (str, optional): The layer name to use. Defaults to None.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        \"\"\"\n        layer = planet_tile_by_month(year, month, name, api_key, token_name)\n        self.add_layer(layer)\n\n    def add_planet_by_quarter(\n        self, year=2016, quarter=1, name=None, api_key=None, token_name=\"PLANET_API_KEY\"\n    ):\n\"\"\"Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            quarter (int, optional): The quarter of Planet global mosaic, must be 1-12. Defaults to 1.\n            name (str, optional): The layer name to use. Defaults to None.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        \"\"\"\n        layer = planet_tile_by_quarter(year, quarter, name, api_key, token_name)\n        self.add_layer(layer)\n\n    def to_streamlit(self, width=None, height=600, scrolling=False, **kwargs):\n\"\"\"Renders map figure in a Streamlit app.\n\n        Args:\n            width (int, optional): Width of the map. Defaults to None.\n            height (int, optional): Height of the map. Defaults to 600.\n            responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n            scrolling (bool, optional): If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.\n\n        Returns:\n            streamlit.components: components.html object.\n        \"\"\"\n\n        try:\n            import streamlit.components.v1 as components\n\n            # if responsive:\n            #     make_map_responsive = \"\"\"\n            #     &lt;style&gt;\n            #     [title~=\"st.iframe\"] { width: 100%}\n            #     &lt;/style&gt;\n            #     \"\"\"\n            #     st.markdown(make_map_responsive, unsafe_allow_html=True)\n            return components.html(\n                self.to_html(), width=width, height=height, scrolling=scrolling\n            )\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_point_layer(\n        self, filename, popup=None, layer_name=\"Marker Cluster\", **kwargs\n    ):\n\"\"\"Adds a point layer to the map with a popup attribute.\n\n        Args:\n            filename (str): str, http url, path object or file-like object. Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO)\n            popup (str | list, optional): Column name(s) to be used for popup. Defaults to None.\n            layer_name (str, optional): A layer name to use. Defaults to \"Marker Cluster\".\n\n        Raises:\n            ValueError: If the specified column name does not exist.\n            ValueError: If the specified column names do not exist.\n        \"\"\"\n        import warnings\n\n        warnings.filterwarnings(\"ignore\")\n        check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n        import geopandas as gpd\n\n        self.default_style = {\"cursor\": \"wait\"}\n\n        if not filename.startswith(\"http\"):\n            filename = os.path.abspath(filename)\n        ext = os.path.splitext(filename)[1].lower()\n        if ext == \".kml\":\n            gpd.io.file.fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n            gdf = gpd.read_file(filename, driver=\"KML\", **kwargs)\n        else:\n            gdf = gpd.read_file(filename, **kwargs)\n        df = gdf.to_crs(epsg=\"4326\")\n        col_names = df.columns.values.tolist()\n        if popup is not None:\n            if isinstance(popup, str) and (popup not in col_names):\n                raise ValueError(\n                    f\"popup must be one of the following: {', '.join(col_names)}\"\n                )\n            elif isinstance(popup, list) and (\n                not all(item in col_names for item in popup)\n            ):\n                raise ValueError(\n                    f\"All popup items must be select from: {', '.join(col_names)}\"\n                )\n\n        df[\"x\"] = df.geometry.x\n        df[\"y\"] = df.geometry.y\n\n        points = list(zip(df[\"y\"], df[\"x\"]))\n\n        if popup is not None:\n            if isinstance(popup, str):\n                labels = df[popup]\n                markers = [\n                    ipyleaflet.Marker(\n                        location=point,\n                        draggable=False,\n                        popup=widgets.HTML(str(labels[index])),\n                    )\n                    for index, point in enumerate(points)\n                ]\n            elif isinstance(popup, list):\n                labels = []\n                for i in range(len(points)):\n                    label = \"\"\n                    for item in popup:\n                        label = label + str(item) + \": \" + str(df[item][i]) + \"&lt;br&gt;\"\n                    labels.append(label)\n                df[\"popup\"] = labels\n\n                markers = [\n                    ipyleaflet.Marker(\n                        location=point,\n                        draggable=False,\n                        popup=widgets.HTML(labels[index]),\n                    )\n                    for index, point in enumerate(points)\n                ]\n\n        else:\n            markers = [\n                ipyleaflet.Marker(location=point, draggable=False) for point in points\n            ]\n\n        marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n        self.add_layer(marker_cluster)\n\n        self.default_style = {\"cursor\": \"default\"}\n\n    def add_census_data(self, wms, layer, census_dict=None, **kwargs):\n\"\"\"Adds a census data layer to the map.\n\n        Args:\n            wms (str): The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html\n            layer (str): The layer name to add to the map.\n            census_dict (dict, optional): A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.\n        \"\"\"\n\n        try:\n            if census_dict is None:\n                census_dict = get_census_dict()\n\n            if wms not in census_dict.keys():\n                raise ValueError(\n                    f\"The provided WMS is invalid. It must be one of {census_dict.keys()}\"\n                )\n\n            layers = census_dict[wms][\"layers\"]\n            if layer not in layers:\n                raise ValueError(\n                    f\"The layer name is not valid. It must be one of {layers}\"\n                )\n\n            url = census_dict[wms][\"url\"]\n            if \"name\" not in kwargs:\n                kwargs[\"name\"] = layer\n            if \"attribution\" not in kwargs:\n                kwargs[\"attribution\"] = \"U.S. Census Bureau\"\n            if \"format\" not in kwargs:\n                kwargs[\"format\"] = \"image/png\"\n            if \"transparent\" not in kwargs:\n                kwargs[\"transparent\"] = True\n\n            self.add_wms_layer(url, layer, **kwargs)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_xyz_service(self, provider, **kwargs):\n\"\"\"Add a XYZ tile layer to the map.\n\n        Args:\n            provider (str): A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,\n\n        Raises:\n            ValueError: The provider is not valid. It must start with xyz or qms.\n        \"\"\"\n        import xyzservices.providers as xyz\n        from xyzservices import TileProvider\n\n        if provider.startswith(\"xyz\"):\n            name = provider[4:]\n            xyz_provider = xyz.flatten()[name]\n            url = xyz_provider.build_url()\n            attribution = xyz_provider.attribution\n            if attribution.strip() == \"\":\n                attribution = \" \"\n            self.add_tile_layer(url, name, attribution)\n        elif provider.startswith(\"qms\"):\n            name = provider[4:]\n            qms_provider = TileProvider.from_qms(name)\n            url = qms_provider.build_url()\n            attribution = qms_provider.attribution\n            if attribution.strip() == \"\":\n                attribution = \" \"\n            self.add_tile_layer(url, name, attribution)\n        else:\n            raise ValueError(\n                f\"The provider {provider} is not valid. It must start with xyz or qms.\"\n            )\n\n    def add_heatmap(\n        self,\n        data,\n        latitude=\"latitude\",\n        longitude=\"longitude\",\n        value=\"value\",\n        name=\"Heat map\",\n        radius=25,\n        **kwargs,\n    ):\n\"\"\"Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html\n\n        Args:\n            data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/world_cities.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            value (str, optional): The column name of values. Defaults to \"value\".\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n        Raises:\n            ValueError: If data is not a list.\n        \"\"\"\n        import pandas as pd\n        from ipyleaflet import Heatmap\n\n        try:\n            if isinstance(data, str):\n                df = pd.read_csv(data)\n                data = df[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, pd.DataFrame):\n                data = data[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, list):\n                pass\n            else:\n                raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n            heatmap = Heatmap(locations=data, radius=radius, name=name, **kwargs)\n            self.add_layer(heatmap)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_labels(\n        self,\n        data,\n        column,\n        font_size=\"12pt\",\n        font_color=\"black\",\n        font_family=\"arial\",\n        font_weight=\"normal\",\n        x=\"longitude\",\n        y=\"latitude\",\n        draggable=True,\n        layer_name=\"Labels\",\n        **kwargs,\n    ):\n\"\"\"Adds a label layer to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/divicon.html\n\n        Args:\n            data (pd.DataFrame | ee.FeatureCollection): The input data to label.\n            column (str): The column name of the data to label.\n            font_size (str, optional): The font size of the labels. Defaults to \"12pt\".\n            font_color (str, optional): The font color of the labels. Defaults to \"black\".\n            font_family (str, optional): The font family of the labels. Defaults to \"arial\".\n            font_weight (str, optional): The font weight of the labels, can be normal, bold. Defaults to \"normal\".\n            x (str, optional): The column name of the longitude. Defaults to \"longitude\".\n            y (str, optional): The column name of the latitude. Defaults to \"latitude\".\n            draggable (bool, optional): Whether the labels are draggable. Defaults to True.\n            layer_name (str, optional): Layer name to use. Defaults to \"Labels\".\n\n        \"\"\"\n        import warnings\n        import pandas as pd\n\n        warnings.filterwarnings(\"ignore\")\n\n        if isinstance(data, ee.FeatureCollection):\n            centroids = vector_centroids(data)\n            df = ee_to_df(centroids)\n        elif isinstance(data, pd.DataFrame):\n            df = data\n        elif isinstance(data, str):\n            ext = os.path.splitext(data)[1]\n            if ext == \".csv\":\n                df = pd.read_csv(data)\n            elif ext in [\".geojson\", \".json\", \".shp\", \".gpkg\"]:\n                try:\n                    import geopandas as gpd\n\n                    df = gpd.read_file(data)\n                    df[x] = df.centroid.x\n                    df[y] = df.centroid.y\n                except Exception as _:\n                    print(\"geopandas is required to read geojson.\")\n                    return\n\n        else:\n            raise ValueError(\"data must be a DataFrame or an ee.FeatureCollection.\")\n\n        if column not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n        if x not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n        if y not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n\n        try:\n            size = int(font_size.replace(\"pt\", \"\"))\n        except:\n            raise ValueError(\"font_size must be something like '10pt'\")\n\n        labels = []\n        for index in df.index:\n            html = f'&lt;div style=\"font-size: {font_size};color:{font_color};font-family:{font_family};font-weight: {font_weight}\"&gt;{df[column][index]}&lt;/div&gt;'\n            marker = ipyleaflet.Marker(\n                location=[df[y][index], df[x][index]],\n                icon=ipyleaflet.DivIcon(\n                    icon_size=(1, 1),\n                    icon_anchor=(size, size),\n                    html=html,\n                    **kwargs,\n                ),\n                draggable=draggable,\n            )\n            labels.append(marker)\n        layer_group = ipyleaflet.LayerGroup(layers=labels, name=layer_name)\n        self.add_layer(layer_group)\n        self.labels = layer_group\n\n    def remove_labels(self):\n\"\"\"Removes all labels from the map.\"\"\"\n        if hasattr(self, \"labels\"):\n            self.remove_layer(self.labels)\n            delattr(self, \"labels\")\n\n    def add_netcdf(\n        self,\n        filename,\n        variables=None,\n        palette=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=\"NetCDF layer\",\n        shift_lon=True,\n        lat=\"lat\",\n        lon=\"lon\",\n        **kwargs,\n    ):\n\"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n            If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n            try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n        Args:\n            filename (str): File path or HTTP URL to the netCDF file.\n            variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n            port (str, optional): The port to use for the server. Defaults to \"default\".\n            palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to \"netCDF layer\".\n            shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n            lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n            lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n        \"\"\"\n\n        if in_colab_shell():\n            print(\"The add_netcdf() function is not supported in Colab.\")\n            return\n\n        tif, vars = netcdf_to_tif(\n            filename, shift_lon=shift_lon, lat=lat, lon=lon, return_vars=True\n        )\n\n        if variables is None:\n            if len(vars) &gt;= 3:\n                band_idx = [1, 2, 3]\n            else:\n                band_idx = [1]\n        else:\n            if not set(variables).issubset(set(vars)):\n                raise ValueError(f\"The variables must be a subset of {vars}.\")\n            else:\n                band_idx = [vars.index(v) + 1 for v in variables]\n\n        self.add_raster(\n            tif,\n            band=band_idx,\n            palette=palette,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            **kwargs,\n        )\n\n    def add_velocity(\n        self,\n        data,\n        zonal_speed,\n        meridional_speed,\n        latitude_dimension=\"lat\",\n        longitude_dimension=\"lon\",\n        level_dimension=\"lev\",\n        level_index=0,\n        time_index=0,\n        velocity_scale=0.01,\n        max_velocity=20,\n        display_options={},\n        name=\"Velocity\",\n    ):\n\"\"\"Add a velocity layer to the map.\n\n        Args:\n            data (str | xr.Dataset): The data to use for the velocity layer. It can be a file path to a NetCDF file or an xarray Dataset.\n            zonal_speed (str): Name of the zonal speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.\n            meridional_speed (str): Name of the meridional speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.\n            latitude_dimension (str, optional): Name of the latitude dimension in the dataset. Defaults to 'lat'.\n            longitude_dimension (str, optional): Name of the longitude dimension in the dataset. Defaults to 'lon'.\n            level_dimension (str, optional): Name of the level dimension in the dataset. Defaults to 'lev'.\n            level_index (int, optional): The index of the level dimension to display. Defaults to 0.\n            time_index (int, optional): The index of the time dimension to display. Defaults to 0.\n            velocity_scale (float, optional): The scale of the velocity. Defaults to 0.01.\n            max_velocity (int, optional): The maximum velocity to display. Defaults to 20.\n            display_options (dict, optional): The display options for the velocity layer. Defaults to {}. See https://bit.ly/3uf8t6w.\n            name (str, optional): Layer name to use . Defaults to 'Velocity'.\n\n        Raises:\n            ImportError: If the xarray package is not installed.\n            ValueError: If the data is not a NetCDF file or an xarray Dataset.\n        \"\"\"\n        try:\n            import xarray as xr\n            from ipyleaflet.velocity import Velocity\n        except ImportError:\n            raise ImportError(\n                \"The xarray package is required to add a velocity layer. \"\n                \"Please install it with `pip install xarray`.\"\n            )\n\n        if isinstance(data, str):\n            if data.startswith(\"http\"):\n                data = download_file(data)\n            ds = xr.open_dataset(data)\n\n        elif isinstance(data, xr.Dataset):\n            ds = data\n        else:\n            raise ValueError(\"The data must be a file path or xarray dataset.\")\n\n        coords = list(ds.coords.keys())\n\n        # Rasterio does not handle time or levels. So we must drop them\n        if \"time\" in coords:\n            ds = ds.isel(time=time_index, drop=True)\n\n        params = {level_dimension: level_index}\n        if level_dimension in coords:\n            ds = ds.isel(drop=True, **params)\n\n        wind = Velocity(\n            data=ds,\n            zonal_speed=zonal_speed,\n            meridional_speed=meridional_speed,\n            latitude_dimension=latitude_dimension,\n            longitude_dimension=longitude_dimension,\n            velocity_scale=velocity_scale,\n            max_velocity=max_velocity,\n            display_options=display_options,\n            name=name,\n        )\n        self.add_layer(wind)\n\n    def add_data(\n        self,\n        data,\n        column,\n        colors=None,\n        labels=None,\n        cmap=None,\n        scheme=\"Quantiles\",\n        k=5,\n        add_legend=True,\n        legend_title=None,\n        legend_kwds=None,\n        classification_kwds=None,\n        layer_name=\"Untitled\",\n        style=None,\n        hover_style=None,\n        style_callback=None,\n        info_mode=\"on_hover\",\n        encoding=\"utf-8\",\n        **kwargs,\n    ):\n\"\"\"Add vector data to the map with a variety of classification schemes.\n\n        Args:\n            data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n            column (str): The column to classify.\n            cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n            colors (list, optional): A list of colors to use for the classification. Defaults to None.\n            labels (list, optional): A list of labels to use for the legend. Defaults to None.\n            scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n                Name of a choropleth classification scheme (requires mapclassify).\n                A mapclassify.MapClassifier object will be used\n                under the hood. Supported are all schemes provided by mapclassify (e.g.\n                'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n                'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n                'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n                'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n                'UserDefined'). Arguments can be passed in classification_kwds.\n            k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n            legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n                Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n                Additional accepted keywords when `scheme` is specified:\n                fmt : string\n                    A formatting specification for the bin edges of the classes in the\n                    legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n                labels : list-like\n                    A list of legend labels to override the auto-generated labblels.\n                    Needs to have the same number of elements as the number of\n                    classes (`k`).\n                interval : boolean (default False)\n                    An option to control brackets from mapclassify legend.\n                    If True, open/closed interval brackets are shown in the legend.\n            classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to None.\n                style is a dictionary of the following form:\n                    style = {\n                    \"stroke\": False,\n                    \"color\": \"#ff0000\",\n                    \"weight\": 1,\n                    \"opacity\": 1,\n                    \"fill\": True,\n                    \"fillColor\": \"#ffffff\",\n                    \"fillOpacity\": 1.0,\n                    \"dashArray\": \"9\"\n                    \"clickable\": True,\n                }\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n                hover_style is a dictionary of the following form:\n                    hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n                style_callback is a function that takes the feature as argument and should return a dictionary of the following form:\n                style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n        \"\"\"\n\n        gdf, legend_dict = classify(\n            data=data,\n            column=column,\n            cmap=cmap,\n            colors=colors,\n            labels=labels,\n            scheme=scheme,\n            k=k,\n            legend_kwds=legend_kwds,\n            classification_kwds=classification_kwds,\n        )\n\n        if legend_title is None:\n            legend_title = column\n\n        if style is None:\n            style = {\n                # \"stroke\": False,\n                # \"color\": \"#ff0000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 1.0,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n            }\n            if colors is not None:\n                style[\"color\"] = \"#000000\"\n\n        if hover_style is None:\n            hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n\n        if style_callback is None:\n            style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n\n        self.add_gdf(\n            gdf,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            info_mode=info_mode,\n            encoding=encoding,\n            **kwargs,\n        )\n        if add_legend:\n            self.add_legend(title=legend_title, legend_dict=legend_dict)\n\n    def user_roi_coords(self, decimals=4):\n\"\"\"Return the bounding box of the ROI as a list of coordinates.\n\n        Args:\n            decimals (int, optional): Number of decimals to round the coordinates to. Defaults to 4.\n        \"\"\"\n        return bbox_coords(self.user_roi, decimals=decimals)\n\n    def _point_info(self, latlon, decimals=3, return_node=False):\n\"\"\"Create the ipytree widget for displaying the mouse clicking info.\n\n        Args:\n            latlon (list | tuple): The coordinates (lat, lon) of the point.\n            decimals (int, optional): Number of decimals to round the coordinates to. Defaults to 3.\n            return_node (bool, optional): If True, return the ipytree node.\n                Otherwise, return the ipytree tree widget. Defaults to False.\n\n        Returns:\n            ipytree.Node | ipytree.Tree: The ipytree node or tree widget.\n        \"\"\"\n        point_nodes = [\n            Node(f\"Longitude: {latlon[1]}\"),\n            Node(f\"Latitude: {latlon[0]}\"),\n            Node(f\"Zoom Level: {self.zoom}\"),\n            Node(f\"Scale (approx. m/px): {self.get_scale()}\"),\n        ]\n        label = f\"Point ({latlon[1]:.{decimals}f}, {latlon[0]:.{decimals}f}) at {int(self.get_scale())}m/px\"\n        root_node = Node(\n            label, nodes=point_nodes, icon=\"map\", opened=self._expand_point\n        )\n\n        root_node.open_icon = \"plus-square\"\n        root_node.open_icon_style = \"success\"\n        root_node.close_icon = \"minus-square\"\n        root_node.close_icon_style = \"info\"\n\n        if return_node:\n            return root_node\n        else:\n            return Tree(nodes=[root_node])\n\n    def _pixels_info(self, latlon, return_node=False):\n\"\"\"Create the ipytree widget for displaying the pixel values at the mouse clicking point.\n\n        Args:\n            latlon (list | tuple): The coordinates (lat, lon) of the point.\n            return_node (bool, optional): If True, return the ipytree node.\n                Otherwise, return the ipytree tree widget. Defaults to False.\n\n        Returns:\n            ipytree.Node | ipytree.Tree: The ipytree node or tree widget.\n        \"\"\"\n        layers = self.ee_layers\n        xy = ee.Geometry.Point(latlon[::-1])\n        sample_scale = self.getScale()\n\n        root_node = Node(\"Pixels\", icon=\"archive\")\n\n        nodes = []\n\n        for index, ee_object in enumerate(layers):\n            layer_names = self.ee_layer_names\n            layer_name = layer_names[index]\n            object_type = ee_object.__class__.__name__\n\n            if not self.ee_layer_dict[layer_name][\"ee_layer\"].visible:\n                continue\n\n            try:\n                if isinstance(ee_object, ee.ImageCollection):\n                    ee_object = ee_object.mosaic()\n\n                if isinstance(ee_object, ee.Image):\n                    item = ee_object.reduceRegion(\n                        ee.Reducer.first(), xy, sample_scale\n                    ).getInfo()\n                    b_name = \"band\"\n                    if len(item) &gt; 1:\n                        b_name = \"bands\"\n\n                    label = f\"{layer_name}: {object_type} ({len(item)} {b_name})\"\n                    layer_node = Node(label, opened=self._expand_pixels)\n\n                    keys = sorted(item.keys())\n                    for key in keys:\n                        layer_node.add_node(Node(f\"{key}: {item[key]}\", icon=\"file\"))\n\n                    nodes.append(layer_node)\n            except:\n                pass\n\n        root_node.nodes = nodes\n\n        root_node.open_icon = \"plus-square\"\n        root_node.open_icon_style = \"success\"\n        root_node.close_icon = \"minus-square\"\n        root_node.close_icon_style = \"info\"\n\n        if return_node:\n            return root_node\n        else:\n            return Tree(nodes=[root_node])\n\n    def _objects_info(self, latlon, return_node=False):\n\"\"\"Create the ipytree widget for displaying the Earth Engine objects at the mouse clicking point.\n\n        Args:\n            latlon (list | tuple): The coordinates (lat, lon) of the point.\n            return_node (bool, optional): If True, return the ipytree node.\n                Otherwise, return the ipytree tree widget. Defaults to False.\n\n        Returns:\n            ipytree.Node | ipytree.Tree: The ipytree node or tree widget.\n        \"\"\"\n        layers = self.ee_layers\n        xy = ee.Geometry.Point(latlon[::-1])\n        root_node = Node(\"Objects\", icon=\"archive\")\n\n        nodes = []\n\n        for index, ee_object in enumerate(layers):\n            layer_names = self.ee_layer_names\n            layer_name = layer_names[index]\n\n            if not self.ee_layer_dict[layer_name][\"ee_layer\"].visible:\n                continue\n\n            if isinstance(ee_object, ee.FeatureCollection):\n                # Check geometry type\n                geom_type = ee.Feature(ee_object.first()).geometry().type()\n                lat, lon = latlon\n                delta = 0.005\n                bbox = ee.Geometry.BBox(\n                    lon - delta,\n                    lat - delta,\n                    lon + delta,\n                    lat + delta,\n                )\n                # Create a bounding box to filter points\n                xy = ee.Algorithms.If(\n                    geom_type.compareTo(ee.String(\"Point\")),\n                    xy,\n                    bbox,\n                )\n\n                ee_object = ee_object.filterBounds(xy).first()\n\n            try:\n                node = get_info(\n                    ee_object, layer_name, opened=self._expand_objects, return_node=True\n                )\n                nodes.append(node)\n            except:\n                pass\n\n        root_node.nodes = nodes\n\n        root_node.open_icon = \"plus-square\"\n        root_node.open_icon_style = \"success\"\n        root_node.close_icon = \"minus-square\"\n        root_node.close_icon_style = \"info\"\n\n        if return_node:\n            return root_node\n        else:\n            return Tree(nodes=[root_node])\n\n    def inspector(self, latlon):\n\"\"\"Create the Inspector GUI.\n\n        Args:\n            latlon (list | tuple): The coordinates (lat, lon) of the point.\n        Returns:\n            ipytree.Tree: The ipytree tree widget for the Inspector GUI.\n        \"\"\"\n        tree = Tree()\n        nodes = []\n        point_node = self._point_info(latlon, return_node=True)\n        nodes.append(point_node)\n        pixels_node = self._pixels_info(latlon, return_node=True)\n        if pixels_node.nodes:\n            nodes.append(pixels_node)\n        objects_node = self._objects_info(latlon, return_node=True)\n        if objects_node.nodes:\n            nodes.append(objects_node)\n        tree.nodes = nodes\n        return tree\n\n    def add_widget(self, content, position=\"bottomright\", **kwargs):\n\"\"\"Add a widget (e.g., text, HTML, figure) to the map.\n\n        Args:\n            content (str | ipywidgets.Widget | object): The widget to add.\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n            **kwargs: Other keyword arguments for ipywidgets.HTML().\n        \"\"\"\n\n        allowed_positions = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n\n        if position not in allowed_positions:\n            raise Exception(f\"position must be one of {allowed_positions}\")\n\n        if \"layout\" not in kwargs:\n            kwargs[\"layout\"] = widgets.Layout(padding=\"0px 4px 0px 4px\")\n        try:\n            if isinstance(content, str):\n                widget = widgets.HTML(value=content, **kwargs)\n                control = ipyleaflet.WidgetControl(widget=widget, position=position)\n            else:\n                output = widgets.Output(**kwargs)\n                with output:\n                    display(content)\n                control = ipyleaflet.WidgetControl(widget=output, position=position)\n            self.add_control(control)\n\n        except Exception as e:\n            raise Exception(f\"Error adding widget: {e}\")\n\n    def add_image(self, image, position=\"bottomright\", **kwargs):\n\"\"\"Add an image to the map.\n\n        Args:\n            image (str | ipywidgets.Image): The image to add.\n            position (str, optional): The position of the image, can be one of \"topleft\",\n                \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n\n        \"\"\"\n\n        if isinstance(image, str):\n            if image.startswith(\"http\"):\n                image = widgets.Image(value=requests.get(image).content, **kwargs)\n            elif os.path.exists(image):\n                with open(image, \"rb\") as f:\n                    image = widgets.Image(value=f.read(), **kwargs)\n        elif isinstance(image, widgets.Image):\n            pass\n        else:\n            raise Exception(\"Invalid image\")\n\n        self.add_widget(image, position=position)\n\n    def add_html(self, html, position=\"bottomright\", **kwargs):\n\"\"\"Add HTML to the map.\n\n        Args:\n            html (str): The HTML to add.\n            position (str, optional): The position of the HTML, can be one of \"topleft\",\n                \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n        \"\"\"\n        self.add_widget(html, position=position, **kwargs)\n\n    def add_text(\n        self,\n        text,\n        fontsize=20,\n        fontcolor=\"black\",\n        bold=False,\n        padding=\"5px\",\n        background=True,\n        bg_color=\"white\",\n        border_radius=\"5px\",\n        position=\"bottomright\",\n        **kwargs,\n    ):\n\"\"\"Add text to the map.\n\n        Args:\n            text (str): The text to add.\n            fontsize (int, optional): The font size. Defaults to 20.\n            fontcolor (str, optional): The font color. Defaults to \"black\".\n            bold (bool, optional): Whether to use bold font. Defaults to False.\n            padding (str, optional): The padding. Defaults to \"5px\".\n            background (bool, optional): Whether to use background. Defaults to True.\n            bg_color (str, optional): The background color. Defaults to \"white\".\n            border_radius (str, optional): The border radius. Defaults to \"5px\".\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        \"\"\"\n\n        if background:\n            text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'}; \n            padding: {padding}; background-color: {bg_color}; \n            border-radius: {border_radius};\"&gt;{text}&lt;/div&gt;\"\"\"\n        else:\n            text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'}; \n            padding: {padding};\"&gt;{text}&lt;/div&gt;\"\"\"\n\n        self.add_html(text, position=position, **kwargs)\n\n    def to_gradio(self, width=\"100%\", height=\"500px\", **kwargs):\n\"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n            attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n        Args:\n            width (str, optional): The width of the map. Defaults to '100%'.\n            height (str, optional): The height of the map. Defaults to '500px'.\n\n        Returns:\n            str: The HTML string to use in Gradio.\n        \"\"\"\n\n        print(\n            \"The ipyleaflet plotting backend does not support this function. Please use the folium backend instead.\"\n        )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.addLayer","title":"<code>addLayer(self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0)</code>","text":"<p>Adds a given EE object to the map as a layer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer N'.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_ee_layer(\n    self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0\n):\n\"\"\"Adds a given EE object to the map as a layer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer N'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n\n    image = None\n\n    if vis_params is None:\n        vis_params = {}\n\n    if name is None:\n        layer_count = len(self.layers)\n        name = \"Layer \" + str(layer_count + 1)\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], tuple):\n            vis_params[\"palette\"] = list(vis_params[\"palette\"])\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n    url = map_id_dict[\"tile_fetcher\"].url_format\n    tile_layer = ipyleaflet.TileLayer(\n        url=url,\n        attribution=\"Google Earth Engine\",\n        name=name,\n        opacity=opacity,\n        visible=shown,\n        max_zoom=24,\n    )\n\n    layer = self.find_layer(name=name)\n    if layer is not None:\n        existing_object = self.ee_layer_dict[name][\"ee_object\"]\n\n        if isinstance(existing_object, ee.Image) or isinstance(\n            existing_object, ee.ImageCollection\n        ):\n            self.ee_raster_layers.remove(existing_object)\n            self.ee_raster_layer_names.remove(name)\n            if self.plot_dropdown_widget is not None:\n                self.plot_dropdown_widget.options = list(self.ee_raster_layer_names)\n        elif (\n            isinstance(ee_object, ee.Geometry)\n            or isinstance(ee_object, ee.Feature)\n            or isinstance(ee_object, ee.FeatureCollection)\n        ):\n            self.ee_vector_layers.remove(existing_object)\n            self.ee_vector_layer_names.remove(name)\n\n        self.ee_layers.remove(existing_object)\n        self.ee_layer_names.remove(name)\n        self.remove_layer(layer)\n\n    self.ee_layers.append(ee_object)\n    if name not in self.ee_layer_names:\n        self.ee_layer_names.append(name)\n    self.ee_layer_dict[name] = {\n        \"ee_object\": ee_object,\n        \"ee_layer\": tile_layer,\n        \"vis_params\": vis_params,\n    }\n\n    self.add_layer(tile_layer)\n    self.last_ee_layer = self.ee_layer_dict[name]\n    self.last_ee_data = self.ee_layer_dict[name][\"ee_object\"]\n\n    if isinstance(ee_object, ee.Image) or isinstance(ee_object, ee.ImageCollection):\n        self.ee_raster_layers.append(ee_object)\n        self.ee_raster_layer_names.append(name)\n        if self.plot_dropdown_widget is not None:\n            self.plot_dropdown_widget.options = list(self.ee_raster_layer_names)\n    elif (\n        isinstance(ee_object, ee.Geometry)\n        or isinstance(ee_object, ee.Feature)\n        or isinstance(ee_object, ee.FeatureCollection)\n    ):\n        self.ee_vector_layers.append(ee_object)\n        self.ee_vector_layer_names.append(name)\n\n    arc_add_layer(url, name, shown, opacity)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.addLayerControl","title":"<code>addLayerControl(self)</code>","text":"<p>Adds the layer control to the map.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_layer_control(self):\n\"\"\"Adds the layer control to the map.\"\"\"\n    if self.layer_control is None:\n        layer_control = ipyleaflet.LayersControl(position=\"topright\")\n        self.layer_control = layer_control\n        self.add_control(layer_control)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_basemap","title":"<code>add_basemap(self, basemap='HYBRID')</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Can be one of string from basemaps. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_basemap(self, basemap=\"HYBRID\"):\n\"\"\"Adds a basemap to the map.\n\n    Args:\n        basemap (str, optional): Can be one of string from basemaps. Defaults to 'HYBRID'.\n    \"\"\"\n    try:\n        if basemap in basemaps.keys() and basemaps[basemap] not in self.layers:\n            self.add_layer(basemaps[basemap])\n\n            if is_arcpy():\n                arc_add_layer(basemaps[basemap].url, basemap)\n\n    except Exception:\n        raise ValueError(\n            \"Basemap can only be one of the following:\\n  {}\".format(\n                \"\\n  \".join(basemaps.keys())\n            )\n        )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_census_data","title":"<code>add_census_data(self, wms, layer, census_dict=None, **kwargs)</code>","text":"<p>Adds a census data layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>wms</code> <code>str</code> <p>The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html</p> required <code>layer</code> <code>str</code> <p>The layer name to add to the map.</p> required <code>census_dict</code> <code>dict</code> <p>A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_census_data(self, wms, layer, census_dict=None, **kwargs):\n\"\"\"Adds a census data layer to the map.\n\n    Args:\n        wms (str): The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html\n        layer (str): The layer name to add to the map.\n        census_dict (dict, optional): A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.\n    \"\"\"\n\n    try:\n        if census_dict is None:\n            census_dict = get_census_dict()\n\n        if wms not in census_dict.keys():\n            raise ValueError(\n                f\"The provided WMS is invalid. It must be one of {census_dict.keys()}\"\n            )\n\n        layers = census_dict[wms][\"layers\"]\n        if layer not in layers:\n            raise ValueError(\n                f\"The layer name is not valid. It must be one of {layers}\"\n            )\n\n        url = census_dict[wms][\"url\"]\n        if \"name\" not in kwargs:\n            kwargs[\"name\"] = layer\n        if \"attribution\" not in kwargs:\n            kwargs[\"attribution\"] = \"U.S. Census Bureau\"\n        if \"format\" not in kwargs:\n            kwargs[\"format\"] = \"image/png\"\n        if \"transparent\" not in kwargs:\n            kwargs[\"transparent\"] = True\n\n        self.add_wms_layer(url, layer, **kwargs)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_circle_markers_from_xy","title":"<code>add_circle_markers_from_xy(self, data, x='longitude', y='latitude', radius=10, popup=None, **kwargs)</code>","text":"<p>Adds a marker cluster to the map. For a list of options, see https://ipyleaflet.readthedocs.io/en/latest/api_reference/circle_marker.html</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>radius</code> <code>int</code> <p>The radius of the circle. Defaults to 10.</p> <code>10</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_circle_markers_from_xy(\n    self,\n    data,\n    x=\"longitude\",\n    y=\"latitude\",\n    radius=10,\n    popup=None,\n    **kwargs,\n):\n\"\"\"Adds a marker cluster to the map. For a list of options, see https://ipyleaflet.readthedocs.io/en/latest/api_reference/circle_marker.html\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        radius (int, optional): The radius of the circle. Defaults to 10.\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n\n    \"\"\"\n    import pandas as pd\n\n    data = github_raw_url(data)\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    else:\n        df = pd.read_csv(data)\n\n    col_names = df.columns.values.tolist()\n\n    if popup is None:\n        popup = col_names\n\n    if not isinstance(popup, list):\n        popup = [popup]\n\n    if x not in col_names:\n        raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n    if y not in col_names:\n        raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n    for row in df.itertuples():\n        html = \"\"\n        for p in popup:\n            html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(getattr(row, p)) + \"&lt;br&gt;\"\n        popup_html = widgets.HTML(html)\n\n        marker = ipyleaflet.CircleMarker(\n            location=[getattr(row, y), getattr(row, x)],\n            radius=radius,\n            popup=popup_html,\n            **kwargs,\n        )\n        super().add_layer(marker)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_cog_layer","title":"<code>add_cog_layer(self, url, name='Untitled', attribution='', opacity=1.0, shown=True, bands=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Adds a COG TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the COG tile layer.</p> required <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Untitled'.</p> <code>'Untitled'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>bands</code> <code>list</code> <p>A list of bands to use for the layer. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]</p> <code>{}</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_cog_layer(\n    self,\n    url,\n    name=\"Untitled\",\n    attribution=\"\",\n    opacity=1.0,\n    shown=True,\n    bands=None,\n    titiler_endpoint=None,\n    **kwargs,\n):\n\"\"\"Adds a COG TileLayer to the map.\n\n    Args:\n        url (str): The URL of the COG tile layer.\n        name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        bands (list, optional): A list of bands to use for the layer. Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]\n    \"\"\"\n    tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n    bounds = cog_bounds(url, titiler_endpoint)\n    self.add_tile_layer(tile_url, name, attribution, opacity, shown)\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    if not hasattr(self, \"cog_layer_dict\"):\n        self.cog_layer_dict = {}\n\n    params = {\n        \"url\": url,\n        \"titizer_endpoint\": titiler_endpoint,\n        \"bounds\": bounds,\n        \"type\": \"COG\",\n    }\n    self.cog_layer_dict[name] = params\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_colorbar","title":"<code>add_colorbar(self, vis_params=None, cmap='gray', discrete=False, label=None, orientation='horizontal', position='bottomright', transparent_bg=False, layer_name=None, font_size=9, axis_off=False, **kwargs)</code>","text":"<p>Add a matplotlib colorbar to the map</p> <p>Parameters:</p> Name Type Description Default <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>position</code> <code>str</code> <p>Position of the colorbar on the map. It can be one of: topleft, topright, bottomleft, and bottomright. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>transparent_bg</code> <code>bool</code> <p>Whether to use transparent background. Defaults to False.</p> <code>False</code> <code>layer_name</code> <code>str</code> <p>The layer name associated with the colorbar. Defaults to None.</p> <code>None</code> <code>font_size</code> <code>int</code> <p>Font size for the colorbar. Defaults to 9.</p> <code>9</code> <code>axis_off</code> <code>bool</code> <p>Whether to turn off the axis. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the vis_params is not a dictionary.</p> <code>ValueError</code> <p>If the orientation is not either horizontal or vertical.</p> <code>ValueError</code> <p>If the provided min value is not scalar type.</p> <code>ValueError</code> <p>If the provided max value is not scalar type.</p> <code>ValueError</code> <p>If the provided opacity value is not scalar type.</p> <code>ValueError</code> <p>If cmap or palette is not provided.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_colorbar(\n    self,\n    vis_params=None,\n    cmap=\"gray\",\n    discrete=False,\n    label=None,\n    orientation=\"horizontal\",\n    position=\"bottomright\",\n    transparent_bg=False,\n    layer_name=None,\n    font_size=9,\n    axis_off=False,\n    **kwargs,\n):\n\"\"\"Add a matplotlib colorbar to the map\n\n    Args:\n        vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n        position (str, optional): Position of the colorbar on the map. It can be one of: topleft, topright, bottomleft, and bottomright. Defaults to \"bottomright\".\n        transparent_bg (bool, optional): Whether to use transparent background. Defaults to False.\n        layer_name (str, optional): The layer name associated with the colorbar. Defaults to None.\n        font_size (int, optional): Font size for the colorbar. Defaults to 9.\n        axis_off (bool, optional): Whether to turn off the axis. Defaults to False.\n\n    Raises:\n        TypeError: If the vis_params is not a dictionary.\n        ValueError: If the orientation is not either horizontal or vertical.\n        ValueError: If the provided min value is not scalar type.\n        ValueError: If the provided max value is not scalar type.\n        ValueError: If the provided opacity value is not scalar type.\n        ValueError: If cmap or palette is not provided.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n    import numpy as np\n\n    if isinstance(vis_params, list):\n        vis_params = {\"palette\": vis_params}\n    elif isinstance(vis_params, tuple):\n        vis_params = {\"palette\": list(vis_params)}\n    elif vis_params is None:\n        vis_params = {}\n\n    if \"colors\" in kwargs and isinstance(kwargs[\"colors\"], list):\n        vis_params[\"palette\"] = kwargs[\"colors\"]\n\n    if \"colors\" in kwargs and isinstance(kwargs[\"colors\"], tuple):\n        vis_params[\"palette\"] = list(kwargs[\"colors\"])\n\n    if \"vmin\" in kwargs:\n        vis_params[\"min\"] = kwargs[\"vmin\"]\n        del kwargs[\"vmin\"]\n\n    if \"vmax\" in kwargs:\n        vis_params[\"max\"] = kwargs[\"vmax\"]\n        del kwargs[\"vmax\"]\n\n    if \"caption\" in kwargs:\n        label = kwargs[\"caption\"]\n        del kwargs[\"caption\"]\n\n    if not isinstance(vis_params, dict):\n        raise TypeError(\"The vis_params must be a dictionary.\")\n\n    if orientation not in [\"horizontal\", \"vertical\"]:\n        raise ValueError(\"The orientation must be either horizontal or vertical.\")\n\n    if orientation == \"horizontal\":\n        width, height = 3.0, 0.3\n    else:\n        width, height = 0.3, 3.0\n\n    if \"width\" in kwargs:\n        width = kwargs[\"width\"]\n        kwargs.pop(\"width\")\n\n    if \"height\" in kwargs:\n        height = kwargs[\"height\"]\n        kwargs.pop(\"height\")\n\n    vis_keys = list(vis_params.keys())\n\n    if \"min\" in vis_params:\n        vmin = vis_params[\"min\"]\n        if type(vmin) not in (int, float):\n            raise ValueError(\"The provided min value must be scalar type.\")\n    else:\n        vmin = 0\n\n    if \"max\" in vis_params:\n        vmax = vis_params[\"max\"]\n        if type(vmax) not in (int, float):\n            raise ValueError(\"The provided max value must be scalar type.\")\n    else:\n        vmax = 1\n\n    if \"opacity\" in vis_params:\n        alpha = vis_params[\"opacity\"]\n        if type(alpha) not in (int, float):\n            raise ValueError(\"The provided opacity value must be type scalar.\")\n    elif \"alpha\" in kwargs:\n        alpha = kwargs[\"alpha\"]\n    else:\n        alpha = 1\n\n    if cmap is not None:\n        cmap = mpl.pyplot.get_cmap(cmap)\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    if \"palette\" in vis_keys:\n        hexcodes = to_hex_colors(check_cmap(vis_params[\"palette\"]))\n        if discrete:\n            cmap = mpl.colors.ListedColormap(hexcodes)\n            vals = np.linspace(vmin, vmax, cmap.N + 1)\n            norm = mpl.colors.BoundaryNorm(vals, cmap.N)\n\n        else:\n            cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                \"custom\", hexcodes, N=256\n            )\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    elif cmap is not None:\n        cmap = mpl.pyplot.get_cmap(cmap)\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    else:\n        raise ValueError(\n            'cmap keyword or \"palette\" key in vis_params must be provided.'\n        )\n\n    _, ax = plt.subplots(figsize=(width, height))\n    cb = mpl.colorbar.ColorbarBase(\n        ax, norm=norm, alpha=alpha, cmap=cmap, orientation=orientation, **kwargs\n    )\n\n    if label is not None:\n        cb.set_label(label, fontsize=font_size)\n    elif \"bands\" in vis_keys:\n        cb.set_label(vis_params[\"bands\"], fontsize=font_size)\n\n    if axis_off:\n        ax.set_axis_off()\n    ax.tick_params(labelsize=font_size)\n\n    output = widgets.Output()\n    colormap_ctrl = ipyleaflet.WidgetControl(\n        widget=output,\n        position=position,\n        transparent_bg=transparent_bg,\n    )\n    with output:\n        output.clear_output()\n        plt.show()\n\n    self.colorbar = colormap_ctrl\n    if layer_name in self.ee_layer_names:\n        if \"colorbar\" in self.ee_layer_dict[layer_name]:\n            self.remove_control(self.ee_layer_dict[layer_name][\"colorbar\"])\n        self.ee_layer_dict[layer_name][\"colorbar\"] = colormap_ctrl\n    if not hasattr(self, \"colorbars\"):\n        self.colorbars = [colormap_ctrl]\n    else:\n        self.colorbars.append(colormap_ctrl)\n\n    self.add_control(colormap_ctrl)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_colorbar_branca","title":"<code>add_colorbar_branca(self, colors, vmin=0, vmax=1.0, index=None, caption='', categorical=False, step=None, height='45px', transparent_bg=False, position='bottomright', layer_name=None, **kwargs)</code>","text":"<p>Add a branca colorbar to the map.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)</p> required <code>vmin</code> <code>int</code> <p>The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.</p> <code>1.0</code> <code>index</code> <code>list</code> <p>The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.</p> <code>None</code> <code>caption</code> <code>str</code> <p>The caption for the colormap. Defaults to \"\".</p> <code>''</code> <code>categorical</code> <code>bool</code> <p>Whether or not to create a categorical colormap. Defaults to False.</p> <code>False</code> <code>step</code> <code>int</code> <p>The step to split the LinearColormap into a StepColormap. Defaults to None.</p> <code>None</code> <code>height</code> <code>str</code> <p>The height of the colormap widget. Defaults to \"45px\".</p> <code>'45px'</code> <code>transparent_bg</code> <code>bool</code> <p>Whether to use transparent background for the colormap widget. Defaults to True.</p> <code>False</code> <code>position</code> <code>str</code> <p>The position for the colormap widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>layer_name</code> <code>str</code> <p>Layer name of the colorbar to be associated with. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_colorbar_branca(\n    self,\n    colors,\n    vmin=0,\n    vmax=1.0,\n    index=None,\n    caption=\"\",\n    categorical=False,\n    step=None,\n    height=\"45px\",\n    transparent_bg=False,\n    position=\"bottomright\",\n    layer_name=None,\n    **kwargs,\n):\n\"\"\"Add a branca colorbar to the map.\n\n    Args:\n        colors (list): The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)\n        vmin (int, optional): The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.\n        vmax (float, optional): The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.\n        index (list, optional):The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.\n        caption (str, optional): The caption for the colormap. Defaults to \"\".\n        categorical (bool, optional): Whether or not to create a categorical colormap. Defaults to False.\n        step (int, optional): The step to split the LinearColormap into a StepColormap. Defaults to None.\n        height (str, optional): The height of the colormap widget. Defaults to \"45px\".\n        transparent_bg (bool, optional): Whether to use transparent background for the colormap widget. Defaults to True.\n        position (str, optional): The position for the colormap widget. Defaults to \"bottomright\".\n        layer_name (str, optional): Layer name of the colorbar to be associated with. Defaults to None.\n\n    \"\"\"\n    from branca.colormap import LinearColormap\n\n    output = widgets.Output()\n    output.layout.height = height\n\n    if \"width\" in kwargs.keys():\n        output.layout.width = kwargs[\"width\"]\n\n    if isinstance(colors, Box):\n        try:\n            colors = list(colors[\"default\"])\n        except Exception as e:\n            print(\"The provided color list is invalid.\")\n            raise Exception(e)\n\n    if all(len(color) == 6 for color in colors):\n        colors = [\"#\" + color for color in colors]\n\n    colormap = LinearColormap(\n        colors=colors, index=index, vmin=vmin, vmax=vmax, caption=caption\n    )\n\n    if categorical:\n        if step is not None:\n            colormap = colormap.to_step(step)\n        elif index is not None:\n            colormap = colormap.to_step(len(index) - 1)\n        else:\n            colormap = colormap.to_step(3)\n\n    colormap_ctrl = ipyleaflet.WidgetControl(\n        widget=output,\n        position=position,\n        transparent_bg=transparent_bg,\n        **kwargs,\n    )\n    with output:\n        output.clear_output()\n        display(colormap)\n\n    self.colorbar = colormap_ctrl\n    self.add_control(colormap_ctrl)\n\n    if not hasattr(self, \"colorbars\"):\n        self.colorbars = [colormap_ctrl]\n    else:\n        self.colorbars.append(colormap_ctrl)\n\n    if layer_name in self.ee_layer_names:\n        self.ee_layer_dict[layer_name][\"colorbar\"] = colormap_ctrl\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_data","title":"<code>add_data(self, data, column, colors=None, labels=None, cmap=None, scheme='Quantiles', k=5, add_legend=True, legend_title=None, legend_kwds=None, classification_kwds=None, layer_name='Untitled', style=None, hover_style=None, style_callback=None, info_mode='on_hover', encoding='utf-8', **kwargs)</code>","text":"<p>Add vector data to the map with a variety of classification schemes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame | gpd.GeoDataFrame</code> <p>The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.</p> required <code>column</code> <code>str</code> <p>The column to classify.</p> required <code>cmap</code> <code>str</code> <p>The name of a colormap recognized by matplotlib. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of colors to use for the classification. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of labels to use for the legend. Defaults to None.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>Name of a choropleth classification scheme (requires mapclassify). Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if scheme is None or if column is categorical). Default to 5.</p> <code>5</code> <code>legend_kwds</code> <code>dict</code> <p>Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or <code>matplotlib.pyplot.colorbar</code>. Defaults to None. Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or Additional accepted keywords when <code>scheme</code> is specified: fmt : string     A formatting specification for the bin edges of the classes in the     legend. For example, to have no decimals: <code>{\"fmt\": \"{:.0f}\"}</code>. labels : list-like     A list of legend labels to override the auto-generated labblels.     Needs to have the same number of elements as the number of     classes (<code>k</code>). interval : boolean (default False)     An option to control brackets from mapclassify legend.     If True, open/closed interval brackets are shown in the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Keyword arguments to pass to mapclassify. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to None. style is a dictionary of the following form:     style = {     \"stroke\": False,     \"color\": \"#ff0000\",     \"weight\": 1,     \"opacity\": 1,     \"fill\": True,     \"fillColor\": \"#ffffff\",     \"fillOpacity\": 1.0,     \"dashArray\": \"9\"     \"clickable\": True, }</p> <code>None</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}. hover_style is a dictionary of the following form:     hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}</p> <code>None</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None. style_callback is a function that takes the feature as argument and should return a dictionary of the following form: style_callback = lambda feat: {\"fillColor\": feat\"properties\"}</p> <code>None</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_data(\n    self,\n    data,\n    column,\n    colors=None,\n    labels=None,\n    cmap=None,\n    scheme=\"Quantiles\",\n    k=5,\n    add_legend=True,\n    legend_title=None,\n    legend_kwds=None,\n    classification_kwds=None,\n    layer_name=\"Untitled\",\n    style=None,\n    hover_style=None,\n    style_callback=None,\n    info_mode=\"on_hover\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n\"\"\"Add vector data to the map with a variety of classification schemes.\n\n    Args:\n        data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n        column (str): The column to classify.\n        cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n        colors (list, optional): A list of colors to use for the classification. Defaults to None.\n        labels (list, optional): A list of labels to use for the legend. Defaults to None.\n        scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n        legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n            Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n            Additional accepted keywords when `scheme` is specified:\n            fmt : string\n                A formatting specification for the bin edges of the classes in the\n                legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n            labels : list-like\n                A list of legend labels to override the auto-generated labblels.\n                Needs to have the same number of elements as the number of\n                classes (`k`).\n            interval : boolean (default False)\n                An option to control brackets from mapclassify legend.\n                If True, open/closed interval brackets are shown in the legend.\n        classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to None.\n            style is a dictionary of the following form:\n                style = {\n                \"stroke\": False,\n                \"color\": \"#ff0000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                \"fill\": True,\n                \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 1.0,\n                \"dashArray\": \"9\"\n                \"clickable\": True,\n            }\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            hover_style is a dictionary of the following form:\n                hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            style_callback is a function that takes the feature as argument and should return a dictionary of the following form:\n            style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n    \"\"\"\n\n    gdf, legend_dict = classify(\n        data=data,\n        column=column,\n        cmap=cmap,\n        colors=colors,\n        labels=labels,\n        scheme=scheme,\n        k=k,\n        legend_kwds=legend_kwds,\n        classification_kwds=classification_kwds,\n    )\n\n    if legend_title is None:\n        legend_title = column\n\n    if style is None:\n        style = {\n            # \"stroke\": False,\n            # \"color\": \"#ff0000\",\n            \"weight\": 1,\n            \"opacity\": 1,\n            # \"fill\": True,\n            # \"fillColor\": \"#ffffff\",\n            \"fillOpacity\": 1.0,\n            # \"dashArray\": \"9\"\n            # \"clickable\": True,\n        }\n        if colors is not None:\n            style[\"color\"] = \"#000000\"\n\n    if hover_style is None:\n        hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n\n    if style_callback is None:\n        style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n\n    self.add_gdf(\n        gdf,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        info_mode=info_mode,\n        encoding=encoding,\n        **kwargs,\n    )\n    if add_legend:\n        self.add_legend(title=legend_title, legend_dict=legend_dict)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_ee_layer","title":"<code>add_ee_layer(self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0)</code>","text":"<p>Adds a given EE object to the map as a layer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer N'.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_ee_layer(\n    self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0\n):\n\"\"\"Adds a given EE object to the map as a layer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer N'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n\n    image = None\n\n    if vis_params is None:\n        vis_params = {}\n\n    if name is None:\n        layer_count = len(self.layers)\n        name = \"Layer \" + str(layer_count + 1)\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], tuple):\n            vis_params[\"palette\"] = list(vis_params[\"palette\"])\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n    url = map_id_dict[\"tile_fetcher\"].url_format\n    tile_layer = ipyleaflet.TileLayer(\n        url=url,\n        attribution=\"Google Earth Engine\",\n        name=name,\n        opacity=opacity,\n        visible=shown,\n        max_zoom=24,\n    )\n\n    layer = self.find_layer(name=name)\n    if layer is not None:\n        existing_object = self.ee_layer_dict[name][\"ee_object\"]\n\n        if isinstance(existing_object, ee.Image) or isinstance(\n            existing_object, ee.ImageCollection\n        ):\n            self.ee_raster_layers.remove(existing_object)\n            self.ee_raster_layer_names.remove(name)\n            if self.plot_dropdown_widget is not None:\n                self.plot_dropdown_widget.options = list(self.ee_raster_layer_names)\n        elif (\n            isinstance(ee_object, ee.Geometry)\n            or isinstance(ee_object, ee.Feature)\n            or isinstance(ee_object, ee.FeatureCollection)\n        ):\n            self.ee_vector_layers.remove(existing_object)\n            self.ee_vector_layer_names.remove(name)\n\n        self.ee_layers.remove(existing_object)\n        self.ee_layer_names.remove(name)\n        self.remove_layer(layer)\n\n    self.ee_layers.append(ee_object)\n    if name not in self.ee_layer_names:\n        self.ee_layer_names.append(name)\n    self.ee_layer_dict[name] = {\n        \"ee_object\": ee_object,\n        \"ee_layer\": tile_layer,\n        \"vis_params\": vis_params,\n    }\n\n    self.add_layer(tile_layer)\n    self.last_ee_layer = self.ee_layer_dict[name]\n    self.last_ee_data = self.ee_layer_dict[name][\"ee_object\"]\n\n    if isinstance(ee_object, ee.Image) or isinstance(ee_object, ee.ImageCollection):\n        self.ee_raster_layers.append(ee_object)\n        self.ee_raster_layer_names.append(name)\n        if self.plot_dropdown_widget is not None:\n            self.plot_dropdown_widget.options = list(self.ee_raster_layer_names)\n    elif (\n        isinstance(ee_object, ee.Geometry)\n        or isinstance(ee_object, ee.Feature)\n        or isinstance(ee_object, ee.FeatureCollection)\n    ):\n        self.ee_vector_layers.append(ee_object)\n        self.ee_vector_layer_names.append(name)\n\n    arc_add_layer(url, name, shown, opacity)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_gdf","title":"<code>add_gdf(self, gdf, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', zoom_to_layer=True, encoding='utf-8')</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer.</p> <code>True</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoDataFrame. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_gdf(\n    self,\n    gdf,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    zoom_to_layer=True,\n    encoding=\"utf-8\",\n):\n\"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer.\n        encoding (str, optional): The encoding of the GeoDataFrame. Defaults to \"utf-8\".\n    \"\"\"\n\n    data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n    self.add_geojson(\n        data,\n        layer_name,\n        style,\n        hover_style,\n        style_callback,\n        fill_colors,\n        info_mode,\n        encoding,\n    )\n\n    if zoom_to_layer:\n        import numpy as np\n\n        bounds = gdf.to_crs(epsg=\"4326\").bounds\n        west = np.min(bounds[\"minx\"])\n        south = np.min(bounds[\"miny\"])\n        east = np.max(bounds[\"maxx\"])\n        north = np.max(bounds[\"maxy\"])\n        self.fit_bounds([[south, east], [north, west]])\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_gdf_from_postgis","title":"<code>add_gdf_from_postgis(self, sql, con, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', zoom_to_layer=True, **kwargs)</code>","text":"<p>Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_gdf_from_postgis(\n    self,\n    sql,\n    con,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    zoom_to_layer=True,\n    **kwargs,\n):\n\"\"\"Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer.\n    \"\"\"\n    gdf = read_postgis(sql, con, **kwargs)\n    gdf = gdf.to_crs(\"epsg:4326\")\n    self.add_gdf(\n        gdf,\n        layer_name,\n        style,\n        hover_style,\n        style_callback,\n        fill_colors,\n        info_mode,\n        zoom_to_layer,\n    )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_geojson","title":"<code>add_geojson(self, in_geojson, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', encoding='utf-8')</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The file path or http URL to the input GeoJSON or a dictionary containing the geojson.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided GeoJSON file could not be found.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_geojson(\n    self,\n    in_geojson,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    encoding=\"utf-8\",\n):\n\"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n\n    Raises:\n        FileNotFoundError: The provided GeoJSON file could not be found.\n    \"\"\"\n    import json\n    import random\n    import requests\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n\n    style_callback_only = False\n\n    if len(style) == 0 and style_callback is not None:\n        style_callback_only = True\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                in_geojson = github_raw_url(in_geojson)\n                data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n    except Exception as e:\n        raise Exception(e)\n\n    if not style:\n        style = {\n            # \"stroke\": True,\n            \"color\": \"#000000\",\n            \"weight\": 1,\n            \"opacity\": 1,\n            # \"fill\": True,\n            # \"fillColor\": \"#ffffff\",\n            \"fillOpacity\": 0.1,\n            # \"dashArray\": \"9\"\n            # \"clickable\": True,\n        }\n    elif \"weight\" not in style:\n        style[\"weight\"] = 1\n\n    if not hover_style:\n        hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n\n    def random_color(feature):\n        return {\n            \"color\": \"black\",\n            \"fillColor\": random.choice(fill_colors),\n        }\n\n    toolbar_button = widgets.ToggleButton(\n        value=True,\n        tooltip=\"Toolbar\",\n        icon=\"info\",\n        layout=widgets.Layout(\n            width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"\n        ),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        # button_style=\"primary\",\n        layout=widgets.Layout(\n            height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n        ),\n    )\n\n    html = widgets.HTML()\n    html.layout.margin = \"0px 10px 0px 10px\"\n    html.layout.max_height = \"250px\"\n    html.layout.max_width = \"250px\"\n\n    output_widget = widgets.VBox(\n        [widgets.HBox([toolbar_button, close_button]), html]\n    )\n    info_control = ipyleaflet.WidgetControl(\n        widget=output_widget, position=\"bottomright\"\n    )\n\n    if info_mode in [\"on_hover\", \"on_click\"]:\n        self.add_control(info_control)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            output_widget.children = [\n                widgets.VBox([widgets.HBox([toolbar_button, close_button]), html])\n            ]\n        else:\n            output_widget.children = [widgets.HBox([toolbar_button, close_button])]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if info_control in self.controls:\n                self.remove_control(info_control)\n            output_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def update_html(feature, **kwargs):\n        value = [\n            \"&lt;b&gt;{}: &lt;/b&gt;{}&lt;br&gt;\".format(prop, feature[\"properties\"][prop])\n            for prop in feature[\"properties\"].keys()\n        ][:-1]\n\n        value = \"\"\"{}\"\"\".format(\"\".join(value))\n        html.value = value\n\n    if style_callback is None:\n        style_callback = random_color\n\n    if style_callback_only:\n        geojson = ipyleaflet.GeoJSON(\n            data=data,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            name=layer_name,\n        )\n    else:\n        geojson = ipyleaflet.GeoJSON(\n            data=data,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            name=layer_name,\n        )\n\n    if info_mode == \"on_hover\":\n        geojson.on_hover(update_html)\n    elif info_mode == \"on_click\":\n        geojson.on_click(update_html)\n\n    self.add_layer(geojson)\n    self.geojson_layers.append(geojson)\n\n    if not hasattr(self, \"json_layer_dict\"):\n        self.json_layer_dict = {}\n\n    params = {\n        \"data\": geojson,\n        \"style\": style,\n        \"hover_style\": hover_style,\n        \"style_callback\": style_callback,\n    }\n    self.json_layer_dict[layer_name] = params\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', value='value', name='Heat map', radius=25, **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | list | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/world_cities.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>value</code> <code>str</code> <p>The column name of values. Defaults to \"value\".</p> <code>'value'</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>25</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data is not a list.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_heatmap(\n    self,\n    data,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"value\",\n    name=\"Heat map\",\n    radius=25,\n    **kwargs,\n):\n\"\"\"Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html\n\n    Args:\n        data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/world_cities.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        value (str, optional): The column name of values. Defaults to \"value\".\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n    Raises:\n        ValueError: If data is not a list.\n    \"\"\"\n    import pandas as pd\n    from ipyleaflet import Heatmap\n\n    try:\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n            data = df[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, pd.DataFrame):\n            data = data[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, list):\n            pass\n        else:\n            raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n        heatmap = Heatmap(locations=data, radius=radius, name=name, **kwargs)\n        self.add_layer(heatmap)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_html","title":"<code>add_html(self, html, position='bottomright', **kwargs)</code>","text":"<p>Add HTML to the map.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML to add.</p> required <code>position</code> <code>str</code> <p>The position of the HTML, can be one of \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_html(self, html, position=\"bottomright\", **kwargs):\n\"\"\"Add HTML to the map.\n\n    Args:\n        html (str): The HTML to add.\n        position (str, optional): The position of the HTML, can be one of \"topleft\",\n            \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n    \"\"\"\n    self.add_widget(html, position=position, **kwargs)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_image","title":"<code>add_image(self, image, position='bottomright', **kwargs)</code>","text":"<p>Add an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | ipywidgets.Image</code> <p>The image to add.</p> required <code>position</code> <code>str</code> <p>The position of the image, can be one of \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_image(self, image, position=\"bottomright\", **kwargs):\n\"\"\"Add an image to the map.\n\n    Args:\n        image (str | ipywidgets.Image): The image to add.\n        position (str, optional): The position of the image, can be one of \"topleft\",\n            \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n\n    \"\"\"\n\n    if isinstance(image, str):\n        if image.startswith(\"http\"):\n            image = widgets.Image(value=requests.get(image).content, **kwargs)\n        elif os.path.exists(image):\n            with open(image, \"rb\") as f:\n                image = widgets.Image(value=f.read(), **kwargs)\n    elif isinstance(image, widgets.Image):\n        pass\n    else:\n        raise Exception(\"Invalid image\")\n\n    self.add_widget(image, position=position)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_kml","title":"<code>add_kml(self, in_kml, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The input file path to the KML.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided KML file could not be found.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_kml(\n    self,\n    in_kml,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        in_kml (str): The input file path to the KML.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    Raises:\n        FileNotFoundError: The provided KML file could not be found.\n    \"\"\"\n\n    if isinstance(in_kml, str) and in_kml.startswith(\"http\"):\n        in_kml = github_raw_url(in_kml)\n        in_kml = download_file(in_kml)\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The provided KML file could not be found.\")\n    self.add_vector(\n        in_kml,\n        layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_labels","title":"<code>add_labels(self, data, column, font_size='12pt', font_color='black', font_family='arial', font_weight='normal', x='longitude', y='latitude', draggable=True, layer_name='Labels', **kwargs)</code>","text":"<p>Adds a label layer to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/divicon.html</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame | ee.FeatureCollection</code> <p>The input data to label.</p> required <code>column</code> <code>str</code> <p>The column name of the data to label.</p> required <code>font_size</code> <code>str</code> <p>The font size of the labels. Defaults to \"12pt\".</p> <code>'12pt'</code> <code>font_color</code> <code>str</code> <p>The font color of the labels. Defaults to \"black\".</p> <code>'black'</code> <code>font_family</code> <code>str</code> <p>The font family of the labels. Defaults to \"arial\".</p> <code>'arial'</code> <code>font_weight</code> <code>str</code> <p>The font weight of the labels, can be normal, bold. Defaults to \"normal\".</p> <code>'normal'</code> <code>x</code> <code>str</code> <p>The column name of the longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name of the latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>draggable</code> <code>bool</code> <p>Whether the labels are draggable. Defaults to True.</p> <code>True</code> <code>layer_name</code> <code>str</code> <p>Layer name to use. Defaults to \"Labels\".</p> <code>'Labels'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_labels(\n    self,\n    data,\n    column,\n    font_size=\"12pt\",\n    font_color=\"black\",\n    font_family=\"arial\",\n    font_weight=\"normal\",\n    x=\"longitude\",\n    y=\"latitude\",\n    draggable=True,\n    layer_name=\"Labels\",\n    **kwargs,\n):\n\"\"\"Adds a label layer to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/divicon.html\n\n    Args:\n        data (pd.DataFrame | ee.FeatureCollection): The input data to label.\n        column (str): The column name of the data to label.\n        font_size (str, optional): The font size of the labels. Defaults to \"12pt\".\n        font_color (str, optional): The font color of the labels. Defaults to \"black\".\n        font_family (str, optional): The font family of the labels. Defaults to \"arial\".\n        font_weight (str, optional): The font weight of the labels, can be normal, bold. Defaults to \"normal\".\n        x (str, optional): The column name of the longitude. Defaults to \"longitude\".\n        y (str, optional): The column name of the latitude. Defaults to \"latitude\".\n        draggable (bool, optional): Whether the labels are draggable. Defaults to True.\n        layer_name (str, optional): Layer name to use. Defaults to \"Labels\".\n\n    \"\"\"\n    import warnings\n    import pandas as pd\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(data, ee.FeatureCollection):\n        centroids = vector_centroids(data)\n        df = ee_to_df(centroids)\n    elif isinstance(data, pd.DataFrame):\n        df = data\n    elif isinstance(data, str):\n        ext = os.path.splitext(data)[1]\n        if ext == \".csv\":\n            df = pd.read_csv(data)\n        elif ext in [\".geojson\", \".json\", \".shp\", \".gpkg\"]:\n            try:\n                import geopandas as gpd\n\n                df = gpd.read_file(data)\n                df[x] = df.centroid.x\n                df[y] = df.centroid.y\n            except Exception as _:\n                print(\"geopandas is required to read geojson.\")\n                return\n\n    else:\n        raise ValueError(\"data must be a DataFrame or an ee.FeatureCollection.\")\n\n    if column not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n    if x not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n    if y not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n\n    try:\n        size = int(font_size.replace(\"pt\", \"\"))\n    except:\n        raise ValueError(\"font_size must be something like '10pt'\")\n\n    labels = []\n    for index in df.index:\n        html = f'&lt;div style=\"font-size: {font_size};color:{font_color};font-family:{font_family};font-weight: {font_weight}\"&gt;{df[column][index]}&lt;/div&gt;'\n        marker = ipyleaflet.Marker(\n            location=[df[y][index], df[x][index]],\n            icon=ipyleaflet.DivIcon(\n                icon_size=(1, 1),\n                icon_anchor=(size, size),\n                html=html,\n                **kwargs,\n            ),\n            draggable=draggable,\n        )\n        labels.append(marker)\n    layer_group = ipyleaflet.LayerGroup(layers=labels, name=layer_name)\n    self.add_layer(layer_group)\n    self.labels = layer_group\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_landsat_ts_gif","title":"<code>add_landsat_ts_gif(self, layer_name='Timelapse', roi=None, label=None, start_year=1984, end_year=2021, start_date='06-10', end_date='09-20', bands=['NIR', 'Red', 'Green'], vis_params=None, dimensions=768, frames_per_second=10, font_size=30, font_color='white', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, out_gif=None, download=False, apply_fmask=True, nd_bands=None, nd_threshold=0, nd_palette=['black', 'blue'])</code>","text":"<p>Adds a Landsat timelapse to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>str</code> <p>Layer name to show under the layer control. Defaults to 'Timelapse'.</p> <code>'Timelapse'</code> <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to None.</p> <code>None</code> <code>label</code> <code>str</code> <p>A label to show on the GIF, such as place name. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 1984.</p> <code>1984</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to 2021.</p> <code>2021</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.</p> <code>'06-10'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.</p> <code>'09-20'</code> <code>bands</code> <code>list</code> <p>Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green'].</p> <code>['NIR', 'Red', 'Green']</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters. Defaults to None.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> <code>10</code> <code>font_size</code> <code>int</code> <p>Font size of the animated text and label. Defaults to 30.</p> <code>30</code> <code>font_color</code> <code>str</code> <p>Font color of the animated text and label. Defaults to 'black'.</p> <code>'white'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>out_gif</code> <code>str</code> <p>File path to the output animated GIF. Defaults to None.</p> <code>None</code> <code>download</code> <code>bool</code> <p>Whether to download the gif. Defaults to False.</p> <code>False</code> <code>apply_fmask</code> <code>bool</code> <p>Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.</p> <code>True</code> <code>nd_bands</code> <code>list</code> <p>A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1).</p> <code>None</code> <code>nd_threshold</code> <code>float</code> <p>The threshold for extacting pixels from the normalized difference band.</p> <code>0</code> <code>nd_palette</code> <code>str</code> <p>The color palette to use for displaying the normalized difference band.</p> <code>['black', 'blue']</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_landsat_ts_gif(\n    self,\n    layer_name=\"Timelapse\",\n    roi=None,\n    label=None,\n    start_year=1984,\n    end_year=2021,\n    start_date=\"06-10\",\n    end_date=\"09-20\",\n    bands=[\"NIR\", \"Red\", \"Green\"],\n    vis_params=None,\n    dimensions=768,\n    frames_per_second=10,\n    font_size=30,\n    font_color=\"white\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    out_gif=None,\n    download=False,\n    apply_fmask=True,\n    nd_bands=None,\n    nd_threshold=0,\n    nd_palette=[\"black\", \"blue\"],\n):\n\"\"\"Adds a Landsat timelapse to the map.\n\n    Args:\n        layer_name (str, optional): Layer name to show under the layer control. Defaults to 'Timelapse'.\n        roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n        label (str, optional): A label to show on the GIF, such as place name. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 1984.\n        end_year (int, optional): Ending year for the timelapse. Defaults to 2021.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.\n        bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green'].\n        vis_params (dict, optional): Visualization parameters. Defaults to None.\n        dimensions (int, optional): a number or pair of numbers in format WIDTHxHEIGHT) Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        font_size (int, optional): Font size of the animated text and label. Defaults to 30.\n        font_color (str, optional): Font color of the animated text and label. Defaults to 'black'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        out_gif (str, optional): File path to the output animated GIF. Defaults to None.\n        download (bool, optional): Whether to download the gif. Defaults to False.\n        apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.\n        nd_bands (list, optional): A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1).\n        nd_threshold (float, optional): The threshold for extacting pixels from the normalized difference band.\n        nd_palette (str, optional): The color palette to use for displaying the normalized difference band.\n\n    \"\"\"\n    try:\n        if roi is None:\n            if self.draw_last_feature is not None:\n                feature = self.draw_last_feature\n                roi = feature.geometry()\n            else:\n                roi = ee.Geometry.Polygon(\n                    [\n                        [\n                            [-115.471773, 35.892718],\n                            [-115.471773, 36.409454],\n                            [-114.271283, 36.409454],\n                            [-114.271283, 35.892718],\n                            [-115.471773, 35.892718],\n                        ]\n                    ],\n                    None,\n                    False,\n                )\n        elif isinstance(roi, ee.Feature) or isinstance(roi, ee.FeatureCollection):\n            roi = roi.geometry()\n        elif isinstance(roi, ee.Geometry):\n            pass\n        else:\n            print(\"The provided roi is invalid. It must be an ee.Geometry\")\n            return\n\n        geojson = ee_to_geojson(roi)\n        bounds = minimum_bounding_box(geojson)\n        geojson = adjust_longitude(geojson)\n        roi = ee.Geometry(geojson)\n\n        in_gif = landsat_timelapse(\n            roi=roi,\n            out_gif=out_gif,\n            start_year=start_year,\n            end_year=end_year,\n            start_date=start_date,\n            end_date=end_date,\n            bands=bands,\n            vis_params=vis_params,\n            dimensions=dimensions,\n            frames_per_second=frames_per_second,\n            apply_fmask=apply_fmask,\n            nd_bands=nd_bands,\n            nd_threshold=nd_threshold,\n            nd_palette=nd_palette,\n            font_size=font_size,\n            font_color=font_color,\n            progress_bar_color=progress_bar_color,\n            progress_bar_height=progress_bar_height,\n        )\n        in_nd_gif = in_gif.replace(\".gif\", \"_nd.gif\")\n\n        if nd_bands is not None:\n            add_text_to_gif(\n                in_nd_gif,\n                in_nd_gif,\n                xy=(\"2%\", \"2%\"),\n                text_sequence=start_year,\n                font_size=font_size,\n                font_color=font_color,\n                duration=int(1000 / frames_per_second),\n                add_progress_bar=add_progress_bar,\n                progress_bar_color=progress_bar_color,\n                progress_bar_height=progress_bar_height,\n            )\n\n        if label is not None:\n            add_text_to_gif(\n                in_gif,\n                in_gif,\n                xy=(\"2%\", \"90%\"),\n                text_sequence=label,\n                font_size=font_size,\n                font_color=font_color,\n                duration=int(1000 / frames_per_second),\n                add_progress_bar=add_progress_bar,\n                progress_bar_color=progress_bar_color,\n                progress_bar_height=progress_bar_height,\n            )\n            # if nd_bands is not None:\n            #     add_text_to_gif(in_nd_gif, in_nd_gif, xy=('2%', '90%'), text_sequence=label,\n            #                     font_size=font_size, font_color=font_color, duration=int(1000 / frames_per_second), add_progress_bar=add_progress_bar, progress_bar_color=progress_bar_color, progress_bar_height=progress_bar_height)\n\n        if is_tool(\"ffmpeg\"):\n            reduce_gif_size(in_gif)\n            if nd_bands is not None:\n                reduce_gif_size(in_nd_gif)\n\n        print(\"Adding GIF to the map ...\")\n        self.image_overlay(url=in_gif, bounds=bounds, name=layer_name)\n        if nd_bands is not None:\n            self.image_overlay(\n                url=in_nd_gif, bounds=bounds, name=layer_name + \" ND\"\n            )\n        print(\"The timelapse has been added to the map.\")\n\n        if download:\n            link = create_download_link(\n                in_gif,\n                title=\"Click here to download the Landsat timelapse: \",\n            )\n            display(link)\n            if nd_bands is not None:\n                link2 = create_download_link(\n                    in_nd_gif,\n                    title=\"Click here to download the Normalized Difference Index timelapse: \",\n                )\n                display(link2)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds the layer control to the map.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_layer_control(self):\n\"\"\"Adds the layer control to the map.\"\"\"\n    if self.layer_control is None:\n        layer_control = ipyleaflet.LayersControl(position=\"topright\")\n        self.layer_control = layer_control\n        self.add_control(layer_control)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_legend","title":"<code>add_legend(self, title='Legend', legend_dict=None, labels=None, colors=None, position='bottomright', builtin_legend=None, layer_name=None, **kwargs)</code>","text":"<p>Adds a customized basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the legend. Defaults to 'Legend'.</p> <code>'Legend'</code> <code>legend_dict</code> <code>dict</code> <p>A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of legend keys. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of legend colors. Defaults to None.</p> <code>None</code> <code>position</code> <code>str</code> <p>Position of the legend. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>builtin_legend</code> <code>str</code> <p>Name of the builtin legend to add to the map. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>Layer name of the legend to be associated with. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_legend(\n    self,\n    title=\"Legend\",\n    legend_dict=None,\n    labels=None,\n    colors=None,\n    position=\"bottomright\",\n    builtin_legend=None,\n    layer_name=None,\n    **kwargs,\n):\n\"\"\"Adds a customized basemap to the map.\n\n    Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'.\n        legend_dict (dict, optional): A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n        labels (list, optional): A list of legend keys. Defaults to None.\n        colors (list, optional): A list of legend colors. Defaults to None.\n        position (str, optional): Position of the legend. Defaults to 'bottomright'.\n        builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n        layer_name (str, optional): Layer name of the legend to be associated with. Defaults to None.\n\n    \"\"\"\n    from IPython.display import display\n\n    pkg_dir = os.path.dirname(\n        pkg_resources.resource_filename(\"geemap\", \"geemap.py\")\n    )\n    legend_template = os.path.join(pkg_dir, \"data/template/legend.html\")\n\n    if \"min_width\" not in kwargs.keys():\n        min_width = None\n    if \"max_width\" not in kwargs.keys():\n        max_width = None\n    else:\n        max_width = kwargs[\"max_width\"]\n    if \"min_height\" not in kwargs.keys():\n        min_height = None\n    else:\n        min_height = kwargs[\"min_height\"]\n    if \"max_height\" not in kwargs.keys():\n        max_height = None\n    else:\n        max_height = kwargs[\"max_height\"]\n    if \"height\" not in kwargs.keys():\n        height = None\n    else:\n        height = kwargs[\"height\"]\n    if \"width\" not in kwargs.keys():\n        width = None\n    else:\n        width = kwargs[\"width\"]\n\n    if width is None:\n        max_width = \"300px\"\n    if height is None:\n        max_height = \"400px\"\n\n    if not os.path.exists(legend_template):\n        print(\"The legend template does not exist.\")\n        return\n\n    if labels is not None:\n        if not isinstance(labels, list):\n            print(\"The legend keys must be a list.\")\n            return\n    else:\n        labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n\n    if colors is not None:\n        if not isinstance(colors, list):\n            print(\"The legend colors must be a list.\")\n            return\n        elif all(isinstance(item, tuple) for item in colors):\n            try:\n                colors = [rgb_to_hex(x) for x in colors]\n            except Exception as e:\n                print(e)\n        elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n            pass\n        elif all((len(item) == 6) for item in colors):\n            pass\n        else:\n            print(\"The legend colors must be a list of tuples.\")\n            return\n    else:\n        colors = [\n            \"#8DD3C7\",\n            \"#FFFFB3\",\n            \"#BEBADA\",\n            \"#FB8072\",\n            \"#80B1D3\",\n        ]\n\n    if len(labels) != len(colors):\n        print(\"The legend keys and values must be the same length.\")\n        return\n\n    allowed_builtin_legends = builtin_legends.keys()\n    if builtin_legend is not None:\n        if builtin_legend not in allowed_builtin_legends:\n            print(\n                \"The builtin legend must be one of the following: {}\".format(\n                    \", \".join(allowed_builtin_legends)\n                )\n            )\n            return\n        else:\n            legend_dict = builtin_legends[builtin_legend]\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n\n    if legend_dict is not None:\n        if not isinstance(legend_dict, dict):\n            print(\"The legend dict must be a dictionary.\")\n            return\n        else:\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n            if all(isinstance(item, tuple) for item in colors):\n                try:\n                    colors = [rgb_to_hex(x) for x in colors]\n                except Exception as e:\n                    print(e)\n\n    allowed_positions = [\n        \"topleft\",\n        \"topright\",\n        \"bottomleft\",\n        \"bottomright\",\n    ]\n    if position not in allowed_positions:\n        print(\n            \"The position must be one of the following: {}\".format(\n                \", \".join(allowed_positions)\n            )\n        )\n        return\n\n    header = []\n    content = []\n    footer = []\n\n    with open(legend_template) as f:\n        lines = f.readlines()\n        lines[3] = lines[3].replace(\"Legend\", title)\n        header = lines[:6]\n        footer = lines[11:]\n\n    for index, key in enumerate(labels):\n        color = colors[index]\n        if not color.startswith(\"#\"):\n            color = \"#\" + color\n        item = \"      &lt;li&gt;&lt;span style='background:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n            color, key\n        )\n        content.append(item)\n\n    legend_html = header + content + footer\n    legend_text = \"\".join(legend_html)\n\n    try:\n        legend_output_widget = widgets.Output(\n            layout={\n                # \"border\": \"1px solid black\",\n                \"max_width\": max_width,\n                \"min_width\": min_width,\n                \"max_height\": max_height,\n                \"min_height\": min_height,\n                \"height\": height,\n                \"width\": width,\n                \"overflow\": \"scroll\",\n            }\n        )\n        legend_control = ipyleaflet.WidgetControl(\n            widget=legend_output_widget, position=position\n        )\n        legend_widget = widgets.HTML(value=legend_text)\n        with legend_output_widget:\n            display(legend_widget)\n\n        self.legend_widget = legend_output_widget\n        self.legend_control = legend_control\n        self.add_control(legend_control)\n\n        if not hasattr(self, \"legends\"):\n            setattr(self, \"legends\", [legend_control])\n        else:\n            self.legends.append(legend_control)\n\n        if layer_name in self.ee_layer_names:\n            self.ee_layer_dict[layer_name][\"legend\"] = legend_control\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_local_tile","title":"<code>add_local_tile(self, source, band=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name=None, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.</p> <pre><code>If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\nrunning the following two lines before calling this function:\n\nimport os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>band</code> <code>int</code> <p>The band to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_raster(\n    self,\n    source,\n    band=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=None,\n    **kwargs,\n):\n\"\"\"Add a local raster dataset to the map.\n\n        If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\n        running the following two lines before calling this function:\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n    \"\"\"\n\n    if in_colab_shell():\n        print(\"This add_raster() function is not supported in Colab.\")\n        return\n\n    tile_layer, tile_client = get_local_tile_layer(\n        source,\n        band=band,\n        palette=palette,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        return_client=True,\n        **kwargs,\n    )\n\n    self.add_layer(tile_layer)\n\n    output = widgets.Output()\n\n    with output:\n        bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n        bounds = (\n            bounds[2],\n            bounds[0],\n            bounds[3],\n            bounds[1],\n        )  # [minx, miny, maxx, maxy]\n        self.zoom_to_bounds(bounds)\n\n    if not hasattr(self, \"cog_layer_dict\"):\n        self.cog_layer_dict = {}\n    band_names = list(tile_client.metadata()[\"bands\"].keys())\n    params = {\n        \"tile_layer\": tile_layer,\n        \"tile_client\": tile_client,\n        \"band\": band,\n        \"band_names\": band_names,\n        \"bounds\": bounds,\n        \"type\": \"LOCAL\",\n    }\n    self.cog_layer_dict[layer_name] = params\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_marker","title":"<code>add_marker(self, location, **kwargs)</code>","text":"<p>Adds a marker to the map. More info about marker at https://ipyleaflet.readthedocs.io/en/latest/api_reference/marker.html.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>list | tuple</code> <p>The location of the marker in the format of [lat, lng].</p> required <code>**kwargs</code> <p>Keyword arguments for the marker.</p> <code>{}</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_marker(self, location, **kwargs):\n\"\"\"Adds a marker to the map. More info about marker at https://ipyleaflet.readthedocs.io/en/latest/api_reference/marker.html.\n\n    Args:\n        location (list | tuple): The location of the marker in the format of [lat, lng].\n\n        **kwargs: Keyword arguments for the marker.\n    \"\"\"\n    if isinstance(location, list):\n        location = tuple(location)\n    if isinstance(location, tuple):\n        marker = ipyleaflet.Marker(location=location, **kwargs)\n        self.add_layer(marker)\n    else:\n        raise TypeError(\"The location must be a list or a tuple.\")\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_marker_cluster","title":"<code>add_marker_cluster(self, event='click', add_marker=True)</code>","text":"<p>Captures user inputs and add markers to the map.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>[description]. Defaults to 'click'.</p> <code>'click'</code> <code>add_marker</code> <code>bool</code> <p>If True, add markers to the map. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>object</code> <p>a marker cluster.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_marker_cluster(self, event=\"click\", add_marker=True):\n\"\"\"Captures user inputs and add markers to the map.\n\n    Args:\n        event (str, optional): [description]. Defaults to 'click'.\n        add_marker (bool, optional): If True, add markers to the map. Defaults to True.\n\n    Returns:\n        object: a marker cluster.\n    \"\"\"\n    coordinates = []\n    markers = []\n    marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n    self.last_click = []\n    self.all_clicks = []\n    if add_marker:\n        self.add_layer(marker_cluster)\n\n    def handle_interaction(**kwargs):\n        latlon = kwargs.get(\"coordinates\")\n\n        if event == \"click\" and kwargs.get(\"type\") == \"click\":\n            coordinates.append(latlon)\n            self.last_click = latlon\n            self.all_clicks = coordinates\n            if add_marker:\n                markers.append(ipyleaflet.Marker(location=latlon))\n                marker_cluster.markers = markers\n        elif kwargs.get(\"type\") == \"mousemove\":\n            pass\n\n    # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp\n    self.default_style = {\"cursor\": \"crosshair\"}\n    self.on_interaction(handle_interaction)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_minimap","title":"<code>add_minimap(self, zoom=5, position='bottomright')</code>","text":"<p>Adds a minimap (overview) to the ipyleaflet map.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>Initial map zoom level. Defaults to 5.</p> <code>5</code> <code>position</code> <code>str</code> <p>Position of the minimap. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_minimap(self, zoom=5, position=\"bottomright\"):\n\"\"\"Adds a minimap (overview) to the ipyleaflet map.\n\n    Args:\n        zoom (int, optional): Initial map zoom level. Defaults to 5.\n        position (str, optional): Position of the minimap. Defaults to \"bottomright\".\n    \"\"\"\n    minimap = ipyleaflet.Map(\n        zoom_control=False,\n        attribution_control=False,\n        zoom=zoom,\n        center=self.center,\n        layers=[basemaps[\"ROADMAP\"]],\n    )\n    minimap.layout.width = \"150px\"\n    minimap.layout.height = \"150px\"\n    ipyleaflet.link((minimap, \"center\"), (self, \"center\"))\n    minimap_control = ipyleaflet.WidgetControl(widget=minimap, position=position)\n    self.add_control(minimap_control)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_netcdf","title":"<code>add_netcdf(self, filename, variables=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='NetCDF layer', shift_lon=True, lat='lat', lon='lon', **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a netCDF file.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),     try adding to following two lines to the beginning of the notebook if the raster does not render properly.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netCDF file.</p> required <code>variables</code> <code>int</code> <p>The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> required <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"netCDF layer\".</p> <code>'NetCDF layer'</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_netcdf(\n    self,\n    filename,\n    variables=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=\"NetCDF layer\",\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    **kwargs,\n):\n\"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n        try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n    Args:\n        filename (str): File path or HTTP URL to the netCDF file.\n        variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to \"netCDF layer\".\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n    \"\"\"\n\n    if in_colab_shell():\n        print(\"The add_netcdf() function is not supported in Colab.\")\n        return\n\n    tif, vars = netcdf_to_tif(\n        filename, shift_lon=shift_lon, lat=lat, lon=lon, return_vars=True\n    )\n\n    if variables is None:\n        if len(vars) &gt;= 3:\n            band_idx = [1, 2, 3]\n        else:\n            band_idx = [1]\n    else:\n        if not set(variables).issubset(set(vars)):\n            raise ValueError(f\"The variables must be a subset of {vars}.\")\n        else:\n            band_idx = [vars.index(v) + 1 for v in variables]\n\n    self.add_raster(\n        tif,\n        band=band_idx,\n        palette=palette,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_osm","title":"<code>add_osm(self, query, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', which_result=None, by_osmid=False, buffer_dist=None, to_ee=False, geodesic=True)</code>","text":"<p>Adds OSM data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>which_result</code> <code>INT</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>to_ee</code> <code>bool</code> <p>Whether to convert the csv to an ee.FeatureCollection.</p> <code>False</code> <code>geodesic</code> <code>bool</code> <p>Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_osm(\n    self,\n    query,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n    to_ee=False,\n    geodesic=True,\n):\n\"\"\"Adds OSM data to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        to_ee (bool, optional): Whether to convert the csv to an ee.FeatureCollection.\n        geodesic (bool, optional): Whether line segments should be interpreted as spherical geodesics. If false, indicates that line segments should be interpreted as planar lines in the specified CRS. If absent, defaults to true if the CRS is geographic (including the default EPSG:4326), or to false if the CRS is projected.\n\n    \"\"\"\n\n    gdf = osm_to_gdf(\n        query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n    )\n    geojson = gdf.__geo_interface__\n\n    if to_ee:\n        fc = geojson_to_ee(geojson, geodesic=geodesic)\n        self.addLayer(fc, {}, layer_name)\n        self.zoomToObject(fc)\n    else:\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        bounds = gdf.bounds.iloc[0]\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_osm_from_address","title":"<code>add_osm_from_address(self, address, tags, dist=1000, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within some distance N, S, E, W of address to the map.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_osm_from_address(\n    self,\n    address,\n    tags,\n    dist=1000,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within some distance N, S, E, W of address to the map.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_address(address, tags, dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_osm_from_bbox","title":"<code>add_osm_from_bbox(self, north, south, east, west, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within a N, S, E, W bounding box to the map.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_osm_from_bbox(\n    self,\n    north,\n    south,\n    east,\n    west,\n    tags,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within a N, S, E, W bounding box to the map.\n\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_osm_from_geocode","title":"<code>add_osm_from_geocode(self, query, which_result=None, by_osmid=False, buffer_dist=None, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM data of place(s) by name or ID to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_osm_from_geocode(\n    self,\n    query,\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM data of place(s) by name or ID to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n\n    gdf = osm_gdf_from_geocode(\n        query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n    )\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_osm_from_place","title":"<code>add_osm_from_place(self, query, tags, which_result=None, buffer_dist=None, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within boundaries of geocodable place(s) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_osm_from_place(\n    self,\n    query,\n    tags,\n    which_result=None,\n    buffer_dist=None,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within boundaries of geocodable place(s) to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_osm_from_point","title":"<code>add_osm_from_point(self, center_point, tags, dist=1000, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within some distance N, S, E, W of a point to the map.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_osm_from_point(\n    self,\n    center_point,\n    tags,\n    dist=1000,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within some distance N, S, E, W of a point to the map.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_point(center_point, tags, dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_osm_from_polygon","title":"<code>add_osm_from_polygon(self, polygon, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within boundaries of a (multi)polygon to the map.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_osm_from_polygon(\n    self,\n    polygon,\n    tags,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within boundaries of a (multi)polygon to the map.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_polygon(polygon, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_osm_from_view","title":"<code>add_osm_from_view(self, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within the current map view to the map.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_osm_from_view(\n    self,\n    tags,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n\"\"\"Adds OSM entities within the current map view to the map.\n\n    Args:\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    bounds = self.bounds\n    if len(bounds) == 0:\n        bounds = (\n            (40.74824858675827, -73.98933637940563),\n            (40.75068694343106, -73.98364473187601),\n        )\n    north, south, east, west = (\n        bounds[1][0],\n        bounds[0][0],\n        bounds[1][1],\n        bounds[0][1],\n    )\n\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_planet_by_month","title":"<code>add_planet_by_month(self, year=2016, month=1, name=None, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_planet_by_month(\n    self, year=2016, month=1, name=None, api_key=None, token_name=\"PLANET_API_KEY\"\n):\n\"\"\"Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n    \"\"\"\n    layer = planet_tile_by_month(year, month, name, api_key, token_name)\n    self.add_layer(layer)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_planet_by_quarter","title":"<code>add_planet_by_quarter(self, year=2016, quarter=1, name=None, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_planet_by_quarter(\n    self, year=2016, quarter=1, name=None, api_key=None, token_name=\"PLANET_API_KEY\"\n):\n\"\"\"Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-12. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n    \"\"\"\n    layer = planet_tile_by_quarter(year, quarter, name, api_key, token_name)\n    self.add_layer(layer)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_point_layer","title":"<code>add_point_layer(self, filename, popup=None, layer_name='Marker Cluster', **kwargs)</code>","text":"<p>Adds a point layer to the map with a popup attribute.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>str, http url, path object or file-like object. Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO)</p> required <code>popup</code> <code>str | list</code> <p>Column name(s) to be used for popup. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>A layer name to use. Defaults to \"Marker Cluster\".</p> <code>'Marker Cluster'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the specified column name does not exist.</p> <code>ValueError</code> <p>If the specified column names do not exist.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_point_layer(\n    self, filename, popup=None, layer_name=\"Marker Cluster\", **kwargs\n):\n\"\"\"Adds a point layer to the map with a popup attribute.\n\n    Args:\n        filename (str): str, http url, path object or file-like object. Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO)\n        popup (str | list, optional): Column name(s) to be used for popup. Defaults to None.\n        layer_name (str, optional): A layer name to use. Defaults to \"Marker Cluster\".\n\n    Raises:\n        ValueError: If the specified column name does not exist.\n        ValueError: If the specified column names do not exist.\n    \"\"\"\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n\n    self.default_style = {\"cursor\": \"wait\"}\n\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".kml\":\n        gpd.io.file.fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n        gdf = gpd.read_file(filename, driver=\"KML\", **kwargs)\n    else:\n        gdf = gpd.read_file(filename, **kwargs)\n    df = gdf.to_crs(epsg=\"4326\")\n    col_names = df.columns.values.tolist()\n    if popup is not None:\n        if isinstance(popup, str) and (popup not in col_names):\n            raise ValueError(\n                f\"popup must be one of the following: {', '.join(col_names)}\"\n            )\n        elif isinstance(popup, list) and (\n            not all(item in col_names for item in popup)\n        ):\n            raise ValueError(\n                f\"All popup items must be select from: {', '.join(col_names)}\"\n            )\n\n    df[\"x\"] = df.geometry.x\n    df[\"y\"] = df.geometry.y\n\n    points = list(zip(df[\"y\"], df[\"x\"]))\n\n    if popup is not None:\n        if isinstance(popup, str):\n            labels = df[popup]\n            markers = [\n                ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(str(labels[index])),\n                )\n                for index, point in enumerate(points)\n            ]\n        elif isinstance(popup, list):\n            labels = []\n            for i in range(len(points)):\n                label = \"\"\n                for item in popup:\n                    label = label + str(item) + \": \" + str(df[item][i]) + \"&lt;br&gt;\"\n                labels.append(label)\n            df[\"popup\"] = labels\n\n            markers = [\n                ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(labels[index]),\n                )\n                for index, point in enumerate(points)\n            ]\n\n    else:\n        markers = [\n            ipyleaflet.Marker(location=point, draggable=False) for point in points\n        ]\n\n    marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n    self.add_layer(marker_cluster)\n\n    self.default_style = {\"cursor\": \"default\"}\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_points_from_xy","title":"<code>add_points_from_xy(self, data, x='longitude', y='latitude', popup=None, layer_name='Marker Cluster', color_column=None, marker_colors=None, icon_colors=['white'], icon_names=['info'], spin=False, add_legend=True, **kwargs)</code>","text":"<p>Adds a marker cluster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"Marker Cluster\".</p> <code>'Marker Cluster'</code> <code>color_column</code> <code>str</code> <p>The column name for the color values. Defaults to None.</p> <code>None</code> <code>marker_colors</code> <code>list</code> <p>A list of colors to be used for the markers. Defaults to None.</p> <code>None</code> <code>icon_colors</code> <code>list</code> <p>A list of colors to be used for the icons. Defaults to ['white'].</p> <code>['white']</code> <code>icon_names</code> <code>list</code> <p>A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons. Defaults to ['info'].</p> <code>['info']</code> <code>spin</code> <code>bool</code> <p>If True, the icon will spin. Defaults to False.</p> <code>False</code> <code>add_legend</code> <code>bool</code> <p>If True, a legend will be added to the map. Defaults to True.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_points_from_xy(\n    self,\n    data,\n    x=\"longitude\",\n    y=\"latitude\",\n    popup=None,\n    layer_name=\"Marker Cluster\",\n    color_column=None,\n    marker_colors=None,\n    icon_colors=[\"white\"],\n    icon_names=[\"info\"],\n    spin=False,\n    add_legend=True,\n    **kwargs,\n):\n\"\"\"Adds a marker cluster to the map.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n        color_column (str, optional): The column name for the color values. Defaults to None.\n        marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n        icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n        icon_names (list, optional): A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons. Defaults to ['info'].\n        spin (bool, optional): If True, the icon will spin. Defaults to False.\n        add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n\n    \"\"\"\n    import pandas as pd\n\n    data = github_raw_url(data)\n\n    color_options = [\n        \"red\",\n        \"blue\",\n        \"green\",\n        \"purple\",\n        \"orange\",\n        \"darkred\",\n        \"lightred\",\n        \"beige\",\n        \"darkblue\",\n        \"darkgreen\",\n        \"cadetblue\",\n        \"darkpurple\",\n        \"white\",\n        \"pink\",\n        \"lightblue\",\n        \"lightgreen\",\n        \"gray\",\n        \"black\",\n        \"lightgray\",\n    ]\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    else:\n        df = pd.read_csv(data)\n\n    df = points_from_xy(df, x, y)\n\n    col_names = df.columns.values.tolist()\n\n    if color_column is not None and color_column not in col_names:\n        raise ValueError(\n            f\"The color column {color_column} does not exist in the dataframe.\"\n        )\n\n    if color_column is not None:\n        items = list(set(df[color_column]))\n\n    else:\n        items = None\n\n    if color_column is not None and marker_colors is None:\n        if len(items) &gt; len(color_options):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n            )\n        else:\n            marker_colors = color_options[: len(items)]\n    elif color_column is not None and marker_colors is not None:\n        if len(items) != len(marker_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if items is not None:\n        if len(icon_colors) == 1:\n            icon_colors = icon_colors * len(items)\n        elif len(items) != len(icon_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n        if len(icon_names) == 1:\n            icon_names = icon_names * len(items)\n        elif len(items) != len(icon_names):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if \"geometry\" in col_names:\n        col_names.remove(\"geometry\")\n\n    if popup is not None:\n        if isinstance(popup, str) and (popup not in col_names):\n            raise ValueError(\n                f\"popup must be one of the following: {', '.join(col_names)}\"\n            )\n        elif isinstance(popup, list) and (\n            not all(item in col_names for item in popup)\n        ):\n            raise ValueError(\n                f\"All popup items must be select from: {', '.join(col_names)}\"\n            )\n    else:\n        popup = col_names\n\n    df[\"x\"] = df.geometry.x\n    df[\"y\"] = df.geometry.y\n\n    points = list(zip(df[\"y\"], df[\"x\"]))\n\n    if popup is not None:\n        if isinstance(popup, str):\n            labels = df[popup]\n\n            markers = []\n            for index, point in enumerate(points):\n                if items is not None:\n                    marker_color = marker_colors[\n                        items.index(df[color_column][index])\n                    ]\n                    icon_name = icon_names[items.index(df[color_column][index])]\n                    icon_color = icon_colors[items.index(df[color_column][index])]\n                    marker_icon = ipyleaflet.AwesomeIcon(\n                        name=icon_name,\n                        marker_color=marker_color,\n                        icon_color=icon_color,\n                        spin=spin,\n                    )\n                else:\n                    marker_icon = None\n\n                marker = ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(str(labels[index])),\n                    icon=marker_icon,\n                )\n                markers.append(marker)\n\n        elif isinstance(popup, list):\n            labels = []\n            for i in range(len(points)):\n                label = \"\"\n                for item in popup:\n                    label = (\n                        label\n                        + \"&lt;b&gt;\"\n                        + str(item)\n                        + \"&lt;/b&gt;\"\n                        + \": \"\n                        + str(df[item][i])\n                        + \"&lt;br&gt;\"\n                    )\n                labels.append(label)\n            df[\"popup\"] = labels\n\n            markers = []\n            for index, point in enumerate(points):\n                if items is not None:\n                    marker_color = marker_colors[\n                        items.index(df[color_column][index])\n                    ]\n                    icon_name = icon_names[items.index(df[color_column][index])]\n                    icon_color = icon_colors[items.index(df[color_column][index])]\n                    marker_icon = ipyleaflet.AwesomeIcon(\n                        name=icon_name,\n                        marker_color=marker_color,\n                        icon_color=icon_color,\n                        spin=spin,\n                    )\n                else:\n                    marker_icon = None\n\n                marker = ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(labels[index]),\n                    icon=marker_icon,\n                )\n                markers.append(marker)\n\n    else:\n        markers = []\n        for point in points:\n            if items is not None:\n                marker_color = marker_colors[items.index(df[color_column][index])]\n                icon_name = icon_names[items.index(df[color_column][index])]\n                icon_color = icon_colors[items.index(df[color_column][index])]\n                marker_icon = ipyleaflet.AwesomeIcon(\n                    name=icon_name,\n                    marker_color=marker_color,\n                    icon_color=icon_color,\n                    spin=spin,\n                )\n            else:\n                marker_icon = None\n\n            marker = ipyleaflet.Marker(\n                location=point, draggable=False, icon=marker_icon\n            )\n            markers.append(marker)\n\n    marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n    self.add_layer(marker_cluster)\n\n    if items is not None and add_legend:\n        marker_colors = [check_color(c) for c in marker_colors]\n        self.add_legend(\n            title=color_column.title(), colors=marker_colors, labels=items\n        )\n\n    self.default_style = {\"cursor\": \"default\"}\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_raster","title":"<code>add_raster(self, source, band=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name=None, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.</p> <pre><code>If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\nrunning the following two lines before calling this function:\n\nimport os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>band</code> <code>int</code> <p>The band to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_raster(\n    self,\n    source,\n    band=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=None,\n    **kwargs,\n):\n\"\"\"Add a local raster dataset to the map.\n\n        If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\n        running the following two lines before calling this function:\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n    \"\"\"\n\n    if in_colab_shell():\n        print(\"This add_raster() function is not supported in Colab.\")\n        return\n\n    tile_layer, tile_client = get_local_tile_layer(\n        source,\n        band=band,\n        palette=palette,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        return_client=True,\n        **kwargs,\n    )\n\n    self.add_layer(tile_layer)\n\n    output = widgets.Output()\n\n    with output:\n        bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n        bounds = (\n            bounds[2],\n            bounds[0],\n            bounds[3],\n            bounds[1],\n        )  # [minx, miny, maxx, maxy]\n        self.zoom_to_bounds(bounds)\n\n    if not hasattr(self, \"cog_layer_dict\"):\n        self.cog_layer_dict = {}\n    band_names = list(tile_client.metadata()[\"bands\"].keys())\n    params = {\n        \"tile_layer\": tile_layer,\n        \"tile_client\": tile_client,\n        \"band\": band,\n        \"band_names\": band_names,\n        \"bounds\": bounds,\n        \"type\": \"LOCAL\",\n    }\n    self.cog_layer_dict[layer_name] = params\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_raster_legacy","title":"<code>add_raster_legacy(self, image, bands=None, layer_name=None, colormap=None, x_dim='x', y_dim='y')</code>","text":"<p>Adds a local raster dataset to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The image file path.</p> required <code>bands</code> <code>int or list</code> <p>The image bands to use. It can be either a number (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use for the raster. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None.</p> <code>None</code> <code>x_dim</code> <code>str</code> <p>The x dimension. Defaults to 'x'.</p> <code>'x'</code> <code>y_dim</code> <code>str</code> <p>The y dimension. Defaults to 'y'.</p> <code>'y'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_raster_legacy(\n    self,\n    image,\n    bands=None,\n    layer_name=None,\n    colormap=None,\n    x_dim=\"x\",\n    y_dim=\"y\",\n):\n\"\"\"Adds a local raster dataset to the map.\n\n    Args:\n        image (str): The image file path.\n        bands (int or list, optional): The image bands to use. It can be either a number (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None.\n        layer_name (str, optional): The layer name to use for the raster. Defaults to None.\n        colormap (str, optional): The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None.\n        x_dim (str, optional): The x dimension. Defaults to 'x'.\n        y_dim (str, optional): The y dimension. Defaults to 'y'.\n    \"\"\"\n    try:\n        import xarray_leaflet\n\n    except Exception:\n        # import platform\n        # if platform.system() != \"Windows\":\n        #     # install_from_github(\n        #     #     url='https://github.com/davidbrochart/xarray_leaflet')\n        #     check_install('xarray_leaflet')\n        #     import xarray_leaflet\n        # else:\n        raise ImportError(\n            \"You need to install xarray_leaflet first. See https://github.com/davidbrochart/xarray_leaflet\"\n        )\n\n    import warnings\n\n    # import xarray as xr\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import rioxarray\n\n    warnings.simplefilter(\"ignore\")\n\n    if not os.path.exists(image):\n        print(\"The image file does not exist.\")\n        return\n\n    if colormap is None:\n        colormap = plt.cm.inferno\n\n    if layer_name is None:\n        layer_name = \"Layer_\" + random_string()\n\n    if isinstance(colormap, str):\n        colormap = plt.cm.get_cmap(name=colormap)\n\n    da = rioxarray.open_rasterio(image, masked=True)\n\n    # print(da.rio.nodata)\n\n    multi_band = False\n    if len(da.band) &gt; 1:\n        multi_band = True\n        if bands is None:\n            bands = [3, 2, 1]\n    else:\n        bands = 1\n\n    if multi_band:\n        da = da.rio.write_nodata(0)\n    else:\n        da = da.rio.write_nodata(np.nan)\n    da = da.sel(band=bands)\n\n    # crs = da.rio.crs\n    # nan = da.attrs['nodatavals'][0]\n    # da = da / da.max()\n    # # if multi_band:\n    # da = xr.where(da == nan, np.nan, da)\n    # da = da.rio.write_nodata(0)\n    # da = da.rio.write_crs(crs)\n\n    if multi_band and type(bands) == list:\n        layer = da.leaflet.plot(self, x_dim=x_dim, y_dim=y_dim, rgb_dim=\"band\")\n    else:\n        layer = da.leaflet.plot(self, x_dim=x_dim, y_dim=y_dim, colormap=colormap)\n\n    layer.name = layer_name\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_remote_tile","title":"<code>add_remote_tile(self, source, band=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name=None, **kwargs)</code>","text":"<p>Add a remote Cloud Optimized GeoTIFF (COG) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the remote Cloud Optimized GeoTIFF.</p> required <code>band</code> <code>int</code> <p>The band to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_remote_tile(\n    self,\n    source,\n    band=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=None,\n    **kwargs,\n):\n\"\"\"Add a remote Cloud Optimized GeoTIFF (COG) to the map.\n\n    Args:\n        source (str): The path to the remote Cloud Optimized GeoTIFF.\n        band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n    \"\"\"\n    if isinstance(source, str) and source.startswith(\"http\"):\n        self.add_raster(\n            source,\n            band=band,\n            palette=palette,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            **kwargs,\n        )\n    else:\n        raise Exception(\"The source must be a URL.\")\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_shapefile","title":"<code>add_shapefile(self, in_shp, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', encoding='utf-8')</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input file path to the shapefile.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>encoding</code> <code>str</code> <p>The encoding of the shapefile. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shapefile could not be found.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_shp(\n    self,\n    in_shp,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    encoding=\"utf-8\",\n):\n\"\"\"Adds a shapefile to the map.\n\n    Args:\n        in_shp (str): The input file path to the shapefile.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding of the shapefile. Defaults to \"utf-8\".\n\n    Raises:\n        FileNotFoundError: The provided shapefile could not be found.\n    \"\"\"\n    in_shp = os.path.abspath(in_shp)\n    if not os.path.exists(in_shp):\n        raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n    geojson = shp_to_geojson(in_shp)\n    self.add_geojson(\n        geojson,\n        layer_name,\n        style,\n        hover_style,\n        style_callback,\n        fill_colors,\n        info_mode,\n        encoding,\n    )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_shp","title":"<code>add_shp(self, in_shp, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', encoding='utf-8')</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input file path to the shapefile.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>encoding</code> <code>str</code> <p>The encoding of the shapefile. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shapefile could not be found.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_shp(\n    self,\n    in_shp,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    encoding=\"utf-8\",\n):\n\"\"\"Adds a shapefile to the map.\n\n    Args:\n        in_shp (str): The input file path to the shapefile.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding of the shapefile. Defaults to \"utf-8\".\n\n    Raises:\n        FileNotFoundError: The provided shapefile could not be found.\n    \"\"\"\n    in_shp = os.path.abspath(in_shp)\n    if not os.path.exists(in_shp):\n        raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n    geojson = shp_to_geojson(in_shp)\n    self.add_geojson(\n        geojson,\n        layer_name,\n        style,\n        hover_style,\n        style_callback,\n        fill_colors,\n        info_mode,\n        encoding,\n    )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_stac_layer","title":"<code>add_stac_layer(self, url=None, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, name='STAC Layer', attribution='', opacity=1.0, shown=True, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'STAC Layer'.</p> <code>'STAC Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_stac_layer(\n    self,\n    url=None,\n    collection=None,\n    item=None,\n    assets=None,\n    bands=None,\n    titiler_endpoint=None,\n    name=\"STAC Layer\",\n    attribution=\"\",\n    opacity=1.0,\n    shown=True,\n    **kwargs,\n):\n\"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n    \"\"\"\n    tile_url = stac_tile(\n        url, collection, item, assets, bands, titiler_endpoint, **kwargs\n    )\n    bounds = stac_bounds(url, collection, item, titiler_endpoint)\n    self.add_tile_layer(tile_url, name, attribution, opacity, shown)\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    if not hasattr(self, \"cog_layer_dict\"):\n        self.cog_layer_dict = {}\n\n    if assets is None and bands is not None:\n        assets = bands\n\n    params = {\n        \"url\": url,\n        \"collection\": collection,\n        \"item\": item,\n        \"assets\": assets,\n        \"bounds\": bounds,\n        \"titiler_endpoint\": titiler_endpoint,\n        \"type\": \"STAC\",\n    }\n\n    self.cog_layer_dict[name] = params\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_styled_vector","title":"<code>add_styled_vector(self, ee_object, column, palette, layer_name='Untitled', **kwargs)</code>","text":"<p>Adds a styled vector to the map.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>An ee.FeatureCollection.</p> required <code>column</code> <code>str</code> <p>The column name to use for styling.</p> required <code>palette</code> <code>list | dict</code> <p>The palette (e.g., list of colors or a dict containing label and color pairs) to use for styling.</p> required <code>layer_name</code> <code>str</code> <p>The name to be used for the new layer. Defaults to \"Untitled\".</p> <code>'Untitled'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_styled_vector(\n    self, ee_object, column, palette, layer_name=\"Untitled\", **kwargs\n):\n\"\"\"Adds a styled vector to the map.\n\n    Args:\n        ee_object (object): An ee.FeatureCollection.\n        column (str): The column name to use for styling.\n        palette (list | dict): The palette (e.g., list of colors or a dict containing label and color pairs) to use for styling.\n        layer_name (str, optional): The name to be used for the new layer. Defaults to \"Untitled\".\n    \"\"\"\n    styled_vector = vector_styling(ee_object, column, palette, **kwargs)\n    self.addLayer(styled_vector.style(**{\"styleProperty\": \"style\"}), {}, layer_name)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_text","title":"<code>add_text(self, text, fontsize=20, fontcolor='black', bold=False, padding='5px', background=True, bg_color='white', border_radius='5px', position='bottomright', **kwargs)</code>","text":"<p>Add text to the map.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to add.</p> required <code>fontsize</code> <code>int</code> <p>The font size. Defaults to 20.</p> <code>20</code> <code>fontcolor</code> <code>str</code> <p>The font color. Defaults to \"black\".</p> <code>'black'</code> <code>bold</code> <code>bool</code> <p>Whether to use bold font. Defaults to False.</p> <code>False</code> <code>padding</code> <code>str</code> <p>The padding. Defaults to \"5px\".</p> <code>'5px'</code> <code>background</code> <code>bool</code> <p>Whether to use background. Defaults to True.</p> <code>True</code> <code>bg_color</code> <code>str</code> <p>The background color. Defaults to \"white\".</p> <code>'white'</code> <code>border_radius</code> <code>str</code> <p>The border radius. Defaults to \"5px\".</p> <code>'5px'</code> <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_text(\n    self,\n    text,\n    fontsize=20,\n    fontcolor=\"black\",\n    bold=False,\n    padding=\"5px\",\n    background=True,\n    bg_color=\"white\",\n    border_radius=\"5px\",\n    position=\"bottomright\",\n    **kwargs,\n):\n\"\"\"Add text to the map.\n\n    Args:\n        text (str): The text to add.\n        fontsize (int, optional): The font size. Defaults to 20.\n        fontcolor (str, optional): The font color. Defaults to \"black\".\n        bold (bool, optional): Whether to use bold font. Defaults to False.\n        padding (str, optional): The padding. Defaults to \"5px\".\n        background (bool, optional): Whether to use background. Defaults to True.\n        bg_color (str, optional): The background color. Defaults to \"white\".\n        border_radius (str, optional): The border radius. Defaults to \"5px\".\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n    \"\"\"\n\n    if background:\n        text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'}; \n        padding: {padding}; background-color: {bg_color}; \n        border-radius: {border_radius};\"&gt;{text}&lt;/div&gt;\"\"\"\n    else:\n        text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'}; \n        padding: {padding};\"&gt;{text}&lt;/div&gt;\"\"\"\n\n    self.add_html(text, position=position, **kwargs)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_tile_layer","title":"<code>add_tile_layer(self, url='https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', name='Untitled', attribution='', opacity=1.0, shown=True, **kwargs)</code>","text":"<p>Adds a TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer. Defaults to 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'.</p> <code>'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Untitled'.</p> <code>'Untitled'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_tile_layer(\n    self,\n    url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    name=\"Untitled\",\n    attribution=\"\",\n    opacity=1.0,\n    shown=True,\n    **kwargs,\n):\n\"\"\"Adds a TileLayer to the map.\n\n    Args:\n        url (str, optional): The URL of the tile layer. Defaults to 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'.\n        name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n    \"\"\"\n\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 100\n    if \"max_native_zoom\" not in kwargs:\n        kwargs[\"max_native_zoom\"] = 100\n\n    try:\n        tile_layer = ipyleaflet.TileLayer(\n            url=url,\n            name=name,\n            attribution=attribution,\n            opacity=opacity,\n            visible=shown,\n            **kwargs,\n        )\n        self.add_layer(tile_layer)\n\n    except Exception as e:\n        print(\"Failed to add the specified TileLayer.\")\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_time_slider","title":"<code>add_time_slider(self, ee_object, vis_params={}, region=None, layer_name='Time series', labels=None, time_interval=1, position='bottomright', slider_length='150px', date_format='YYYY-MM-dd', opacity=1.0, **kwargs)</code>","text":"<p>Adds a time slider to the map.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>ee.Image | ee.ImageCollection</code> <p>The Image or ImageCollection to visualize.</p> required <code>vis_params</code> <code>dict</code> <p>Visualization parameters to use for visualizing image. Defaults to {}.</p> <code>{}</code> <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region to visualize.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Time series\".</p> <code>'Time series'</code> <code>labels</code> <code>list</code> <p>The list of labels to be used for the time series. Defaults to None.</p> <code>None</code> <code>time_interval</code> <code>int</code> <p>Time interval in seconds. Defaults to 1.</p> <code>1</code> <code>position</code> <code>str</code> <p>Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>slider_length</code> <code>str</code> <p>Length of the time slider. Defaults to \"150px\".</p> <code>'150px'</code> <code>date_format</code> <code>str</code> <p>The date format to use. Defaults to 'YYYY-MM-dd'.</p> <code>'YYYY-MM-dd'</code> <code>opacity</code> <code>float</code> <p>The opacity of layers. Defaults to 1.0.</p> <code>1.0</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the ee_object is not ee.Image | ee.ImageCollection.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_time_slider(\n    self,\n    ee_object,\n    vis_params={},\n    region=None,\n    layer_name=\"Time series\",\n    labels=None,\n    time_interval=1,\n    position=\"bottomright\",\n    slider_length=\"150px\",\n    date_format=\"YYYY-MM-dd\",\n    opacity=1.0,\n    **kwargs,\n):\n\"\"\"Adds a time slider to the map.\n\n    Args:\n        ee_object (ee.Image | ee.ImageCollection): The Image or ImageCollection to visualize.\n        vis_params (dict, optional): Visualization parameters to use for visualizing image. Defaults to {}.\n        region (ee.Geometry | ee.FeatureCollection): The region to visualize.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Time series\".\n        labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n        time_interval (int, optional): Time interval in seconds. Defaults to 1.\n        position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n        slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n        date_format (str, optional): The date format to use. Defaults to 'YYYY-MM-dd'.\n        opacity (float, optional): The opacity of layers. Defaults to 1.0.\n\n    Raises:\n        TypeError: If the ee_object is not ee.Image | ee.ImageCollection.\n    \"\"\"\n    import threading\n\n    if isinstance(ee_object, ee.Image):\n        if region is not None:\n            if isinstance(region, ee.Geometry):\n                ee_object = ee_object.clip(region)\n            elif isinstance(region, ee.FeatureCollection):\n                ee_object = ee_object.clipToCollection(region)\n        if layer_name not in self.ee_raster_layer_names:\n            self.addLayer(ee_object, {}, layer_name, False, opacity)\n        band_names = ee_object.bandNames()\n        ee_object = ee.ImageCollection(\n            ee_object.bandNames().map(lambda b: ee_object.select([b]))\n        )\n\n        if labels is not None:\n            if len(labels) != int(ee_object.size().getInfo()):\n                raise ValueError(\n                    \"The length of labels must be equal to the number of bands in the image.\"\n                )\n        else:\n            labels = band_names.getInfo()\n\n    elif isinstance(ee_object, ee.ImageCollection):\n        if region is not None:\n            if isinstance(region, ee.Geometry):\n                ee_object = ee_object.map(lambda img: img.clip(region))\n            elif isinstance(region, ee.FeatureCollection):\n                ee_object = ee_object.map(lambda img: img.clipToCollection(region))\n\n        if labels is not None:\n            if len(labels) != int(ee_object.size().getInfo()):\n                raise ValueError(\n                    \"The length of labels must be equal to the number of images in the ImageCollection.\"\n                )\n        else:\n            labels = (\n                ee_object.aggregate_array(\"system:time_start\")\n                .map(lambda d: ee.Date(d).format(date_format))\n                .getInfo()\n            )\n    else:\n        raise TypeError(\"The ee_object must be an ee.Image or ee.ImageCollection\")\n\n    # if labels is not None:\n    #     size = len(labels)\n    # else:\n    #     size = ee_object.size().getInfo()\n    #     labels = [str(i) for i in range(1, size + 1)]\n\n    first = ee.Image(ee_object.first())\n\n    if layer_name not in self.ee_raster_layer_names:\n        self.addLayer(ee_object.toBands(), {}, layer_name, False, opacity)\n    self.addLayer(first, vis_params, \"Image X\", True, opacity)\n\n    slider = widgets.IntSlider(\n        min=1,\n        max=len(labels),\n        readout=False,\n        continuous_update=False,\n        layout=widgets.Layout(width=slider_length),\n    )\n    label = widgets.Label(\n        value=labels[0], layout=widgets.Layout(padding=\"0px 5px 0px 5px\")\n    )\n\n    play_btn = widgets.Button(\n        icon=\"play\",\n        tooltip=\"Play the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    pause_btn = widgets.Button(\n        icon=\"pause\",\n        tooltip=\"Pause the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    play_chk = widgets.Checkbox(value=False)\n\n    slider_widget = widgets.HBox([slider, label, play_btn, pause_btn, close_btn])\n\n    def play_click(b):\n        play_chk.value = True\n\n        def work(slider):\n            while play_chk.value:\n                if slider.value &lt; len(labels):\n                    slider.value += 1\n                else:\n                    slider.value = 1\n                time.sleep(time_interval)\n\n        thread = threading.Thread(target=work, args=(slider,))\n        thread.start()\n\n    def pause_click(b):\n        play_chk.value = False\n\n    play_btn.on_click(play_click)\n    pause_btn.on_click(pause_click)\n\n    def slider_changed(change):\n        self.default_style = {\"cursor\": \"wait\"}\n        index = slider.value - 1\n        label.value = labels[index]\n        image = ee.Image(ee_object.toList(ee_object.size()).get(index))\n        if layer_name not in self.ee_raster_layer_names:\n            self.addLayer(ee_object.toBands(), {}, layer_name, False, opacity)\n        self.addLayer(image, vis_params, \"Image X\", True, opacity)\n        self.default_style = {\"cursor\": \"default\"}\n\n    slider.observe(slider_changed, \"value\")\n\n    def close_click(b):\n        play_chk.value = False\n        self.toolbar_reset()\n        self.remove_ee_layer(\"Image X\")\n        self.remove_ee_layer(layer_name)\n\n        if self.slider_ctrl is not None and self.slider_ctrl in self.controls:\n            self.remove_control(self.slider_ctrl)\n        slider_widget.close()\n\n    close_btn.on_click(close_click)\n\n    slider_ctrl = ipyleaflet.WidgetControl(widget=slider_widget, position=position)\n    self.add_control(slider_ctrl)\n    self.slider_ctrl = slider_ctrl\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_vector","title":"<code>add_vector(self, filename, layer_name='Untitled', to_ee=False, bbox=None, mask=None, rows=None, style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', encoding='utf-8', **kwargs)</code>","text":"<p>Adds any geopandas-supported vector dataset to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>to_ee</code> <code>bool</code> <p>Whether to convert the GeoJSON to ee.FeatureCollection. Defaults to False.</p> <code>False</code> <code>bbox</code> <code>tuple | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.</p> <code>None</code> <code>mask</code> <code>dict | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.</p> <code>None</code> <code>rows</code> <code>int or slice</code> <p>Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.</p> <code>None</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>encoding</code> <code>str</code> <p>The encoding to use to read the file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_vector(\n    self,\n    filename,\n    layer_name=\"Untitled\",\n    to_ee=False,\n    bbox=None,\n    mask=None,\n    rows=None,\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n\"\"\"Adds any geopandas-supported vector dataset to the map.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n        to_ee (bool, optional): Whether to convert the GeoJSON to ee.FeatureCollection. Defaults to False.\n        bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n        mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n        rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding to use to read the file. Defaults to \"utf-8\".\n\n    \"\"\"\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n    else:\n        filename = github_raw_url(filename)\n    if to_ee:\n        fc = vector_to_ee(\n            filename,\n            bbox=bbox,\n            mask=mask,\n            rows=rows,\n            geodesic=True,\n            **kwargs,\n        )\n\n        self.addLayer(fc, {}, layer_name)\n    else:\n        ext = os.path.splitext(filename)[1].lower()\n        if ext == \".shp\":\n            self.add_shapefile(\n                filename,\n                layer_name,\n                style,\n                hover_style,\n                style_callback,\n                fill_colors,\n                info_mode,\n                encoding,\n            )\n        elif ext in [\".json\", \".geojson\"]:\n            self.add_geojson(\n                filename,\n                layer_name,\n                style,\n                hover_style,\n                style_callback,\n                fill_colors,\n                info_mode,\n                encoding,\n            )\n        else:\n            geojson = vector_to_geojson(\n                filename,\n                bbox=bbox,\n                mask=mask,\n                rows=rows,\n                epsg=\"4326\",\n                **kwargs,\n            )\n\n            self.add_geojson(\n                geojson,\n                layer_name,\n                style,\n                hover_style,\n                style_callback,\n                fill_colors,\n                info_mode,\n                encoding,\n            )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_velocity","title":"<code>add_velocity(self, data, zonal_speed, meridional_speed, latitude_dimension='lat', longitude_dimension='lon', level_dimension='lev', level_index=0, time_index=0, velocity_scale=0.01, max_velocity=20, display_options={}, name='Velocity')</code>","text":"<p>Add a velocity layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | xr.Dataset</code> <p>The data to use for the velocity layer. It can be a file path to a NetCDF file or an xarray Dataset.</p> required <code>zonal_speed</code> <code>str</code> <p>Name of the zonal speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.</p> required <code>meridional_speed</code> <code>str</code> <p>Name of the meridional speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.</p> required <code>latitude_dimension</code> <code>str</code> <p>Name of the latitude dimension in the dataset. Defaults to 'lat'.</p> <code>'lat'</code> <code>longitude_dimension</code> <code>str</code> <p>Name of the longitude dimension in the dataset. Defaults to 'lon'.</p> <code>'lon'</code> <code>level_dimension</code> <code>str</code> <p>Name of the level dimension in the dataset. Defaults to 'lev'.</p> <code>'lev'</code> <code>level_index</code> <code>int</code> <p>The index of the level dimension to display. Defaults to 0.</p> <code>0</code> <code>time_index</code> <code>int</code> <p>The index of the time dimension to display. Defaults to 0.</p> <code>0</code> <code>velocity_scale</code> <code>float</code> <p>The scale of the velocity. Defaults to 0.01.</p> <code>0.01</code> <code>max_velocity</code> <code>int</code> <p>The maximum velocity to display. Defaults to 20.</p> <code>20</code> <code>display_options</code> <code>dict</code> <p>The display options for the velocity layer. Defaults to {}. See https://bit.ly/3uf8t6w.</p> <code>{}</code> <code>name</code> <code>str</code> <p>Layer name to use . Defaults to 'Velocity'.</p> <code>'Velocity'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray package is not installed.</p> <code>ValueError</code> <p>If the data is not a NetCDF file or an xarray Dataset.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_velocity(\n    self,\n    data,\n    zonal_speed,\n    meridional_speed,\n    latitude_dimension=\"lat\",\n    longitude_dimension=\"lon\",\n    level_dimension=\"lev\",\n    level_index=0,\n    time_index=0,\n    velocity_scale=0.01,\n    max_velocity=20,\n    display_options={},\n    name=\"Velocity\",\n):\n\"\"\"Add a velocity layer to the map.\n\n    Args:\n        data (str | xr.Dataset): The data to use for the velocity layer. It can be a file path to a NetCDF file or an xarray Dataset.\n        zonal_speed (str): Name of the zonal speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.\n        meridional_speed (str): Name of the meridional speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.\n        latitude_dimension (str, optional): Name of the latitude dimension in the dataset. Defaults to 'lat'.\n        longitude_dimension (str, optional): Name of the longitude dimension in the dataset. Defaults to 'lon'.\n        level_dimension (str, optional): Name of the level dimension in the dataset. Defaults to 'lev'.\n        level_index (int, optional): The index of the level dimension to display. Defaults to 0.\n        time_index (int, optional): The index of the time dimension to display. Defaults to 0.\n        velocity_scale (float, optional): The scale of the velocity. Defaults to 0.01.\n        max_velocity (int, optional): The maximum velocity to display. Defaults to 20.\n        display_options (dict, optional): The display options for the velocity layer. Defaults to {}. See https://bit.ly/3uf8t6w.\n        name (str, optional): Layer name to use . Defaults to 'Velocity'.\n\n    Raises:\n        ImportError: If the xarray package is not installed.\n        ValueError: If the data is not a NetCDF file or an xarray Dataset.\n    \"\"\"\n    try:\n        import xarray as xr\n        from ipyleaflet.velocity import Velocity\n    except ImportError:\n        raise ImportError(\n            \"The xarray package is required to add a velocity layer. \"\n            \"Please install it with `pip install xarray`.\"\n        )\n\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = download_file(data)\n        ds = xr.open_dataset(data)\n\n    elif isinstance(data, xr.Dataset):\n        ds = data\n    else:\n        raise ValueError(\"The data must be a file path or xarray dataset.\")\n\n    coords = list(ds.coords.keys())\n\n    # Rasterio does not handle time or levels. So we must drop them\n    if \"time\" in coords:\n        ds = ds.isel(time=time_index, drop=True)\n\n    params = {level_dimension: level_index}\n    if level_dimension in coords:\n        ds = ds.isel(drop=True, **params)\n\n    wind = Velocity(\n        data=ds,\n        zonal_speed=zonal_speed,\n        meridional_speed=meridional_speed,\n        latitude_dimension=latitude_dimension,\n        longitude_dimension=longitude_dimension,\n        velocity_scale=velocity_scale,\n        max_velocity=max_velocity,\n        display_options=display_options,\n        name=name,\n    )\n    self.add_layer(wind)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_widget","title":"<code>add_widget(self, content, position='bottomright', **kwargs)</code>","text":"<p>Add a widget (e.g., text, HTML, figure) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str | ipywidgets.Widget | object</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>**kwargs</code> <p>Other keyword arguments for ipywidgets.HTML().</p> <code>{}</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_widget(self, content, position=\"bottomright\", **kwargs):\n\"\"\"Add a widget (e.g., text, HTML, figure) to the map.\n\n    Args:\n        content (str | ipywidgets.Widget | object): The widget to add.\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        **kwargs: Other keyword arguments for ipywidgets.HTML().\n    \"\"\"\n\n    allowed_positions = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n\n    if position not in allowed_positions:\n        raise Exception(f\"position must be one of {allowed_positions}\")\n\n    if \"layout\" not in kwargs:\n        kwargs[\"layout\"] = widgets.Layout(padding=\"0px 4px 0px 4px\")\n    try:\n        if isinstance(content, str):\n            widget = widgets.HTML(value=content, **kwargs)\n            control = ipyleaflet.WidgetControl(widget=widget, position=position)\n        else:\n            output = widgets.Output(**kwargs)\n            with output:\n                display(content)\n            control = ipyleaflet.WidgetControl(widget=output, position=position)\n        self.add_control(control)\n\n    except Exception as e:\n        raise Exception(f\"Error adding widget: {e}\")\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name=None, attribution='', format='image/png', transparent=True, opacity=1.0, shown=True, **kwargs)</code>","text":"<p>Add a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the WMS web service.</p> required <code>layers</code> <code>str</code> <p>Comma-separated list of WMS layers to show.</p> required <code>name</code> <code>str</code> <p>The layer name to use on the layer control. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution of the data layer. Defaults to ''.</p> <code>''</code> <code>format</code> <code>str</code> <p>WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>If True, the WMS service will return images with transparency. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def add_wms_layer(\n    self,\n    url,\n    layers,\n    name=None,\n    attribution=\"\",\n    format=\"image/png\",\n    transparent=True,\n    opacity=1.0,\n    shown=True,\n    **kwargs,\n):\n\"\"\"Add a WMS layer to the map.\n\n    Args:\n        url (str): The URL of the WMS web service.\n        layers (str): Comma-separated list of WMS layers to show.\n        name (str, optional): The layer name to use on the layer control. Defaults to None.\n        attribution (str, optional): The attribution of the data layer. Defaults to ''.\n        format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.\n        transparent (bool, optional): If True, the WMS service will return images with transparency. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n    \"\"\"\n\n    if name is None:\n        name = str(layers)\n\n    try:\n        wms_layer = ipyleaflet.WMSLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            attribution=attribution,\n            format=format,\n            transparent=transparent,\n            opacity=opacity,\n            visible=shown,\n            **kwargs,\n        )\n        self.add_layer(wms_layer)\n\n    except Exception as e:\n        print(\"Failed to add the specified WMS TileLayer.\")\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_xy_data","title":"<code>add_xy_data(self, in_csv, x='longitude', y='latitude', label=None, layer_name='Marker cluster', to_ee=False)</code>","text":"<p>Adds points from a CSV file containing lat/lon information and display data on the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>x</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>label</code> <code>str</code> <p>The name of the column containing label information to used for marker popup. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"Marker cluster\".</p> <code>'Marker cluster'</code> <code>to_ee</code> <code>bool</code> <p>Whether to convert the csv to an ee.FeatureCollection.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The specified input csv does not exist.</p> <code>ValueError</code> <p>The specified x column does not exist.</p> <code>ValueError</code> <p>The specified y column does not exist.</p> <code>ValueError</code> <p>The specified label column does not exist.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_xy_data(\n    self,\n    in_csv,\n    x=\"longitude\",\n    y=\"latitude\",\n    label=None,\n    layer_name=\"Marker cluster\",\n    to_ee=False,\n):\n\"\"\"Adds points from a CSV file containing lat/lon information and display data on the map.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        x (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        y (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        label (str, optional): The name of the column containing label information to used for marker popup. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to \"Marker cluster\".\n        to_ee (bool, optional): Whether to convert the csv to an ee.FeatureCollection.\n\n    Raises:\n        FileNotFoundError: The specified input csv does not exist.\n        ValueError: The specified x column does not exist.\n        ValueError: The specified y column does not exist.\n        ValueError: The specified label column does not exist.\n    \"\"\"\n    import pandas as pd\n\n    if not in_csv.startswith(\"http\") and (not os.path.exists(in_csv)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n\n    df = pd.read_csv(in_csv)\n    col_names = df.columns.values.tolist()\n\n    if x not in col_names:\n        raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n    if y not in col_names:\n        raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n    if label is not None and (label not in col_names):\n        raise ValueError(\n            f\"label must be one of the following: {', '.join(col_names)}\"\n        )\n\n    self.default_style = {\"cursor\": \"wait\"}\n\n    if to_ee:\n        fc = csv_to_ee(in_csv, latitude=y, longitude=x)\n        self.addLayer(fc, {}, layer_name)\n\n    else:\n        points = list(zip(df[y], df[x]))\n\n        if label is not None:\n            labels = df[label]\n            markers = [\n                ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(str(labels[index])),\n                )\n                for index, point in enumerate(points)\n            ]\n        else:\n            markers = [\n                ipyleaflet.Marker(location=point, draggable=False)\n                for point in points\n            ]\n\n        marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n        self.add_layer(marker_cluster)\n\n    self.default_style = {\"cursor\": \"default\"}\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.add_xyz_service","title":"<code>add_xyz_service(self, provider, **kwargs)</code>","text":"<p>Add a XYZ tile layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The provider is not valid. It must start with xyz or qms.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def add_xyz_service(self, provider, **kwargs):\n\"\"\"Add a XYZ tile layer to the map.\n\n    Args:\n        provider (str): A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,\n\n    Raises:\n        ValueError: The provider is not valid. It must start with xyz or qms.\n    \"\"\"\n    import xyzservices.providers as xyz\n    from xyzservices import TileProvider\n\n    if provider.startswith(\"xyz\"):\n        name = provider[4:]\n        xyz_provider = xyz.flatten()[name]\n        url = xyz_provider.build_url()\n        attribution = xyz_provider.attribution\n        if attribution.strip() == \"\":\n            attribution = \" \"\n        self.add_tile_layer(url, name, attribution)\n    elif provider.startswith(\"qms\"):\n        name = provider[4:]\n        qms_provider = TileProvider.from_qms(name)\n        url = qms_provider.build_url()\n        attribution = qms_provider.attribution\n        if attribution.strip() == \"\":\n            attribution = \" \"\n        self.add_tile_layer(url, name, attribution)\n    else:\n        raise ValueError(\n            f\"The provider {provider} is not valid. It must start with xyz or qms.\"\n        )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.basemap_demo","title":"<code>basemap_demo(self)</code>","text":"<p>A demo for using geemap basemaps.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def basemap_demo(self):\n\"\"\"A demo for using geemap basemaps.\"\"\"\n    dropdown = widgets.Dropdown(\n        options=list(basemaps.keys()),\n        value=\"HYBRID\",\n        description=\"Basemaps\",\n    )\n\n    def on_click(change):\n        basemap_name = change[\"new\"]\n        old_basemap = self.layers[-1]\n        self.substitute_layer(old_basemap, basemaps[basemap_name])\n\n    dropdown.observe(on_click, \"value\")\n    basemap_control = ipyleaflet.WidgetControl(widget=dropdown, position=\"topright\")\n    self.add_control(basemap_control)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.centerObject","title":"<code>centerObject(self, ee_object, zoom=None)</code>","text":"<p>Centers the map view on a given object.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Element|Geometry</code> <p>An Earth Engine object to center on a geometry, image or feature.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def center_object(self, ee_object, zoom=None):\n\"\"\"Centers the map view on a given object.\n\n    Args:\n        ee_object (Element|Geometry): An Earth Engine object to center on a geometry, image or feature.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n    \"\"\"\n    maxError = 0.001\n    if isinstance(ee_object, ee.Geometry):\n        geometry = ee_object.transform(maxError=maxError)\n    else:\n        try:\n            geometry = ee_object.geometry(maxError=maxError).transform(\n                maxError=maxError\n            )\n        except Exception:\n            raise Exception(\n                \"ee_object must be an instance of one of ee.Geometry, ee.FeatureCollection, ee.Image, or ee.ImageCollection.\"\n            )\n\n    if zoom is not None:\n        if not isinstance(zoom, int):\n            raise Exception(\"Zoom must be an integer.\")\n        else:\n            centroid = geometry.centroid(maxError=maxError).getInfo()[\"coordinates\"]\n            lat = centroid[1]\n            lon = centroid[0]\n            self.set_center(lon, lat, zoom)\n\n            if is_arcpy():\n                arc_zoom_to_extent(lon, lat, lon, lat)\n\n    else:\n        coordinates = geometry.bounds(maxError).getInfo()[\"coordinates\"][0]\n        x = [c[0] for c in coordinates]\n        y = [c[1] for c in coordinates]\n        xmin = min(x)\n        xmax = max(x)\n        ymin = min(y)\n        ymax = max(y)\n        bounds = [[ymin, xmin], [ymax, xmax]]\n        self.fit_bounds(bounds)\n\n        if is_arcpy():\n            arc_zoom_to_extent(xmin, ymin, xmax, ymax)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.center_object","title":"<code>center_object(self, ee_object, zoom=None)</code>","text":"<p>Centers the map view on a given object.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Element|Geometry</code> <p>An Earth Engine object to center on a geometry, image or feature.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def center_object(self, ee_object, zoom=None):\n\"\"\"Centers the map view on a given object.\n\n    Args:\n        ee_object (Element|Geometry): An Earth Engine object to center on a geometry, image or feature.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n    \"\"\"\n    maxError = 0.001\n    if isinstance(ee_object, ee.Geometry):\n        geometry = ee_object.transform(maxError=maxError)\n    else:\n        try:\n            geometry = ee_object.geometry(maxError=maxError).transform(\n                maxError=maxError\n            )\n        except Exception:\n            raise Exception(\n                \"ee_object must be an instance of one of ee.Geometry, ee.FeatureCollection, ee.Image, or ee.ImageCollection.\"\n            )\n\n    if zoom is not None:\n        if not isinstance(zoom, int):\n            raise Exception(\"Zoom must be an integer.\")\n        else:\n            centroid = geometry.centroid(maxError=maxError).getInfo()[\"coordinates\"]\n            lat = centroid[1]\n            lon = centroid[0]\n            self.set_center(lon, lat, zoom)\n\n            if is_arcpy():\n                arc_zoom_to_extent(lon, lat, lon, lat)\n\n    else:\n        coordinates = geometry.bounds(maxError).getInfo()[\"coordinates\"][0]\n        x = [c[0] for c in coordinates]\n        y = [c[1] for c in coordinates]\n        xmin = min(x)\n        xmax = max(x)\n        ymin = min(y)\n        ymax = max(y)\n        bounds = [[ymin, xmin], [ymax, xmax]]\n        self.fit_bounds(bounds)\n\n        if is_arcpy():\n            arc_zoom_to_extent(xmin, ymin, xmax, ymax)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.create_vis_widget","title":"<code>create_vis_widget(self, layer_dict)</code>","text":"<p>Create a GUI for changing layer visualization parameters interactively.</p> <p>Parameters:</p> Name Type Description Default <code>layer_dict</code> <code>dict</code> <p>A dict containning information about the layer. It is an element from Map.ee_layer_dict.</p> required <p>Returns:</p> Type Description <code>object</code> <p>An ipywidget.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def create_vis_widget(self, layer_dict):\n\"\"\"Create a GUI for changing layer visualization parameters interactively.\n\n    Args:\n        layer_dict (dict): A dict containning information about the layer. It is an element from Map.ee_layer_dict.\n\n    Returns:\n        object: An ipywidget.\n    \"\"\"\n\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    ee_object = layer_dict[\"ee_object\"]\n\n    if isinstance(ee_object, ee.Geometry) or isinstance(ee_object, ee.Feature):\n        ee_object = ee.FeatureCollection(ee_object)\n\n    ee_layer = layer_dict[\"ee_layer\"]\n    vis_params = layer_dict[\"vis_params\"]\n\n    layer_name = ee_layer.name\n    layer_opacity = ee_layer.opacity\n\n    band_names = None\n    min_value = 0\n    max_value = 100\n    sel_bands = None\n    layer_palette = []\n    layer_gamma = 1\n    left_value = 0\n    right_value = 10000\n\n    self.colorbar_widget = widgets.Output(layout=widgets.Layout(height=\"60px\"))\n    self.colorbar_ctrl = ipyleaflet.WidgetControl(\n        widget=self.colorbar_widget, position=\"bottomright\"\n    )\n    self.add_control(self.colorbar_ctrl)\n\n    # def vdir(obj):  # Get branca colormap list\n    #     return [x for x in dir(obj) if not x.startswith(\"_\")]\n\n    if isinstance(ee_object, ee.Image):\n        band_names = ee_object.bandNames().getInfo()\n        band_count = len(band_names)\n\n        if \"min\" in vis_params.keys():\n            min_value = vis_params[\"min\"]\n            if min_value &lt; left_value:\n                left_value = min_value - max_value\n        if \"max\" in vis_params.keys():\n            max_value = vis_params[\"max\"]\n            right_value = 2 * max_value\n        if \"gamma\" in vis_params.keys():\n            layer_gamma = vis_params[\"gamma\"]\n        if \"bands\" in vis_params.keys():\n            sel_bands = vis_params[\"bands\"]\n        if \"palette\" in vis_params.keys():\n            layer_palette = [\n                color.replace(\"#\", \"\") for color in list(vis_params[\"palette\"])\n            ]\n\n        vis_widget = widgets.VBox(\n            layout=widgets.Layout(padding=\"5px 5px 5px 8px\", width=\"330px\")\n        )\n        label = widgets.Label(value=f\"{layer_name} visualization parameters\")\n\n        radio1 = widgets.RadioButtons(\n            options=[\"1 band (Grayscale)\"], layout={\"width\": \"max-content\"}\n        )\n        radio2 = widgets.RadioButtons(\n            options=[\"3 bands (RGB)\"], layout={\"width\": \"max-content\"}\n        )\n        radio1.index = None\n        radio2.index = None\n\n        dropdown_width = \"98px\"\n        band1_dropdown = widgets.Dropdown(\n            options=band_names,\n            value=band_names[0],\n            layout=widgets.Layout(width=dropdown_width),\n        )\n        band2_dropdown = widgets.Dropdown(\n            options=band_names,\n            value=band_names[0],\n            layout=widgets.Layout(width=dropdown_width),\n        )\n        band3_dropdown = widgets.Dropdown(\n            options=band_names,\n            value=band_names[0],\n            layout=widgets.Layout(width=dropdown_width),\n        )\n\n        bands_hbox = widgets.HBox()\n\n        legend_chk = widgets.Checkbox(\n            value=False,\n            description=\"Legend\",\n            indent=False,\n            layout=widgets.Layout(width=\"70px\"),\n        )\n\n        color_picker = widgets.ColorPicker(\n            concise=False,\n            value=\"#000000\",\n            layout=widgets.Layout(width=\"116px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        add_color = widgets.Button(\n            icon=\"plus\",\n            tooltip=\"Add a hex color string to the palette\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n\n        del_color = widgets.Button(\n            icon=\"minus\",\n            tooltip=\"Remove a hex color string from the palette\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n\n        reset_color = widgets.Button(\n            icon=\"eraser\",\n            tooltip=\"Remove all color strings from the palette\",\n            layout=widgets.Layout(width=\"34px\"),\n        )\n\n        classes = widgets.Dropdown(\n            options=[\"Any\"] + [str(i) for i in range(3, 13)],\n            description=\"Classes:\",\n            layout=widgets.Layout(width=\"115px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        colormap_options = plt.colormaps()\n        colormap_options.sort()\n        colormap = widgets.Dropdown(\n            options=colormap_options,\n            value=None,\n            description=\"Colormap:\",\n            layout=widgets.Layout(width=\"181px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        def classes_changed(change):\n            if change[\"new\"]:\n                selected = change[\"owner\"].value\n                if colormap.value is not None:\n                    n_class = None\n                    if selected != \"Any\":\n                        n_class = int(classes.value)\n\n                    colors = plt.cm.get_cmap(colormap.value, n_class)\n                    cmap_colors = [\n                        mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n                    ]\n\n                    _, ax = plt.subplots(figsize=(6, 0.4))\n                    cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                        \"custom\", to_hex_colors(cmap_colors), N=256\n                    )\n                    norm = mpl.colors.Normalize(\n                        vmin=value_range.value[0], vmax=value_range.value[1]\n                    )\n                    mpl.colorbar.ColorbarBase(\n                        ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                    )\n\n                    palette.value = \", \".join([color for color in cmap_colors])\n\n                    if self.colorbar_widget is None:\n                        self.colorbar_widget = widgets.Output(\n                            layout=widgets.Layout(height=\"60px\")\n                        )\n\n                    if self.colorbar_ctrl is None:\n                        self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                            widget=self.colorbar_widget, position=\"bottomright\"\n                        )\n                        self.add_control(self.colorbar_ctrl)\n\n                    colorbar_output = self.colorbar_widget\n                    with colorbar_output:\n                        colorbar_output.clear_output()\n                        plt.show()\n\n                    if len(palette.value) &gt; 0 and \",\" in palette.value:\n                        labels = [\n                            f\"Class {i+1}\"\n                            for i in range(len(palette.value.split(\",\")))\n                        ]\n                        legend_labels.value = \", \".join(labels)\n\n        classes.observe(classes_changed, \"value\")\n\n        palette = widgets.Text(\n            value=\", \".join(layer_palette),\n            placeholder=\"List of hex color code (RRGGBB)\",\n            description=\"Palette:\",\n            tooltip=\"Enter a list of hex color code (RRGGBB)\",\n            layout=widgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        def add_color_clicked(b):\n            if color_picker.value is not None:\n                if len(palette.value) == 0:\n                    palette.value = color_picker.value[1:]\n                else:\n                    palette.value += \", \" + color_picker.value[1:]\n\n        def del_color_clicked(b):\n            if \",\" in palette.value:\n                items = [item.strip() for item in palette.value.split(\",\")]\n                palette.value = \", \".join(items[:-1])\n            else:\n                palette.value = \"\"\n\n        def reset_color_clicked(b):\n            palette.value = \"\"\n\n        add_color.on_click(add_color_clicked)\n        del_color.on_click(del_color_clicked)\n        reset_color.on_click(reset_color_clicked)\n\n        spacer = widgets.Label(layout=widgets.Layout(width=\"5px\"))\n        v_spacer = widgets.Label(layout=widgets.Layout(height=\"5px\"))\n        radio_btn = widgets.HBox([radio1, spacer, spacer, spacer, radio2])\n\n        value_range = widgets.FloatRangeSlider(\n            value=[min_value, max_value],\n            min=left_value,\n            max=right_value,\n            step=0.1,\n            description=\"Range:\",\n            disabled=False,\n            continuous_update=False,\n            readout=True,\n            readout_format=\".1f\",\n            layout=widgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"45px\"},\n        )\n\n        range_hbox = widgets.HBox([value_range, spacer])\n\n        opacity = widgets.FloatSlider(\n            value=layer_opacity,\n            min=0,\n            max=1,\n            step=0.01,\n            description=\"Opacity:\",\n            continuous_update=False,\n            readout=True,\n            readout_format=\".2f\",\n            layout=widgets.Layout(width=\"320px\"),\n            style={\"description_width\": \"50px\"},\n        )\n\n        gamma = widgets.FloatSlider(\n            value=layer_gamma,\n            min=0.1,\n            max=10,\n            step=0.01,\n            description=\"Gamma:\",\n            continuous_update=False,\n            readout=True,\n            readout_format=\".2f\",\n            layout=widgets.Layout(width=\"320px\"),\n            style={\"description_width\": \"50px\"},\n        )\n\n        legend_chk = widgets.Checkbox(\n            value=False,\n            description=\"Legend\",\n            indent=False,\n            layout=widgets.Layout(width=\"70px\"),\n        )\n\n        linear_chk = widgets.Checkbox(\n            value=True,\n            description=\"Linear colormap\",\n            indent=False,\n            layout=widgets.Layout(width=\"150px\"),\n        )\n\n        step_chk = widgets.Checkbox(\n            value=False,\n            description=\"Step colormap\",\n            indent=False,\n            layout=widgets.Layout(width=\"140px\"),\n        )\n\n        legend_title = widgets.Text(\n            value=\"Legend\",\n            description=\"Legend title:\",\n            tooltip=\"Enter a title for the legend\",\n            layout=widgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        legend_labels = widgets.Text(\n            value=\"Class 1, Class 2, Class 3\",\n            description=\"Legend labels:\",\n            tooltip=\"Enter a a list of labels for the legend\",\n            layout=widgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        colormap_hbox = widgets.HBox([linear_chk, step_chk])\n        legend_vbox = widgets.VBox()\n\n        def linear_chk_changed(change):\n            if change[\"new\"]:\n                step_chk.value = False\n                legend_vbox.children = [colormap_hbox]\n            else:\n                step_chk.value = True\n\n        def step_chk_changed(change):\n            if change[\"new\"]:\n                linear_chk.value = False\n                if len(layer_palette) &gt; 0:\n                    legend_labels.value = \",\".join(\n                        [\n                            \"Class \" + str(i)\n                            for i in range(1, len(layer_palette) + 1)\n                        ]\n                    )\n                legend_vbox.children = [\n                    colormap_hbox,\n                    legend_title,\n                    legend_labels,\n                ]\n            else:\n                linear_chk.value = True\n\n        linear_chk.observe(linear_chk_changed, \"value\")\n        step_chk.observe(step_chk_changed, \"value\")\n\n        def colormap_changed(change):\n            if change[\"new\"]:\n                n_class = None\n                if classes.value != \"Any\":\n                    n_class = int(classes.value)\n\n                colors = plt.cm.get_cmap(colormap.value, n_class)\n                cmap_colors = [\n                    mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n                ]\n\n                _, ax = plt.subplots(figsize=(6, 0.4))\n                cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                    \"custom\", to_hex_colors(cmap_colors), N=256\n                )\n                norm = mpl.colors.Normalize(\n                    vmin=value_range.value[0], vmax=value_range.value[1]\n                )\n                mpl.colorbar.ColorbarBase(\n                    ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                )\n\n                palette.value = \", \".join(cmap_colors)\n\n                if self.colorbar_widget is None:\n                    self.colorbar_widget = widgets.Output(\n                        layout=widgets.Layout(height=\"60px\")\n                    )\n\n                if self.colorbar_ctrl is None:\n                    self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                        widget=self.colorbar_widget, position=\"bottomright\"\n                    )\n                    self.add_control(self.colorbar_ctrl)\n\n                colorbar_output = self.colorbar_widget\n                with colorbar_output:\n                    colorbar_output.clear_output()\n                    plt.show()\n                    # display(colorbar)\n\n                if len(palette.value) &gt; 0 and \",\" in palette.value:\n                    labels = [\n                        f\"Class {i+1}\" for i in range(len(palette.value.split(\",\")))\n                    ]\n                    legend_labels.value = \", \".join(labels)\n\n        colormap.observe(colormap_changed, \"value\")\n\n        btn_width = \"97.5px\"\n        import_btn = widgets.Button(\n            description=\"Import\",\n            button_style=\"primary\",\n            tooltip=\"Import vis params to notebook\",\n            layout=widgets.Layout(width=btn_width),\n        )\n\n        apply_btn = widgets.Button(\n            description=\"Apply\",\n            tooltip=\"Apply vis params to the layer\",\n            layout=widgets.Layout(width=btn_width),\n        )\n\n        close_btn = widgets.Button(\n            description=\"Close\",\n            tooltip=\"Close vis params diaglog\",\n            layout=widgets.Layout(width=btn_width),\n        )\n\n        def import_btn_clicked(b):\n            vis = {}\n            if radio1.index == 0:\n                vis[\"bands\"] = [band1_dropdown.value]\n                if len(palette.value) &gt; 0:\n                    vis[\"palette\"] = palette.value.split(\",\")\n            else:\n                vis[\"bands\"] = [\n                    band1_dropdown.value,\n                    band2_dropdown.value,\n                    band3_dropdown.value,\n                ]\n\n            vis[\"min\"] = value_range.value[0]\n            vis[\"max\"] = value_range.value[1]\n            vis[\"opacity\"] = opacity.value\n            vis[\"gamma\"] = gamma.value\n\n            create_code_cell(f\"vis_params = {str(vis)}\")\n\n        def apply_btn_clicked(b):\n            vis = {}\n            if radio1.index == 0:\n                vis[\"bands\"] = [band1_dropdown.value]\n                if len(palette.value) &gt; 0:\n                    vis[\"palette\"] = [c.strip() for c in palette.value.split(\",\")]\n            else:\n                vis[\"bands\"] = [\n                    band1_dropdown.value,\n                    band2_dropdown.value,\n                    band3_dropdown.value,\n                ]\n                vis[\"gamma\"] = gamma.value\n\n            vis[\"min\"] = value_range.value[0]\n            vis[\"max\"] = value_range.value[1]\n\n            self.addLayer(ee_object, vis, layer_name, True, opacity.value)\n            ee_layer.visible = False\n\n            if legend_chk.value:\n                if (\n                    self.colorbar_ctrl is not None\n                    and self.colorbar_ctrl in self.controls\n                ):\n                    self.remove_control(self.colorbar_ctrl)\n                    self.colorbar_ctrl.close()\n                    self.colorbar_widget.close()\n\n                if (\n                    \"colorbar\" in layer_dict.keys()\n                    and layer_dict[\"colorbar\"] in self.controls\n                ):\n                    self.remove_control(layer_dict[\"colorbar\"])\n                    layer_dict[\"colorbar\"] = None\n\n                if linear_chk.value:\n                    if (\n                        \"legend\" in layer_dict.keys()\n                        and layer_dict[\"legend\"] in self.controls\n                    ):\n                        self.remove_control(layer_dict[\"legend\"])\n                        layer_dict[\"legend\"] = None\n\n                    if len(palette.value) &gt; 0 and \",\" in palette.value:\n                        colors = to_hex_colors(\n                            [color.strip() for color in palette.value.split(\",\")]\n                        )\n\n                        self.add_colorbar(\n                            vis_params={\n                                \"palette\": colors,\n                                \"min\": value_range.value[0],\n                                \"max\": value_range.value[1],\n                            },\n                            layer_name=layer_name,\n                        )\n                elif step_chk.value:\n                    if len(palette.value) &gt; 0 and \",\" in palette.value:\n                        colors = to_hex_colors(\n                            [color.strip() for color in palette.value.split(\",\")]\n                        )\n                        labels = [\n                            label.strip()\n                            for label in legend_labels.value.split(\",\")\n                        ]\n\n                        self.add_legend(\n                            title=legend_title.value,\n                            legend_keys=labels,\n                            legend_colors=colors,\n                            layer_name=layer_name,\n                        )\n            else:\n                if radio1.index == 0 and \"palette\" in vis:\n                    self.colorbar_widget.clear_output()\n                    with self.colorbar_widget:\n                        _, ax = plt.subplots(figsize=(6, 0.4))\n                        colors = to_hex_colors(vis[\"palette\"])\n                        cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                            \"custom\", colors, N=256\n                        )\n                        norm = mpl.colors.Normalize(\n                            vmin=vis[\"min\"], vmax=vis[\"max\"]\n                        )\n                        mpl.colorbar.ColorbarBase(\n                            ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                        )\n                        plt.show()\n\n                    if (\n                        \"colorbar\" in layer_dict.keys()\n                        and layer_dict[\"colorbar\"] in self.controls\n                    ):\n                        self.remove_control(layer_dict[\"colorbar\"])\n                        layer_dict[\"colorbar\"] = None\n                    if (\n                        \"legend\" in layer_dict.keys()\n                        and layer_dict[\"legend\"] in self.controls\n                    ):\n                        self.remove_control(layer_dict[\"legend\"])\n                        layer_dict[\"legend\"] = None\n\n        def close_btn_clicked(b):\n            if self.vis_control in self.controls:\n                self.remove_control(self.vis_control)\n                self.vis_control = None\n                self.vis_widget.close()\n\n            if (\n                self.colorbar_ctrl is not None\n                and self.colorbar_ctrl in self.controls\n            ):\n                self.remove_control(self.colorbar_ctrl)\n                self.colorbar_ctrl = None\n                self.colorbar_widget.close()\n\n        import_btn.on_click(import_btn_clicked)\n        apply_btn.on_click(apply_btn_clicked)\n        close_btn.on_click(close_btn_clicked)\n\n        color_hbox = widgets.HBox(\n            [legend_chk, color_picker, add_color, del_color, reset_color]\n        )\n        btn_hbox = widgets.HBox([import_btn, apply_btn, close_btn])\n\n        gray_box = [\n            label,\n            radio_btn,\n            bands_hbox,\n            v_spacer,\n            range_hbox,\n            opacity,\n            gamma,\n            widgets.HBox([classes, colormap]),\n            palette,\n            color_hbox,\n            legend_vbox,\n            btn_hbox,\n        ]\n\n        rgb_box = [\n            label,\n            radio_btn,\n            bands_hbox,\n            v_spacer,\n            range_hbox,\n            opacity,\n            gamma,\n            btn_hbox,\n        ]\n\n        def legend_chk_changed(change):\n            if change[\"new\"]:\n                linear_chk.value = True\n                legend_vbox.children = [\n                    widgets.HBox([linear_chk, step_chk]),\n                    # legend_title,\n                    # legend_labels,\n                ]\n            else:\n                legend_vbox.children = []\n\n        legend_chk.observe(legend_chk_changed, \"value\")\n\n        if band_count &lt; 3:\n            radio1.index = 0\n            band1_dropdown.layout.width = \"300px\"\n            bands_hbox.children = [band1_dropdown]\n            vis_widget.children = gray_box\n            legend_chk.value = False\n\n            if len(palette.value) &gt; 0 and \",\" in palette.value:\n                import matplotlib as mpl\n                import matplotlib.pyplot as plt\n\n                colors = to_hex_colors(\n                    [color.strip() for color in palette.value.split(\",\")]\n                )\n\n                self.colorbar_widget.clear_output()\n                with self.colorbar_widget:\n                    _, ax = plt.subplots(figsize=(6, 0.4))\n                    cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                        \"custom\", colors, N=256\n                    )\n                    norm = mpl.colors.Normalize(\n                        vmin=value_range.value[0], vmax=value_range.value[1]\n                    )\n                    mpl.colorbar.ColorbarBase(\n                        ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                    )\n                    plt.show()\n\n        else:\n            radio2.index = 0\n            if (sel_bands is None) or (len(sel_bands) &lt; 2):\n                sel_bands = band_names[0:3]\n            band1_dropdown.value = sel_bands[0]\n            band2_dropdown.value = sel_bands[1]\n            band3_dropdown.value = sel_bands[2]\n            bands_hbox.children = [\n                band1_dropdown,\n                band2_dropdown,\n                band3_dropdown,\n            ]\n            vis_widget.children = rgb_box\n\n        def radio1_observer(sender):\n            radio2.unobserve(radio2_observer, names=[\"value\"])\n            radio2.index = None\n            radio2.observe(radio2_observer, names=[\"value\"])\n            band1_dropdown.layout.width = \"300px\"\n            bands_hbox.children = [band1_dropdown]\n            palette.value = \", \".join(layer_palette)\n            palette.disabled = False\n            color_picker.disabled = False\n            add_color.disabled = False\n            del_color.disabled = False\n            reset_color.disabled = False\n            vis_widget.children = gray_box\n\n            if len(palette.value) &gt; 0 and \",\" in palette.value:\n                colors = [color.strip() for color in palette.value.split(\",\")]\n\n                _, ax = plt.subplots(figsize=(6, 0.4))\n                cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                    \"custom\", to_hex_colors(colors), N=256\n                )\n                norm = mpl.colors.Normalize(vmin=0, vmax=1)\n                mpl.colorbar.ColorbarBase(\n                    ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                )\n\n                self.colorbar_widget = widgets.Output(\n                    layout=widgets.Layout(height=\"60px\")\n                )\n                self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                    widget=self.colorbar_widget, position=\"bottomright\"\n                )\n\n                if self.colorbar_ctrl not in self.controls:\n                    self.add_control(self.colorbar_ctrl)\n\n                self.colorbar_widget.clear_output()\n                with self.colorbar_widget:\n                    plt.show()\n\n        def radio2_observer(sender):\n            radio1.unobserve(radio1_observer, names=[\"value\"])\n            radio1.index = None\n            radio1.observe(radio1_observer, names=[\"value\"])\n            band1_dropdown.layout.width = dropdown_width\n            bands_hbox.children = [\n                band1_dropdown,\n                band2_dropdown,\n                band3_dropdown,\n            ]\n            palette.value = \"\"\n            palette.disabled = True\n            color_picker.disabled = True\n            add_color.disabled = True\n            del_color.disabled = True\n            reset_color.disabled = True\n            vis_widget.children = rgb_box\n\n            if (\n                self.colorbar_ctrl is not None\n                and self.colorbar_ctrl in self.controls\n            ):\n                self.remove_control(self.colorbar_ctrl)\n                self.colorbar_ctrl.close()\n                self.colorbar_widget.close()\n\n        radio1.observe(radio1_observer, names=[\"value\"])\n        radio2.observe(radio2_observer, names=[\"value\"])\n\n        return vis_widget\n\n    elif isinstance(ee_object, ee.FeatureCollection):\n        vis_widget = widgets.VBox(\n            layout=widgets.Layout(padding=\"5px 5px 5px 8px\", width=\"330px\")\n        )\n        label = widgets.Label(value=f\"{layer_name} visualization parameters\")\n\n        new_layer_name = widgets.Text(\n            value=f\"{layer_name} style\",\n            description=\"New layer name:\",\n            style={\"description_width\": \"initial\"},\n        )\n\n        color = widgets.ColorPicker(\n            concise=False,\n            value=\"#000000\",\n            description=\"Color:\",\n            layout=widgets.Layout(width=\"140px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        color_opacity = widgets.FloatSlider(\n            value=layer_opacity,\n            min=0,\n            max=1,\n            step=0.01,\n            description=\"Opacity:\",\n            continuous_update=True,\n            readout=False,\n            #             readout_format=\".2f\",\n            layout=widgets.Layout(width=\"130px\"),\n            style={\"description_width\": \"50px\"},\n        )\n\n        color_opacity_label = widgets.Label(\n            style={\"description_width\": \"initial\"},\n            layout=widgets.Layout(padding=\"0px\"),\n        )\n\n        def color_opacity_change(change):\n            color_opacity_label.value = str(change[\"new\"])\n\n        color_opacity.observe(color_opacity_change, names=\"value\")\n\n        # widgets.jslink((color_opacity, \"value\"), (color_opacity_label, \"value\"))\n\n        point_size = widgets.IntText(\n            value=3,\n            description=\"Point size:\",\n            layout=widgets.Layout(width=\"110px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        point_shape_options = [\n            \"circle\",\n            \"square\",\n            \"diamond\",\n            \"cross\",\n            \"plus\",\n            \"pentagram\",\n            \"hexagram\",\n            \"triangle\",\n            \"triangle_up\",\n            \"triangle_down\",\n            \"triangle_left\",\n            \"triangle_right\",\n            \"pentagon\",\n            \"hexagon\",\n            \"star5\",\n            \"star6\",\n        ]\n        point_shape = widgets.Dropdown(\n            options=point_shape_options,\n            value=\"circle\",\n            description=\"Point shape:\",\n            layout=widgets.Layout(width=\"185px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        line_width = widgets.IntText(\n            value=2,\n            description=\"Line width:\",\n            layout=widgets.Layout(width=\"110px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        line_type = widgets.Dropdown(\n            options=[\"solid\", \"dotted\", \"dashed\"],\n            value=\"solid\",\n            description=\"Line type:\",\n            layout=widgets.Layout(width=\"185px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        fill_color = widgets.ColorPicker(\n            concise=False,\n            value=\"#000000\",\n            description=\"Fill Color:\",\n            layout=widgets.Layout(width=\"160px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        fill_color_opacity = widgets.FloatSlider(\n            value=0.66,\n            min=0,\n            max=1,\n            step=0.01,\n            description=\"Opacity:\",\n            continuous_update=True,\n            readout=False,\n            #             readout_format=\".2f\",\n            layout=widgets.Layout(width=\"110px\"),\n            style={\"description_width\": \"50px\"},\n        )\n\n        fill_color_opacity_label = widgets.Label(\n            style={\"description_width\": \"initial\"},\n            layout=widgets.Layout(padding=\"0px\"),\n        )\n\n        def fill_color_opacity_change(change):\n            fill_color_opacity_label.value = str(change[\"new\"])\n\n        fill_color_opacity.observe(fill_color_opacity_change, names=\"value\")\n\n        # widgets.jslink(\n        #     (fill_color_opacity, \"value\"),\n        #     (fill_color_opacity_label, \"value\"),\n        # )\n\n        color_picker = widgets.ColorPicker(\n            concise=False,\n            value=\"#000000\",\n            layout=widgets.Layout(width=\"116px\"),\n            style={\"description_width\": \"initial\"},\n        )\n        add_color = widgets.Button(\n            icon=\"plus\",\n            tooltip=\"Add a hex color string to the palette\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n        del_color = widgets.Button(\n            icon=\"minus\",\n            tooltip=\"Remove a hex color string from the palette\",\n            layout=widgets.Layout(width=\"32px\"),\n        )\n        reset_color = widgets.Button(\n            icon=\"eraser\",\n            tooltip=\"Remove all color strings from the palette\",\n            layout=widgets.Layout(width=\"34px\"),\n        )\n\n        palette = widgets.Text(\n            value=\"\",\n            placeholder=\"List of hex code (RRGGBB) separated by comma\",\n            description=\"Palette:\",\n            tooltip=\"Enter a list of hex code (RRGGBB) separated by comma\",\n            layout=widgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        legend_title = widgets.Text(\n            value=\"Legend\",\n            description=\"Legend title:\",\n            tooltip=\"Enter a title for the legend\",\n            layout=widgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        legend_labels = widgets.Text(\n            value=\"Labels\",\n            description=\"Legend labels:\",\n            tooltip=\"Enter a a list of labels for the legend\",\n            layout=widgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        def add_color_clicked(b):\n            if color_picker.value is not None:\n                if len(palette.value) == 0:\n                    palette.value = color_picker.value[1:]\n                else:\n                    palette.value += \", \" + color_picker.value[1:]\n\n        def del_color_clicked(b):\n            if \",\" in palette.value:\n                items = [item.strip() for item in palette.value.split(\",\")]\n                palette.value = \", \".join(items[:-1])\n            else:\n                palette.value = \"\"\n\n        def reset_color_clicked(b):\n            palette.value = \"\"\n\n        add_color.on_click(add_color_clicked)\n        del_color.on_click(del_color_clicked)\n        reset_color.on_click(reset_color_clicked)\n\n        field = widgets.Dropdown(\n            options=[],\n            value=None,\n            description=\"Field:\",\n            layout=widgets.Layout(width=\"140px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        field_values = widgets.Dropdown(\n            options=[],\n            value=None,\n            description=\"Values:\",\n            layout=widgets.Layout(width=\"156px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        classes = widgets.Dropdown(\n            options=[\"Any\"] + [str(i) for i in range(3, 13)],\n            description=\"Classes:\",\n            layout=widgets.Layout(width=\"115px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        colormap = widgets.Dropdown(\n            options=[\"viridis\"],\n            value=\"viridis\",\n            description=\"Colormap:\",\n            layout=widgets.Layout(width=\"181px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        def classes_changed(change):\n            if change[\"new\"]:\n                selected = change[\"owner\"].value\n                if colormap.value is not None:\n                    n_class = None\n                    if selected != \"Any\":\n                        n_class = int(classes.value)\n\n                    colors = plt.cm.get_cmap(colormap.value, n_class)\n                    cmap_colors = [\n                        mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n                    ]\n\n                    _, ax = plt.subplots(figsize=(6, 0.4))\n                    cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                        \"custom\", to_hex_colors(cmap_colors), N=256\n                    )\n                    norm = mpl.colors.Normalize(vmin=0, vmax=1)\n                    mpl.colorbar.ColorbarBase(\n                        ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                    )\n\n                    palette.value = \", \".join([color for color in cmap_colors])\n\n                    if self.colorbar_widget is None:\n                        self.colorbar_widget = widgets.Output(\n                            layout=widgets.Layout(height=\"60px\")\n                        )\n\n                    if self.colorbar_ctrl is None:\n                        self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                            widget=self.colorbar_widget, position=\"bottomright\"\n                        )\n                        self.add_control(self.colorbar_ctrl)\n\n                    colorbar_output = self.colorbar_widget\n                    with colorbar_output:\n                        colorbar_output.clear_output()\n                        plt.show()\n\n                    if len(palette.value) &gt; 0 and \",\" in palette.value:\n                        labels = [\n                            f\"Class {i+1}\"\n                            for i in range(len(palette.value.split(\",\")))\n                        ]\n                        legend_labels.value = \", \".join(labels)\n\n        classes.observe(classes_changed, \"value\")\n\n        def colormap_changed(change):\n            if change[\"new\"]:\n                n_class = None\n                if classes.value != \"Any\":\n                    n_class = int(classes.value)\n\n                colors = plt.cm.get_cmap(colormap.value, n_class)\n                cmap_colors = [\n                    mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n                ]\n\n                _, ax = plt.subplots(figsize=(6, 0.4))\n                cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                    \"custom\", to_hex_colors(cmap_colors), N=256\n                )\n                norm = mpl.colors.Normalize(vmin=0, vmax=1)\n                mpl.colorbar.ColorbarBase(\n                    ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                )\n\n                palette.value = \", \".join(cmap_colors)\n\n                if self.colorbar_widget is None:\n                    self.colorbar_widget = widgets.Output(\n                        layout=widgets.Layout(height=\"60px\")\n                    )\n\n                if self.colorbar_ctrl is None:\n                    self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                        widget=self.colorbar_widget, position=\"bottomright\"\n                    )\n                    self.add_control(self.colorbar_ctrl)\n\n                colorbar_output = self.colorbar_widget\n                with colorbar_output:\n                    colorbar_output.clear_output()\n                    plt.show()\n                    # display(colorbar)\n\n                if len(palette.value) &gt; 0 and \",\" in palette.value:\n                    labels = [\n                        f\"Class {i+1}\" for i in range(len(palette.value.split(\",\")))\n                    ]\n                    legend_labels.value = \", \".join(labels)\n\n        colormap.observe(colormap_changed, \"value\")\n\n        btn_width = \"97.5px\"\n        import_btn = widgets.Button(\n            description=\"Import\",\n            button_style=\"primary\",\n            tooltip=\"Import vis params to notebook\",\n            layout=widgets.Layout(width=btn_width),\n        )\n\n        apply_btn = widgets.Button(\n            description=\"Apply\",\n            tooltip=\"Apply vis params to the layer\",\n            layout=widgets.Layout(width=btn_width),\n        )\n\n        close_btn = widgets.Button(\n            description=\"Close\",\n            tooltip=\"Close vis params diaglog\",\n            layout=widgets.Layout(width=btn_width),\n        )\n\n        style_chk = widgets.Checkbox(\n            value=False,\n            description=\"Style by attribute\",\n            indent=False,\n            layout=widgets.Layout(width=\"140px\"),\n        )\n\n        legend_chk = widgets.Checkbox(\n            value=False,\n            description=\"Legend\",\n            indent=False,\n            layout=widgets.Layout(width=\"70px\"),\n        )\n        compute_label = widgets.Label(value=\"\")\n\n        style_vbox = widgets.VBox([widgets.HBox([style_chk, compute_label])])\n\n        def style_chk_changed(change):\n            if change[\"new\"]:\n                if (\n                    self.colorbar_ctrl is not None\n                    and self.colorbar_ctrl in self.controls\n                ):\n                    self.remove_control(self.colorbar_ctrl)\n                    self.colorbar_ctrl.close()\n                    self.colorbar_widget.close()\n\n                self.colorbar_widget = widgets.Output(\n                    layout=widgets.Layout(height=\"60px\")\n                )\n                self.colorbar_ctrl = ipyleaflet.WidgetControl(\n                    widget=self.colorbar_widget, position=\"bottomright\"\n                )\n                self.add_control(self.colorbar_ctrl)\n                fill_color.disabled = True\n                colormap_options = plt.colormaps()\n                colormap_options.sort()\n                colormap.options = colormap_options\n                colormap.value = \"viridis\"\n                style_vbox.children = [\n                    widgets.HBox([style_chk, compute_label]),\n                    widgets.HBox([field, field_values]),\n                    widgets.HBox([classes, colormap]),\n                    palette,\n                    widgets.HBox(\n                        [\n                            legend_chk,\n                            color_picker,\n                            add_color,\n                            del_color,\n                            reset_color,\n                        ]\n                    ),\n                ]\n                compute_label.value = \"Computing ...\"\n\n                field.options = (\n                    ee.Feature(ee_object.first()).propertyNames().getInfo()\n                )\n                compute_label.value = \"\"\n                classes.value = \"Any\"\n                legend_chk.value = False\n\n            else:\n                fill_color.disabled = False\n                style_vbox.children = [widgets.HBox([style_chk, compute_label])]\n                compute_label.value = \"\"\n                if (\n                    self.colorbar_ctrl is not None\n                    and self.colorbar_ctrl in self.controls\n                ):\n                    self.remove_control(self.colorbar_ctrl)\n                    self.colorbar_ctrl = None\n                    self.colorbar_widget = None\n                # legend_chk.value = False\n\n        style_chk.observe(style_chk_changed, \"value\")\n\n        def legend_chk_changed(change):\n            if change[\"new\"]:\n                style_vbox.children = list(style_vbox.children) + [\n                    widgets.VBox([legend_title, legend_labels])\n                ]\n\n                if len(palette.value) &gt; 0 and \",\" in palette.value:\n                    labels = [\n                        f\"Class {i+1}\" for i in range(len(palette.value.split(\",\")))\n                    ]\n                    legend_labels.value = \", \".join(labels)\n\n            else:\n                style_vbox.children = [\n                    widgets.HBox([style_chk, compute_label]),\n                    widgets.HBox([field, field_values]),\n                    widgets.HBox([classes, colormap]),\n                    palette,\n                    widgets.HBox(\n                        [\n                            legend_chk,\n                            color_picker,\n                            add_color,\n                            del_color,\n                            reset_color,\n                        ]\n                    ),\n                ]\n\n        legend_chk.observe(legend_chk_changed, \"value\")\n\n        def field_changed(change):\n            if change[\"new\"]:\n                compute_label.value = \"Computing ...\"\n                options = ee_object.aggregate_array(field.value).getInfo()\n                if options is not None:\n                    options = list(set(options))\n                    options.sort()\n\n                field_values.options = options\n                compute_label.value = \"\"\n\n        field.observe(field_changed, \"value\")\n\n        def get_vis_params():\n            vis = {}\n            vis[\"color\"] = color.value[1:] + str(\n                hex(int(color_opacity.value * 255))\n            )[2:].zfill(2)\n            if geometry_type(ee_object) in [\"Point\", \"MultiPoint\"]:\n                vis[\"pointSize\"] = point_size.value\n                vis[\"pointShape\"] = point_shape.value\n            vis[\"width\"] = line_width.value\n            vis[\"lineType\"] = line_type.value\n            vis[\"fillColor\"] = fill_color.value[1:] + str(\n                hex(int(fill_color_opacity.value * 255))\n            )[2:].zfill(2)\n\n            return vis\n\n        def import_btn_clicked(b):\n            vis = get_vis_params()\n            create_code_cell(f\"vis_params = {str(vis)}\")\n\n        def apply_btn_clicked(b):\n            compute_label.value = \"Computing ...\"\n\n            if new_layer_name.value in self.ee_layer_names:\n                old_layer = new_layer_name.value\n\n                if \"legend\" in self.ee_layer_dict[old_layer].keys():\n                    legend = self.ee_layer_dict[old_layer][\"legend\"]\n                    if legend in self.controls:\n                        self.remove_control(legend)\n                    legend.close()\n                if \"colorbar\" in self.ee_layer_dict[old_layer].keys():\n                    colorbar = self.ee_layer_dict[old_layer][\"colorbar\"]\n                    if colorbar in self.controls:\n                        self.remove_control(colorbar)\n                    colorbar.close()\n\n            if not style_chk.value:\n                vis = get_vis_params()\n                self.addLayer(ee_object.style(**vis), {}, new_layer_name.value)\n                ee_layer.visible = False\n\n            elif (\n                style_chk.value and len(palette.value) &gt; 0 and \",\" in palette.value\n            ):\n                try:\n                    colors = ee.List(\n                        [\n                            color.strip()\n                            + str(hex(int(fill_color_opacity.value * 255)))[\n                                2:\n                            ].zfill(2)\n                            for color in palette.value.split(\",\")\n                        ]\n                    )\n                    arr = ee_object.aggregate_array(field.value).distinct().sort()\n                    fc = ee_object.map(\n                        lambda f: f.set(\n                            {\"styleIndex\": arr.indexOf(f.get(field.value))}\n                        )\n                    )\n                    step = arr.size().divide(colors.size()).ceil()\n                    fc = fc.map(\n                        lambda f: f.set(\n                            {\n                                \"style\": {\n                                    \"color\": color.value[1:]\n                                    + str(hex(int(color_opacity.value * 255)))[\n                                        2:\n                                    ].zfill(2),\n                                    \"pointSize\": point_size.value,\n                                    \"pointShape\": point_shape.value,\n                                    \"width\": line_width.value,\n                                    \"lineType\": line_type.value,\n                                    \"fillColor\": colors.get(\n                                        ee.Number(\n                                            ee.Number(f.get(\"styleIndex\")).divide(\n                                                step\n                                            )\n                                        ).floor()\n                                    ),\n                                }\n                            }\n                        )\n                    )\n\n                    self.addLayer(\n                        fc.style(**{\"styleProperty\": \"style\"}),\n                        {},\n                        f\"{new_layer_name.value}\",\n                    )\n\n                    if (\n                        len(palette.value)\n                        and legend_chk.value\n                        and len(legend_labels.value) &gt; 0\n                    ):\n                        legend_colors = [\n                            color.strip() for color in palette.value.split(\",\")\n                        ]\n                        legend_keys = [\n                            label.strip()\n                            for label in legend_labels.value.split(\",\")\n                        ]\n                        self.add_legend(\n                            title=legend_title.value,\n                            legend_keys=legend_keys,\n                            legend_colors=legend_colors,\n                            layer_name=new_layer_name.value,\n                        )\n                except Exception as e:\n                    compute_label.value = \"Error: \" + str(e)\n                ee_layer.visible = False\n                compute_label.value = \"\"\n\n        def close_btn_clicked(b):\n            self.remove_control(self.vis_control)\n            self.vis_control.close()\n            self.vis_widget.close()\n\n            if (\n                self.colorbar_ctrl is not None\n                and self.colorbar_ctrl in self.controls\n            ):\n                self.remove_control(self.colorbar_ctrl)\n                self.colorbar_ctrl.close()\n                self.colorbar_widget.close()\n\n        import_btn.on_click(import_btn_clicked)\n        apply_btn.on_click(apply_btn_clicked)\n        close_btn.on_click(close_btn_clicked)\n\n        vis_widget.children = [\n            label,\n            new_layer_name,\n            widgets.HBox([color, color_opacity, color_opacity_label]),\n            widgets.HBox([point_size, point_shape]),\n            widgets.HBox([line_width, line_type]),\n            widgets.HBox(\n                [fill_color, fill_color_opacity, fill_color_opacity_label]\n            ),\n            style_vbox,\n            widgets.HBox([import_btn, apply_btn, close_btn]),\n        ]\n\n        if geometry_type(ee_object) in [\"Point\", \"MultiPoint\"]:\n            point_size.disabled = False\n            point_shape.disabled = False\n        else:\n            point_size.disabled = True\n            point_shape.disabled = True\n\n        return vis_widget\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.draw_layer_on_top","title":"<code>draw_layer_on_top(self)</code>","text":"<p>Move user-drawn feature layer to the top of all layers.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def draw_layer_on_top(self):\n\"\"\"Move user-drawn feature layer to the top of all layers.\"\"\"\n    draw_layer_index = self.find_layer_index(name=\"Drawn Features\")\n    if draw_layer_index &gt; -1 and draw_layer_index &lt; (len(self.layers) - 1):\n        layers = list(self.layers)\n        layers = (\n            layers[0:draw_layer_index]\n            + layers[(draw_layer_index + 1) :]\n            + [layers[draw_layer_index]]\n        )\n        self.layers = layers\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.extract_values_to_points","title":"<code>extract_values_to_points(self, filename)</code>","text":"<p>Exports pixel values to a csv file based on user-drawn geometries.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The output file path to the csv file or shapefile.</p> required Source code in <code>geemap/geemap.py</code> <pre><code>def extract_values_to_points(self, filename):\n\"\"\"Exports pixel values to a csv file based on user-drawn geometries.\n\n    Args:\n        filename (str): The output file path to the csv file or shapefile.\n    \"\"\"\n    import csv\n\n    filename = os.path.abspath(filename)\n    allowed_formats = [\"csv\", \"shp\"]\n    ext = filename[-3:]\n\n    if ext not in allowed_formats:\n        print(\n            \"The output file must be one of the following: {}\".format(\n                \", \".join(allowed_formats)\n            )\n        )\n        return\n\n    out_dir = os.path.dirname(filename)\n    out_csv = filename[:-3] + \"csv\"\n    out_shp = filename[:-3] + \"shp\"\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    count = len(self.chart_points)\n    out_list = []\n    if count &gt; 0:\n        header = [\"id\", \"longitude\", \"latitude\"] + self.chart_labels\n        out_list.append(header)\n\n        for i in range(0, count):\n            id = i + 1\n            line = [id] + self.chart_points[i] + self.chart_values[i]\n            out_list.append(line)\n\n        with open(out_csv, \"w\", newline=\"\") as f:\n            writer = csv.writer(f)\n            writer.writerows(out_list)\n\n        if ext == \"csv\":\n            print(f\"The csv file has been saved to: {out_csv}\")\n        else:\n            csv_to_shp(out_csv, out_shp)\n            print(f\"The shapefile has been saved to: {out_shp}\")\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.find_layer","title":"<code>find_layer(self, name)</code>","text":"<p>Finds layer by name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to find.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ipyleaflet layer object.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def find_layer(self, name):\n\"\"\"Finds layer by name\n\n    Args:\n        name (str): Name of the layer to find.\n\n    Returns:\n        object: ipyleaflet layer object.\n    \"\"\"\n    layers = self.layers\n\n    for layer in layers:\n        if layer.name == name:\n            return layer\n\n    return None\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.find_layer_index","title":"<code>find_layer_index(self, name)</code>","text":"<p>Finds layer index by name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to find.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the layer with the specified name</p> Source code in <code>geemap/geemap.py</code> <pre><code>def find_layer_index(self, name):\n\"\"\"Finds layer index by name\n\n    Args:\n        name (str): Name of the layer to find.\n\n    Returns:\n        int: Index of the layer with the specified name\n    \"\"\"\n    layers = self.layers\n\n    for index, layer in enumerate(layers):\n        if layer.name == name:\n            return index\n\n    return -1\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.getBounds","title":"<code>getBounds(self, asGeoJSON=False)</code>","text":"<p>Returns the bounds of the current map view, as a list in the format [west, south, east, north] in degrees.</p> <p>Parameters:</p> Name Type Description Default <code>asGeoJSON</code> <code>bool</code> <p>If true, returns map bounds as GeoJSON. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | dict</code> <p>A list in the format [west, south, east, north] in degrees.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def get_bounds(self, asGeoJSON=False):\n\"\"\"Returns the bounds of the current map view, as a list in the format [west, south, east, north] in degrees.\n\n    Args:\n        asGeoJSON (bool, optional): If true, returns map bounds as GeoJSON. Defaults to False.\n\n    Returns:\n        list | dict: A list in the format [west, south, east, north] in degrees.\n    \"\"\"\n    bounds = self.bounds\n    coords = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n\n    if asGeoJSON:\n        return ee.Geometry.BBox(\n            bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]\n        ).getInfo()\n    else:\n        return coords\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.getScale","title":"<code>getScale(self)</code>","text":"<p>Returns the approximate pixel scale of the current map view, in meters.</p> <p>Returns:</p> Type Description <code>float</code> <p>Map resolution in meters.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def get_scale(self):\n\"\"\"Returns the approximate pixel scale of the current map view, in meters.\n\n    Returns:\n        float: Map resolution in meters.\n    \"\"\"\n    zoom_level = self.zoom\n    # Reference: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution\n    resolution = 156543.04 * math.cos(0) / math.pow(2, zoom_level)\n    return resolution\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.get_bounds","title":"<code>get_bounds(self, asGeoJSON=False)</code>","text":"<p>Returns the bounds of the current map view, as a list in the format [west, south, east, north] in degrees.</p> <p>Parameters:</p> Name Type Description Default <code>asGeoJSON</code> <code>bool</code> <p>If true, returns map bounds as GeoJSON. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | dict</code> <p>A list in the format [west, south, east, north] in degrees.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def get_bounds(self, asGeoJSON=False):\n\"\"\"Returns the bounds of the current map view, as a list in the format [west, south, east, north] in degrees.\n\n    Args:\n        asGeoJSON (bool, optional): If true, returns map bounds as GeoJSON. Defaults to False.\n\n    Returns:\n        list | dict: A list in the format [west, south, east, north] in degrees.\n    \"\"\"\n    bounds = self.bounds\n    coords = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n\n    if asGeoJSON:\n        return ee.Geometry.BBox(\n            bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]\n        ).getInfo()\n    else:\n        return coords\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.get_scale","title":"<code>get_scale(self)</code>","text":"<p>Returns the approximate pixel scale of the current map view, in meters.</p> <p>Returns:</p> Type Description <code>float</code> <p>Map resolution in meters.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def get_scale(self):\n\"\"\"Returns the approximate pixel scale of the current map view, in meters.\n\n    Returns:\n        float: Map resolution in meters.\n    \"\"\"\n    zoom_level = self.zoom\n    # Reference: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution\n    resolution = 156543.04 * math.cos(0) / math.pow(2, zoom_level)\n    return resolution\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.image_overlay","title":"<code>image_overlay(self, url, bounds, name)</code>","text":"<p>Overlays an image from the Internet or locally on the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>http URL or local file path to the image.</p> required <code>bounds</code> <code>tuple</code> <p>bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).</p> required <code>name</code> <code>str</code> <p>name of the layer to show on the layer control.</p> required Source code in <code>geemap/geemap.py</code> <pre><code>def image_overlay(self, url, bounds, name):\n\"\"\"Overlays an image from the Internet or locally on the map.\n\n    Args:\n        url (str): http URL or local file path to the image.\n        bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n        name (str): name of the layer to show on the layer control.\n    \"\"\"\n    from base64 import b64encode\n    from io import BytesIO\n\n    from PIL import Image, ImageSequence\n\n    try:\n        if not url.startswith(\"http\"):\n            if not os.path.exists(url):\n                print(\"The provided file does not exist.\")\n                return\n\n            ext = os.path.splitext(url)[1][1:]  # file extension\n            image = Image.open(url)\n\n            f = BytesIO()\n            if ext.lower() == \"gif\":\n                frames = []\n                # Loop over each frame in the animated image\n                for frame in ImageSequence.Iterator(image):\n                    frame = frame.convert(\"RGBA\")\n                    b = BytesIO()\n                    frame.save(b, format=\"gif\")\n                    frame = Image.open(b)\n                    frames.append(frame)\n                frames[0].save(\n                    f,\n                    format=\"GIF\",\n                    save_all=True,\n                    append_images=frames[1:],\n                    loop=0,\n                )\n            else:\n                image.save(f, ext)\n\n            data = b64encode(f.getvalue())\n            data = data.decode(\"ascii\")\n            url = \"data:image/{};base64,\".format(ext) + data\n        img = ipyleaflet.ImageOverlay(url=url, bounds=bounds, name=name)\n        self.add_layer(img)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.inspector","title":"<code>inspector(self, latlon)</code>","text":"<p>Create the Inspector GUI.</p> <p>Parameters:</p> Name Type Description Default <code>latlon</code> <code>list | tuple</code> <p>The coordinates (lat, lon) of the point.</p> required <p>Returns:</p> Type Description <code>ipytree.Tree</code> <p>The ipytree tree widget for the Inspector GUI.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def inspector(self, latlon):\n\"\"\"Create the Inspector GUI.\n\n    Args:\n        latlon (list | tuple): The coordinates (lat, lon) of the point.\n    Returns:\n        ipytree.Tree: The ipytree tree widget for the Inspector GUI.\n    \"\"\"\n    tree = Tree()\n    nodes = []\n    point_node = self._point_info(latlon, return_node=True)\n    nodes.append(point_node)\n    pixels_node = self._pixels_info(latlon, return_node=True)\n    if pixels_node.nodes:\n        nodes.append(pixels_node)\n    objects_node = self._objects_info(latlon, return_node=True)\n    if objects_node.nodes:\n        nodes.append(objects_node)\n    tree.nodes = nodes\n    return tree\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.layer_opacity","title":"<code>layer_opacity(self, name, opacity=1.0)</code>","text":"<p>Changes layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer to change opacity.</p> required <code>opacity</code> <code>float</code> <p>The opacity value to set. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>geemap/geemap.py</code> <pre><code>def layer_opacity(self, name, opacity=1.0):\n\"\"\"Changes layer opacity.\n\n    Args:\n        name (str): The name of the layer to change opacity.\n        opacity (float, optional): The opacity value to set. Defaults to 1.0.\n    \"\"\"\n    layer = self.find_layer(name)\n    try:\n        layer.opacity = opacity\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.marker_cluster","title":"<code>marker_cluster(self)</code>","text":"<p>Adds a marker cluster to the map and returns a list of ee.Feature, which can be accessed using Map.ee_marker_cluster.</p> <p>Returns:</p> Type Description <code>object</code> <p>a list of ee.Feature</p> Source code in <code>geemap/geemap.py</code> <pre><code>def marker_cluster(self):\n\"\"\"Adds a marker cluster to the map and returns a list of ee.Feature, which can be accessed using Map.ee_marker_cluster.\n\n    Returns:\n        object: a list of ee.Feature\n    \"\"\"\n    coordinates = []\n    markers = []\n    marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n    self.last_click = []\n    self.all_clicks = []\n    self.ee_markers = []\n    self.add_layer(marker_cluster)\n\n    def handle_interaction(**kwargs):\n        latlon = kwargs.get(\"coordinates\")\n        if kwargs.get(\"type\") == \"click\":\n            coordinates.append(latlon)\n            geom = ee.Geometry.Point(latlon[1], latlon[0])\n            feature = ee.Feature(geom)\n            self.ee_markers.append(feature)\n            self.last_click = latlon\n            self.all_clicks = coordinates\n            markers.append(ipyleaflet.Marker(location=latlon))\n            marker_cluster.markers = markers\n        elif kwargs.get(\"type\") == \"mousemove\":\n            pass\n\n    # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp\n    self.default_style = {\"cursor\": \"crosshair\"}\n    self.on_interaction(handle_interaction)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.plot","title":"<code>plot(self, x, y, plot_type=None, overlay=False, position='bottomright', min_width=None, max_width=None, min_height=None, max_height=None, **kwargs)</code>","text":"<p>Creates a plot based on x-array and y-array data.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>numpy.ndarray or list</code> <p>The x-coordinates of the plotted line.</p> required <code>y</code> <code>numpy.ndarray or list</code> <p>The y-coordinates of the plotted line.</p> required <code>plot_type</code> <code>str</code> <p>The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay plotted lines on the figure. Defaults to False.</p> <code>False</code> <code>position</code> <code>str</code> <p>Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>min_width</code> <code>int</code> <p>Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_width</code> <code>int</code> <p>Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>min_height</code> <code>int</code> <p>Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_height</code> <code>int</code> <p>Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def plot(\n    self,\n    x,\n    y,\n    plot_type=None,\n    overlay=False,\n    position=\"bottomright\",\n    min_width=None,\n    max_width=None,\n    min_height=None,\n    max_height=None,\n    **kwargs,\n):\n\"\"\"Creates a plot based on x-array and y-array data.\n\n    Args:\n        x (numpy.ndarray or list): The x-coordinates of the plotted line.\n        y (numpy.ndarray or list): The y-coordinates of the plotted line.\n        plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.\n        overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False.\n        position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.\n        min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n\n    \"\"\"\n    if self.plot_widget is not None:\n        plot_widget = self.plot_widget\n    else:\n        plot_widget = widgets.Output(layout={\"border\": \"1px solid black\"})\n        plot_control = ipyleaflet.WidgetControl(\n            widget=plot_widget,\n            position=position,\n            min_width=min_width,\n            max_width=max_width,\n            min_height=min_height,\n            max_height=max_height,\n        )\n        self.plot_widget = plot_widget\n        self.plot_control = plot_control\n        self.add_control(plot_control)\n\n    if max_width is None:\n        max_width = 500\n    if max_height is None:\n        max_height = 300\n\n    if (plot_type is None) and (\"markers\" not in kwargs.keys()):\n        kwargs[\"markers\"] = \"circle\"\n\n    with plot_widget:\n        try:\n            fig = plt.figure(1, **kwargs)\n            if max_width is not None:\n                fig.layout.width = str(max_width) + \"px\"\n            if max_height is not None:\n                fig.layout.height = str(max_height) + \"px\"\n\n            plot_widget.clear_output(wait=True)\n            if not overlay:\n                plt.clear()\n\n            if plot_type is None:\n                if \"marker\" not in kwargs.keys():\n                    kwargs[\"marker\"] = \"circle\"\n                plt.plot(x, y, **kwargs)\n            elif plot_type == \"bar\":\n                plt.bar(x, y, **kwargs)\n            elif plot_type == \"scatter\":\n                plt.scatter(x, y, **kwargs)\n            elif plot_type == \"hist\":\n                plt.hist(y, **kwargs)\n            plt.show()\n\n        except Exception as e:\n            print(\"Failed to create plot.\")\n            raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.plot_demo","title":"<code>plot_demo(self, iterations=20, plot_type=None, overlay=False, position='bottomright', min_width=None, max_width=None, min_height=None, max_height=None, **kwargs)</code>","text":"<p>A demo of interactive plotting using random pixel coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>iterations</code> <code>int</code> <p>How many iterations to run for the demo. Defaults to 20.</p> <code>20</code> <code>plot_type</code> <code>str</code> <p>The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay plotted lines on the figure. Defaults to False.</p> <code>False</code> <code>position</code> <code>str</code> <p>Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>min_width</code> <code>int</code> <p>Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_width</code> <code>int</code> <p>Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>min_height</code> <code>int</code> <p>Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_height</code> <code>int</code> <p>Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def plot_demo(\n    self,\n    iterations=20,\n    plot_type=None,\n    overlay=False,\n    position=\"bottomright\",\n    min_width=None,\n    max_width=None,\n    min_height=None,\n    max_height=None,\n    **kwargs,\n):\n\"\"\"A demo of interactive plotting using random pixel coordinates.\n\n    Args:\n        iterations (int, optional): How many iterations to run for the demo. Defaults to 20.\n        plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.\n        overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False.\n        position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.\n        min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n    \"\"\"\n\n    import numpy as np\n\n    if self.random_marker is not None:\n        self.remove_layer(self.random_marker)\n\n    image = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\").select([0, 1, 2, 3, 4, 6])\n    self.addLayer(\n        image,\n        {\"bands\": [\"B4\", \"B3\", \"B2\"], \"gamma\": 1.4},\n        \"LANDSAT/LE7_TOA_5YEAR/1999_2003\",\n    )\n    self.setCenter(-50.078877, 25.190030, 3)\n    band_names = image.bandNames().getInfo()\n    # band_count = len(band_names)\n\n    latitudes = np.random.uniform(30, 48, size=iterations)\n    longitudes = np.random.uniform(-121, -76, size=iterations)\n\n    marker = ipyleaflet.Marker(location=(0, 0))\n    self.random_marker = marker\n    self.add_layer(marker)\n\n    for i in range(iterations):\n        try:\n            coordinate = ee.Geometry.Point([longitudes[i], latitudes[i]])\n            dict_values = image.sample(coordinate).first().toDictionary().getInfo()\n            band_values = list(dict_values.values())\n            title = \"{}/{}: Spectral signature at ({}, {})\".format(\n                i + 1,\n                iterations,\n                round(latitudes[i], 2),\n                round(longitudes[i], 2),\n            )\n            marker.location = (latitudes[i], longitudes[i])\n            self.plot(\n                band_names,\n                band_values,\n                plot_type=plot_type,\n                overlay=overlay,\n                min_width=min_width,\n                max_width=max_width,\n                min_height=min_height,\n                max_height=max_height,\n                title=title,\n                **kwargs,\n            )\n            time.sleep(0.3)\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.plot_raster","title":"<code>plot_raster(self, ee_object=None, sample_scale=None, plot_type=None, overlay=False, position='bottomright', min_width=None, max_width=None, min_height=None, max_height=None, **kwargs)</code>","text":"<p>Interactive plotting of Earth Engine data by clicking on the map.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>object</code> <p>The ee.Image or ee.ImageCollection to sample. Defaults to None.</p> <code>None</code> <code>sample_scale</code> <code>float</code> <p>A nominal scale in meters of the projection to sample in. Defaults to None.</p> <code>None</code> <code>plot_type</code> <code>str</code> <p>The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay plotted lines on the figure. Defaults to False.</p> <code>False</code> <code>position</code> <code>str</code> <p>Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>min_width</code> <code>int</code> <p>Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_width</code> <code>int</code> <p>Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>min_height</code> <code>int</code> <p>Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_height</code> <code>int</code> <p>Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def plot_raster(\n    self,\n    ee_object=None,\n    sample_scale=None,\n    plot_type=None,\n    overlay=False,\n    position=\"bottomright\",\n    min_width=None,\n    max_width=None,\n    min_height=None,\n    max_height=None,\n    **kwargs,\n):\n\"\"\"Interactive plotting of Earth Engine data by clicking on the map.\n\n    Args:\n        ee_object (object, optional): The ee.Image or ee.ImageCollection to sample. Defaults to None.\n        sample_scale (float, optional): A nominal scale in meters of the projection to sample in. Defaults to None.\n        plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.\n        overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False.\n        position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.\n        min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n\n    \"\"\"\n    if self.plot_control is not None:\n        del self.plot_widget\n        if self.plot_control in self.controls:\n            self.remove_control(self.plot_control)\n\n    if self.random_marker is not None:\n        self.remove_layer(self.random_marker)\n\n    plot_widget = widgets.Output(layout={\"border\": \"1px solid black\"})\n    plot_control = ipyleaflet.WidgetControl(\n        widget=plot_widget,\n        position=position,\n        min_width=min_width,\n        max_width=max_width,\n        min_height=min_height,\n        max_height=max_height,\n    )\n    self.plot_widget = plot_widget\n    self.plot_control = plot_control\n    self.add_control(plot_control)\n\n    self.default_style = {\"cursor\": \"crosshair\"}\n    msg = \"The plot function can only be used on ee.Image or ee.ImageCollection with more than one band.\"\n    if (ee_object is None) and len(self.ee_raster_layers) &gt; 0:\n        ee_object = self.ee_raster_layers[-1]\n        if isinstance(ee_object, ee.ImageCollection):\n            ee_object = ee_object.mosaic()\n    elif isinstance(ee_object, ee.ImageCollection):\n        ee_object = ee_object.mosaic()\n    elif not isinstance(ee_object, ee.Image):\n        print(msg)\n        return\n\n    if sample_scale is None:\n        sample_scale = self.getScale()\n\n    if max_width is None:\n        max_width = 500\n\n    band_names = ee_object.bandNames().getInfo()\n\n    coordinates = []\n    markers = []\n    marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n    self.last_click = []\n    self.all_clicks = []\n    self.add_layer(marker_cluster)\n\n    def handle_interaction(**kwargs2):\n        latlon = kwargs2.get(\"coordinates\")\n\n        if kwargs2.get(\"type\") == \"click\":\n            try:\n                coordinates.append(latlon)\n                self.last_click = latlon\n                self.all_clicks = coordinates\n                markers.append(ipyleaflet.Marker(location=latlon))\n                marker_cluster.markers = markers\n                self.default_style = {\"cursor\": \"wait\"}\n                xy = ee.Geometry.Point(latlon[::-1])\n                dict_values = (\n                    ee_object.sample(xy, scale=sample_scale)\n                    .first()\n                    .toDictionary()\n                    .getInfo()\n                )\n                band_values = list(dict_values.values())\n                self.plot(\n                    band_names,\n                    band_values,\n                    plot_type=plot_type,\n                    overlay=overlay,\n                    min_width=min_width,\n                    max_width=max_width,\n                    min_height=min_height,\n                    max_height=max_height,\n                    **kwargs,\n                )\n                self.default_style = {\"cursor\": \"crosshair\"}\n            except Exception as e:\n                if self.plot_widget is not None:\n                    with self.plot_widget:\n                        self.plot_widget.clear_output()\n                        print(\"No data for the clicked location.\")\n                else:\n                    print(e)\n                self.default_style = {\"cursor\": \"crosshair\"}\n\n    self.on_interaction(handle_interaction)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.remove_colorbar","title":"<code>remove_colorbar(self)</code>","text":"<p>Remove colorbar from the map.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def remove_colorbar(self):\n\"\"\"Remove colorbar from the map.\"\"\"\n    if self.colorbar is not None:\n        self.remove_control(self.colorbar)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.remove_colorbars","title":"<code>remove_colorbars(self)</code>","text":"<p>Remove all colorbars from the map.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def remove_colorbars(self):\n\"\"\"Remove all colorbars from the map.\"\"\"\n    if hasattr(self, \"colorbars\"):\n        for colorbar in self.colorbars:\n            if colorbar in self.controls:\n                self.remove_control(colorbar)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.remove_drawn_features","title":"<code>remove_drawn_features(self)</code>","text":"<p>Removes user-drawn geometries from the map</p> Source code in <code>geemap/geemap.py</code> <pre><code>def remove_drawn_features(self):\n\"\"\"Removes user-drawn geometries from the map\"\"\"\n    if self.draw_layer is not None:\n        self.remove_layer(self.draw_layer)\n        self.draw_count = 0\n        self.draw_features = []\n        self.draw_last_feature = None\n        self.draw_layer = None\n        self.draw_last_json = None\n        self.draw_last_bounds = None\n        self.user_roi = None\n        self.user_rois = None\n        self.chart_values = []\n        self.chart_points = []\n        self.chart_labels = None\n    if self.draw_control is not None:\n        self.draw_control.clear()\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.remove_ee_layer","title":"<code>remove_ee_layer(self, name)</code>","text":"<p>Removes an Earth Engine layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Earth Engine layer to remove.</p> required Source code in <code>geemap/geemap.py</code> <pre><code>def remove_ee_layer(self, name):\n\"\"\"Removes an Earth Engine layer.\n\n    Args:\n        name (str): The name of the Earth Engine layer to remove.\n    \"\"\"\n    if name in self.ee_layer_dict:\n        ee_object = self.ee_layer_dict[name][\"ee_object\"]\n        ee_layer = self.ee_layer_dict[name][\"ee_layer\"]\n        if name in self.ee_raster_layer_names:\n            self.ee_raster_layer_names.remove(name)\n            self.ee_raster_layers.remove(ee_object)\n        elif name in self.ee_vector_layer_names:\n            self.ee_vector_layer_names.remove(name)\n            self.ee_vector_layers.remove(ee_object)\n        self.ee_layers.remove(ee_object)\n        self.ee_layer_names.remove(name)\n        if ee_layer in self.layers:\n            self.remove_layer(ee_layer)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.remove_labels","title":"<code>remove_labels(self)</code>","text":"<p>Removes all labels from the map.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def remove_labels(self):\n\"\"\"Removes all labels from the map.\"\"\"\n    if hasattr(self, \"labels\"):\n        self.remove_layer(self.labels)\n        delattr(self, \"labels\")\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.remove_last_drawn","title":"<code>remove_last_drawn(self)</code>","text":"<p>Removes user-drawn geometries from the map</p> Source code in <code>geemap/geemap.py</code> <pre><code>def remove_last_drawn(self):\n\"\"\"Removes user-drawn geometries from the map\"\"\"\n    if self.draw_layer is not None:\n        collection = ee.FeatureCollection(self.draw_features[:-1])\n        ee_draw_layer = ee_tile_layer(\n            collection, {\"color\": \"blue\"}, \"Drawn Features\", True, 0.5\n        )\n        if self.draw_count == 1:\n            self.remove_drawn_features()\n        else:\n            self.substitute_layer(self.draw_layer, ee_draw_layer)\n            self.draw_layer = ee_draw_layer\n            self.draw_count -= 1\n            self.draw_features = self.draw_features[:-1]\n            self.draw_last_feature = self.draw_features[-1]\n            self.draw_layer = ee_draw_layer\n            self.draw_last_json = None\n            self.draw_last_bounds = None\n            self.user_roi = ee.Feature(\n                collection.toList(collection.size()).get(\n                    collection.size().subtract(1)\n                )\n            ).geometry()\n            self.user_rois = collection\n            self.chart_values = self.chart_values[:-1]\n            self.chart_points = self.chart_points[:-1]\n            # self.chart_labels = None\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.remove_legend","title":"<code>remove_legend(self)</code>","text":"<p>Remove legend from the map.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def remove_legend(self):\n\"\"\"Remove legend from the map.\"\"\"\n    if self.legend is not None:\n        if self.legend in self.controls:\n            self.remove_control(self.legend)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.remove_legends","title":"<code>remove_legends(self)</code>","text":"<p>Remove all legends from the map.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def remove_legends(self):\n\"\"\"Remove all legends from the map.\"\"\"\n    if hasattr(self, \"legends\"):\n        for legend in self.legends:\n            if legend in self.controls:\n                self.remove_control(legend)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.setCenter","title":"<code>setCenter(self, lon, lat, zoom=None)</code>","text":"<p>Centers the map view at a given coordinates with the given zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>The longitude of the center, in degrees.</p> required <code>lat</code> <code>float</code> <p>The latitude of the center, in degrees.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def set_center(self, lon, lat, zoom=None):\n\"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n    Args:\n        lon (float): The longitude of the center, in degrees.\n        lat (float): The latitude of the center, in degrees.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n    \"\"\"\n    self.center = (lat, lon)\n    if zoom is not None:\n        self.zoom = zoom\n\n    if is_arcpy():\n        arc_zoom_to_extent(lon, lat, lon, lat)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.setControlVisibility","title":"<code>setControlVisibility(self, layerControl=True, fullscreenControl=True, latLngPopup=True)</code>","text":"<p>Sets the visibility of the controls on the map.</p> <p>Parameters:</p> Name Type Description Default <code>layerControl</code> <code>bool</code> <p>Whether to show the control that allows the user to toggle layers on/off. Defaults to True.</p> <code>True</code> <code>fullscreenControl</code> <code>bool</code> <p>Whether to show the control that allows the user to make the map full-screen. Defaults to True.</p> <code>True</code> <code>latLngPopup</code> <code>bool</code> <p>Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def set_control_visibility(\n    self, layerControl=True, fullscreenControl=True, latLngPopup=True\n):\n\"\"\"Sets the visibility of the controls on the map.\n\n    Args:\n        layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True.\n        fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True.\n        latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.setOptions","title":"<code>setOptions(self, mapTypeId='HYBRID', styles=None, types=None)</code>","text":"<p>Adds Google basemap and controls to the ipyleaflet map.</p> <p>Parameters:</p> Name Type Description Default <code>mapTypeId</code> <code>str</code> <p>A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>styles</code> <code>object</code> <p>A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.</p> <code>None</code> <code>types</code> <code>list</code> <p>A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def set_options(self, mapTypeId=\"HYBRID\", styles=None, types=None):\n\"\"\"Adds Google basemap and controls to the ipyleaflet map.\n\n    Args:\n        mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.\n        styles (object, optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.\n        types (list, optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.\n    \"\"\"\n    self.clear_layers()\n    self.clear_controls()\n    self.scroll_wheel_zoom = True\n    self.add_control(ipyleaflet.ZoomControl(position=\"topleft\"))\n    self.add_control(ipyleaflet.LayersControl(position=\"topright\"))\n    self.add_control(ipyleaflet.ScaleControl(position=\"bottomleft\"))\n    self.add_control(ipyleaflet.FullScreenControl())\n    self.add_control(ipyleaflet.DrawControl())\n\n    measure = ipyleaflet.MeasureControl(\n        position=\"bottomleft\",\n        active_color=\"orange\",\n        primary_length_unit=\"kilometers\",\n    )\n    self.add_control(measure)\n\n    try:\n        self.add_layer(basemaps[mapTypeId])\n    except Exception:\n        raise ValueError(\n            'Google basemaps can only be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\".'\n        )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.set_center","title":"<code>set_center(self, lon, lat, zoom=None)</code>","text":"<p>Centers the map view at a given coordinates with the given zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>The longitude of the center, in degrees.</p> required <code>lat</code> <code>float</code> <p>The latitude of the center, in degrees.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def set_center(self, lon, lat, zoom=None):\n\"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n    Args:\n        lon (float): The longitude of the center, in degrees.\n        lat (float): The latitude of the center, in degrees.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n    \"\"\"\n    self.center = (lat, lon)\n    if zoom is not None:\n        self.zoom = zoom\n\n    if is_arcpy():\n        arc_zoom_to_extent(lon, lat, lon, lat)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.set_control_visibility","title":"<code>set_control_visibility(self, layerControl=True, fullscreenControl=True, latLngPopup=True)</code>","text":"<p>Sets the visibility of the controls on the map.</p> <p>Parameters:</p> Name Type Description Default <code>layerControl</code> <code>bool</code> <p>Whether to show the control that allows the user to toggle layers on/off. Defaults to True.</p> <code>True</code> <code>fullscreenControl</code> <code>bool</code> <p>Whether to show the control that allows the user to make the map full-screen. Defaults to True.</p> <code>True</code> <code>latLngPopup</code> <code>bool</code> <p>Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def set_control_visibility(\n    self, layerControl=True, fullscreenControl=True, latLngPopup=True\n):\n\"\"\"Sets the visibility of the controls on the map.\n\n    Args:\n        layerControl (bool, optional): Whether to show the control that allows the user to toggle layers on/off. Defaults to True.\n        fullscreenControl (bool, optional): Whether to show the control that allows the user to make the map full-screen. Defaults to True.\n        latLngPopup (bool, optional): Whether to show the control that pops up the Lat/lon when the user clicks on the map. Defaults to True.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.set_options","title":"<code>set_options(self, mapTypeId='HYBRID', styles=None, types=None)</code>","text":"<p>Adds Google basemap and controls to the ipyleaflet map.</p> <p>Parameters:</p> Name Type Description Default <code>mapTypeId</code> <code>str</code> <p>A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>styles</code> <code>object</code> <p>A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.</p> <code>None</code> <code>types</code> <code>list</code> <p>A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def set_options(self, mapTypeId=\"HYBRID\", styles=None, types=None):\n\"\"\"Adds Google basemap and controls to the ipyleaflet map.\n\n    Args:\n        mapTypeId (str, optional): A mapTypeId to set the basemap to. Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\" to select one of the standard Google Maps API map types. Defaults to 'HYBRID'.\n        styles (object, optional): A dictionary of custom MapTypeStyle objects keyed with a name that will appear in the map's Map Type Controls. Defaults to None.\n        types (list, optional): A list of mapTypeIds to make available. If omitted, but opt_styles is specified, appends all of the style keys to the standard Google Maps API map types.. Defaults to None.\n    \"\"\"\n    self.clear_layers()\n    self.clear_controls()\n    self.scroll_wheel_zoom = True\n    self.add_control(ipyleaflet.ZoomControl(position=\"topleft\"))\n    self.add_control(ipyleaflet.LayersControl(position=\"topright\"))\n    self.add_control(ipyleaflet.ScaleControl(position=\"bottomleft\"))\n    self.add_control(ipyleaflet.FullScreenControl())\n    self.add_control(ipyleaflet.DrawControl())\n\n    measure = ipyleaflet.MeasureControl(\n        position=\"bottomleft\",\n        active_color=\"orange\",\n        primary_length_unit=\"kilometers\",\n    )\n    self.add_control(measure)\n\n    try:\n        self.add_layer(basemaps[mapTypeId])\n    except Exception:\n        raise ValueError(\n            'Google basemaps can only be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\".'\n        )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.set_plot_options","title":"<code>set_plot_options(self, add_marker_cluster=False, sample_scale=None, plot_type=None, overlay=False, position='bottomright', min_width=None, max_width=None, min_height=None, max_height=None, **kwargs)</code>","text":"<p>Sets plotting options.</p> <p>Parameters:</p> Name Type Description Default <code>add_marker_cluster</code> <code>bool</code> <p>Whether to add a marker cluster. Defaults to False.</p> <code>False</code> <code>sample_scale</code> <code>float</code> <p>A nominal scale in meters of the projection to sample in . Defaults to None.</p> <code>None</code> <code>plot_type</code> <code>str</code> <p>The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.</p> <code>None</code> <code>overlay</code> <code>bool</code> <p>Whether to overlay plotted lines on the figure. Defaults to False.</p> <code>False</code> <code>position</code> <code>str</code> <p>Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>min_width</code> <code>int</code> <p>Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_width</code> <code>int</code> <p>Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>min_height</code> <code>int</code> <p>Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> <code>max_height</code> <code>int</code> <p>Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.</p> <code>None</code> Source code in <code>geemap/geemap.py</code> <pre><code>def set_plot_options(\n    self,\n    add_marker_cluster=False,\n    sample_scale=None,\n    plot_type=None,\n    overlay=False,\n    position=\"bottomright\",\n    min_width=None,\n    max_width=None,\n    min_height=None,\n    max_height=None,\n    **kwargs,\n):\n\"\"\"Sets plotting options.\n\n    Args:\n        add_marker_cluster (bool, optional): Whether to add a marker cluster. Defaults to False.\n        sample_scale (float, optional):  A nominal scale in meters of the projection to sample in . Defaults to None.\n        plot_type (str, optional): The plot type can be one of \"None\", \"bar\", \"scatter\" or \"hist\". Defaults to None.\n        overlay (bool, optional): Whether to overlay plotted lines on the figure. Defaults to False.\n        position (str, optional): Position of the control, can be \u2018bottomleft\u2019, \u2018bottomright\u2019, \u2018topleft\u2019, or \u2018topright\u2019. Defaults to 'bottomright'.\n        min_width (int, optional): Min width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        max_width (int, optional): Max width of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        min_height (int, optional): Min height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n        max_height (int, optional): Max height of the widget (in pixels), if None it will respect the content size. Defaults to None.\n\n    \"\"\"\n    plot_options_dict = {}\n    plot_options_dict[\"add_marker_cluster\"] = add_marker_cluster\n    plot_options_dict[\"sample_scale\"] = sample_scale\n    plot_options_dict[\"plot_type\"] = plot_type\n    plot_options_dict[\"overlay\"] = overlay\n    plot_options_dict[\"position\"] = position\n    plot_options_dict[\"min_width\"] = min_width\n    plot_options_dict[\"max_width\"] = max_width\n    plot_options_dict[\"min_height\"] = min_height\n    plot_options_dict[\"max_height\"] = max_height\n\n    for key in kwargs.keys():\n        plot_options_dict[key] = kwargs[key]\n\n    self.plot_options = plot_options_dict\n\n    if add_marker_cluster and (self.plot_marker_cluster not in self.layers):\n        self.add_layer(self.plot_marker_cluster)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.show_layer","title":"<code>show_layer(self, name, show=True)</code>","text":"<p>Shows or hides a layer on the map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to show/hide.</p> required <code>show</code> <code>bool</code> <p>Whether to show or hide the layer. Defaults to True.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def show_layer(self, name, show=True):\n\"\"\"Shows or hides a layer on the map.\n\n    Args:\n        name (str): Name of the layer to show/hide.\n        show (bool, optional): Whether to show or hide the layer. Defaults to True.\n    \"\"\"\n    layer = self.find_layer(name)\n\n    if layer is not None:\n        layer.visible = show\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.split_map","title":"<code>split_map(self, left_layer='HYBRID', right_layer='ROADMAP', zoom_control=True, fullscreen_control=True, layer_control=True, add_close_button=False, left_label=None, right_label=None, left_position='bottomleft', right_position='bottomright', widget_layout=None, **kwargs)</code>","text":"<p>Adds split map.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>The layer tile layer. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>right_layer</code> <code>str</code> <p>The right tile layer. Defaults to 'ROADMAP'.</p> <code>'ROADMAP'</code> <code>zoom_control</code> <code>bool</code> <p>Whether to show the zoom control. Defaults to True.</p> <code>True</code> <code>fullscreen_control</code> <code>bool</code> <p>Whether to show the full screen control. Defaults to True.</p> <code>True</code> <code>layer_control</code> <code>bool</code> <p>Whether to show the layer control. Defaults to True.</p> <code>True</code> <code>add_close_button</code> <code>bool</code> <p>Whether to add a close button. Defaults to False.</p> <code>False</code> <code>left_label</code> <code>str</code> <p>The label for the left map. Defaults to None.</p> <code>None</code> <code>right_label</code> <code>str</code> <p>The label for the right map. Defaults to None.</p> <code>None</code> <code>left_position</code> <code>str</code> <p>The position of the left label. Defaults to 'bottomleft'.</p> <code>'bottomleft'</code> <code>right_position</code> <code>str</code> <p>The position of the right label. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>widget_layout</code> <code>str</code> <p>The layout of the label widget, such as ipywidgets.Layout(padding=\"0px 4px 0px 4px\"). Defaults to None.</p> <code>None</code> <code>kwargs</code> <p>Other arguments for ipyleaflet.TileLayer.</p> <code>{}</code> Source code in <code>geemap/geemap.py</code> <pre><code>def split_map(\n    self,\n    left_layer=\"HYBRID\",\n    right_layer=\"ROADMAP\",\n    zoom_control=True,\n    fullscreen_control=True,\n    layer_control=True,\n    add_close_button=False,\n    left_label=None,\n    right_label=None,\n    left_position=\"bottomleft\",\n    right_position=\"bottomright\",\n    widget_layout=None,\n    **kwargs,\n):\n\"\"\"Adds split map.\n\n    Args:\n        left_layer (str, optional): The layer tile layer. Defaults to 'HYBRID'.\n        right_layer (str, optional): The right tile layer. Defaults to 'ROADMAP'.\n        zoom_control (bool, optional): Whether to show the zoom control. Defaults to True.\n        fullscreen_control (bool, optional): Whether to show the full screen control. Defaults to True.\n        layer_control (bool, optional): Whether to show the layer control. Defaults to True.\n        add_close_button (bool, optional): Whether to add a close button. Defaults to False.\n        left_label (str, optional): The label for the left map. Defaults to None.\n        right_label (str, optional): The label for the right map. Defaults to None.\n        left_position (str, optional): The position of the left label. Defaults to 'bottomleft'.\n        right_position (str, optional): The position of the right label. Defaults to 'bottomright'.\n        widget_layout (str, optional): The layout of the label widget, such as ipywidgets.Layout(padding=\"0px 4px 0px 4px\"). Defaults to None.\n        kwargs: Other arguments for ipyleaflet.TileLayer.\n    \"\"\"\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 100\n    if \"max_native_zoom\" not in kwargs:\n        kwargs[\"max_native_zoom\"] = 100\n    try:\n        controls = self.controls\n        layers = self.layers\n        self.clear_controls()\n\n        if zoom_control:\n            self.add_control(ipyleaflet.ZoomControl())\n        if fullscreen_control:\n            self.add_control(ipyleaflet.FullScreenControl())\n\n        if left_label is not None:\n            left_name = left_label\n        else:\n            left_name = \"Left Layer\"\n\n        if right_label is not None:\n            right_name = right_label\n        else:\n            right_name = \"Right Layer\"\n\n        if \"attribution\" not in kwargs:\n            kwargs[\"attribution\"] = \" \"\n\n        if left_layer in basemaps.keys():\n            left_layer = basemaps[left_layer]\n        elif isinstance(left_layer, str):\n            if left_layer.startswith(\"http\") and left_layer.endswith(\".tif\"):\n                url = cog_tile(left_layer)\n                left_layer = ipyleaflet.TileLayer(\n                    url=url,\n                    name=left_name,\n                    **kwargs,\n                )\n            else:\n                left_layer = ipyleaflet.TileLayer(\n                    url=left_layer,\n                    name=left_name,\n                    **kwargs,\n                )\n        elif isinstance(left_layer, ipyleaflet.TileLayer):\n            pass\n        else:\n            raise ValueError(\n                f\"left_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n\n        if right_layer in basemaps.keys():\n            right_layer = basemaps[right_layer]\n        elif isinstance(right_layer, str):\n            if right_layer.startswith(\"http\") and right_layer.endswith(\".tif\"):\n                url = cog_tile(right_layer)\n                right_layer = ipyleaflet.TileLayer(\n                    url=url,\n                    name=right_name,\n                    **kwargs,\n                )\n            else:\n                right_layer = ipyleaflet.TileLayer(\n                    url=right_layer,\n                    name=right_name,\n                    **kwargs,\n                )\n        elif isinstance(right_layer, ipyleaflet.TileLayer):\n            pass\n        else:\n            raise ValueError(\n                f\"right_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n\n        control = ipyleaflet.SplitMapControl(\n            left_layer=left_layer, right_layer=right_layer\n        )\n\n        self.add_control(control)\n\n        if left_label is not None:\n            if widget_layout is None:\n                widget_layout = widgets.Layout(padding=\"0px 4px 0px 4px\")\n            left_widget = widgets.HTML(value=left_label, layout=widget_layout)\n\n            left_control = ipyleaflet.WidgetControl(\n                widget=left_widget, position=left_position\n            )\n            self.add_control(left_control)\n\n        if right_label is not None:\n            if widget_layout is None:\n                widget_layout = widgets.Layout(padding=\"0px 4px 0px 4px\")\n            right_widget = widgets.HTML(value=right_label, layout=widget_layout)\n            right_control = ipyleaflet.WidgetControl(\n                widget=right_widget, position=right_position\n            )\n            self.add_control(right_control)\n\n        close_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Close split-panel map\",\n            icon=\"times\",\n            layout=widgets.Layout(\n                height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n            ),\n        )\n\n        def close_btn_click(change):\n            if change[\"new\"]:\n                self.controls = controls\n                self.layers = layers[:-1]\n                self.add_layer(layers[-1])\n\n            if left_label is not None:\n                self.remove_control(left_control)\n\n            if right_label is not None:\n                self.remove_control(right_control)\n\n        close_button.observe(close_btn_click, \"value\")\n        close_control = ipyleaflet.WidgetControl(\n            widget=close_button, position=\"bottomright\"\n        )\n\n        if add_close_button:\n            self.add_control(close_control)\n\n        if layer_control:\n            self.addLayerControl()\n\n    except Exception as e:\n        print(\"The provided layers are invalid!\")\n        raise ValueError(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.to_gradio","title":"<code>to_gradio(self, width='100%', height='500px', **kwargs)</code>","text":"<p>Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as     attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>The width of the map. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map. Defaults to '500px'.</p> <code>'500px'</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML string to use in Gradio.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def to_gradio(self, width=\"100%\", height=\"500px\", **kwargs):\n\"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n        attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n    Args:\n        width (str, optional): The width of the map. Defaults to '100%'.\n        height (str, optional): The height of the map. Defaults to '500px'.\n\n    Returns:\n        str: The HTML string to use in Gradio.\n    \"\"\"\n\n    print(\n        \"The ipyleaflet plotting backend does not support this function. Please use the folium backend instead.\"\n    )\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.to_html","title":"<code>to_html(self, filename=None, title='My Map', width='100%', height='880px', add_layer_control=True, **kwargs)</code>","text":"<p>Saves the map as an HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The output file path to the HTML file.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the HTML file. Defaults to 'My Map'.</p> <code>'My Map'</code> <code>width</code> <code>str</code> <p>The width of the map in pixels or percentage. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map in pixels. Defaults to '880px'.</p> <code>'880px'</code> <code>add_layer_control</code> <code>bool</code> <p>Whether to add the LayersControl. Defaults to True.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def to_html(\n    self,\n    filename=None,\n    title=\"My Map\",\n    width=\"100%\",\n    height=\"880px\",\n    add_layer_control=True,\n    **kwargs,\n):\n\"\"\"Saves the map as an HTML file.\n\n    Args:\n        filename (str, optional): The output file path to the HTML file.\n        title (str, optional): The title of the HTML file. Defaults to 'My Map'.\n        width (str, optional): The width of the map in pixels or percentage. Defaults to '100%'.\n        height (str, optional): The height of the map in pixels. Defaults to '880px'.\n        add_layer_control (bool, optional): Whether to add the LayersControl. Defaults to True.\n\n    \"\"\"\n    try:\n        save = True\n        if filename is not None:\n            if not filename.endswith(\".html\"):\n                raise ValueError(\"The output file extension must be html.\")\n            filename = os.path.abspath(filename)\n            out_dir = os.path.dirname(filename)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n        else:\n            filename = os.path.abspath(random_string() + \".html\")\n            save = False\n\n        if add_layer_control and self.layer_control is None:\n            layer_control = ipyleaflet.LayersControl(position=\"topright\")\n            self.layer_control = layer_control\n            self.add_control(layer_control)\n\n        before_width = self.layout.width\n        before_height = self.layout.height\n\n        if not isinstance(width, str):\n            print(\"width must be a string.\")\n            return\n        elif width.endswith(\"px\") or width.endswith(\"%\"):\n            pass\n        else:\n            print(\"width must end with px or %\")\n            return\n\n        if not isinstance(height, str):\n            print(\"height must be a string.\")\n            return\n        elif not height.endswith(\"px\"):\n            print(\"height must end with px\")\n            return\n\n        self.layout.width = width\n        self.layout.height = height\n\n        self.save(filename, title=title, **kwargs)\n\n        self.layout.width = before_width\n        self.layout.height = before_height\n\n        if not save:\n            out_html = \"\"\n            with open(filename) as f:\n                lines = f.readlines()\n                out_html = \"\".join(lines)\n            os.remove(filename)\n            return out_html\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.to_image","title":"<code>to_image(self, filename=None, monitor=1)</code>","text":"<p>Saves the map as a PNG or JPG image.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The output file path to the image. Defaults to None.</p> <code>None</code> <code>monitor</code> <code>int</code> <p>The monitor to take the screenshot. Defaults to 1.</p> <code>1</code> Source code in <code>geemap/geemap.py</code> <pre><code>def to_image(self, filename=None, monitor=1):\n\"\"\"Saves the map as a PNG or JPG image.\n\n    Args:\n        filename (str, optional): The output file path to the image. Defaults to None.\n        monitor (int, optional): The monitor to take the screenshot. Defaults to 1.\n    \"\"\"\n    if filename is None:\n        filename = os.path.join(os.getcwd(), \"my_map.png\")\n\n    if filename.endswith(\".png\") or filename.endswith(\".jpg\"):\n        pass\n    else:\n        print(\"The output file must be a PNG or JPG image.\")\n        return\n\n    work_dir = os.path.dirname(filename)\n    if not os.path.exists(work_dir):\n        os.makedirs(work_dir)\n\n    screenshot = screen_capture(filename, monitor)\n    self.screenshot = screenshot\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.to_streamlit","title":"<code>to_streamlit(self, width=None, height=600, scrolling=False, **kwargs)</code>","text":"<p>Renders map figure in a Streamlit app.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the map. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>responsive</code> <code>bool</code> <p>Whether to make the map responsive. Defaults to True.</p> required <code>scrolling</code> <code>bool</code> <p>If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def to_streamlit(self, width=None, height=600, scrolling=False, **kwargs):\n\"\"\"Renders map figure in a Streamlit app.\n\n    Args:\n        width (int, optional): Width of the map. Defaults to None.\n        height (int, optional): Height of the map. Defaults to 600.\n        responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n        scrolling (bool, optional): If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    try:\n        import streamlit.components.v1 as components\n\n        # if responsive:\n        #     make_map_responsive = \"\"\"\n        #     &lt;style&gt;\n        #     [title~=\"st.iframe\"] { width: 100%}\n        #     &lt;/style&gt;\n        #     \"\"\"\n        #     st.markdown(make_map_responsive, unsafe_allow_html=True)\n        return components.html(\n            self.to_html(), width=width, height=height, scrolling=scrolling\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.toolbar_reset","title":"<code>toolbar_reset(self)</code>","text":"<p>Reset the toolbar so that no tool is selected.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def toolbar_reset(self):\n\"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n    toolbar_grid = self.toolbar\n    for tool in toolbar_grid.children:\n        tool.value = False\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.ts_inspector","title":"<code>ts_inspector(self, left_ts, left_names=None, left_vis={}, left_index=0, right_ts=None, right_names=None, right_vis=None, right_index=-1, width='130px', date_format='YYYY-MM-dd', add_close_button=False, **kwargs)</code>","text":"<p>Creates a split-panel map for inspecting timeseries images.</p> <p>Parameters:</p> Name Type Description Default <code>left_ts</code> <code>object</code> <p>An ee.ImageCollection to show on the left panel.</p> required <code>left_names</code> <code>list</code> <p>A list of names to show under the left dropdown.</p> <code>None</code> <code>left_vis</code> <code>dict</code> <p>Visualization parameters for the left layer. Defaults to {}.</p> <code>{}</code> <code>left_index</code> <code>int</code> <p>The index of the left layer to show. Defaults to 0.</p> <code>0</code> <code>right_ts</code> <code>object</code> <p>An ee.ImageCollection to show on the right panel.</p> <code>None</code> <code>right_names</code> <code>list</code> <p>A list of names to show under the right dropdown.</p> <code>None</code> <code>right_vis</code> <code>dict</code> <p>Visualization parameters for the right layer. Defaults to {}.</p> <code>None</code> <code>right_index</code> <code>int</code> <p>The index of the right layer to show. Defaults to -1.</p> <code>-1</code> <code>width</code> <code>str</code> <p>The width of the dropdown list. Defaults to '130px'.</p> <code>'130px'</code> <code>date_format</code> <code>str</code> <p>The date format to show in the dropdown. Defaults to 'YYYY-MM-dd'.</p> <code>'YYYY-MM-dd'</code> <code>add_close_button</code> <code>bool</code> <p>Whether to show the close button. Defaults to False.</p> <code>False</code> Source code in <code>geemap/geemap.py</code> <pre><code>def ts_inspector(\n    self,\n    left_ts,\n    left_names=None,\n    left_vis={},\n    left_index=0,\n    right_ts=None,\n    right_names=None,\n    right_vis=None,\n    right_index=-1,\n    width=\"130px\",\n    date_format=\"YYYY-MM-dd\",\n    add_close_button=False,\n    **kwargs,\n):\n\"\"\"Creates a split-panel map for inspecting timeseries images.\n\n    Args:\n        left_ts (object): An ee.ImageCollection to show on the left panel.\n        left_names (list): A list of names to show under the left dropdown.\n        left_vis (dict, optional): Visualization parameters for the left layer. Defaults to {}.\n        left_index (int, optional): The index of the left layer to show. Defaults to 0.\n        right_ts (object): An ee.ImageCollection to show on the right panel.\n        right_names (list): A list of names to show under the right dropdown.\n        right_vis (dict, optional): Visualization parameters for the right layer. Defaults to {}.\n        right_index (int, optional): The index of the right layer to show. Defaults to -1.\n        width (str, optional): The width of the dropdown list. Defaults to '130px'.\n        date_format (str, optional): The date format to show in the dropdown. Defaults to 'YYYY-MM-dd'.\n        add_close_button (bool, optional): Whether to show the close button. Defaults to False.\n    \"\"\"\n    controls = self.controls\n    layers = self.layers\n\n    if left_names is None:\n        left_names = image_dates(left_ts, date_format=date_format).getInfo()\n\n    if right_ts is None:\n        right_ts = left_ts\n\n    if right_names is None:\n        right_names = left_names\n\n    if right_vis is None:\n        right_vis = left_vis\n\n    left_count = int(left_ts.size().getInfo())\n    right_count = int(right_ts.size().getInfo())\n\n    if left_count != len(left_names):\n        print(\n            \"The number of images in left_ts must match the number of layer names in left_names.\"\n        )\n        return\n    if right_count != len(right_names):\n        print(\n            \"The number of images in right_ts must match the number of layer names in right_names.\"\n        )\n        return\n\n    left_layer = ipyleaflet.TileLayer(\n        url=\"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n        attribution=\"Google\",\n        name=\"Google Maps\",\n    )\n    right_layer = ipyleaflet.TileLayer(\n        url=\"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n        attribution=\"Google\",\n        name=\"Google Maps\",\n    )\n\n    self.clear_controls()\n    left_dropdown = widgets.Dropdown(options=left_names, value=None)\n    right_dropdown = widgets.Dropdown(options=right_names, value=None)\n    left_dropdown.layout.max_width = width\n    right_dropdown.layout.max_width = width\n\n    left_control = ipyleaflet.WidgetControl(\n        widget=left_dropdown, position=\"topleft\"\n    )\n    right_control = ipyleaflet.WidgetControl(\n        widget=right_dropdown, position=\"topright\"\n    )\n\n    self.add_control(control=left_control)\n    self.add_control(control=right_control)\n\n    self.add_control(ipyleaflet.ZoomControl(position=\"topleft\"))\n    self.add_control(ipyleaflet.ScaleControl(position=\"bottomleft\"))\n    self.add_control(ipyleaflet.FullScreenControl())\n\n    def left_dropdown_change(change):\n        left_dropdown_index = left_dropdown.index\n        if left_dropdown_index is not None and left_dropdown_index &gt;= 0:\n            try:\n                if isinstance(left_ts, ee.ImageCollection):\n                    left_image = left_ts.toList(left_ts.size()).get(\n                        left_dropdown_index\n                    )\n                elif isinstance(left_ts, ee.List):\n                    left_image = left_ts.get(left_dropdown_index)\n                else:\n                    print(\"The left_ts argument must be an ImageCollection.\")\n                    return\n\n                if isinstance(left_image, ee.ImageCollection):\n                    left_image = ee.Image(left_image.mosaic())\n                elif isinstance(left_image, ee.Image):\n                    pass\n                else:\n                    left_image = ee.Image(left_image)\n\n                left_image = ee_tile_layer(\n                    left_image, left_vis, left_names[left_dropdown_index]\n                )\n                left_layer.url = left_image.url\n            except Exception as e:\n                print(e)\n                return\n\n    left_dropdown.observe(left_dropdown_change, names=\"value\")\n\n    def right_dropdown_change(change):\n        right_dropdown_index = right_dropdown.index\n        if right_dropdown_index is not None and right_dropdown_index &gt;= 0:\n            try:\n                if isinstance(right_ts, ee.ImageCollection):\n                    right_image = right_ts.toList(left_ts.size()).get(\n                        right_dropdown_index\n                    )\n                elif isinstance(right_ts, ee.List):\n                    right_image = right_ts.get(right_dropdown_index)\n                else:\n                    print(\"The left_ts argument must be an ImageCollection.\")\n                    return\n\n                if isinstance(right_image, ee.ImageCollection):\n                    right_image = ee.Image(right_image.mosaic())\n                elif isinstance(right_image, ee.Image):\n                    pass\n                else:\n                    right_image = ee.Image(right_image)\n\n                right_image = ee_tile_layer(\n                    right_image,\n                    right_vis,\n                    right_names[right_dropdown_index],\n                )\n                right_layer.url = right_image.url\n            except Exception as e:\n                print(e)\n                return\n\n    right_dropdown.observe(right_dropdown_change, names=\"value\")\n\n    if left_index is not None:\n        left_dropdown.value = left_names[left_index]\n    if right_index is not None:\n        right_dropdown.value = right_names[right_index]\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        # button_style=\"primary\",\n        layout=widgets.Layout(\n            height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n        ),\n    )\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            self.controls = controls\n            self.clear_layers()\n            self.layers = layers\n\n    close_button.observe(close_btn_click, \"value\")\n    close_control = ipyleaflet.WidgetControl(\n        widget=close_button, position=\"bottomright\"\n    )\n\n    try:\n        split_control = ipyleaflet.SplitMapControl(\n            left_layer=left_layer, right_layer=right_layer\n        )\n        self.add_control(split_control)\n\n        if add_close_button:\n            self.add_control(close_control)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.user_roi_coords","title":"<code>user_roi_coords(self, decimals=4)</code>","text":"<p>Return the bounding box of the ROI as a list of coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimals to round the coordinates to. Defaults to 4.</p> <code>4</code> Source code in <code>geemap/geemap.py</code> <pre><code>def user_roi_coords(self, decimals=4):\n\"\"\"Return the bounding box of the ROI as a list of coordinates.\n\n    Args:\n        decimals (int, optional): Number of decimals to round the coordinates to. Defaults to 4.\n    \"\"\"\n    return bbox_coords(self.user_roi, decimals=decimals)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.video_overlay","title":"<code>video_overlay(self, url, bounds, name='Video')</code>","text":"<p>Overlays a video from the Internet on the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\"</p> required <code>bounds</code> <code>tuple</code> <p>bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).</p> required <code>name</code> <code>str</code> <p>name of the layer to show on the layer control.</p> <code>'Video'</code> Source code in <code>geemap/geemap.py</code> <pre><code>def video_overlay(self, url, bounds, name=\"Video\"):\n\"\"\"Overlays a video from the Internet on the map.\n\n    Args:\n        url (str): http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\"\n        bounds (tuple): bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n        name (str): name of the layer to show on the layer control.\n    \"\"\"\n    try:\n        video = ipyleaflet.VideoOverlay(url=url, bounds=bounds, name=name)\n        self.add_layer(video)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.zoom_to_bounds","title":"<code>zoom_to_bounds(self, bounds)</code>","text":"<p>Zooms to a bounding box in the form of [minx, miny, maxx, maxy].</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list | tuple</code> <p>A list/tuple containing minx, miny, maxx, maxy values for the bounds.</p> required Source code in <code>geemap/geemap.py</code> <pre><code>def zoom_to_bounds(self, bounds):\n\"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n    Args:\n        bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n    \"\"\"\n    #  The ipyleaflet fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.zoom_to_gdf","title":"<code>zoom_to_gdf(self, gdf)</code>","text":"<p>Zooms to the bounding box of a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required Source code in <code>geemap/geemap.py</code> <pre><code>def zoom_to_gdf(self, gdf):\n\"\"\"Zooms to the bounding box of a GeoPandas GeoDataFrame.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n    \"\"\"\n    bounds = gdf.total_bounds\n    self.zoom_to_bounds(bounds)\n</code></pre>"},{"location":"geemap/#geemap.geemap.Map.zoom_to_me","title":"<code>zoom_to_me(self, zoom=14, add_marker=True)</code>","text":"<p>Zoom to the current device location.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>Zoom level. Defaults to 14.</p> <code>14</code> <code>add_marker</code> <code>bool</code> <p>Whether to add a marker of the current device location. Defaults to True.</p> <code>True</code> Source code in <code>geemap/geemap.py</code> <pre><code>def zoom_to_me(self, zoom=14, add_marker=True):\n\"\"\"Zoom to the current device location.\n\n    Args:\n        zoom (int, optional): Zoom level. Defaults to 14.\n        add_marker (bool, optional): Whether to add a marker of the current device location. Defaults to True.\n    \"\"\"\n    lat, lon = get_current_latlon()\n    self.set_center(lon, lat, zoom)\n\n    if add_marker:\n        marker = ipyleaflet.Marker(\n            location=(lat, lon),\n            draggable=False,\n            name=\"Device location\",\n        )\n        self.add_layer(marker)\n</code></pre>"},{"location":"geemap/#geemap.geemap.ee_tile_layer","title":"<code>ee_tile_layer(ee_object, vis_params={}, name='Layer untitled', shown=True, opacity=1.0)</code>","text":"<p>Converts and Earth Engine layer to ipyleaflet TileLayer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer untitled'.</p> <code>'Layer untitled'</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/geemap.py</code> <pre><code>def ee_tile_layer(\n    ee_object, vis_params={}, name=\"Layer untitled\", shown=True, opacity=1.0\n):\n\"\"\"Converts and Earth Engine layer to ipyleaflet TileLayer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer untitled'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n\n    image = None\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n    tile_layer = ipyleaflet.TileLayer(\n        url=map_id_dict[\"tile_fetcher\"].url_format,\n        attribution=\"Google Earth Engine\",\n        name=name,\n        opacity=opacity,\n        visible=shown,\n    )\n    return tile_layer\n</code></pre>"},{"location":"geemap/#geemap.geemap.linked_maps","title":"<code>linked_maps(rows=2, cols=2, height='400px', ee_objects=[], vis_params=[], labels=[], label_position='topright', **kwargs)</code>","text":"<p>Create linked maps of Earth Engine data layers.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows of maps to create. Defaults to 2.</p> <code>2</code> <code>cols</code> <code>int</code> <p>The number of columns of maps to create. Defaults to 2.</p> <code>2</code> <code>height</code> <code>str</code> <p>The height of each map in pixels. Defaults to \"400px\".</p> <code>'400px'</code> <code>ee_objects</code> <code>list</code> <p>The list of Earth Engine objects to use for each map. Defaults to [].</p> <code>[]</code> <code>vis_params</code> <code>list</code> <p>The list of visualization parameters to use for each map. Defaults to [].</p> <code>[]</code> <code>labels</code> <code>list</code> <p>The list of labels to show on the map. Defaults to [].</p> <code>[]</code> <code>label_position</code> <code>str</code> <p>The position of the label, can be [topleft, topright, bottomleft, bottomright]. Defaults to \"topright\".</p> <code>'topright'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the length of ee_objects is not equal to rows*cols.</p> <code>ValueError</code> <p>If the length of vis_params is not equal to rows*cols.</p> <code>ValueError</code> <p>If the length of labels is not equal to rows*cols.</p> <p>Returns:</p> Type Description <code>ipywidget</code> <p>A GridspecLayout widget.</p> Source code in <code>geemap/geemap.py</code> <pre><code>def linked_maps(\n    rows=2,\n    cols=2,\n    height=\"400px\",\n    ee_objects=[],\n    vis_params=[],\n    labels=[],\n    label_position=\"topright\",\n    **kwargs,\n):\n\"\"\"Create linked maps of Earth Engine data layers.\n\n    Args:\n        rows (int, optional): The number of rows of maps to create. Defaults to 2.\n        cols (int, optional): The number of columns of maps to create. Defaults to 2.\n        height (str, optional): The height of each map in pixels. Defaults to \"400px\".\n        ee_objects (list, optional): The list of Earth Engine objects to use for each map. Defaults to [].\n        vis_params (list, optional): The list of visualization parameters to use for each map. Defaults to [].\n        labels (list, optional): The list of labels to show on the map. Defaults to [].\n        label_position (str, optional): The position of the label, can be [topleft, topright, bottomleft, bottomright]. Defaults to \"topright\".\n\n    Raises:\n        ValueError: If the length of ee_objects is not equal to rows*cols.\n        ValueError: If the length of vis_params is not equal to rows*cols.\n        ValueError: If the length of labels is not equal to rows*cols.\n\n    Returns:\n        ipywidget: A GridspecLayout widget.\n    \"\"\"\n    grid = widgets.GridspecLayout(rows, cols, grid_gap=\"0px\")\n    count = rows * cols\n\n    maps = []\n\n    if len(ee_objects) &gt; 0:\n        if len(ee_objects) == 1:\n            ee_objects = ee_objects * count\n        elif len(ee_objects) &lt; count:\n            raise ValueError(f\"The length of ee_objects must be equal to {count}.\")\n\n    if len(vis_params) &gt; 0:\n        if len(vis_params) == 1:\n            vis_params = vis_params * count\n        elif len(vis_params) &lt; count:\n            raise ValueError(f\"The length of vis_params must be equal to {count}.\")\n\n    if len(labels) &gt; 0:\n        if len(labels) == 1:\n            labels = labels * count\n        elif len(labels) &lt; count:\n            raise ValueError(f\"The length of labels must be equal to {count}.\")\n\n    for i in range(rows):\n        for j in range(cols):\n            index = i * rows + j\n            m = Map(\n                height=height,\n                lite_mode=True,\n                add_google_map=False,\n                layout=widgets.Layout(margin=\"0px\", padding=\"0px\"),\n                **kwargs,\n            )\n\n            if len(ee_objects) &gt; 0:\n                m.addLayer(ee_objects[index], vis_params[index], labels[index])\n\n            if len(labels) &gt; 0:\n                label = widgets.Label(\n                    labels[index], layout=widgets.Layout(padding=\"0px 5px 0px 5px\")\n                )\n                control = ipyleaflet.WidgetControl(\n                    widget=label, position=label_position\n                )\n                m.add_control(control)\n\n            maps.append(m)\n            widgets.jslink((maps[0], \"center\"), (m, \"center\"))\n            widgets.jslink((maps[0], \"zoom\"), (m, \"zoom\"))\n\n            output = widgets.Output()\n            with output:\n                display(m)\n            grid[i, j] = output\n\n    return grid\n</code></pre>"},{"location":"get-started/","title":"Get Started","text":"<p>This Get Started guide is intended as a quick way to start programming with geemap and the Earth Engine Python API.</p>"},{"location":"get-started/#plotting-backends","title":"Plotting backends","text":"<p>Geemap has six plotting backends, including folium, ipyleaflet, plotly, pydeck, kepler.gl, and heremap. An interactive map created using one of the plotting backends can be displayed in a Jupyter environment, such as Google Colab, Jupyter Notebook, and JupyterLab. By default, <code>import geemap</code> will use the <code>ipyleaflet</code> plotting backend.</p> <p>The six plotting backends do not offer equal functionality. The <code>ipyleaflet</code> plotting backend provides the richest interactive functionality, including the custom toolset for loading, analyzing, and visualizing geospatial data interactively without coding. For example, users can add vector data (e.g., GeoJSON, Shapefile, KML, GeoDataFrame) and raster data (e.g., GeoTIFF, Cloud Optimized GeoTIFF [COG]) to the map with a few clicks (see Figure 1). Users can also perform geospatial analysis using the WhiteboxTools GUI with 468 geoprocessing tools directly within the map interface (see Figure 2). Other interactive functionality (e.g., split-panel map, linked map, time slider, time-series inspector) can also be useful for visualizing geospatial data. The <code>ipyleaflet</code> package is built upon <code>ipywidgets</code> and allows bidirectional communication between the front-end and the backend enabling the use of the map to capture user input (source). In contrast, <code>folium</code> has relatively limited interactive functionality. It is meant for displaying static data only. Note that the aforementioned custom toolset and interactive functionality are not available for other plotting backends. Compared with <code>ipyleaflet</code> and <code>folium</code>, the <code>pydeck</code>, <code>kepler.gl</code>, and <code>heremap</code> plotting backend provides some unique 3D mapping functionality. An API key from the Here Developer Portal is required to use <code>heremap</code>.</p> <p>To choose a specific plotting backend, use one of the following:</p> <ul> <li><code>import geemap.geemap as geemap</code></li> <li><code>import geemap.foliumap as geemap</code></li> <li><code>import geemap.deck as geemap</code></li> <li><code>import geemap.kepler as geemap</code></li> <li><code>import geemap.plotlymap as geemap</code></li> <li><code>import geemap.heremap as geemap</code></li> </ul>"},{"location":"get-started/#launch-jupyter-notebook","title":"Launch Jupyter notebook","text":"<pre><code>conda activate gee\njupyter notebook\n</code></pre>"},{"location":"get-started/#import-libraries","title":"Import libraries","text":"<pre><code>import ee\nimport geemap\n</code></pre>"},{"location":"get-started/#create-an-interactive-map","title":"Create an interactive map","text":"<pre><code>Map = geemap.Map(center=(40, -100), zoom=4)\nMap\n</code></pre>"},{"location":"get-started/#add-earth-engine-data","title":"Add Earth Engine data","text":"<pre><code>dem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n</code></pre>"},{"location":"get-started/#set-visualization-parameters","title":"Set visualization parameters","text":"<pre><code>dem_vis = {\n'min': 0,\n'max': 4000,\n'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']}\n\nlandsat_vis = {\n    'min': 20,\n    'max': 200,\n    'bands': ['B4', 'B3', 'B2']\n}\n</code></pre>"},{"location":"get-started/#display-data-on-the-map","title":"Display data on the map","text":"<pre><code>Map.addLayer(dem, dem_vis, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(landsat7, landsat_vis, 'Landsat 7')\nMap.addLayer(states, {}, \"US States\")\n</code></pre>"},{"location":"get-started/#interact-with-the-map","title":"Interact with the map","text":"<p>Once data are added to the map, you can interact with data using various tools, such as the drawing tools, inspector tool, plotting tool. Check the video below on how to use the Inspector tool to query Earth Engine interactively.</p> <p></p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#earth-engine-account","title":"Earth Engine Account","text":"<p>To use geemap, you must first sign up for a Google Earth Engine account. You cannot use Google Earth Engine unless your application has been approved. Once you receive the application approval email, you can log in to the Earth Engine Code Editor to get familiar with the JavaScript API.</p> <p></p>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>Geemap is available on PyPI. To install geemap, run this command in your terminal:</p> <pre><code>pip install geemap\n</code></pre>"},{"location":"installation/#install-from-conda-forge","title":"Install from conda-forge","text":"<p>Geemap is also available on conda-forge. If you have Anaconda or Miniconda installed on your computer, you can install geemap using the following command:</p> <pre><code>conda install geemap -c conda-forge\n</code></pre> <p>The geemap package has some optional dependencies, such as GeoPandas and localtileserver. These optional dependencies can be challenging to install on some computers, especially Windows. It is highly recommended that you create a fresh conda environment to install geemap. Follow the commands below to set up a conda env and install geemap:</p> <pre><code>conda install -n base mamba -c conda-forge\nmamba create -n gee geemap geopandas localtileserver python -c conda-forge\n</code></pre> <p>All the optional dependencies are listed in requirements_all.txt, which can be installed using one of the following:</p> <ul> <li><code>pip install geemap[all]</code>: installing all optional dependencies listed in requirements_all.txt.</li> <li><code>pip install geemap[backends]</code>: installing keplergl, pydeck.</li> <li><code>pip install geemap[lidar]</code>: installing ipygany, ipyvtklink, laspy, panel, pyntcloud[LAS], pyvista.</li> <li><code>pip install geemap[raster]</code>: installing localtileserver, rio-cogeo, rioxarray, netcdf4, xarray_leaflet.</li> <li><code>pip install geemap[sql]</code>: installing psycopg2, sqlalchemy.</li> <li><code>pip install geemap[streamlit]</code>: installing streamlit-folium.</li> <li><code>pip install geemap[vector]</code>: installing geopandas, osmnx.</li> </ul> <p>Optionally, you can install some Jupyter notebook extensions, which can improve your productivity in the notebook environment. Some useful extensions include Table of Contents, Gist-it, Autopep8, Variable Inspector, etc. See this post for more information.</p> <pre><code>conda install jupyter_contrib_nbextensions -c conda-forge\n</code></pre> <p>Check the YouTube video below on how to install geemap using conda.</p> <p></p>"},{"location":"installation/#install-from-github","title":"Install from GitHub","text":"<p>To install the development version from GitHub using Git, run the following command in your terminal:</p> <pre><code>pip install git+https://github.com/gee-community/geemap\n</code></pre>"},{"location":"installation/#upgrade-geemap","title":"Upgrade geemap","text":"<p>If you have installed geemap before and want to upgrade to the latest version, you can run the following command in your terminal:</p> <pre><code>pip install -U geemap\n</code></pre> <p>If you use conda, you can update geemap to the latest version by running the following command in your terminal:</p> <pre><code>conda update -c conda-forge geemap\n</code></pre> <p>To install the development version from GitHub directly within Jupyter notebook without using Git, run the following code:</p> <pre><code>import geemap\ngeemap.update_package()\n</code></pre>"},{"location":"installation/#use-docker","title":"Use Docker","text":"<p>You can also use Docker to run geemap:</p> <pre><code>docker run -it -p 8888:8888 gee-community/geemap:latest\n</code></pre>"},{"location":"kepler/","title":"kepler module","text":""},{"location":"kepler/#geemap.kepler.Map","title":"<code> Map            (KeplerGl)         </code>","text":"<p>The Map class inherits keplergl.KeperGl.</p> <p>Returns:</p> Type Description <code>object</code> <p>keplergl.KeperGl map object.</p> Source code in <code>geemap/kepler.py</code> <pre><code>class Map(keplergl.KeplerGl):\n\"\"\"The Map class inherits keplergl.KeperGl.\n\n    Returns:\n        object: keplergl.KeperGl map object.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        if \"center\" not in kwargs:\n            kwargs[\"center\"] = [20, 0]\n\n        if \"zoom\" not in kwargs:\n            kwargs[\"zoom\"] = 1.3\n\n        if \"height\" not in kwargs:\n            kwargs[\"height\"] = 600\n        elif \"px\" in str(kwargs[\"height\"]):\n            kwargs[\"height\"] = kwargs[\"height\"].replace(\"px\", \"\")\n\n        if \"width\" not in kwargs:\n            kwargs[\"width\"] = 600\n        elif \"px\" in str(kwargs[\"width\"]):\n            kwargs[\"width\"] = kwargs[\"width\"].replace(\"px\", \"\")\n\n        if \"widescreen\" not in kwargs:\n            kwargs[\"widescreen\"] = False\n\n        if \"pitch\" not in kwargs:\n            kwargs[\"pitch\"] = 0\n\n        if \"bearing\" not in kwargs:\n            kwargs[\"bearing\"] = 0\n\n        if \"dragRotate\" not in kwargs:\n            kwargs[\"dragRotate\"] = False\n\n        if \"isSplit\" not in kwargs:\n            kwargs[\"isSplit\"] = False\n\n        if kwargs[\"widescreen\"]:\n            display(HTML(\"&lt;style&gt;.container { width:100% !important; }&lt;/style&gt;\"))\n\n        config = {\n            \"version\": \"v1\",\n            \"config\": {\n                \"mapState\": {\n                    \"latitude\": kwargs[\"center\"][0],\n                    \"longitude\": kwargs[\"center\"][1],\n                    \"zoom\": kwargs[\"zoom\"],\n                    \"bearing\": kwargs[\"bearing\"],\n                    \"pitch\": kwargs[\"pitch\"],\n                    \"isSplit\": kwargs[\"isSplit\"],\n                    \"dragRotate\": kwargs[\"dragRotate\"],\n                    \"height\": kwargs[\"height\"],\n                    \"width\": kwargs[\"width\"],\n                }\n            },\n        }\n\n        kwargs.pop(\"widescreen\")\n        kwargs.pop(\"center\")\n        kwargs.pop(\"zoom\")\n        if \"show_docs\" not in kwargs:\n            kwargs[\"show_docs\"] = False\n\n        super().__init__(**kwargs)\n        self.config = config\n\n    # def _repr_mimebundle_(self, include=None, exclude=None):\n    #     \"\"\"Display the map in a notebook.\n\n    #     Args:\n    #         include (list, optional): A list of MIME types to include.\n    #         exclude (list, optional): A list of MIME types to exclude.\n\n    #     Returns:\n    #         dict: A dictionary of MIME type keyed dict of MIME type data.\n    #     \"\"\"\n    #     print(\"hello\")\n    #     # import base64\n\n    #     # bundle = super()._repr_mimebundle_(include=include, exclude=exclude)\n    #     # if bundle[\"text/html\"]:\n    #     #     bundle[\"text/html\"] = self.display_html()\n    #     # return bundle\n\n    def add_geojson(self, in_geojson, layer_name=\"Untitled\", config=None, **kwargs):\n\"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided GeoJSON file could not be found.\n            TypeError: The input geojson must be a type of str or dict.\n        \"\"\"\n\n        if \"encoding\" in kwargs:\n            encoding = kwargs[\"encoding\"]\n        else:\n            encoding = \"utf-8\"\n\n        try:\n            if isinstance(in_geojson, str):\n                if in_geojson.startswith(\"http\"):\n                    data = requests.get(in_geojson).json()\n                else:\n                    in_geojson = os.path.abspath(in_geojson)\n                    if not os.path.exists(in_geojson):\n                        raise FileNotFoundError(\n                            \"The provided GeoJSON file could not be found.\"\n                        )\n\n                    with open(in_geojson, encoding=encoding) as f:\n                        data = json.load(f)\n            elif isinstance(in_geojson, dict):\n                data = in_geojson\n            else:\n                raise TypeError(\"The input geojson must be a type of str or dict.\")\n        except Exception as e:\n            raise Exception(e)\n\n        self.add_data(data, name=layer_name)\n        self.load_config(config)\n\n    def add_shp(self, in_shp, layer_name=\"Untitled\", config=None, **kwargs):\n\"\"\"Adds a shapefile to the map.\n\n        Args:\n            in_shp (str): The input file path to the shapefile.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided shapefile could not be found.\n        \"\"\"\n\n        import glob\n\n        if in_shp.startswith(\"http\") and in_shp.endswith(\".zip\"):\n            out_dir = os.path.abspath(\"./cache/shp\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            download_from_url(in_shp, out_dir=out_dir, verbose=False)\n            files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n            if len(files) &gt; 0:\n                in_shp = files[0]\n            else:\n                raise FileNotFoundError(\n                    \"The downloaded zip file does not contain any shapefile in the root directory.\"\n                )\n        else:\n            in_shp = os.path.abspath(in_shp)\n            if not os.path.exists(in_shp):\n                raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n        geojson = shp_to_geojson(in_shp)\n        self.add_geojson(\n            geojson,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n\n    def add_gdf(\n        self,\n        gdf,\n        layer_name=\"Untitled\",\n        config=None,\n        **kwargs,\n    ):\n\"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n\n        data = gdf_to_geojson(gdf, epsg=\"4326\")\n        self.add_geojson(data, layer_name, **kwargs)\n        self.load_config(config)\n\n    def add_df(\n        self,\n        df,\n        layer_name=\"Untitled\",\n        config=None,\n        **kwargs,\n    ):\n\"\"\"Adds a DataFrame to the map.\n\n        Args:\n            df (DataFrame): A Pandas DataFrame.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n        try:\n            self.add_data(data=df, name=layer_name)\n            self.load_config(config)\n        except Exception as e:\n            print(e)\n\n    def add_csv(\n        self,\n        in_csv,\n        layer_name=\"Untitled\",\n        config=None,\n        **kwargs,\n    ):\n\"\"\"Adds a CSV to the map.\n\n        Args:\n            in_csv (str): File path to the CSV.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n\n        df = pd.read_csv(in_csv)\n        self.add_df(df, layer_name, config, **kwargs)\n\n    def add_vector(\n        self,\n        filename,\n        layer_name=\"Untitled\",\n        config=None,\n        **kwargs,\n    ):\n\"\"\"Adds any geopandas-supported vector dataset to the map.\n\n        Args:\n            filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n            layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n        if not filename.startswith(\"http\"):\n            filename = os.path.abspath(filename)\n\n        ext = os.path.splitext(filename)[1].lower()\n        if ext == \".shp\":\n            self.add_shp(\n                filename,\n                layer_name,\n                **kwargs,\n            )\n            self.load_config(config)\n        elif ext in [\".json\", \".geojson\"]:\n            self.add_geojson(\n                filename,\n                layer_name,\n                **kwargs,\n            )\n            self.load_config(config)\n        else:\n            geojson = vector_to_geojson(\n                filename,\n                epsg=\"4326\",\n                **kwargs,\n            )\n\n            self.add_geojson(\n                geojson,\n                layer_name,\n                **kwargs,\n            )\n            self.load_config(config)\n\n    def add_kml(\n        self,\n        in_kml,\n        layer_name=\"Untitled\",\n        config=None,\n        **kwargs,\n    ):\n\"\"\"Adds a KML file to the map.\n\n        Args:\n            in_kml (str): The input file path to the KML.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided KML file could not be found.\n        \"\"\"\n\n        if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n            out_dir = os.path.abspath(\"./cache\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            download_from_url(in_kml, out_dir=out_dir, unzip=False, verbose=False)\n            in_kml = os.path.join(out_dir, os.path.basename(in_kml))\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n        else:\n            in_kml = os.path.abspath(in_kml)\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The provided KML could not be found.\")\n\n        self.add_vector(\n            in_kml,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n\n    def add_gdf_from_postgis(\n        self,\n        sql,\n        con,\n        layer_name=\"Untitled\",\n        config=None,\n        **kwargs,\n    ):\n\"\"\"Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.\n\n        Args:\n            sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n            con (sqlalchemy.engine.Engine): Active connection to the database to query.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n        gdf = read_postgis(sql, con, **kwargs)\n        gdf = gdf.to_crs(\"epsg:4326\")\n        self.add_gdf(\n            gdf,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n\n    def static_map(\n        self, width=950, height=600, read_only=False, out_file=None, **kwargs\n    ):\n\"\"\"Display a kepler.gl static map in a Jupyter Notebook.\n\n        Args\n            width (int, optional): Width of the map. Defaults to 950.\n            height (int, optional): Height of the map. Defaults to 600.\n            read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n            out_file (str, optional): Output html file path. Defaults to None.\n        \"\"\"\n        if isinstance(self, keplergl.KeplerGl):\n            if out_file is None:\n                if os.environ.get(\"USE_MKDOCS\") is not None:\n                    out_file = \"../maps/\" + \"kepler_\" + random_string(3) + \".html\"\n                else:\n                    out_file = \"./cache/\" + \"kepler_\" + random_string(3) + \".html\"\n            out_dir = os.path.abspath(os.path.dirname(out_file))\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            output = widgets.Output()\n            with output:\n                self.save_to_html(file_name=out_file, read_only=read_only)\n            display_html(src=out_file, width=width, height=height)\n        else:\n            raise TypeError(\"The provided map is not a kepler.gl map.\")\n\n    def to_html(\n        self,\n        filename=None,\n        read_only=False,\n        **kwargs,\n    ):\n\"\"\"Saves the map as a HTML file.\n\n        Args:\n            filename (str, optional): The output file path to the HTML file.\n            read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n\n        \"\"\"\n        try:\n            save = True\n            if filename is not None:\n                if not filename.endswith(\".html\"):\n                    raise ValueError(\"The output file extension must be html.\")\n                filename = os.path.abspath(filename)\n                out_dir = os.path.dirname(filename)\n                if not os.path.exists(out_dir):\n                    os.makedirs(out_dir)\n            else:\n                filename = os.path.abspath(random_string() + \".html\")\n                save = False\n\n            output = widgets.Output()\n            with output:\n                self.save_to_html(file_name=filename, read_only=read_only)\n\n            if not save:\n                out_html = \"\"\n                with open(filename) as f:\n                    lines = f.readlines()\n                    out_html = \"\".join(lines)\n                os.remove(filename)\n                return out_html\n\n        except Exception as e:\n            raise Exception(e)\n\n    def to_streamlit(\n        self, width=800, height=600, responsive=True, scrolling=False, **kwargs\n    ):\n\"\"\"Renders `keplergl.KeplerGl` map figure in a Streamlit app.\n\n        Args:\n            width (int, optional): Width of the map. Defaults to 800.\n            height (int, optional): Height of the map. Defaults to 600.\n            responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n            scrolling (bool, optional): If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.\n\n        Raises:\n            ImportError: If streamlit is not installed.\n\n        Returns:\n            streamlit.components: components.html object.\n        \"\"\"\n\n        try:\n            import streamlit as st\n            import streamlit.components.v1 as components\n\n            html = self._repr_html_()\n            if responsive:\n                make_map_responsive = \"\"\"\n                &lt;style&gt;\n                [title~=\"st.iframe\"] { width: 100%}\n                &lt;/style&gt;\n                \"\"\"\n                st.markdown(make_map_responsive, unsafe_allow_html=True)\n            return components.html(\n                html, width=width, height=height, scrolling=scrolling\n            )\n\n        except ImportError:\n            raise ImportError(\n                \"streamlit is not installed. You need to install streamlitusing 'pip install streamlit'. Seehttps://docs.streamlit.io/library/get-started/installation\"\n            )\n\n    def load_config(self, config=None):\n\"\"\"Loads a kepler.gl config file.\n\n        Args:\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided config file could not be found.\n            TypeError: The provided config file is not a kepler.gl config file.\n        \"\"\"\n        if config is None:\n            pass\n        elif isinstance(config, dict):\n            self.config = config\n        elif isinstance(config, str):\n            if config.startswith(\"http\"):\n                r = requests.get(config)\n                self.config = r.json()\n            elif os.path.isfile(config):\n                with open(config) as f:\n                    self.config = json.load(f)\n            else:\n                raise FileNotFoundError(\"The provided config file could not be found.\")\n        else:\n            raise TypeError(\"The provided config is not a dictionary or filepath.\")\n\n    def save_config(self, out_json):\n\"\"\"Saves a kepler.gl config file.\n\n        Args:\n            out_json (str): Output file path to the config file.\n\n        Raises:\n            ValueError: The output file extension must be json.\n            TypeError: The provided filepath is invalid.\n        \"\"\"\n        if isinstance(out_json, str):\n            if not out_json.endswith(\".json\"):\n                raise ValueError(\"The output file extension must be json.\")\n            out_json = os.path.abspath(out_json)\n            out_dir = os.path.dirname(out_json)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            json_str = json.dumps(self.config, indent=2)\n            with open(out_json, \"w\") as f:\n                f.write(json_str)\n        else:\n            raise TypeError(\"The provided filepath is invalid.\")\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.add_csv","title":"<code>add_csv(self, in_csv, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a CSV to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path to the CSV.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>geemap/kepler.py</code> <pre><code>def add_csv(\n    self,\n    in_csv,\n    layer_name=\"Untitled\",\n    config=None,\n    **kwargs,\n):\n\"\"\"Adds a CSV to the map.\n\n    Args:\n        in_csv (str): File path to the CSV.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n\n    df = pd.read_csv(in_csv)\n    self.add_df(df, layer_name, config, **kwargs)\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.add_df","title":"<code>add_df(self, df, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a DataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A Pandas DataFrame.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>geemap/kepler.py</code> <pre><code>def add_df(\n    self,\n    df,\n    layer_name=\"Untitled\",\n    config=None,\n    **kwargs,\n):\n\"\"\"Adds a DataFrame to the map.\n\n    Args:\n        df (DataFrame): A Pandas DataFrame.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n    try:\n        self.add_data(data=df, name=layer_name)\n        self.load_config(config)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.add_gdf","title":"<code>add_gdf(self, gdf, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>geemap/kepler.py</code> <pre><code>def add_gdf(\n    self,\n    gdf,\n    layer_name=\"Untitled\",\n    config=None,\n    **kwargs,\n):\n\"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n\n    data = gdf_to_geojson(gdf, epsg=\"4326\")\n    self.add_geojson(data, layer_name, **kwargs)\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.add_gdf_from_postgis","title":"<code>add_gdf_from_postgis(self, sql, con, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>geemap/kepler.py</code> <pre><code>def add_gdf_from_postgis(\n    self,\n    sql,\n    con,\n    layer_name=\"Untitled\",\n    config=None,\n    **kwargs,\n):\n\"\"\"Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n    gdf = read_postgis(sql, con, **kwargs)\n    gdf = gdf.to_crs(\"epsg:4326\")\n    self.add_gdf(\n        gdf,\n        layer_name,\n        **kwargs,\n    )\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.add_geojson","title":"<code>add_geojson(self, in_geojson, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The file path or http URL to the input GeoJSON or a dictionary containing the geojson.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided GeoJSON file could not be found.</p> <code>TypeError</code> <p>The input geojson must be a type of str or dict.</p> Source code in <code>geemap/kepler.py</code> <pre><code>def add_geojson(self, in_geojson, layer_name=\"Untitled\", config=None, **kwargs):\n\"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided GeoJSON file could not be found.\n        TypeError: The input geojson must be a type of str or dict.\n    \"\"\"\n\n    if \"encoding\" in kwargs:\n        encoding = kwargs[\"encoding\"]\n    else:\n        encoding = \"utf-8\"\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n    except Exception as e:\n        raise Exception(e)\n\n    self.add_data(data, name=layer_name)\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.add_kml","title":"<code>add_kml(self, in_kml, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a KML file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The input file path to the KML.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided KML file could not be found.</p> Source code in <code>geemap/kepler.py</code> <pre><code>def add_kml(\n    self,\n    in_kml,\n    layer_name=\"Untitled\",\n    config=None,\n    **kwargs,\n):\n\"\"\"Adds a KML file to the map.\n\n    Args:\n        in_kml (str): The input file path to the KML.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided KML file could not be found.\n    \"\"\"\n\n    if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n        out_dir = os.path.abspath(\"./cache\")\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        download_from_url(in_kml, out_dir=out_dir, unzip=False, verbose=False)\n        in_kml = os.path.join(out_dir, os.path.basename(in_kml))\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n    else:\n        in_kml = os.path.abspath(in_kml)\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The provided KML could not be found.\")\n\n    self.add_vector(\n        in_kml,\n        layer_name,\n        **kwargs,\n    )\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.add_shp","title":"<code>add_shp(self, in_shp, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input file path to the shapefile.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shapefile could not be found.</p> Source code in <code>geemap/kepler.py</code> <pre><code>def add_shp(self, in_shp, layer_name=\"Untitled\", config=None, **kwargs):\n\"\"\"Adds a shapefile to the map.\n\n    Args:\n        in_shp (str): The input file path to the shapefile.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided shapefile could not be found.\n    \"\"\"\n\n    import glob\n\n    if in_shp.startswith(\"http\") and in_shp.endswith(\".zip\"):\n        out_dir = os.path.abspath(\"./cache/shp\")\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        download_from_url(in_shp, out_dir=out_dir, verbose=False)\n        files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n        if len(files) &gt; 0:\n            in_shp = files[0]\n        else:\n            raise FileNotFoundError(\n                \"The downloaded zip file does not contain any shapefile in the root directory.\"\n            )\n    else:\n        in_shp = os.path.abspath(in_shp)\n        if not os.path.exists(in_shp):\n            raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n    geojson = shp_to_geojson(in_shp)\n    self.add_geojson(\n        geojson,\n        layer_name,\n        **kwargs,\n    )\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.add_vector","title":"<code>add_vector(self, filename, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds any geopandas-supported vector dataset to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>geemap/kepler.py</code> <pre><code>def add_vector(\n    self,\n    filename,\n    layer_name=\"Untitled\",\n    config=None,\n    **kwargs,\n):\n\"\"\"Adds any geopandas-supported vector dataset to the map.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".shp\":\n        self.add_shp(\n            filename,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n    elif ext in [\".json\", \".geojson\"]:\n        self.add_geojson(\n            filename,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n    else:\n        geojson = vector_to_geojson(\n            filename,\n            epsg=\"4326\",\n            **kwargs,\n        )\n\n        self.add_geojson(\n            geojson,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.load_config","title":"<code>load_config(self, config=None)</code>","text":"<p>Loads a kepler.gl config file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided config file could not be found.</p> <code>TypeError</code> <p>The provided config file is not a kepler.gl config file.</p> Source code in <code>geemap/kepler.py</code> <pre><code>def load_config(self, config=None):\n\"\"\"Loads a kepler.gl config file.\n\n    Args:\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided config file could not be found.\n        TypeError: The provided config file is not a kepler.gl config file.\n    \"\"\"\n    if config is None:\n        pass\n    elif isinstance(config, dict):\n        self.config = config\n    elif isinstance(config, str):\n        if config.startswith(\"http\"):\n            r = requests.get(config)\n            self.config = r.json()\n        elif os.path.isfile(config):\n            with open(config) as f:\n                self.config = json.load(f)\n        else:\n            raise FileNotFoundError(\"The provided config file could not be found.\")\n    else:\n        raise TypeError(\"The provided config is not a dictionary or filepath.\")\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.save_config","title":"<code>save_config(self, out_json)</code>","text":"<p>Saves a kepler.gl config file.</p> <p>Parameters:</p> Name Type Description Default <code>out_json</code> <code>str</code> <p>Output file path to the config file.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The output file extension must be json.</p> <code>TypeError</code> <p>The provided filepath is invalid.</p> Source code in <code>geemap/kepler.py</code> <pre><code>def save_config(self, out_json):\n\"\"\"Saves a kepler.gl config file.\n\n    Args:\n        out_json (str): Output file path to the config file.\n\n    Raises:\n        ValueError: The output file extension must be json.\n        TypeError: The provided filepath is invalid.\n    \"\"\"\n    if isinstance(out_json, str):\n        if not out_json.endswith(\".json\"):\n            raise ValueError(\"The output file extension must be json.\")\n        out_json = os.path.abspath(out_json)\n        out_dir = os.path.dirname(out_json)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        json_str = json.dumps(self.config, indent=2)\n        with open(out_json, \"w\") as f:\n            f.write(json_str)\n    else:\n        raise TypeError(\"The provided filepath is invalid.\")\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.static_map","title":"<code>static_map(self, width=950, height=600, read_only=False, out_file=None, **kwargs)</code>","text":"<p>Display a kepler.gl static map in a Jupyter Notebook.</p> <p>Args     width (int, optional): Width of the map. Defaults to 950.     height (int, optional): Height of the map. Defaults to 600.     read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.     out_file (str, optional): Output html file path. Defaults to None.</p> Source code in <code>geemap/kepler.py</code> <pre><code>def static_map(\n    self, width=950, height=600, read_only=False, out_file=None, **kwargs\n):\n\"\"\"Display a kepler.gl static map in a Jupyter Notebook.\n\n    Args\n        width (int, optional): Width of the map. Defaults to 950.\n        height (int, optional): Height of the map. Defaults to 600.\n        read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n        out_file (str, optional): Output html file path. Defaults to None.\n    \"\"\"\n    if isinstance(self, keplergl.KeplerGl):\n        if out_file is None:\n            if os.environ.get(\"USE_MKDOCS\") is not None:\n                out_file = \"../maps/\" + \"kepler_\" + random_string(3) + \".html\"\n            else:\n                out_file = \"./cache/\" + \"kepler_\" + random_string(3) + \".html\"\n        out_dir = os.path.abspath(os.path.dirname(out_file))\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        output = widgets.Output()\n        with output:\n            self.save_to_html(file_name=out_file, read_only=read_only)\n        display_html(src=out_file, width=width, height=height)\n    else:\n        raise TypeError(\"The provided map is not a kepler.gl map.\")\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.to_html","title":"<code>to_html(self, filename=None, read_only=False, **kwargs)</code>","text":"<p>Saves the map as a HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The output file path to the HTML file.</p> <code>None</code> <code>read_only</code> <code>bool</code> <p>Whether to hide the side panel to disable map customization. Defaults to False.</p> <code>False</code> Source code in <code>geemap/kepler.py</code> <pre><code>def to_html(\n    self,\n    filename=None,\n    read_only=False,\n    **kwargs,\n):\n\"\"\"Saves the map as a HTML file.\n\n    Args:\n        filename (str, optional): The output file path to the HTML file.\n        read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n\n    \"\"\"\n    try:\n        save = True\n        if filename is not None:\n            if not filename.endswith(\".html\"):\n                raise ValueError(\"The output file extension must be html.\")\n            filename = os.path.abspath(filename)\n            out_dir = os.path.dirname(filename)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n        else:\n            filename = os.path.abspath(random_string() + \".html\")\n            save = False\n\n        output = widgets.Output()\n        with output:\n            self.save_to_html(file_name=filename, read_only=read_only)\n\n        if not save:\n            out_html = \"\"\n            with open(filename) as f:\n                lines = f.readlines()\n                out_html = \"\".join(lines)\n            os.remove(filename)\n            return out_html\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"kepler/#geemap.kepler.Map.to_streamlit","title":"<code>to_streamlit(self, width=800, height=600, responsive=True, scrolling=False, **kwargs)</code>","text":"<p>Renders <code>keplergl.KeplerGl</code> map figure in a Streamlit app.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the map. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>responsive</code> <code>bool</code> <p>Whether to make the map responsive. Defaults to True.</p> <code>True</code> <code>scrolling</code> <code>bool</code> <p>If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If streamlit is not installed.</p> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>geemap/kepler.py</code> <pre><code>def to_streamlit(\n    self, width=800, height=600, responsive=True, scrolling=False, **kwargs\n):\n\"\"\"Renders `keplergl.KeplerGl` map figure in a Streamlit app.\n\n    Args:\n        width (int, optional): Width of the map. Defaults to 800.\n        height (int, optional): Height of the map. Defaults to 600.\n        responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n        scrolling (bool, optional): If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.\n\n    Raises:\n        ImportError: If streamlit is not installed.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    try:\n        import streamlit as st\n        import streamlit.components.v1 as components\n\n        html = self._repr_html_()\n        if responsive:\n            make_map_responsive = \"\"\"\n            &lt;style&gt;\n            [title~=\"st.iframe\"] { width: 100%}\n            &lt;/style&gt;\n            \"\"\"\n            st.markdown(make_map_responsive, unsafe_allow_html=True)\n        return components.html(\n            html, width=width, height=height, scrolling=scrolling\n        )\n\n    except ImportError:\n        raise ImportError(\n            \"streamlit is not installed. You need to install streamlitusing 'pip install streamlit'. Seehttps://docs.streamlit.io/library/get-started/installation\"\n        )\n</code></pre>"},{"location":"legends/","title":"legends module","text":"<p>Module of sample legends for some commonly used geospatial datasets.</p>"},{"location":"legends/#geemap.legends.ee_table_to_legend","title":"<code>ee_table_to_legend(in_table, out_file)</code>","text":"<p>Converts an Earth Engine color table to a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>in_table</code> <code>str</code> <p>The input file path (*.txt) to the Earth Engine color table.</p> required <code>out_file</code> <code>str</code> <p>The output file path (*.txt) to the legend dictionary.</p> required Source code in <code>geemap/legends.py</code> <pre><code>def ee_table_to_legend(in_table, out_file):\n\"\"\"Converts an Earth Engine color table to a dictionary\n\n    Args:\n        in_table (str): The input file path (*.txt) to the Earth Engine color table.\n        out_file (str): The output file path (*.txt) to the legend dictionary.\n    \"\"\"\n    # pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    # ee_legend_table = os.path.join(pkg_dir, \"data/template/ee_legend_table.txt\")\n\n    if not os.path.exists(in_table):\n        print(\"The class table does not exist.\")\n\n    out_file = os.path.abspath(out_file)\n    if not os.path.exists(os.path.dirname(out_file)):\n        os.makedirs(os.path.dirname(out_file))\n\n    legend_dict = {}\n    with open(in_table) as f:\n        lines = f.readlines()\n        for index, line in enumerate(lines):\n            if index &gt; 0:\n                items = line.split(\"\\t\")\n                items = [item.strip() for item in items]\n                color = items[1]\n                key = items[0] + \" \" + items[2]\n                legend_dict[key] = color\n\n    out_lines = []\n    out_lines.append(\"{\\n\")\n\n    for key in legend_dict.keys():\n        line = \"\\t'{}': '{}',\\n\".format(key, legend_dict[key])\n        out_lines.append(line)\n\n    out_lines[-1] = out_lines[-1].rstrip()[:-1] + \"\\n\"\n    out_lines.append(\"}\\n\")\n\n    with open(out_file, \"w\") as f:\n        f.writelines(out_lines)\n</code></pre>"},{"location":"ml/","title":"ml module","text":""},{"location":"ml/#geemap.ml.csv_to_classifier","title":"<code>csv_to_classifier(in_csv)</code>","text":"<p>Convert a CSV file containing a list of strings (an ensemble of decision trees) to an ee.Classifier.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path to the input CSV.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ee.Classifier.</p> Source code in <code>geemap/ml.py</code> <pre><code>def csv_to_classifier(in_csv):\n\"\"\"Convert a CSV file containing a list of strings (an ensemble of decision trees) to an ee.Classifier.\n\n    Args:\n        in_csv (str): File path to the input CSV.\n    Returns:\n        object: ee.Classifier.\n    \"\"\"\n\n    in_csv = os.path.join(in_csv)\n\n    try:\n        with open(in_csv) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        print(f\"{in_csv} could not be found.\")\n        return None\n\n    null_island = ee.Geometry.Point([0, 0])\n    features = [ee.Feature(null_island, {\"tree\": line.strip()}) for line in lines]\n    rf_fc = ee.FeatureCollection(features)\n    classifier = fc_to_classifier(rf_fc)\n\n    return classifier\n</code></pre>"},{"location":"ml/#geemap.ml.export_trees_to_fc","title":"<code>export_trees_to_fc(trees, asset_id, description='geemap_rf_export')</code>","text":"<p>Function that creates a feature collection with a property tree which contains the string representation of decision trees and exports to ee asset for later use</p> <p>Parameters:</p> Name Type Description Default <code>trees</code> <code>list[str]</code> <p>list of string representation of the decision trees</p> required <code>asset_id</code> <code>str</code> <p>ee asset id path to export the feature collection to</p> required <p>Kwargs</p> <p>description (str): optional description to provide export information. default = \"geemap_rf_export\"</p> Source code in <code>geemap/ml.py</code> <pre><code>def export_trees_to_fc(trees, asset_id, description=\"geemap_rf_export\"):\n\"\"\"Function that creates a feature collection with a property tree which contains the string representation of decision trees and exports to ee asset for later use\n\n    args:\n        trees (list[str]): list of string representation of the decision trees\n        asset_id (str): ee asset id path to export the feature collection to\n\n    kwargs:\n        description (str): optional description to provide export information. default = \"geemap_rf_export\"\n\n    \"\"\"\n    # create a null geometry point. This is needed to properly export the feature collection\n    null_island = ee.Geometry.Point([0, 0])\n\n    # create a list of feature over null island\n    # set the tree property as the tree string\n    # encode return values (\\n) as #, use to parse later\n    features = [\n        ee.Feature(null_island, {\"tree\": tree.replace(\"\\n\", \"#\")}) for tree in trees\n    ]\n    # cast as feature collection\n    fc = ee.FeatureCollection(features)\n\n    # get export task and start\n    task = ee.batch.Export.table.toAsset(\n        collection=fc, description=description, assetId=asset_id\n    )\n    task.start()\n</code></pre>"},{"location":"ml/#geemap.ml.fc_to_classifier","title":"<code>fc_to_classifier(fc)</code>","text":"<p>Function that takes a feature collection resulting from <code>export_trees_to_fc</code> and creates a ee.Classifier that can be used with ee objects</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>ee.FeatureCollection</code> <p>feature collection that has trees property for each feature that represents the decision tree</p> required <p>Returns:</p> Type Description <code>classifier (ee.Classifier)</code> <p>ee classifier object representing an ensemble decision tree</p> Source code in <code>geemap/ml.py</code> <pre><code>def fc_to_classifier(fc):\n\"\"\"Function that takes a feature collection resulting from `export_trees_to_fc` and creates a ee.Classifier that can be used with ee objects\n\n    args:\n        fc (ee.FeatureCollection): feature collection that has trees property for each feature that represents the decision tree\n\n    returns:\n        classifier (ee.Classifier): ee classifier object representing an ensemble decision tree\n\n    \"\"\"\n\n    # get a list of tree strings from feature collection\n    tree_strings = fc.aggregate_array(\"tree\").map(\n        lambda x: ee.String(x).replace(\n            \"#\", \"\\n\", \"g\"\n        )  # expects that # is ecoded to be a return\n    )\n    # pass list of ee.Strings to an ensemble decision tree classifier (i.e. RandomForest)\n    classifier = ee.Classifier.decisionTreeEnsemble(tree_strings)\n\n    return classifier\n</code></pre>"},{"location":"ml/#geemap.ml.rf_to_strings","title":"<code>rf_to_strings(estimator, feature_names, processes=2, output_mode='INFER')</code>","text":"<p>Function to convert a ensemble of decision trees into a list of strings. Wraps <code>tree_to_string</code></p> <p>Parameters:</p> Name Type Description Default <code>estimator</code> <code>sklearn.ensemble.estimator</code> <p>A decision tree classifier or regressor object created using sklearn</p> required <code>feature_names</code> <code>list[str]</code> <p>List of strings that define the name of features (i.e. bands) used to create the model</p> required <code>processes</code> <code>int</code> <p>number of cpu processes to spawn. Increasing processes will improve speed for large models. default = 2</p> <code>2</code> <code>output_mode</code> <code>str</code> <p>the output mode of the estimator. Options are \"INFER\", \"CLASSIFIATION\", or \"REGRESSION\" (capitalization does not matter). default = \"INFER\"</p> <code>'INFER'</code> <p>Returns:</p> Type Description <code>trees (list[str])</code> <p>list of strings where each string represents a decision tree estimator and collectively represent an ensemble decision tree estimator (i.e. RandomForest)</p> Source code in <code>geemap/ml.py</code> <pre><code>def rf_to_strings(estimator, feature_names, processes=2, output_mode=\"INFER\"):\n\"\"\"Function to convert a ensemble of decision trees into a list of strings. Wraps `tree_to_string`\n\n    args:\n        estimator (sklearn.ensemble.estimator): A decision tree classifier or regressor object created using sklearn\n        feature_names (list[str]): List of strings that define the name of features (i.e. bands) used to create the model\n        processes (int): number of cpu processes to spawn. Increasing processes will improve speed for large models. default = 2\n        output_mode (str): the output mode of the estimator. Options are \"INFER\", \"CLASSIFIATION\", or \"REGRESSION\" (capitalization does not matter). default = \"INFER\"\n\n    returns:\n        trees (list[str]): list of strings where each string represents a decision tree estimator and collectively represent an ensemble decision tree estimator (i.e. RandomForest)\n\n    \"\"\"\n\n    # force output mode to be capital\n    output_mode = output_mode.upper()\n\n    available_modes = [\"INFER\", \"CLASSIFICATION\", \"REGRESSION\", \"PROBABILITY\"]\n\n    if output_mode not in available_modes:\n        raise ValueError(\n            f\"The provided output_mode is not available, please provide one from the following list: {available_modes}\"\n        )\n\n    # extract out the estimator trees\n    estimators = np.squeeze(estimator.estimators_)\n\n    if output_mode == \"INFER\":\n        if estimator.criterion in [\"gini\", \"entropy\"]:\n            class_labels = estimator.classes_\n        elif estimator.criterion in [\"mse\", \"mae\"]:\n            class_labels = None\n        else:\n            raise RuntimeError(\n                \"Could not infer the output type from the estimator, please explicitly provide the output_mode \"\n            )\n\n    elif output_mode == \"CLASSIFICATION\":\n        class_labels = estimator.classes_\n\n    else:\n        class_labels = None\n\n    # check that number of processors set to use is not more than available\n    if processes &gt;= mp.cpu_count():\n        # if so, force to use only cpu count - 1\n        processes = mp.cpu_count() - 1\n\n    # run the tree extraction process in parallel\n    with mp.Pool(processes) as pool:\n        proc = pool.map_async(\n            partial(\n                tree_to_string,\n                feature_names=feature_names,\n                labels=class_labels,\n                output_mode=output_mode,\n            ),\n            estimators,\n        )\n        trees = list(proc.get())\n\n    return trees\n</code></pre>"},{"location":"ml/#geemap.ml.strings_to_classifier","title":"<code>strings_to_classifier(trees)</code>","text":"<p>Function that takes string representation of decision trees and creates a ee.Classifier that can be used with ee objects</p> <p>Parameters:</p> Name Type Description Default <code>trees</code> <code>list[str]</code> <p>list of string representation of the decision trees</p> required <p>Returns:</p> Type Description <code>classifier (ee.Classifier)</code> <p>ee classifier object representing an ensemble decision tree</p> Source code in <code>geemap/ml.py</code> <pre><code>def strings_to_classifier(trees):\n\"\"\"Function that takes string representation of decision trees and creates a ee.Classifier that can be used with ee objects\n\n    args:\n        trees (list[str]): list of string representation of the decision trees\n\n    returns:\n        classifier (ee.Classifier): ee classifier object representing an ensemble decision tree\n\n    \"\"\"\n\n    # convert strings to ee.String objects\n    ee_strings = [ee.String(tree) for tree in trees]\n\n    # pass list of ee.Strings to an ensemble decision tree classifier (i.e. RandomForest)\n    classifier = ee.Classifier.decisionTreeEnsemble(ee_strings)\n\n    return classifier\n</code></pre>"},{"location":"ml/#geemap.ml.tree_to_string","title":"<code>tree_to_string(estimator, feature_names, labels=None, output_mode='INFER')</code>","text":"<p>Function to convert a sklearn decision tree object to a string format that EE can interpret</p> <p>Parameters:</p> Name Type Description Default <code>estimator</code> <code>sklearn.tree.estimator</code> <p>An estimator consisting of multiple decision tree classifiers. Expects object to contain estimators_ attribute</p> required <code>feature_names</code> <code>Iterable[str]</code> <p>List of strings that define the name of features (i.e. bands) used to create the model</p> required <code>labels</code> <code>Iterable[numeric]</code> <p>List of class labels to map outputs to, must be numeric values. If None, then raw outputs will be used. default = None</p> <code>None</code> <code>output_mode</code> <code>str</code> <p>the output mode of the estimator. Options are \"INFER\", \"CLASSIFIATION\", or \"REGRESSION\" (capitalization does not matter). default = \"INFER\"</p> <code>'INFER'</code> <p>Returns:</p> Type Description <code>tree_str (str)</code> <p>string representation of decision tree estimator</p> <p>Exceptions:</p> Type Description <code>RuntimeError</code> <p>raises run time error when function cannot determine if the estimator is for regression or classification problem</p> Source code in <code>geemap/ml.py</code> <pre><code>def tree_to_string(estimator, feature_names, labels=None, output_mode=\"INFER\"):\n\"\"\"Function to convert a sklearn decision tree object to a string format that EE can interpret\n\n    args:\n        estimator (sklearn.tree.estimator): An estimator consisting of multiple decision tree classifiers. Expects object to contain estimators_ attribute\n        feature_names (Iterable[str]): List of strings that define the name of features (i.e. bands) used to create the model\n        labels (Iterable[numeric]): List of class labels to map outputs to, must be numeric values. If None, then raw outputs will be used. default = None\n        output_mode (str): the output mode of the estimator. Options are \"INFER\", \"CLASSIFIATION\", or \"REGRESSION\" (capitalization does not matter). default = \"INFER\"\n\n    returns:\n        tree_str (str): string representation of decision tree estimator\n\n    raises:\n        RuntimeError: raises run time error when function cannot determine if the estimator is for regression or classification problem\n    \"\"\"\n\n    # extract out the information need to build the tree string\n    n_nodes = estimator.tree_.node_count\n    children_left = estimator.tree_.children_left\n    children_right = estimator.tree_.children_right\n    feature_idx = estimator.tree_.feature\n    impurities = estimator.tree_.impurity\n    n_samples = estimator.tree_.n_node_samples\n    thresholds = estimator.tree_.threshold\n    features = [feature_names[i] for i in feature_idx]\n\n    raw_vals = np.squeeze(estimator.tree_.value)\n\n    # first check if user wants to infer output mode\n    # if so, reset the output_mode variable to a valid mode\n    if output_mode == \"INFER\":\n        if raw_vals.ndim == 2:\n            output_mode = \"CLASSIFICATION\"\n\n        elif raw_vals.ndim == 1:\n            output_mode = \"REGRESSION\"\n\n        else:\n            raise RuntimeError(\n                \"Could not infer the output type from the estimator, please explicitly provide the output_mode \"\n            )\n\n    # second check on the output mode after the inference\n    if output_mode == \"CLASSIFICATION\":\n        # take argmax along class axis from values\n        values = raw_vals.argmax(axis=-1)\n        if labels is not None:\n            index_labels = np.unique(values)\n            lookup = {idx: labels[i] for i, idx in enumerate(index_labels)}\n            values = [lookup[v] for v in values]\n\n        out_type = int\n\n    elif output_mode == \"REGRESSION\":\n        # take values and drop un needed axis\n        values = np.around(raw_vals, decimals=6)\n        out_type = float\n\n    elif output_mode == \"PROBABILITY\":\n        # calculate fraction of samples of the same class in a leaf\n        # currently only supporting binary classifications\n        # check if n classes == 2 (i.e. binary classes)\n        if raw_vals.shape[-1] != 2:\n            raise ValueError(\n                \"shape mismatch: outputs from trees = {raw_vals.shape[-1]} classes, currently probability outputs is support for binary classifications\"\n            )\n\n        probas = np.around(\n            (raw_vals / np.sum(raw_vals, axis=1)[:, np.newaxis]), decimals=6\n        )\n\n        values = probas[:, -1]\n        out_type = float\n\n    elif output_mode == \"MULTIPROBABILITY\":\n        # calculate fraction of samples of the same class in a leaf\n        # this is a 2-d array making the output multidimensional\n        raise NotImplementedError(\n            \"Currently multiprobability output is not support, please choose one of the following output modes: ['CLASSIFIATION', 'REGRESSION', 'PROBABILITY' or 'INFER']\"\n        )\n\n        # probas = np.around(\n        #     (raw_vals / np.sum(raw_vals,axis=1)[:,np.newaxis]),\n        #     decimals=6\n        # )\n\n        # values = probas.tolist()\n        # out_type = list\n\n    else:\n        raise RuntimeError(\n            \"could not understand estimator type and parse out the values\"\n        )\n\n    # use iterative pre-order search to extract node depth and leaf information\n    node_ids = np.zeros(shape=n_nodes, dtype=np.int64)\n    node_depth = np.zeros(shape=n_nodes, dtype=np.int64)\n    is_leaves = np.zeros(shape=n_nodes, dtype=bool)\n    stack = [(0, -1)]  # seed is the root node id and its parent depth\n    while len(stack) &gt; 0:\n        node_id, parent_depth = stack.pop()\n        node_depth[node_id] = parent_depth + 1\n        node_ids[node_id] = node_id\n\n        # If we have a test node\n        if children_left[node_id] != children_right[node_id]:\n            stack.append((children_left[node_id], parent_depth + 1))\n            stack.append((children_right[node_id], parent_depth + 1))\n        else:\n            is_leaves[node_id] = True\n\n    # create a table of the initial structure\n    # each row is a node or leaf\n    df = pd.DataFrame(\n        {\n            \"node_id\": node_ids,\n            \"node_depth\": node_depth,\n            \"is_leaf\": is_leaves,\n            \"children_left\": children_left,\n            \"children_right\": children_right,\n            \"value\": values,\n            \"criterion\": impurities,\n            \"n_samples\": n_samples,\n            \"threshold\": thresholds,\n            \"feature_name\": features,\n            \"sign\": [\"&lt;=\"] * n_nodes,\n        },\n        dtype=\"object\",\n    )\n\n    # the table representation does not have lef vs right node structure\n    # so we need to add in right nodes in the correct location\n    # we do this by first calculating which nodes are right and then insert them at the correct index\n\n    # get a dict of right node rows and assign key based on index where to insert\n    inserts = {}\n    for row in df.itertuples():\n        child_r = row.children_right\n        if child_r &gt; row.Index:\n            ordered_row = np.array(row)\n            ordered_row[-1] = \"&gt;\"\n            inserts[child_r] = ordered_row[1:]  # drop index value\n    # sort the inserts as to keep track of the additive indexing\n    inserts_sorted = {k: inserts[k] for k in sorted(inserts.keys())}\n\n    # loop through the row inserts and add to table (array)\n    table_values = df.values\n    for i, k in enumerate(inserts_sorted.keys()):\n        table_values = np.insert(table_values, (k + i), inserts_sorted[k], axis=0)\n\n    # make the ordered table array into a dataframe\n    # note: df is dtype \"object\", need to cast later on\n    ordered_df = pd.DataFrame(table_values, columns=df.columns)\n\n    max_depth = np.max(ordered_df.node_depth.astype(int))\n    tree_str = f\"1) root {n_samples[0]} 9999 9999 ({impurities.sum()})\\n\"\n    previous_depth = -1\n    cnts = []\n    # loop through the nodes and calculate the node number and values per node\n    for row in ordered_df.itertuples():\n        node_depth = int(row.node_depth)\n        left = int(row.children_left)\n        right = int(row.children_right)\n        if left != right:\n            if row.Index == 0:\n                cnt = 2\n            elif previous_depth &gt; node_depth:\n                depths = ordered_df.node_depth.values[: row.Index]\n                idx = np.where(depths == node_depth)[0][-1]\n                # cnt = (cnts[row.Index-1] // 2) + 1\n                cnt = cnts[idx] + 1\n            elif previous_depth &lt; node_depth:\n                cnt = cnts[row.Index - 1] * 2\n            elif previous_depth == node_depth:\n                cnt = cnts[row.Index - 1] + 1\n\n            if node_depth == (max_depth - 1):\n                value = out_type(ordered_df.iloc[row.Index + 1].value)\n                samps = int(ordered_df.iloc[row.Index + 1].n_samples)\n                criterion = float(ordered_df.iloc[row.Index + 1].criterion)\n                tail = \" *\\n\"\n            else:\n                if (\n                    (bool(ordered_df.loc[ordered_df.node_id == left].iloc[0].is_leaf))\n                    and (\n                        bool(\n                            int(row.Index)\n                            &lt; int(ordered_df.loc[ordered_df.node_id == left].index[0])\n                        )\n                    )\n                    and (str(row.sign) == \"&lt;=\")\n                ):\n                    rowx = ordered_df.loc[ordered_df.node_id == left].iloc[0]\n                    tail = \" *\\n\"\n                    value = out_type(rowx.value)\n                    samps = int(rowx.n_samples)\n                    criterion = float(rowx.criterion)\n\n                elif (\n                    (bool(ordered_df.loc[ordered_df.node_id == right].iloc[0].is_leaf))\n                    and (\n                        bool(\n                            int(row.Index)\n                            &lt; int(ordered_df.loc[ordered_df.node_id == right].index[0])\n                        )\n                    )\n                    and (str(row.sign) == \"&gt;\")\n                ):\n                    rowx = ordered_df.loc[ordered_df.node_id == right].iloc[0]\n                    tail = \" *\\n\"\n                    value = out_type(rowx.value)\n                    samps = int(rowx.n_samples)\n                    criterion = float(rowx.criterion)\n\n                else:\n                    value = out_type(row.value)\n                    samps = int(row.n_samples)\n                    criterion = float(row.criterion)\n                    tail = \"\\n\"\n\n            # extract out the information needed in each line\n            spacing = (node_depth + 1) * \"  \"  # for pretty printing\n            fname = str(row.feature_name)  # name of the feature (i.e. band name)\n            tresh = float(row.threshold)  # threshold\n            sign = str(row.sign)\n\n            tree_str += f\"{spacing}{cnt}) {fname} {sign} {tresh:.6f} {samps} {criterion:.4f} {value}{tail}\"\n            previous_depth = node_depth\n        cnts.append(cnt)\n\n    return tree_str\n</code></pre>"},{"location":"ml/#geemap.ml.trees_to_csv","title":"<code>trees_to_csv(trees, out_csv)</code>","text":"<p>Save a list of strings (an ensemble of decision trees) to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>trees</code> <code>list</code> <p>A list of strings (an ensemble of decision trees).</p> required <code>out_csv</code> <code>str</code> <p>File path to the output csv</p> required Source code in <code>geemap/ml.py</code> <pre><code>def trees_to_csv(trees, out_csv):\n\"\"\"Save a list of strings (an ensemble of decision trees) to a CSV file.\n\n    Args:\n        trees (list): A list of strings (an ensemble of decision trees).\n        out_csv (str): File path to the output csv\n    \"\"\"\n    out_csv = os.path.abspath(out_csv)\n    with open(out_csv, \"w\") as f:\n        f.writelines([tree.replace(\"\\n\", \"#\") + \"\\n\" for tree in trees])\n</code></pre>"},{"location":"osm/","title":"osm module","text":"<p>The module contains functions for downloading OpenStreetMap data. It wraps the geometries module of the osmnx package  (see https://osmnx.readthedocs.io/en/stable/osmnx.html#module-osmnx.geometries). Credits to Geoff Boeing, the developer of the osmnx package.  Most functions for downloading OpenStreetMap data require tags of map features. The list of commonly used tags can be found at  https://wiki.openstreetmap.org/wiki/Map_features </p>"},{"location":"osm/#geemap.osm.osm_gdf_from_address","title":"<code>osm_gdf_from_address(address, tags, dist=1000)</code>","text":"<p>Create GeoDataFrame of OSM entities within some distance N, S, E, W of address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_gdf_from_address(address, tags, dist=1000):\n\"\"\"Create GeoDataFrame of OSM entities within some distance N, S, E, W of address.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_address(address, tags, dist)\n    return gdf\n</code></pre>"},{"location":"osm/#geemap.osm.osm_gdf_from_bbox","title":"<code>osm_gdf_from_bbox(north, south, east, west, tags)</code>","text":"<p>Create a GeoDataFrame of OSM entities within a N, S, E, W bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_gdf_from_bbox(north, south, east, west, tags):\n\"\"\"Create a GeoDataFrame of OSM entities within a N, S, E, W bounding box.\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_bbox(north, south, east, west, tags)\n    return gdf\n</code></pre>"},{"location":"osm/#geemap.osm.osm_gdf_from_geocode","title":"<code>osm_gdf_from_geocode(query, which_result=None, by_osmid=False, buffer_dist=None)</code>","text":"<p>Retrieves place(s) by name or ID from the Nominatim API as a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>INT</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_gdf_from_geocode(\n    query,\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n):\n\"\"\"Retrieves place(s) by name or ID from the Nominatim API as a GeoDataFrame.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        GeoDataFrame: A GeoPandas GeoDataFrame.\n    \"\"\"\n\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/\")\n\n    import osmnx as ox\n\n    gdf = ox.geocode_to_gdf(query, which_result, by_osmid, buffer_dist)\n    return gdf\n</code></pre>"},{"location":"osm/#geemap.osm.osm_gdf_from_place","title":"<code>osm_gdf_from_place(query, tags, which_result=None, buffer_dist=None)</code>","text":"<p>Create GeoDataFrame of OSM entities within boundaries of geocodable place(s).</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_gdf_from_place(query, tags, which_result=None, buffer_dist=None):\n\"\"\"Create GeoDataFrame of OSM entities within boundaries of geocodable place(s).\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    ox.config(use_cache=True, log_console=True)\n\n    gdf = ox.geometries_from_place(query, tags, which_result, buffer_dist)\n    return gdf\n</code></pre>"},{"location":"osm/#geemap.osm.osm_gdf_from_point","title":"<code>osm_gdf_from_point(center_point, tags, dist=1000)</code>","text":"<p>Create GeoDataFrame of OSM entities within some distance N, S, E, W of a point.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_gdf_from_point(center_point, tags, dist=1000):\n\"\"\"Create GeoDataFrame of OSM entities within some distance N, S, E, W of a point.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_point(center_point, tags, dist)\n    return gdf\n</code></pre>"},{"location":"osm/#geemap.osm.osm_gdf_from_polygon","title":"<code>osm_gdf_from_polygon(polygon, tags)</code>","text":"<p>Create GeoDataFrame of OSM entities within boundaries of a (multi)polygon.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_gdf_from_polygon(polygon, tags):\n\"\"\"Create GeoDataFrame of OSM entities within boundaries of a (multi)polygon.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_polygon(polygon, tags)\n    return gdf\n</code></pre>"},{"location":"osm/#geemap.osm.osm_gdf_from_xml","title":"<code>osm_gdf_from_xml(filepath, polygon=None, tags=None)</code>","text":"<p>Create a GeoDataFrame of OSM entities in an OSM-formatted XML file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>File path to file containing OSM XML data</p> required <code>polygon</code> <code>shapely.geometry.Polygon</code> <p>Optional geographic boundary to filter objects. Defaults to None.</p> <code>None</code> <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_gdf_from_xml(filepath, polygon=None, tags=None):\n\"\"\"Create a GeoDataFrame of OSM entities in an OSM-formatted XML file.\n\n    Args:\n        filepath (str): File path to file containing OSM XML data\n        polygon (shapely.geometry.Polygon, optional): Optional geographic boundary to filter objects. Defaults to None.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_xml(filepath, polygon, tags)\n    return gdf\n</code></pre>"},{"location":"osm/#geemap.osm.osm_geojson_from_address","title":"<code>osm_geojson_from_address(address, tags, filepath=None, dist=1000)</code>","text":"<p>Download OSM entities within some distance N, S, E, W of address as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output GeoJSON. Defaults to None.</p> <code>None</code> <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_geojson_from_address(address, tags, filepath=None, dist=1000):\n\"\"\"Download OSM entities within some distance N, S, E, W of address as a GeoJSON.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str, optional): File path to the output GeoJSON. Defaults to None.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_address(address, tags, dist)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#geemap.osm.osm_geojson_from_bbox","title":"<code>osm_geojson_from_bbox(north, south, east, west, tags, filepath=None)</code>","text":"<p>Download OSM entities within a N, S, E, W bounding box as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output GeoJSON.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_geojson_from_bbox(north, south, east, west, tags, filepath=None):\n\"\"\"Download OSM entities within a N, S, E, W bounding box as a GeoJSON.\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str, optional): File path to the output GeoJSON.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#geemap.osm.osm_geojson_from_geocode","title":"<code>osm_geojson_from_geocode(query, filepath=None, which_result=None, by_osmid=False, buffer_dist=None)</code>","text":"<p>Download place(s) by name or ID from the Nominatim API as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>filepath</code> <code>str</code> <p>File path to the output GeoJSON.</p> <code>None</code> <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_geojson_from_geocode(\n    query,\n    filepath=None,\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n):\n\"\"\"Download place(s) by name or ID from the Nominatim API as a GeoJSON.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        filepath (str): File path to the output GeoJSON.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_geocode(query, which_result, by_osmid, buffer_dist)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#geemap.osm.osm_geojson_from_place","title":"<code>osm_geojson_from_place(query, tags, filepath=None, which_result=None, buffer_dist=None)</code>","text":"<p>Download OSM entities within boundaries of geocodable place(s) as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> <code>None</code> <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_geojson_from_place(\n    query, tags, filepath=None, which_result=None, buffer_dist=None\n):\n\"\"\"Download OSM entities within boundaries of geocodable place(s) as a GeoJSON.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n\n    gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#geemap.osm.osm_geojson_from_point","title":"<code>osm_geojson_from_point(center_point, tags, filepath=None, dist=1000)</code>","text":"<p>Download OSM entities within some distance N, S, E, W of point as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> <code>None</code> <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_geojson_from_point(center_point, tags, filepath=None, dist=1000):\n\"\"\"Download OSM entities within some distance N, S, E, W of point as a GeoJSON.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_point(center_point, tags, dist)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#geemap.osm.osm_geojson_from_polygon","title":"<code>osm_geojson_from_polygon(polygon, tags, filepath=None)</code>","text":"<p>Download OSM entities within boundaries of a (multi)polygon as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output GeoJSON.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_geojson_from_polygon(polygon, tags, filepath=None):\n\"\"\"Download OSM entities within boundaries of a (multi)polygon as a GeoJSON.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str, optional): File path to the output GeoJSON.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_polygon(polygon, tags)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#geemap.osm.osm_shp_from_address","title":"<code>osm_shp_from_address(address, tags, filepath, dist=1000)</code>","text":"<p>Download OSM entities within some distance N, S, E, W of address as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> Source code in <code>geemap/osm.py</code> <pre><code>def osm_shp_from_address(address, tags, filepath, dist=1000):\n\"\"\"Download OSM entities within some distance N, S, E, W of address as a shapefile.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    \"\"\"\n    gdf = osm_gdf_from_address(address, tags, dist)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#geemap.osm.osm_shp_from_bbox","title":"<code>osm_shp_from_bbox(north, south, east, west, tags, filepath)</code>","text":"<p>Download OSM entities within a N, S, E, W bounding box as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required Source code in <code>geemap/osm.py</code> <pre><code>def osm_shp_from_bbox(north, south, east, west, tags, filepath):\n\"\"\"Download OSM entities within a N, S, E, W bounding box as a shapefile.\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n    \"\"\"\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#geemap.osm.osm_shp_from_geocode","title":"<code>osm_shp_from_geocode(query, filepath, which_result=None, by_osmid=False, buffer_dist=None)</code>","text":"<p>Download place(s) by name or ID from the Nominatim API as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> Source code in <code>geemap/osm.py</code> <pre><code>def osm_shp_from_geocode(\n    query,\n    filepath,\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n):\n\"\"\"Download place(s) by name or ID from the Nominatim API as a shapefile.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        filepath (str): File path to the output shapefile.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n    \"\"\"\n    gdf = osm_gdf_from_geocode(query, which_result, by_osmid, buffer_dist)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#geemap.osm.osm_shp_from_place","title":"<code>osm_shp_from_place(query, tags, filepath, which_result=None, buffer_dist=None)</code>","text":"<p>Download OSM entities within boundaries of geocodable place(s) as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> Source code in <code>geemap/osm.py</code> <pre><code>def osm_shp_from_place(query, tags, filepath, which_result=None, buffer_dist=None):\n\"\"\"Download OSM entities within boundaries of geocodable place(s) as a shapefile.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n    \"\"\"\n    gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#geemap.osm.osm_shp_from_point","title":"<code>osm_shp_from_point(center_point, tags, filepath, dist=1000)</code>","text":"<p>Download OSM entities within some distance N, S, E, W of point as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> Source code in <code>geemap/osm.py</code> <pre><code>def osm_shp_from_point(center_point, tags, filepath, dist=1000):\n\"\"\"Download OSM entities within some distance N, S, E, W of point as a shapefile.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n    \"\"\"\n    gdf = osm_gdf_from_point(center_point, tags, dist)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#geemap.osm.osm_shp_from_polygon","title":"<code>osm_shp_from_polygon(polygon, tags, filepath)</code>","text":"<p>Download OSM entities within boundaries of a (multi)polygon as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required Source code in <code>geemap/osm.py</code> <pre><code>def osm_shp_from_polygon(polygon, tags, filepath):\n\"\"\"Download OSM entities within boundaries of a (multi)polygon as a shapefile.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n    \"\"\"\n    gdf = osm_gdf_from_polygon(polygon, tags)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#geemap.osm.osm_tags_list","title":"<code>osm_tags_list()</code>","text":"<p>Open a browser to see all tags of OSM features.</p> Source code in <code>geemap/osm.py</code> <pre><code>def osm_tags_list():\n\"\"\"Open a browser to see all tags of OSM features.\"\"\"\n    import webbrowser\n\n    webbrowser.open_new_tab(\"https://wiki.openstreetmap.org/wiki/Map_features\")\n</code></pre>"},{"location":"plot/","title":"plot module","text":""},{"location":"plot/#geemap.plot.bar_chart","title":"<code>bar_chart(data=None, x=None, y=None, color=None, descending=True, sort_column=None, max_rows=None, x_label=None, y_label=None, title=None, legend_title=None, width=None, height=500, layout_args={}, **kwargs)</code>","text":"<p>Create a bar chart with plotly.express,</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>DataFrame | array-like | dict | str (local file path or HTTP URL) This argument needs to be passed for column names (and not keyword names) to be used. Array-like and dict are transformed internally to a pandas DataFrame. Optional: if missing, a DataFrame gets constructed under the hood using the other arguments.</p> <code>None</code> <code>x</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the x axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>y</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the y axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>color</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to assign color to marks.</p> <code>None</code> <code>descending</code> <code>bool</code> <p>Whether to sort the data in descending order. Defaults to True.</p> <code>True</code> <code>sort_column</code> <code>str</code> <p>The column to sort the data. Defaults to None.</p> <code>None</code> <code>max_rows</code> <code>int</code> <p>Maximum number of rows to display. Defaults to None.</p> <code>None</code> <code>x_label</code> <code>str</code> <p>Label for the x axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>str</code> <p>Label for the y axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>legend_title</code> <code>str</code> <p>Title for the legend. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the plot in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the plot in pixels. Defaults to 500.</p> <code>500</code> <code>layout_args</code> <code>dict</code> <p>Layout arguments for the plot to be passed to fig.update_layout(), such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.</p> <code>{}</code> <code>**kwargs</code> <p>Any additional arguments to pass to plotly.express.bar(), such as:</p> <p>pattern_shape: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign pattern shapes to marks. facet_row: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the vertical direction. facet_col: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the horizontal direction. facet_col_wrap: int     Maximum number of facet columns. Wraps the column variable at this     width, so that the column facets span multiple rows. Ignored if 0, and     forced to 0 if <code>facet_row</code> or a <code>marginal</code> is set. facet_row_spacing: float between 0 and 1     Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7     when facet_col_wrap is used. facet_col_spacing: float between 0 and 1     Spacing between facet columns, in paper units Default is 0.02. hover_name: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in bold     in the hover tooltip. hover_data: list of str or int, or Series or array-like, or dict     Either a list of names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects or a dict with column names as keys, with values     True (for default formatting) False (in order to remove this column     from hover information), or a formatting string, for example ':.3f' or     '|%a' or list-like data to appear in the hover tooltip or tuples with a     bool or formatting string as first element, and list-like data to     appear in hover as second element Values from these columns appear as     extra data in the hover tooltip. custom_data: list of str or int, or Series or array-like     Either names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects Values from these columns are extra data, to be used     in widgets or Dash callbacks for example. This data is not user-visible     but is included in events emitted by the figure (lasso selection etc.) text: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in the     figure as text labels. base: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     position the base of the bar. error_x: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars. If <code>error_x_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_x</code> is used for the positive direction     only. error_x_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars in the negative direction. Ignored if <code>error_x</code>     is <code>None</code>. error_y: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars. If <code>error_y_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_y</code> is used for the positive direction     only. error_y_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars in the negative direction. Ignored if <code>error_y</code>     is <code>None</code>. animation_frame: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to animation frames. animation_group: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     provide object-constancy across animation frames: rows with matching     <code>animation_group</code>s will be treated as if they describe the same object     in each frame. category_orders: dict with str keys and list of str values (default <code>{}</code>)     By default, in Python 3.6+, the order of categorical values in axes,     legends and facets depends on the order in which these values are first     encountered in <code>data_frame</code> (and no order is guaranteed by default in     Python below 3.6). This parameter is used to force a specific ordering     of values per column. The keys of this dict should correspond to column     names, and the values should be lists of strings corresponding to the     specific display order desired. labels: dict with str keys and str values (default <code>{}</code>)     By default, column names are used in the figure for axis titles, legend     entries and hovers. This parameter allows this to be overridden. The     keys of this dict should correspond to column names, and the values     should correspond to the desired label to be displayed. color_discrete_sequence: list of str     Strings should define valid CSS-colors. When <code>color</code> is set and the     values in the corresponding column are not numeric, values in that     column are assigned colors by cycling through <code>color_discrete_sequence</code>     in the order described in <code>category_orders</code>, unless the value of     <code>color</code> is a key in <code>color_discrete_map</code>. Various useful color     sequences are available in the <code>plotly.express.colors</code> submodules,     specifically <code>plotly.express.colors.qualitative</code>. color_discrete_map: dict with str keys and str values (default <code>{}</code>)     String values should define valid CSS-colors Used to override     <code>color_discrete_sequence</code> to assign a specific colors to marks     corresponding with specific values. Keys in <code>color_discrete_map</code> should     be values in the column denoted by <code>color</code>. Alternatively, if the     values of <code>color</code> are valid colors, the string <code>'identity'</code> may be     passed to cause them to be used directly. color_continuous_scale: list of str     Strings should define valid CSS-colors This list is used to build a     continuous color scale when the column denoted by <code>color</code> contains     numeric data. Various useful color scales are available in the     <code>plotly.express.colors</code> submodules, specifically     <code>plotly.express.colors.sequential</code>, <code>plotly.express.colors.diverging</code>     and <code>plotly.express.colors.cyclical</code>. pattern_shape_sequence: list of str     Strings should define valid plotly.js patterns-shapes. When     <code>pattern_shape</code> is set, values in that column are assigned patterns-     shapes by cycling through <code>pattern_shape_sequence</code> in the order     described in <code>category_orders</code>, unless the value of <code>pattern_shape</code> is     a key in <code>pattern_shape_map</code>. pattern_shape_map: dict with str keys and str values (default <code>{}</code>)     Strings values define plotly.js patterns-shapes. Used to override     <code>pattern_shape_sequences</code> to assign a specific patterns-shapes to lines     corresponding with specific values. Keys in <code>pattern_shape_map</code> should     be values in the column denoted by <code>pattern_shape</code>. Alternatively, if     the values of <code>pattern_shape</code> are valid patterns-shapes names, the     string <code>'identity'</code> may be passed to cause them to be used directly. range_color: list of two numbers     If provided, overrides auto-scaling on the continuous color scale. color_continuous_midpoint: number (default <code>None</code>)     If set, computes the bounds of the continuous color scale to have the     desired midpoint. Setting this value is recommended when using     <code>plotly.express.colors.diverging</code> color scales as the inputs to     <code>color_continuous_scale</code>. opacity: float     Value between 0 and 1. Sets the opacity for markers. orientation: str, one of <code>'h'</code> for horizontal or <code>'v'</code> for vertical.     (default <code>'v'</code> if <code>x</code> and <code>y</code> are provided and both continuous or both     categorical,  otherwise <code>'v'</code>(<code>'h'</code>) if <code>x</code>(<code>y</code>) is categorical and     <code>y</code>(<code>x</code>) is continuous,  otherwise <code>'v'</code>(<code>'h'</code>) if only <code>x</code>(<code>y</code>) is     provided) barmode: str (default <code>'relative'</code>)     One of <code>'group'</code>, <code>'overlay'</code> or <code>'relative'</code> In <code>'relative'</code> mode,     bars are stacked above zero for positive values and below zero for     negative values. In <code>'overlay'</code> mode, bars are drawn on top of one     another. In <code>'group'</code> mode, bars are placed beside each other. log_x: boolean (default <code>False</code>)     If <code>True</code>, the x-axis is log-scaled in cartesian coordinates. log_y: boolean (default <code>False</code>)     If <code>True</code>, the y-axis is log-scaled in cartesian coordinates. range_x: list of two numbers     If provided, overrides auto-scaling on the x-axis in cartesian     coordinates. range_y: list of two numbers     If provided, overrides auto-scaling on the y-axis in cartesian     coordinates. text_auto: bool or string (default <code>False</code>)     If <code>True</code> or a string, the x or y or z values will be displayed as     text, depending on the orientation A string like <code>'.2f'</code> will be     interpreted as a <code>texttemplate</code> numeric formatting directive. template: str or dict or plotly.graph_objects.layout.Template instance     The figure template name (must be a key in plotly.io.templates) or     definition.</p> <code>{}</code> <p>Returns:</p> Type Description <code>plotly.graph_objs._figure.Figure</code> <p>A plotly figure object.</p> Source code in <code>geemap/plot.py</code> <pre><code>def bar_chart(\n    data=None,\n    x=None,\n    y=None,\n    color=None,\n    descending=True,\n    sort_column=None,\n    max_rows=None,\n    x_label=None,\n    y_label=None,\n    title=None,\n    legend_title=None,\n    width=None,\n    height=500,\n    layout_args={},\n    **kwargs,\n):\n\"\"\"Create a bar chart with plotly.express,\n\n    Args:\n        data: DataFrame | array-like | dict | str (local file path or HTTP URL)\n            This argument needs to be passed for column names (and not keyword\n            names) to be used. Array-like and dict are transformed internally to a\n            pandas DataFrame. Optional: if missing, a DataFrame gets constructed\n            under the hood using the other arguments.\n        x: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the x axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        y: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the y axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        color: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            assign color to marks.\n        descending (bool, optional): Whether to sort the data in descending order. Defaults to True.\n        sort_column (str, optional): The column to sort the data. Defaults to None.\n        max_rows (int, optional): Maximum number of rows to display. Defaults to None.\n        x_label (str, optional): Label for the x axis. Defaults to None.\n        y_label (str, optional): Label for the y axis. Defaults to None.\n        title (str, optional): Title for the plot. Defaults to None.\n        legend_title (str, optional): Title for the legend. Defaults to None.\n        width (int, optional): Width of the plot in pixels. Defaults to None.\n        height (int, optional): Height of the plot in pixels. Defaults to 500.\n        layout_args (dict, optional): Layout arguments for the plot to be passed to fig.update_layout(),\n            such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.\n        **kwargs: Any additional arguments to pass to plotly.express.bar(), such as:\n\n            pattern_shape: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign pattern shapes to marks.\n            facet_row: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the vertical direction.\n            facet_col: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the horizontal direction.\n            facet_col_wrap: int\n                Maximum number of facet columns. Wraps the column variable at this\n                width, so that the column facets span multiple rows. Ignored if 0, and\n                forced to 0 if `facet_row` or a `marginal` is set.\n            facet_row_spacing: float between 0 and 1\n                Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7\n                when facet_col_wrap is used.\n            facet_col_spacing: float between 0 and 1\n                Spacing between facet columns, in paper units Default is 0.02.\n            hover_name: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in bold\n                in the hover tooltip.\n            hover_data: list of str or int, or Series or array-like, or dict\n                Either a list of names of columns in `data_frame`, or pandas Series, or\n                array_like objects or a dict with column names as keys, with values\n                True (for default formatting) False (in order to remove this column\n                from hover information), or a formatting string, for example ':.3f' or\n                '|%a' or list-like data to appear in the hover tooltip or tuples with a\n                bool or formatting string as first element, and list-like data to\n                appear in hover as second element Values from these columns appear as\n                extra data in the hover tooltip.\n            custom_data: list of str or int, or Series or array-like\n                Either names of columns in `data_frame`, or pandas Series, or\n                array_like objects Values from these columns are extra data, to be used\n                in widgets or Dash callbacks for example. This data is not user-visible\n                but is included in events emitted by the figure (lasso selection etc.)\n            text: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in the\n                figure as text labels.\n            base: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                position the base of the bar.\n            error_x: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars. If `error_x_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_x` is used for the positive direction\n                only.\n            error_x_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars in the negative direction. Ignored if `error_x`\n                is `None`.\n            error_y: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars. If `error_y_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_y` is used for the positive direction\n                only.\n            error_y_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars in the negative direction. Ignored if `error_y`\n                is `None`.\n            animation_frame: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to animation frames.\n            animation_group: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                provide object-constancy across animation frames: rows with matching\n                `animation_group`s will be treated as if they describe the same object\n                in each frame.\n            category_orders: dict with str keys and list of str values (default `{}`)\n                By default, in Python 3.6+, the order of categorical values in axes,\n                legends and facets depends on the order in which these values are first\n                encountered in `data_frame` (and no order is guaranteed by default in\n                Python below 3.6). This parameter is used to force a specific ordering\n                of values per column. The keys of this dict should correspond to column\n                names, and the values should be lists of strings corresponding to the\n                specific display order desired.\n            labels: dict with str keys and str values (default `{}`)\n                By default, column names are used in the figure for axis titles, legend\n                entries and hovers. This parameter allows this to be overridden. The\n                keys of this dict should correspond to column names, and the values\n                should correspond to the desired label to be displayed.\n            color_discrete_sequence: list of str\n                Strings should define valid CSS-colors. When `color` is set and the\n                values in the corresponding column are not numeric, values in that\n                column are assigned colors by cycling through `color_discrete_sequence`\n                in the order described in `category_orders`, unless the value of\n                `color` is a key in `color_discrete_map`. Various useful color\n                sequences are available in the `plotly.express.colors` submodules,\n                specifically `plotly.express.colors.qualitative`.\n            color_discrete_map: dict with str keys and str values (default `{}`)\n                String values should define valid CSS-colors Used to override\n                `color_discrete_sequence` to assign a specific colors to marks\n                corresponding with specific values. Keys in `color_discrete_map` should\n                be values in the column denoted by `color`. Alternatively, if the\n                values of `color` are valid colors, the string `'identity'` may be\n                passed to cause them to be used directly.\n            color_continuous_scale: list of str\n                Strings should define valid CSS-colors This list is used to build a\n                continuous color scale when the column denoted by `color` contains\n                numeric data. Various useful color scales are available in the\n                `plotly.express.colors` submodules, specifically\n                `plotly.express.colors.sequential`, `plotly.express.colors.diverging`\n                and `plotly.express.colors.cyclical`.\n            pattern_shape_sequence: list of str\n                Strings should define valid plotly.js patterns-shapes. When\n                `pattern_shape` is set, values in that column are assigned patterns-\n                shapes by cycling through `pattern_shape_sequence` in the order\n                described in `category_orders`, unless the value of `pattern_shape` is\n                a key in `pattern_shape_map`.\n            pattern_shape_map: dict with str keys and str values (default `{}`)\n                Strings values define plotly.js patterns-shapes. Used to override\n                `pattern_shape_sequences` to assign a specific patterns-shapes to lines\n                corresponding with specific values. Keys in `pattern_shape_map` should\n                be values in the column denoted by `pattern_shape`. Alternatively, if\n                the values of `pattern_shape` are valid patterns-shapes names, the\n                string `'identity'` may be passed to cause them to be used directly.\n            range_color: list of two numbers\n                If provided, overrides auto-scaling on the continuous color scale.\n            color_continuous_midpoint: number (default `None`)\n                If set, computes the bounds of the continuous color scale to have the\n                desired midpoint. Setting this value is recommended when using\n                `plotly.express.colors.diverging` color scales as the inputs to\n                `color_continuous_scale`.\n            opacity: float\n                Value between 0 and 1. Sets the opacity for markers.\n            orientation: str, one of `'h'` for horizontal or `'v'` for vertical.\n                (default `'v'` if `x` and `y` are provided and both continuous or both\n                categorical,  otherwise `'v'`(`'h'`) if `x`(`y`) is categorical and\n                `y`(`x`) is continuous,  otherwise `'v'`(`'h'`) if only `x`(`y`) is\n                provided)\n            barmode: str (default `'relative'`)\n                One of `'group'`, `'overlay'` or `'relative'` In `'relative'` mode,\n                bars are stacked above zero for positive values and below zero for\n                negative values. In `'overlay'` mode, bars are drawn on top of one\n                another. In `'group'` mode, bars are placed beside each other.\n            log_x: boolean (default `False`)\n                If `True`, the x-axis is log-scaled in cartesian coordinates.\n            log_y: boolean (default `False`)\n                If `True`, the y-axis is log-scaled in cartesian coordinates.\n            range_x: list of two numbers\n                If provided, overrides auto-scaling on the x-axis in cartesian\n                coordinates.\n            range_y: list of two numbers\n                If provided, overrides auto-scaling on the y-axis in cartesian\n                coordinates.\n            text_auto: bool or string (default `False`)\n                If `True` or a string, the x or y or z values will be displayed as\n                text, depending on the orientation A string like `'.2f'` will be\n                interpreted as a `texttemplate` numeric formatting directive.\n            template: str or dict or plotly.graph_objects.layout.Template instance\n                The figure template name (must be a key in plotly.io.templates) or\n                definition.\n\n\n    Returns:\n        plotly.graph_objs._figure.Figure: A plotly figure object.\n    \"\"\"\n\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = github_raw_url(data)\n            data = get_direct_url(data)\n\n        try:\n            data = pd.read_csv(data)\n        except Exception as e:\n            raise ValueError(f\"Could not read data from {data}. {e}\")\n\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\n            \"data must be a pandas DataFrame, a string or an ee.FeatureCollection.\"\n        )\n\n    if descending is not None:\n        if sort_column is None:\n            if isinstance(y, str):\n                sort_column = y\n            elif isinstance(y, list):\n                sort_column = y[0]\n        data.sort_values([sort_column, x], ascending=not (descending), inplace=True)\n        if \"barmode\" not in kwargs:\n            kwargs[\"barmode\"] = \"group\"\n\n    if isinstance(max_rows, int):\n        data = data.head(max_rows)\n\n    if \"labels\" in kwargs:\n        labels = kwargs[\"labels\"]\n        kwargs.pop(\"labels\")\n    else:\n        labels = {}\n\n    if x_label is not None:\n        labels[x] = x_label\n    if y_label is not None:\n        if isinstance(y, str):\n            labels[y] = y_label\n        elif isinstance(y, list):\n            labels[y[0]] = y_label\n\n    if isinstance(legend_title, str):\n        if \"legend\" not in layout_args:\n            layout_args[\"legend\"] = {}\n        layout_args[\"legend\"][\"title\"] = legend_title\n\n    try:\n        fig = px.bar(\n            data,\n            x=x,\n            y=y,\n            color=color,\n            labels=labels,\n            title=title,\n            width=width,\n            height=height,\n            **kwargs,\n        )\n\n        if isinstance(layout_args, dict):\n            fig.update_layout(**layout_args)\n\n        return fig\n    except Exception as e:\n        raise ValueError(f\"Could not create bar plot. {e}\")\n</code></pre>"},{"location":"plot/#geemap.plot.histogram","title":"<code>histogram(data=None, x=None, y=None, color=None, descending=None, max_rows=None, x_label=None, y_label=None, title=None, width=None, height=500, layout_args={}, **kwargs)</code>","text":"<p>Create a line chart with plotly.express,</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>DataFrame | array-like | dict | str (local file path or HTTP URL) This argument needs to be passed for column names (and not keyword names) to be used. Array-like and dict are transformed internally to a pandas DataFrame. Optional: if missing, a DataFrame gets constructed under the hood using the other arguments.</p> <code>None</code> <code>x</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the x axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>y</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the y axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>color</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to assign color to marks.</p> <code>None</code> <code>descending</code> <code>bool</code> <p>Whether to sort the data in descending order. Defaults to None.</p> <code>None</code> <code>max_rows</code> <code>int</code> <p>Maximum number of rows to display. Defaults to None.</p> <code>None</code> <code>x_label</code> <code>str</code> <p>Label for the x axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>str</code> <p>Label for the y axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the plot in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the plot in pixels. Defaults to 500.</p> <code>500</code> <code>layout_args</code> <code>dict</code> <p>Layout arguments for the plot to be passed to fig.update_layout(), such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.</p> <code>{}</code> <code>**kwargs</code> <p>Any additional arguments to pass to plotly.express.bar(), such as:</p> <p>pattern_shape: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign pattern shapes to marks. facet_row: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the vertical direction. facet_col: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the horizontal direction. facet_col_wrap: int     Maximum number of facet columns. Wraps the column variable at this     width, so that the column facets span multiple rows. Ignored if 0, and     forced to 0 if <code>facet_row</code> or a <code>marginal</code> is set. facet_row_spacing: float between 0 and 1     Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7     when facet_col_wrap is used. facet_col_spacing: float between 0 and 1     Spacing between facet columns, in paper units Default is 0.02. hover_name: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in bold     in the hover tooltip. hover_data: list of str or int, or Series or array-like, or dict     Either a list of names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects or a dict with column names as keys, with values     True (for default formatting) False (in order to remove this column     from hover information), or a formatting string, for example ':.3f' or     '|%a' or list-like data to appear in the hover tooltip or tuples with a     bool or formatting string as first element, and list-like data to     appear in hover as second element Values from these columns appear as     extra data in the hover tooltip. custom_data: list of str or int, or Series or array-like     Either names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects Values from these columns are extra data, to be used     in widgets or Dash callbacks for example. This data is not user-visible     but is included in events emitted by the figure (lasso selection etc.) text: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in the     figure as text labels. base: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     position the base of the bar. error_x: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars. If <code>error_x_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_x</code> is used for the positive direction     only. error_x_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars in the negative direction. Ignored if <code>error_x</code>     is <code>None</code>. error_y: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars. If <code>error_y_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_y</code> is used for the positive direction     only. error_y_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars in the negative direction. Ignored if <code>error_y</code>     is <code>None</code>. animation_frame: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to animation frames. animation_group: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     provide object-constancy across animation frames: rows with matching     <code>animation_group</code>s will be treated as if they describe the same object     in each frame. category_orders: dict with str keys and list of str values (default <code>{}</code>)     By default, in Python 3.6+, the order of categorical values in axes,     legends and facets depends on the order in which these values are first     encountered in <code>data_frame</code> (and no order is guaranteed by default in     Python below 3.6). This parameter is used to force a specific ordering     of values per column. The keys of this dict should correspond to column     names, and the values should be lists of strings corresponding to the     specific display order desired. labels: dict with str keys and str values (default <code>{}</code>)     By default, column names are used in the figure for axis titles, legend     entries and hovers. This parameter allows this to be overridden. The     keys of this dict should correspond to column names, and the values     should correspond to the desired label to be displayed. color_discrete_sequence: list of str     Strings should define valid CSS-colors. When <code>color</code> is set and the     values in the corresponding column are not numeric, values in that     column are assigned colors by cycling through <code>color_discrete_sequence</code>     in the order described in <code>category_orders</code>, unless the value of     <code>color</code> is a key in <code>color_discrete_map</code>. Various useful color     sequences are available in the <code>plotly.express.colors</code> submodules,     specifically <code>plotly.express.colors.qualitative</code>. color_discrete_map: dict with str keys and str values (default <code>{}</code>)     String values should define valid CSS-colors Used to override     <code>color_discrete_sequence</code> to assign a specific colors to marks     corresponding with specific values. Keys in <code>color_discrete_map</code> should     be values in the column denoted by <code>color</code>. Alternatively, if the     values of <code>color</code> are valid colors, the string <code>'identity'</code> may be     passed to cause them to be used directly. color_continuous_scale: list of str     Strings should define valid CSS-colors This list is used to build a     continuous color scale when the column denoted by <code>color</code> contains     numeric data. Various useful color scales are available in the     <code>plotly.express.colors</code> submodules, specifically     <code>plotly.express.colors.sequential</code>, <code>plotly.express.colors.diverging</code>     and <code>plotly.express.colors.cyclical</code>. pattern_shape_sequence: list of str     Strings should define valid plotly.js patterns-shapes. When     <code>pattern_shape</code> is set, values in that column are assigned patterns-     shapes by cycling through <code>pattern_shape_sequence</code> in the order     described in <code>category_orders</code>, unless the value of <code>pattern_shape</code> is     a key in <code>pattern_shape_map</code>. pattern_shape_map: dict with str keys and str values (default <code>{}</code>)     Strings values define plotly.js patterns-shapes. Used to override     <code>pattern_shape_sequences</code> to assign a specific patterns-shapes to lines     corresponding with specific values. Keys in <code>pattern_shape_map</code> should     be values in the column denoted by <code>pattern_shape</code>. Alternatively, if     the values of <code>pattern_shape</code> are valid patterns-shapes names, the     string <code>'identity'</code> may be passed to cause them to be used directly. range_color: list of two numbers     If provided, overrides auto-scaling on the continuous color scale. color_continuous_midpoint: number (default <code>None</code>)     If set, computes the bounds of the continuous color scale to have the     desired midpoint. Setting this value is recommended when using     <code>plotly.express.colors.diverging</code> color scales as the inputs to     <code>color_continuous_scale</code>. opacity: float     Value between 0 and 1. Sets the opacity for markers. orientation: str, one of <code>'h'</code> for horizontal or <code>'v'</code> for vertical.     (default <code>'v'</code> if <code>x</code> and <code>y</code> are provided and both continuous or both     categorical,  otherwise <code>'v'</code>(<code>'h'</code>) if <code>x</code>(<code>y</code>) is categorical and     <code>y</code>(<code>x</code>) is continuous,  otherwise <code>'v'</code>(<code>'h'</code>) if only <code>x</code>(<code>y</code>) is     provided) barmode: str (default <code>'relative'</code>)     One of <code>'group'</code>, <code>'overlay'</code> or <code>'relative'</code> In <code>'relative'</code> mode,     bars are stacked above zero for positive values and below zero for     negative values. In <code>'overlay'</code> mode, bars are drawn on top of one     another. In <code>'group'</code> mode, bars are placed beside each other. log_x: boolean (default <code>False</code>)     If <code>True</code>, the x-axis is log-scaled in cartesian coordinates. log_y: boolean (default <code>False</code>)     If <code>True</code>, the y-axis is log-scaled in cartesian coordinates. range_x: list of two numbers     If provided, overrides auto-scaling on the x-axis in cartesian     coordinates. range_y: list of two numbers     If provided, overrides auto-scaling on the y-axis in cartesian     coordinates. text_auto: bool or string (default <code>False</code>)     If <code>True</code> or a string, the x or y or z values will be displayed as     text, depending on the orientation A string like <code>'.2f'</code> will be     interpreted as a <code>texttemplate</code> numeric formatting directive. template: str or dict or plotly.graph_objects.layout.Template instance     The figure template name (must be a key in plotly.io.templates) or     definition.</p> <code>{}</code> <p>Returns:</p> Type Description <code>plotly.graph_objs._figure.Figure</code> <p>A plotly figure object.</p> Source code in <code>geemap/plot.py</code> <pre><code>def histogram(\n    data=None,\n    x=None,\n    y=None,\n    color=None,\n    descending=None,\n    max_rows=None,\n    x_label=None,\n    y_label=None,\n    title=None,\n    width=None,\n    height=500,\n    layout_args={},\n    **kwargs,\n):\n\"\"\"Create a line chart with plotly.express,\n\n    Args:\n        data: DataFrame | array-like | dict | str (local file path or HTTP URL)\n            This argument needs to be passed for column names (and not keyword\n            names) to be used. Array-like and dict are transformed internally to a\n            pandas DataFrame. Optional: if missing, a DataFrame gets constructed\n            under the hood using the other arguments.\n        x: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the x axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        y: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the y axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        color: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            assign color to marks.\n        descending (bool, optional): Whether to sort the data in descending order. Defaults to None.\n        max_rows (int, optional): Maximum number of rows to display. Defaults to None.\n        x_label (str, optional): Label for the x axis. Defaults to None.\n        y_label (str, optional): Label for the y axis. Defaults to None.\n        title (str, optional): Title for the plot. Defaults to None.\n        width (int, optional): Width of the plot in pixels. Defaults to None.\n        height (int, optional): Height of the plot in pixels. Defaults to 500.\n        layout_args (dict, optional): Layout arguments for the plot to be passed to fig.update_layout(),\n            such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.\n        **kwargs: Any additional arguments to pass to plotly.express.bar(), such as:\n\n            pattern_shape: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign pattern shapes to marks.\n            facet_row: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the vertical direction.\n            facet_col: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the horizontal direction.\n            facet_col_wrap: int\n                Maximum number of facet columns. Wraps the column variable at this\n                width, so that the column facets span multiple rows. Ignored if 0, and\n                forced to 0 if `facet_row` or a `marginal` is set.\n            facet_row_spacing: float between 0 and 1\n                Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7\n                when facet_col_wrap is used.\n            facet_col_spacing: float between 0 and 1\n                Spacing between facet columns, in paper units Default is 0.02.\n            hover_name: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in bold\n                in the hover tooltip.\n            hover_data: list of str or int, or Series or array-like, or dict\n                Either a list of names of columns in `data_frame`, or pandas Series, or\n                array_like objects or a dict with column names as keys, with values\n                True (for default formatting) False (in order to remove this column\n                from hover information), or a formatting string, for example ':.3f' or\n                '|%a' or list-like data to appear in the hover tooltip or tuples with a\n                bool or formatting string as first element, and list-like data to\n                appear in hover as second element Values from these columns appear as\n                extra data in the hover tooltip.\n            custom_data: list of str or int, or Series or array-like\n                Either names of columns in `data_frame`, or pandas Series, or\n                array_like objects Values from these columns are extra data, to be used\n                in widgets or Dash callbacks for example. This data is not user-visible\n                but is included in events emitted by the figure (lasso selection etc.)\n            text: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in the\n                figure as text labels.\n            base: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                position the base of the bar.\n            error_x: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars. If `error_x_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_x` is used for the positive direction\n                only.\n            error_x_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars in the negative direction. Ignored if `error_x`\n                is `None`.\n            error_y: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars. If `error_y_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_y` is used for the positive direction\n                only.\n            error_y_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars in the negative direction. Ignored if `error_y`\n                is `None`.\n            animation_frame: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to animation frames.\n            animation_group: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                provide object-constancy across animation frames: rows with matching\n                `animation_group`s will be treated as if they describe the same object\n                in each frame.\n            category_orders: dict with str keys and list of str values (default `{}`)\n                By default, in Python 3.6+, the order of categorical values in axes,\n                legends and facets depends on the order in which these values are first\n                encountered in `data_frame` (and no order is guaranteed by default in\n                Python below 3.6). This parameter is used to force a specific ordering\n                of values per column. The keys of this dict should correspond to column\n                names, and the values should be lists of strings corresponding to the\n                specific display order desired.\n            labels: dict with str keys and str values (default `{}`)\n                By default, column names are used in the figure for axis titles, legend\n                entries and hovers. This parameter allows this to be overridden. The\n                keys of this dict should correspond to column names, and the values\n                should correspond to the desired label to be displayed.\n            color_discrete_sequence: list of str\n                Strings should define valid CSS-colors. When `color` is set and the\n                values in the corresponding column are not numeric, values in that\n                column are assigned colors by cycling through `color_discrete_sequence`\n                in the order described in `category_orders`, unless the value of\n                `color` is a key in `color_discrete_map`. Various useful color\n                sequences are available in the `plotly.express.colors` submodules,\n                specifically `plotly.express.colors.qualitative`.\n            color_discrete_map: dict with str keys and str values (default `{}`)\n                String values should define valid CSS-colors Used to override\n                `color_discrete_sequence` to assign a specific colors to marks\n                corresponding with specific values. Keys in `color_discrete_map` should\n                be values in the column denoted by `color`. Alternatively, if the\n                values of `color` are valid colors, the string `'identity'` may be\n                passed to cause them to be used directly.\n            color_continuous_scale: list of str\n                Strings should define valid CSS-colors This list is used to build a\n                continuous color scale when the column denoted by `color` contains\n                numeric data. Various useful color scales are available in the\n                `plotly.express.colors` submodules, specifically\n                `plotly.express.colors.sequential`, `plotly.express.colors.diverging`\n                and `plotly.express.colors.cyclical`.\n            pattern_shape_sequence: list of str\n                Strings should define valid plotly.js patterns-shapes. When\n                `pattern_shape` is set, values in that column are assigned patterns-\n                shapes by cycling through `pattern_shape_sequence` in the order\n                described in `category_orders`, unless the value of `pattern_shape` is\n                a key in `pattern_shape_map`.\n            pattern_shape_map: dict with str keys and str values (default `{}`)\n                Strings values define plotly.js patterns-shapes. Used to override\n                `pattern_shape_sequences` to assign a specific patterns-shapes to lines\n                corresponding with specific values. Keys in `pattern_shape_map` should\n                be values in the column denoted by `pattern_shape`. Alternatively, if\n                the values of `pattern_shape` are valid patterns-shapes names, the\n                string `'identity'` may be passed to cause them to be used directly.\n            range_color: list of two numbers\n                If provided, overrides auto-scaling on the continuous color scale.\n            color_continuous_midpoint: number (default `None`)\n                If set, computes the bounds of the continuous color scale to have the\n                desired midpoint. Setting this value is recommended when using\n                `plotly.express.colors.diverging` color scales as the inputs to\n                `color_continuous_scale`.\n            opacity: float\n                Value between 0 and 1. Sets the opacity for markers.\n            orientation: str, one of `'h'` for horizontal or `'v'` for vertical.\n                (default `'v'` if `x` and `y` are provided and both continuous or both\n                categorical,  otherwise `'v'`(`'h'`) if `x`(`y`) is categorical and\n                `y`(`x`) is continuous,  otherwise `'v'`(`'h'`) if only `x`(`y`) is\n                provided)\n            barmode: str (default `'relative'`)\n                One of `'group'`, `'overlay'` or `'relative'` In `'relative'` mode,\n                bars are stacked above zero for positive values and below zero for\n                negative values. In `'overlay'` mode, bars are drawn on top of one\n                another. In `'group'` mode, bars are placed beside each other.\n            log_x: boolean (default `False`)\n                If `True`, the x-axis is log-scaled in cartesian coordinates.\n            log_y: boolean (default `False`)\n                If `True`, the y-axis is log-scaled in cartesian coordinates.\n            range_x: list of two numbers\n                If provided, overrides auto-scaling on the x-axis in cartesian\n                coordinates.\n            range_y: list of two numbers\n                If provided, overrides auto-scaling on the y-axis in cartesian\n                coordinates.\n            text_auto: bool or string (default `False`)\n                If `True` or a string, the x or y or z values will be displayed as\n                text, depending on the orientation A string like `'.2f'` will be\n                interpreted as a `texttemplate` numeric formatting directive.\n            template: str or dict or plotly.graph_objects.layout.Template instance\n                The figure template name (must be a key in plotly.io.templates) or\n                definition.\n\n\n    Returns:\n        plotly.graph_objs._figure.Figure: A plotly figure object.\n    \"\"\"\n\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = github_raw_url(data)\n            data = get_direct_url(data)\n\n        try:\n            data = pd.read_csv(data)\n        except Exception as e:\n            raise ValueError(f\"Could not read data from {data}. {e}\")\n\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\n            \"data must be a pandas DataFrame, a string or an ee.FeatureCollection.\"\n        )\n\n    if descending is not None:\n        data.sort_values([y, x], ascending=not (descending), inplace=True)\n\n    if isinstance(max_rows, int):\n        data = data.head(max_rows)\n\n    if \"labels\" in kwargs:\n        labels = kwargs[\"labels\"]\n    else:\n        labels = {}\n\n    if x_label is not None:\n        labels[x] = x_label\n    if y_label is not None:\n        labels[y] = y_label\n\n    try:\n        fig = px.histogram(\n            data,\n            x=x,\n            y=y,\n            color=color,\n            labels=labels,\n            title=title,\n            width=width,\n            height=height,\n            **kwargs,\n        )\n\n        if isinstance(layout_args, dict):\n            fig.update_layout(**layout_args)\n\n        return fig\n    except Exception as e:\n        raise ValueError(f\"Could not create bar plot. {e}\")\n</code></pre>"},{"location":"plot/#geemap.plot.line_chart","title":"<code>line_chart(data=None, x=None, y=None, color=None, descending=None, max_rows=None, x_label=None, y_label=None, title=None, legend_title=None, width=None, height=500, layout_args={}, **kwargs)</code>","text":"<p>Create a line chart with plotly.express,</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>DataFrame | array-like | dict | str (local file path or HTTP URL) This argument needs to be passed for column names (and not keyword names) to be used. Array-like and dict are transformed internally to a pandas DataFrame. Optional: if missing, a DataFrame gets constructed under the hood using the other arguments.</p> <code>None</code> <code>x</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the x axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>y</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the y axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>color</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to assign color to marks.</p> <code>None</code> <code>descending</code> <code>bool</code> <p>Whether to sort the data in descending order. Defaults to None.</p> <code>None</code> <code>max_rows</code> <code>int</code> <p>Maximum number of rows to display. Defaults to None.</p> <code>None</code> <code>x_label</code> <code>str</code> <p>Label for the x axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>str</code> <p>Label for the y axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>legend_title</code> <code>str</code> <p>Title for the legend. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the plot in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the plot in pixels. Defaults to 500.</p> <code>500</code> <code>layout_args</code> <code>dict</code> <p>Layout arguments for the plot to be passed to fig.update_layout(), such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.</p> <code>{}</code> <code>**kwargs</code> <p>Any additional arguments to pass to plotly.express.bar(), such as:</p> <p>pattern_shape: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign pattern shapes to marks. facet_row: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the vertical direction. facet_col: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the horizontal direction. facet_col_wrap: int     Maximum number of facet columns. Wraps the column variable at this     width, so that the column facets span multiple rows. Ignored if 0, and     forced to 0 if <code>facet_row</code> or a <code>marginal</code> is set. facet_row_spacing: float between 0 and 1     Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7     when facet_col_wrap is used. facet_col_spacing: float between 0 and 1     Spacing between facet columns, in paper units Default is 0.02. hover_name: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in bold     in the hover tooltip. hover_data: list of str or int, or Series or array-like, or dict     Either a list of names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects or a dict with column names as keys, with values     True (for default formatting) False (in order to remove this column     from hover information), or a formatting string, for example ':.3f' or     '|%a' or list-like data to appear in the hover tooltip or tuples with a     bool or formatting string as first element, and list-like data to     appear in hover as second element Values from these columns appear as     extra data in the hover tooltip. custom_data: list of str or int, or Series or array-like     Either names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects Values from these columns are extra data, to be used     in widgets or Dash callbacks for example. This data is not user-visible     but is included in events emitted by the figure (lasso selection etc.) text: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in the     figure as text labels. base: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     position the base of the bar. error_x: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars. If <code>error_x_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_x</code> is used for the positive direction     only. error_x_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars in the negative direction. Ignored if <code>error_x</code>     is <code>None</code>. error_y: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars. If <code>error_y_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_y</code> is used for the positive direction     only. error_y_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars in the negative direction. Ignored if <code>error_y</code>     is <code>None</code>. animation_frame: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to animation frames. animation_group: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     provide object-constancy across animation frames: rows with matching     <code>animation_group</code>s will be treated as if they describe the same object     in each frame. category_orders: dict with str keys and list of str values (default <code>{}</code>)     By default, in Python 3.6+, the order of categorical values in axes,     legends and facets depends on the order in which these values are first     encountered in <code>data_frame</code> (and no order is guaranteed by default in     Python below 3.6). This parameter is used to force a specific ordering     of values per column. The keys of this dict should correspond to column     names, and the values should be lists of strings corresponding to the     specific display order desired. labels: dict with str keys and str values (default <code>{}</code>)     By default, column names are used in the figure for axis titles, legend     entries and hovers. This parameter allows this to be overridden. The     keys of this dict should correspond to column names, and the values     should correspond to the desired label to be displayed. color_discrete_sequence: list of str     Strings should define valid CSS-colors. When <code>color</code> is set and the     values in the corresponding column are not numeric, values in that     column are assigned colors by cycling through <code>color_discrete_sequence</code>     in the order described in <code>category_orders</code>, unless the value of     <code>color</code> is a key in <code>color_discrete_map</code>. Various useful color     sequences are available in the <code>plotly.express.colors</code> submodules,     specifically <code>plotly.express.colors.qualitative</code>. color_discrete_map: dict with str keys and str values (default <code>{}</code>)     String values should define valid CSS-colors Used to override     <code>color_discrete_sequence</code> to assign a specific colors to marks     corresponding with specific values. Keys in <code>color_discrete_map</code> should     be values in the column denoted by <code>color</code>. Alternatively, if the     values of <code>color</code> are valid colors, the string <code>'identity'</code> may be     passed to cause them to be used directly. color_continuous_scale: list of str     Strings should define valid CSS-colors This list is used to build a     continuous color scale when the column denoted by <code>color</code> contains     numeric data. Various useful color scales are available in the     <code>plotly.express.colors</code> submodules, specifically     <code>plotly.express.colors.sequential</code>, <code>plotly.express.colors.diverging</code>     and <code>plotly.express.colors.cyclical</code>. pattern_shape_sequence: list of str     Strings should define valid plotly.js patterns-shapes. When     <code>pattern_shape</code> is set, values in that column are assigned patterns-     shapes by cycling through <code>pattern_shape_sequence</code> in the order     described in <code>category_orders</code>, unless the value of <code>pattern_shape</code> is     a key in <code>pattern_shape_map</code>. pattern_shape_map: dict with str keys and str values (default <code>{}</code>)     Strings values define plotly.js patterns-shapes. Used to override     <code>pattern_shape_sequences</code> to assign a specific patterns-shapes to lines     corresponding with specific values. Keys in <code>pattern_shape_map</code> should     be values in the column denoted by <code>pattern_shape</code>. Alternatively, if     the values of <code>pattern_shape</code> are valid patterns-shapes names, the     string <code>'identity'</code> may be passed to cause them to be used directly. range_color: list of two numbers     If provided, overrides auto-scaling on the continuous color scale. color_continuous_midpoint: number (default <code>None</code>)     If set, computes the bounds of the continuous color scale to have the     desired midpoint. Setting this value is recommended when using     <code>plotly.express.colors.diverging</code> color scales as the inputs to     <code>color_continuous_scale</code>. opacity: float     Value between 0 and 1. Sets the opacity for markers. orientation: str, one of <code>'h'</code> for horizontal or <code>'v'</code> for vertical.     (default <code>'v'</code> if <code>x</code> and <code>y</code> are provided and both continuous or both     categorical,  otherwise <code>'v'</code>(<code>'h'</code>) if <code>x</code>(<code>y</code>) is categorical and     <code>y</code>(<code>x</code>) is continuous,  otherwise <code>'v'</code>(<code>'h'</code>) if only <code>x</code>(<code>y</code>) is     provided) barmode: str (default <code>'relative'</code>)     One of <code>'group'</code>, <code>'overlay'</code> or <code>'relative'</code> In <code>'relative'</code> mode,     bars are stacked above zero for positive values and below zero for     negative values. In <code>'overlay'</code> mode, bars are drawn on top of one     another. In <code>'group'</code> mode, bars are placed beside each other. log_x: boolean (default <code>False</code>)     If <code>True</code>, the x-axis is log-scaled in cartesian coordinates. log_y: boolean (default <code>False</code>)     If <code>True</code>, the y-axis is log-scaled in cartesian coordinates. range_x: list of two numbers     If provided, overrides auto-scaling on the x-axis in cartesian     coordinates. range_y: list of two numbers     If provided, overrides auto-scaling on the y-axis in cartesian     coordinates. text_auto: bool or string (default <code>False</code>)     If <code>True</code> or a string, the x or y or z values will be displayed as     text, depending on the orientation A string like <code>'.2f'</code> will be     interpreted as a <code>texttemplate</code> numeric formatting directive. template: str or dict or plotly.graph_objects.layout.Template instance     The figure template name (must be a key in plotly.io.templates) or     definition.</p> <code>{}</code> <p>Returns:</p> Type Description <code>plotly.graph_objs._figure.Figure</code> <p>A plotly figure object.</p> Source code in <code>geemap/plot.py</code> <pre><code>def line_chart(\n    data=None,\n    x=None,\n    y=None,\n    color=None,\n    descending=None,\n    max_rows=None,\n    x_label=None,\n    y_label=None,\n    title=None,\n    legend_title=None,\n    width=None,\n    height=500,\n    layout_args={},\n    **kwargs,\n):\n\"\"\"Create a line chart with plotly.express,\n\n    Args:\n        data: DataFrame | array-like | dict | str (local file path or HTTP URL)\n            This argument needs to be passed for column names (and not keyword\n            names) to be used. Array-like and dict are transformed internally to a\n            pandas DataFrame. Optional: if missing, a DataFrame gets constructed\n            under the hood using the other arguments.\n        x: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the x axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        y: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the y axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        color: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            assign color to marks.\n        descending (bool, optional): Whether to sort the data in descending order. Defaults to None.\n        max_rows (int, optional): Maximum number of rows to display. Defaults to None.\n        x_label (str, optional): Label for the x axis. Defaults to None.\n        y_label (str, optional): Label for the y axis. Defaults to None.\n        title (str, optional): Title for the plot. Defaults to None.\n        legend_title (str, optional): Title for the legend. Defaults to None.\n        width (int, optional): Width of the plot in pixels. Defaults to None.\n        height (int, optional): Height of the plot in pixels. Defaults to 500.\n        layout_args (dict, optional): Layout arguments for the plot to be passed to fig.update_layout(),\n            such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.\n        **kwargs: Any additional arguments to pass to plotly.express.bar(), such as:\n\n            pattern_shape: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign pattern shapes to marks.\n            facet_row: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the vertical direction.\n            facet_col: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the horizontal direction.\n            facet_col_wrap: int\n                Maximum number of facet columns. Wraps the column variable at this\n                width, so that the column facets span multiple rows. Ignored if 0, and\n                forced to 0 if `facet_row` or a `marginal` is set.\n            facet_row_spacing: float between 0 and 1\n                Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7\n                when facet_col_wrap is used.\n            facet_col_spacing: float between 0 and 1\n                Spacing between facet columns, in paper units Default is 0.02.\n            hover_name: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in bold\n                in the hover tooltip.\n            hover_data: list of str or int, or Series or array-like, or dict\n                Either a list of names of columns in `data_frame`, or pandas Series, or\n                array_like objects or a dict with column names as keys, with values\n                True (for default formatting) False (in order to remove this column\n                from hover information), or a formatting string, for example ':.3f' or\n                '|%a' or list-like data to appear in the hover tooltip or tuples with a\n                bool or formatting string as first element, and list-like data to\n                appear in hover as second element Values from these columns appear as\n                extra data in the hover tooltip.\n            custom_data: list of str or int, or Series or array-like\n                Either names of columns in `data_frame`, or pandas Series, or\n                array_like objects Values from these columns are extra data, to be used\n                in widgets or Dash callbacks for example. This data is not user-visible\n                but is included in events emitted by the figure (lasso selection etc.)\n            text: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in the\n                figure as text labels.\n            base: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                position the base of the bar.\n            error_x: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars. If `error_x_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_x` is used for the positive direction\n                only.\n            error_x_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars in the negative direction. Ignored if `error_x`\n                is `None`.\n            error_y: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars. If `error_y_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_y` is used for the positive direction\n                only.\n            error_y_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars in the negative direction. Ignored if `error_y`\n                is `None`.\n            animation_frame: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to animation frames.\n            animation_group: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                provide object-constancy across animation frames: rows with matching\n                `animation_group`s will be treated as if they describe the same object\n                in each frame.\n            category_orders: dict with str keys and list of str values (default `{}`)\n                By default, in Python 3.6+, the order of categorical values in axes,\n                legends and facets depends on the order in which these values are first\n                encountered in `data_frame` (and no order is guaranteed by default in\n                Python below 3.6). This parameter is used to force a specific ordering\n                of values per column. The keys of this dict should correspond to column\n                names, and the values should be lists of strings corresponding to the\n                specific display order desired.\n            labels: dict with str keys and str values (default `{}`)\n                By default, column names are used in the figure for axis titles, legend\n                entries and hovers. This parameter allows this to be overridden. The\n                keys of this dict should correspond to column names, and the values\n                should correspond to the desired label to be displayed.\n            color_discrete_sequence: list of str\n                Strings should define valid CSS-colors. When `color` is set and the\n                values in the corresponding column are not numeric, values in that\n                column are assigned colors by cycling through `color_discrete_sequence`\n                in the order described in `category_orders`, unless the value of\n                `color` is a key in `color_discrete_map`. Various useful color\n                sequences are available in the `plotly.express.colors` submodules,\n                specifically `plotly.express.colors.qualitative`.\n            color_discrete_map: dict with str keys and str values (default `{}`)\n                String values should define valid CSS-colors Used to override\n                `color_discrete_sequence` to assign a specific colors to marks\n                corresponding with specific values. Keys in `color_discrete_map` should\n                be values in the column denoted by `color`. Alternatively, if the\n                values of `color` are valid colors, the string `'identity'` may be\n                passed to cause them to be used directly.\n            color_continuous_scale: list of str\n                Strings should define valid CSS-colors This list is used to build a\n                continuous color scale when the column denoted by `color` contains\n                numeric data. Various useful color scales are available in the\n                `plotly.express.colors` submodules, specifically\n                `plotly.express.colors.sequential`, `plotly.express.colors.diverging`\n                and `plotly.express.colors.cyclical`.\n            pattern_shape_sequence: list of str\n                Strings should define valid plotly.js patterns-shapes. When\n                `pattern_shape` is set, values in that column are assigned patterns-\n                shapes by cycling through `pattern_shape_sequence` in the order\n                described in `category_orders`, unless the value of `pattern_shape` is\n                a key in `pattern_shape_map`.\n            pattern_shape_map: dict with str keys and str values (default `{}`)\n                Strings values define plotly.js patterns-shapes. Used to override\n                `pattern_shape_sequences` to assign a specific patterns-shapes to lines\n                corresponding with specific values. Keys in `pattern_shape_map` should\n                be values in the column denoted by `pattern_shape`. Alternatively, if\n                the values of `pattern_shape` are valid patterns-shapes names, the\n                string `'identity'` may be passed to cause them to be used directly.\n            range_color: list of two numbers\n                If provided, overrides auto-scaling on the continuous color scale.\n            color_continuous_midpoint: number (default `None`)\n                If set, computes the bounds of the continuous color scale to have the\n                desired midpoint. Setting this value is recommended when using\n                `plotly.express.colors.diverging` color scales as the inputs to\n                `color_continuous_scale`.\n            opacity: float\n                Value between 0 and 1. Sets the opacity for markers.\n            orientation: str, one of `'h'` for horizontal or `'v'` for vertical.\n                (default `'v'` if `x` and `y` are provided and both continuous or both\n                categorical,  otherwise `'v'`(`'h'`) if `x`(`y`) is categorical and\n                `y`(`x`) is continuous,  otherwise `'v'`(`'h'`) if only `x`(`y`) is\n                provided)\n            barmode: str (default `'relative'`)\n                One of `'group'`, `'overlay'` or `'relative'` In `'relative'` mode,\n                bars are stacked above zero for positive values and below zero for\n                negative values. In `'overlay'` mode, bars are drawn on top of one\n                another. In `'group'` mode, bars are placed beside each other.\n            log_x: boolean (default `False`)\n                If `True`, the x-axis is log-scaled in cartesian coordinates.\n            log_y: boolean (default `False`)\n                If `True`, the y-axis is log-scaled in cartesian coordinates.\n            range_x: list of two numbers\n                If provided, overrides auto-scaling on the x-axis in cartesian\n                coordinates.\n            range_y: list of two numbers\n                If provided, overrides auto-scaling on the y-axis in cartesian\n                coordinates.\n            text_auto: bool or string (default `False`)\n                If `True` or a string, the x or y or z values will be displayed as\n                text, depending on the orientation A string like `'.2f'` will be\n                interpreted as a `texttemplate` numeric formatting directive.\n            template: str or dict or plotly.graph_objects.layout.Template instance\n                The figure template name (must be a key in plotly.io.templates) or\n                definition.\n\n\n    Returns:\n        plotly.graph_objs._figure.Figure: A plotly figure object.\n    \"\"\"\n\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = github_raw_url(data)\n            data = get_direct_url(data)\n\n        try:\n            data = pd.read_csv(data)\n        except Exception as e:\n            raise ValueError(f\"Could not read data from {data}. {e}\")\n\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\n            \"data must be a pandas DataFrame, a string or an ee.FeatureCollection.\"\n        )\n\n    if descending is not None:\n        data.sort_values([y, x], ascending=not (descending), inplace=True)\n\n    if isinstance(max_rows, int):\n        data = data.head(max_rows)\n\n    if \"labels\" in kwargs:\n        labels = kwargs[\"labels\"]\n        kwargs.pop(\"labels\")\n    else:\n        labels = {}\n\n    if x_label is not None:\n        labels[x] = x_label\n    if y_label is not None:\n        labels[y] = y_label\n\n    if isinstance(legend_title, str):\n        if \"legend\" not in layout_args:\n            layout_args[\"legend\"] = {}\n        layout_args[\"legend\"][\"title\"] = legend_title\n\n    try:\n        fig = px.line(\n            data,\n            x=x,\n            y=y,\n            color=color,\n            labels=labels,\n            title=title,\n            width=width,\n            height=height,\n            **kwargs,\n        )\n\n        if isinstance(layout_args, dict):\n            fig.update_layout(**layout_args)\n\n        return fig\n    except Exception as e:\n        raise ValueError(f\"Could not create bar plot. {e}\")\n</code></pre>"},{"location":"plot/#geemap.plot.pie_chart","title":"<code>pie_chart(data, names=None, values=None, descending=True, max_rows=None, other_label=None, color=None, color_discrete_sequence=None, color_discrete_map=None, hover_name=None, hover_data=None, custom_data=None, labels=None, title=None, legend_title=None, template=None, width=None, height=None, opacity=None, hole=None, layout_args={}, **kwargs)</code>","text":"<p>Create a plotly pie chart.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>DataFrame or array-like or dict This argument needs to be passed for column names (and not keyword names) to be used. Array-like and dict are transformed internally to a pandas DataFrame. Optional: if missing, a DataFrame gets constructed under the hood using the other arguments.</p> required <code>names</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used as labels for sectors.</p> <code>None</code> <code>values</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to set values associated to sectors.</p> <code>None</code> <code>descending</code> <code>bool</code> <p>Whether to sort the data in descending order. Defaults to True.</p> <code>True</code> <code>max_rows</code> <code>int</code> <p>Maximum number of rows to display. Defaults to None.</p> <code>None</code> <code>other_label</code> <code>str</code> <p>Label for the \"other\" category. Defaults to None.</p> <code>None</code> <code>color</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to assign color to marks.</p> <code>None</code> <code>color_discrete_sequence</code> <p>list of str Strings should define valid CSS-colors. When <code>color</code> is set and the values in the corresponding column are not numeric, values in that column are assigned colors by cycling through <code>color_discrete_sequence</code> in the order described in <code>category_orders</code>, unless the value of <code>color</code> is a key in <code>color_discrete_map</code>. Various useful color sequences are available in the <code>plotly.express.colors</code> submodules, specifically <code>plotly.express.colors.qualitative</code>.</p> <code>None</code> <code>color_discrete_map</code> <p>dict with str keys and str values (default <code>{}</code>) String values should define valid CSS-colors Used to override <code>color_discrete_sequence</code> to assign a specific colors to marks corresponding with specific values. Keys in <code>color_discrete_map</code> should be values in the column denoted by <code>color</code>. Alternatively, if the values of <code>color</code> are valid colors, the string <code>'identity'</code> may be passed to cause them to be used directly.</p> <code>None</code> <code>hover_name</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like appear in bold in the hover tooltip.</p> <code>None</code> <code>hover_data</code> <p>list of str or int, or Series or array-like, or dict Either a list of names of columns in <code>data_frame</code>, or pandas Series, or array_like objects or a dict with column names as keys, with values True (for default formatting) False (in order to remove this column from hover information), or a formatting string, for example ':.3f' or '|%a' or list-like data to appear in the hover tooltip or tuples with a bool or formatting string as first element, and list-like data to appear in hover as second element Values from these columns appear as extra data in the hover tooltip.</p> <code>None</code> <code>custom_data</code> <p>list of str or int, or Series or array-like Either names of columns in <code>data_frame</code>, or pandas Series, or array_like objects Values from these columns are extra data, to be used in widgets or Dash callbacks for example. This data is not user-visible but is included in events emitted by the figure (lasso selection etc.)</p> <code>None</code> <code>labels</code> <p>dict with str keys and str values (default <code>{}</code>) By default, column names are used in the figure for axis titles, legend entries and hovers. This parameter allows this to be overridden. The keys of this dict should correspond to column names, and the values should correspond to the desired label to be displayed.</p> <code>None</code> <code>title</code> <p>str The figure title.</p> <code>None</code> <code>template</code> <p>str or dict or plotly.graph_objects.layout.Template instance The figure template name (must be a key in plotly.io.templates) or definition.</p> <code>None</code> <code>width</code> <p>int (default <code>None</code>) The figure width in pixels.</p> <code>None</code> <code>height</code> <p>int (default <code>None</code>) The figure height in pixels.</p> <code>None</code> <code>opacity</code> <p>float Value between 0 and 1. Sets the opacity for markers.</p> <code>None</code> <code>hole</code> <p>float Sets the fraction of the radius to cut out of the pie.Use this to make a donut chart.</p> <code>None</code> <p>Returns:</p> Type Description <code>plotly.graph_objs._figure.Figure</code> <p>A plotly figure object.</p> Source code in <code>geemap/plot.py</code> <pre><code>def pie_chart(\n    data,\n    names=None,\n    values=None,\n    descending=True,\n    max_rows=None,\n    other_label=None,\n    color=None,\n    color_discrete_sequence=None,\n    color_discrete_map=None,\n    hover_name=None,\n    hover_data=None,\n    custom_data=None,\n    labels=None,\n    title=None,\n    legend_title=None,\n    template=None,\n    width=None,\n    height=None,\n    opacity=None,\n    hole=None,\n    layout_args={},\n    **kwargs,\n):\n\"\"\"Create a plotly pie chart.\n\n    Args:\n        data: DataFrame or array-like or dict\n            This argument needs to be passed for column names (and not keyword\n            names) to be used. Array-like and dict are transformed internally to a\n            pandas DataFrame. Optional: if missing, a DataFrame gets constructed\n            under the hood using the other arguments.\n        names: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used as\n            labels for sectors.\n        values: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            set values associated to sectors.\n        descending (bool, optional): Whether to sort the data in descending order. Defaults to True.\n        max_rows (int, optional): Maximum number of rows to display. Defaults to None.\n        other_label (str, optional): Label for the \"other\" category. Defaults to None.\n        color: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            assign color to marks.\n        color_discrete_sequence: list of str\n            Strings should define valid CSS-colors. When `color` is set and the\n            values in the corresponding column are not numeric, values in that\n            column are assigned colors by cycling through `color_discrete_sequence`\n            in the order described in `category_orders`, unless the value of\n            `color` is a key in `color_discrete_map`. Various useful color\n            sequences are available in the `plotly.express.colors` submodules,\n            specifically `plotly.express.colors.qualitative`.\n        color_discrete_map: dict with str keys and str values (default `{}`)\n            String values should define valid CSS-colors Used to override\n            `color_discrete_sequence` to assign a specific colors to marks\n            corresponding with specific values. Keys in `color_discrete_map` should\n            be values in the column denoted by `color`. Alternatively, if the\n            values of `color` are valid colors, the string `'identity'` may be\n            passed to cause them to be used directly.\n        hover_name: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like appear in bold\n            in the hover tooltip.\n        hover_data: list of str or int, or Series or array-like, or dict\n            Either a list of names of columns in `data_frame`, or pandas Series, or\n            array_like objects or a dict with column names as keys, with values\n            True (for default formatting) False (in order to remove this column\n            from hover information), or a formatting string, for example ':.3f' or\n            '|%a' or list-like data to appear in the hover tooltip or tuples with a\n            bool or formatting string as first element, and list-like data to\n            appear in hover as second element Values from these columns appear as\n            extra data in the hover tooltip.\n        custom_data: list of str or int, or Series or array-like\n            Either names of columns in `data_frame`, or pandas Series, or\n            array_like objects Values from these columns are extra data, to be used\n            in widgets or Dash callbacks for example. This data is not user-visible\n            but is included in events emitted by the figure (lasso selection etc.)\n        labels: dict with str keys and str values (default `{}`)\n            By default, column names are used in the figure for axis titles, legend\n            entries and hovers. This parameter allows this to be overridden. The\n            keys of this dict should correspond to column names, and the values\n            should correspond to the desired label to be displayed.\n        title: str\n            The figure title.\n        template: str or dict or plotly.graph_objects.layout.Template instance\n            The figure template name (must be a key in plotly.io.templates) or\n            definition.\n        width: int (default `None`)\n            The figure width in pixels.\n        height: int (default `None`)\n            The figure height in pixels.\n        opacity: float\n            Value between 0 and 1. Sets the opacity for markers.\n        hole: float\n            Sets the fraction of the radius to cut out of the pie.Use this to make\n            a donut chart.\n\n    Returns:\n        plotly.graph_objs._figure.Figure: A plotly figure object.\n    \"\"\"\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = github_raw_url(data)\n            data = get_direct_url(data)\n\n        try:\n            data = pd.read_csv(data)\n        except Exception as e:\n            raise ValueError(f\"Could not read data from {data}. {e}\")\n\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\n            \"data must be a pandas DataFrame, a string or an ee.FeatureCollection.\"\n        )\n\n    if descending is not None and isinstance(values, str):\n        data.sort_values([values], ascending=not (descending), inplace=True)\n\n    if other_label is None:\n        other_label = \"Other\"\n\n    if max_rows is not None and isinstance(names, str) and isinstance(values, str):\n        max_rows = min(len(data), max_rows) - 2\n        value = data.iloc[max_rows][values]\n        data.loc[data[values] &lt; value, names] = other_label\n\n    if isinstance(legend_title, str):\n        if \"legend\" not in layout_args:\n            layout_args[\"legend\"] = {}\n        layout_args[\"legend\"][\"title\"] = legend_title\n\n    try:\n        fig = px.pie(\n            data_frame=data,\n            names=names,\n            values=values,\n            color=color,\n            color_discrete_sequence=color_discrete_sequence,\n            color_discrete_map=color_discrete_map,\n            hover_name=hover_name,\n            hover_data=hover_data,\n            custom_data=custom_data,\n            labels=labels,\n            title=title,\n            template=template,\n            width=width,\n            height=height,\n            opacity=opacity,\n            hole=hole,\n            **kwargs,\n        )\n\n        if isinstance(layout_args, dict):\n            fig.update_layout(**layout_args)\n\n        return fig\n    except Exception as e:\n        raise Exception(f\"Could not create pie chart. {e}\")\n</code></pre>"},{"location":"plotlymap/","title":"plotlymap module","text":""},{"location":"plotlymap/#geemap.plotlymap.Canvas","title":"<code> Canvas        </code>","text":"<p>The widgets.HBox containing the map and a toolbar.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>class Canvas:\n\"\"\"The widgets.HBox containing the map and a toolbar.\"\"\"\n\n    def __init__(\n        self,\n        map,\n        map_min_width=\"90%\",\n        map_max_width=\"98%\",\n        map_refresh=False,\n        **kwargs,\n    ):\n\"\"\"Initialize the Canvas.\n\n        Args:\n            map (go.FigureWidget): The map to display.\n            map_min_width (str, optional): The minimum width of the map. Defaults to '90%'.\n            map_max_width (str, optional): The maximum width of the map. Defaults to '98%'.\n            map_refresh (bool, optional): Whether to refresh the map when the map is resized. Defaults to False.\n        \"\"\"\n        from .toolbar import plotly_toolbar\n\n        map_widget = widgets.Output(layout=widgets.Layout(width=map_max_width))\n        with map_widget:\n            display(map)\n\n        self.map = map\n        self.map_min_width = map_min_width\n        self.map_max_width = map_max_width\n        self.map_refresh = map_refresh\n        self.map_widget = map_widget\n\n        container_widget = widgets.VBox()\n        self.container_widget = container_widget\n\n        toolbar_widget = plotly_toolbar(self)\n        sidebar_widget = widgets.VBox([toolbar_widget, container_widget])\n        canvas = widgets.HBox([map_widget, sidebar_widget])\n\n        self.canvas = canvas\n        self.toolbar_widget = toolbar_widget\n\n    def toolbar_reset(self):\n\"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n        if hasattr(self, \"toolbar\"):\n            toolbar_grid = self.toolbar\n            for tool in toolbar_grid.children:\n                tool.value = False\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Canvas.__init__","title":"<code>__init__(self, map, map_min_width='90%', map_max_width='98%', map_refresh=False, **kwargs)</code>  <code>special</code>","text":"<p>Initialize the Canvas.</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <code>go.FigureWidget</code> <p>The map to display.</p> required <code>map_min_width</code> <code>str</code> <p>The minimum width of the map. Defaults to '90%'.</p> <code>'90%'</code> <code>map_max_width</code> <code>str</code> <p>The maximum width of the map. Defaults to '98%'.</p> <code>'98%'</code> <code>map_refresh</code> <code>bool</code> <p>Whether to refresh the map when the map is resized. Defaults to False.</p> <code>False</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def __init__(\n    self,\n    map,\n    map_min_width=\"90%\",\n    map_max_width=\"98%\",\n    map_refresh=False,\n    **kwargs,\n):\n\"\"\"Initialize the Canvas.\n\n    Args:\n        map (go.FigureWidget): The map to display.\n        map_min_width (str, optional): The minimum width of the map. Defaults to '90%'.\n        map_max_width (str, optional): The maximum width of the map. Defaults to '98%'.\n        map_refresh (bool, optional): Whether to refresh the map when the map is resized. Defaults to False.\n    \"\"\"\n    from .toolbar import plotly_toolbar\n\n    map_widget = widgets.Output(layout=widgets.Layout(width=map_max_width))\n    with map_widget:\n        display(map)\n\n    self.map = map\n    self.map_min_width = map_min_width\n    self.map_max_width = map_max_width\n    self.map_refresh = map_refresh\n    self.map_widget = map_widget\n\n    container_widget = widgets.VBox()\n    self.container_widget = container_widget\n\n    toolbar_widget = plotly_toolbar(self)\n    sidebar_widget = widgets.VBox([toolbar_widget, container_widget])\n    canvas = widgets.HBox([map_widget, sidebar_widget])\n\n    self.canvas = canvas\n    self.toolbar_widget = toolbar_widget\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Canvas.toolbar_reset","title":"<code>toolbar_reset(self)</code>","text":"<p>Reset the toolbar so that no tool is selected.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def toolbar_reset(self):\n\"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n    if hasattr(self, \"toolbar\"):\n        toolbar_grid = self.toolbar\n        for tool in toolbar_grid.children:\n            tool.value = False\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map","title":"<code> Map            (FigureWidget)         </code>","text":"<p>The Map class inherits the Plotly FigureWidget class. More info at https://plotly.com/python/figurewidget.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>class Map(go.FigureWidget):\n\"\"\"The Map class inherits the Plotly FigureWidget class. More info at https://plotly.com/python/figurewidget.\"\"\"\n\n    def __init__(\n        self, center=(20, 0), zoom=1, basemap=\"open-street-map\", height=600, **kwargs\n    ):\n\"\"\"Initializes a map. More info at https://plotly.com/python/mapbox-layers/\n\n        Args:\n            center (tuple, optional): Center of the map. Defaults to (20, 0).\n            zoom (int, optional): Zoom level of the map. Defaults to 1.\n            basemap (str, optional): Can be one of string from \"open-street-map\", \"carto-positron\", \"carto-darkmatter\", \"stamen-terrain\", \"stamen-toner\" or \"stamen-watercolor\" . Defaults to 'open-street-map'.\n            height (int, optional): Height of the map. Defaults to 600.\n        \"\"\"\n        # Authenticates Earth Engine and initializes an Earth Engine session\n        if \"ee_initialize\" not in kwargs.keys():\n            kwargs[\"ee_initialize\"] = True\n\n        if kwargs[\"ee_initialize\"]:\n            ee_initialize()\n\n        kwargs.pop(\"ee_initialize\")\n\n        super().__init__(**kwargs)\n        self.add_scattermapbox()\n        self.update_layout(\n            {\n                \"mapbox\": {\n                    \"style\": basemap,\n                    \"center\": {\"lat\": center[0], \"lon\": center[1]},\n                    \"zoom\": zoom,\n                },\n                \"margin\": {\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0},\n                \"height\": height,\n            }\n        )\n\n    def show(\n        self,\n        toolbar=True,\n        map_min_width=\"91%\",\n        map_max_width=\"98%\",\n        refresh=False,\n        **kwargs,\n    ):\n\"\"\"Shows the map.\n\n        Args:\n            toolbar (bool, optional): Whether to show the toolbar. Defaults to True.\n            map_min_width (str, optional): The minimum width of the map. Defaults to '91%'.\n            map_max_width (str, optional): The maximum width of the map. Defaults to '98%'.\n            refresh (bool, optional): Whether to refresh the map when the map is resized. Defaults to False.\n\n        Returns:\n            Canvas: [description]\n        \"\"\"\n        if not toolbar:\n            super().show(**kwargs)\n        else:\n            canvas = Canvas(\n                self,\n                map_min_width=map_min_width,\n                map_max_width=map_max_width,\n                map_refresh=refresh,\n            )\n            return canvas.canvas\n\n    def clear_controls(self):\n\"\"\"Removes all controls from the map.\"\"\"\n        config = {\n            \"scrollZoom\": True,\n            \"displayModeBar\": False,\n            \"editable\": True,\n            \"showLink\": False,\n            \"displaylogo\": False,\n        }\n        self.show(toolbar=False, config=config)\n\n    def add_controls(self, controls):\n\"\"\"Adds controls to the map.\n\n        Args:\n            controls (list): List of controls to add, e.g., ['drawline', 'drawopenpath', 'drawclosedpath', 'drawcircle', 'drawrect', 'eraseshape'] See https://bit.ly/33Tmqxr\n        \"\"\"\n        if isinstance(controls, str):\n            controls = [controls]\n        elif not isinstance(controls, list):\n            raise ValueError(\n                \"Controls must be a string or a list of strings. See https://bit.ly/33Tmqxr\"\n            )\n\n        self.update_layout(modebar_add=controls)\n\n    def remove_controls(self, controls):\n\"\"\"Removes controls to the map.\n\n        Args:\n            controls (list): List of controls to remove, e.g., [\"zoomin\", \"zoomout\", \"toimage\", \"pan\", \"resetview\"]. See https://bit.ly/3Jk7wkb\n        \"\"\"\n        if isinstance(controls, str):\n            controls = [controls]\n        elif not isinstance(controls, list):\n            raise ValueError(\n                \"Controls must be a string or a list of strings. See https://bit.ly/3Jk7wkb\"\n            )\n\n        self.update_layout(modebar_remove=controls)\n\n    def set_center(self, lat, lon, zoom=None):\n\"\"\"Sets the center of the map.\n\n        Args:\n            lat (float): Latitude.\n            lon (float): Longitude.\n            zoom (int, optional): Zoom level of the map. Defaults to None.\n        \"\"\"\n        self.update_layout(\n            mapbox=dict(\n                center=dict(lat=lat, lon=lon),\n                zoom=zoom if zoom is not None else self.layout.mapbox.zoom,\n            )\n        )\n\n    def add_basemap(self, basemap=\"ROADMAP\"):\n\"\"\"Adds a basemap to the map.\n\n        Args:\n            basemap (str, optional): Can be one of string from basemaps. Defaults to 'ROADMAP'.\n        \"\"\"\n        if basemap not in basemaps:\n            raise ValueError(\n                f\"Basemap {basemap} not found. Choose from {','.join(basemaps.keys())}\"\n            )\n\n        if basemap in self.get_tile_layers():\n            self.remove_basemap(basemap)\n        layers = list(self.layout.mapbox.layers) + [basemaps[basemap]]\n        self.update_layout(mapbox_layers=layers)\n\n    def remove_basemap(self, name):\n\"\"\"Removes a basemap from the map.\n\n        Args:\n            name (str): Name of the basemap to remove.\n        \"\"\"\n        layers = list(self.layout.mapbox.layers)\n        layers = [layer for layer in layers if layer[\"name\"] != name]\n        self.layout.mapbox.layers = layers\n\n    def add_mapbox_layer(self, style, access_token=None):\n\"\"\"Adds a mapbox layer to the map.\n\n        Args:\n            layer (str | dict): Layer to add. Can be \"basic\", \"streets\", \"outdoors\", \"light\", \"dark\", \"satellite\", or \"satellite-streets\". See https://plotly.com/python/mapbox-layers/ and https://docs.mapbox.com/mapbox-gl-js/style-spec/\n            access_token (str, optional): The Mapbox Access token. It can be set as an environment variable \"MAPBOX_TOKEN\". Defaults to None.\n        \"\"\"\n\n        if access_token is None:\n            access_token = os.environ.get(\"MAPBOX_TOKEN\")\n\n        self.update_layout(\n            mapbox_style=style, mapbox_layers=[], mapbox_accesstoken=access_token\n        )\n\n    def add_layer(self, layer, name=None, **kwargs):\n\"\"\"Adds a layer to the map.\n\n        Args:\n            layer (plotly.graph_objects): Layer to add.\n            name (str, optional): Name of the layer. Defaults to None.\n        \"\"\"\n        if isinstance(name, str):\n            layer.name = name\n        self.add_trace(layer, **kwargs)\n\n    def remove_layer(self, name):\n\"\"\"Removes a layer from the map.\n\n        Args:\n            name (str): Name of the layer to remove.\n        \"\"\"\n        if name in self.get_data_layers():\n            self.data = [layer for layer in self.data if layer.name != name]\n        elif name in self.get_tile_layers():\n            self.layout.mapbox.layers = [\n                layer for layer in self.layout.mapbox.layers if layer[\"name\"] != name\n            ]\n\n    def clear_layers(self, clear_basemap=False):\n\"\"\"Clears all layers from the map.\n\n        Args:\n            clear_basemap (bool, optional): If True, clears the basemap. Defaults to False.\n        \"\"\"\n        if clear_basemap:\n            self.data = []\n        else:\n            if len(self.data) &gt; 1:\n                self.data = self.data[:1]\n\n    def get_layers(self):\n\"\"\"Returns a dictionary of all layers in the map.\n        Returns:\n            dict: A dictionary of all layers in the map.\n        \"\"\"\n        layers = {}\n\n        for layer in self.layout.mapbox.layers:\n            if layer[\"name\"] is not None:\n                layers[layer[\"name\"]] = layer\n\n        for layer in self.data:\n            if layer.name is not None and layer.name != \"trace 0\":\n                layers[layer.name] = layer\n\n        return layers\n\n    def get_tile_layers(self):\n\"\"\"Returns a dictionary of tile layers in the map.\n\n        Returns:\n            dict: A dictionary of tile layers in the map.\n        \"\"\"\n\n        layers = {}\n\n        for layer in self.layout.mapbox.layers:\n            if layer[\"name\"] is not None:\n                layers[layer[\"name\"]] = layer\n\n        return layers\n\n    def get_data_layers(self):\n\"\"\"Returns a dictionary of data layers in the map.\n\n        Returns:\n            dict: A dictionary of data layers in the map.\n        \"\"\"\n\n        layers = {}\n\n        for layer in self.data:\n            if layer.name is not None and layer.name != \"trace 0\":\n                layers[layer.name] = layer\n\n        return layers\n\n    def find_layer_index(self, name):\n\"\"\"Finds the index of a layer.\n\n        Args:\n            name (str): Name of the layer to find.\n\n        Returns:\n            int: Index of the layer.\n        \"\"\"\n        for i, layer in enumerate(self.data):\n            if layer.name == name:\n                return i\n\n        for i, layer in enumerate(self.layout.mapbox.layers):\n            if layer[\"name\"] == name:\n                return i\n\n        return None\n\n    def set_layer_visibility(self, name, show=True):\n\"\"\"Sets the visibility of a layer.\n\n        Args:\n            name (str): Name of the layer to set.\n            show (bool, optional): If True, shows the layer. Defaults to True.\n        \"\"\"\n\n        if name in self.get_tile_layers():\n            index = self.find_layer_index(name)\n            self.layout.mapbox.layers[index].visible = show\n        elif name in self.get_data_layers():\n            index = self.find_layer_index(name)\n            self.data[index].visible = show\n        else:\n            print(f\"Layer {name} not found.\")\n\n    def set_layer_opacity(self, name, opacity=1):\n\"\"\"Sets the visibility of a layer.\n\n        Args:\n            name (str): Name of the layer to set.\n            opacity (float, optional): Opacity of the layer. Defaults to 1.\n        \"\"\"\n\n        if name in self.get_tile_layers():\n            index = self.find_layer_index(name)\n            self.layout.mapbox.layers[index].opacity = opacity\n        elif name in self.get_data_layers():\n            index = self.find_layer_index(name)\n            layer = self.data[index]\n            if hasattr(layer, \"opacity\"):\n                layer.opacity = opacity\n            elif hasattr(layer, \"marker\"):\n                layer.marker.opacity = opacity\n        else:\n            print(f\"Layer {name} not found.\")\n\n    def add_tile_layer(\n        self,\n        url,\n        name=\"TileLayer\",\n        attribution=\"\",\n        opacity=1.0,\n        **kwargs,\n    ):\n\"\"\"Adds a TileLayer to the map.\n\n        Args:\n            url (str): The URL of the tile layer.\n            name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n            attribution (str): The attribution to use. Defaults to \"\".\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n        \"\"\"\n\n        layer = {\n            \"below\": \"traces\",\n            \"sourcetype\": \"raster\",\n            \"sourceattribution\": attribution,\n            \"source\": [url],\n            \"opacity\": opacity,\n            \"name\": name,\n        }\n        layers = list(self.layout.mapbox.layers) + [layer]\n        self.update_layout(mapbox_layers=layers)\n\n    def add_ee_layer(\n        self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs\n    ):\n\"\"\"Adds a given EE object to the map as a layer.\n\n        Args:\n            ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n            vis_params (dict, optional): The visualization parameters. Defaults to {}.\n            name (str, optional): The name of the layer. Defaults to 'Layer N'.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n        \"\"\"\n        from box import Box\n\n        image = None\n\n        if vis_params is None:\n            vis_params = {}\n\n        if name is None:\n            layer_count = len(self.layout.mapbox.layers)\n            name = \"Layer \" + str(layer_count + 1)\n\n        if (\n            not isinstance(ee_object, ee.Image)\n            and not isinstance(ee_object, ee.ImageCollection)\n            and not isinstance(ee_object, ee.FeatureCollection)\n            and not isinstance(ee_object, ee.Feature)\n            and not isinstance(ee_object, ee.Geometry)\n        ):\n            err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n            raise AttributeError(err_str)\n\n        if (\n            isinstance(ee_object, ee.geometry.Geometry)\n            or isinstance(ee_object, ee.feature.Feature)\n            or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n        ):\n            features = ee.FeatureCollection(ee_object)\n\n            width = 2\n\n            if \"width\" in vis_params:\n                width = vis_params[\"width\"]\n\n            color = \"000000\"\n\n            if \"color\" in vis_params:\n                color = vis_params[\"color\"]\n\n            image_fill = features.style(**{\"fillColor\": color}).updateMask(\n                ee.Image.constant(0.5)\n            )\n            image_outline = features.style(\n                **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n            )\n\n            image = image_fill.blend(image_outline)\n        elif isinstance(ee_object, ee.image.Image):\n            image = ee_object\n        elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n            image = ee_object.mosaic()\n\n        if \"palette\" in vis_params:\n            if isinstance(vis_params[\"palette\"], tuple):\n                vis_params[\"palette\"] = list(vis_params[\"palette\"])\n            if isinstance(vis_params[\"palette\"], Box):\n                try:\n                    vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n                except Exception as e:\n                    print(\"The provided palette is invalid.\")\n                    raise Exception(e)\n            elif isinstance(vis_params[\"palette\"], str):\n                vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n            elif not isinstance(vis_params[\"palette\"], list):\n                raise ValueError(\n                    \"The palette must be a list of colors or a string or a Box object.\"\n                )\n\n        map_id_dict = ee.Image(image).getMapId(vis_params)\n        url = map_id_dict[\"tile_fetcher\"].url_format\n        self.add_tile_layer(\n            url, name=name, attribution=\"Google Earth Engine\", opacity=opacity, **kwargs\n        )\n        self.set_layer_visibility(name=name, show=shown)\n\n    addLayer = add_ee_layer\n\n    def add_cog_layer(\n        self,\n        url,\n        name=\"Untitled\",\n        attribution=\"\",\n        opacity=1.0,\n        bands=None,\n        titiler_endpoint=None,\n        **kwargs,\n    ):\n\"\"\"Adds a COG TileLayer to the map.\n\n        Args:\n            url (str): The URL of the COG tile layer, e.g., 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\n            name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            bands (list, optional): The bands to use. Defaults to None.\n            titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n            **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]\n        \"\"\"\n        tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n        center = cog_center(url, titiler_endpoint)  # (lon, lat)\n        self.add_tile_layer(tile_url, name, attribution, opacity)\n        self.set_center(lon=center[0], lat=center[1], zoom=10)\n\n    def add_stac_layer(\n        self,\n        url=None,\n        collection=None,\n        item=None,\n        assets=None,\n        bands=None,\n        titiler_endpoint=None,\n        name=\"STAC Layer\",\n        attribution=\"\",\n        opacity=1.0,\n        **kwargs,\n    ):\n\"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n            collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n            item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n            assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n            bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n        \"\"\"\n        tile_url = stac_tile(\n            url, collection, item, assets, bands, titiler_endpoint, **kwargs\n        )\n        center = stac_center(url, collection, item, titiler_endpoint)\n        self.add_tile_layer(tile_url, name, attribution, opacity)\n        self.set_center(lon=center[0], lat=center[1], zoom=10)\n\n    def add_planet_by_month(\n        self,\n        year=2016,\n        month=1,\n        api_key=None,\n        token_name=\"PLANET_API_KEY\",\n        name=None,\n        attribution=\"\",\n        opacity=1.0,\n    ):\n\"\"\"Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n            name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n            attribution (str): The attribution to use. Defaults to \"\".\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n        \"\"\"\n        if name is None:\n            name = str(year) + \"-\" + str(month).zfill(2)\n        tile_url = planet_by_month(year, month, api_key, token_name)\n        self.add_tile_layer(\n            tile_url, name=name, attribution=attribution, opacity=opacity\n        )\n\n    def add_planet_by_quarter(\n        self,\n        year=2016,\n        quarter=1,\n        api_key=None,\n        token_name=\"PLANET_API_KEY\",\n        name=None,\n        attribution=\"\",\n        opacity=1.0,\n    ):\n\"\"\"Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n            name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n            attribution (str): The attribution to use. Defaults to \"\".\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n        \"\"\"\n        if name is None:\n            name = str(year) + \"-\" + \"q\" + str(quarter)\n        tile_url = planet_by_quarter(year, quarter, api_key, token_name)\n        self.add_tile_layer(\n            tile_url, name=name, attribution=attribution, opacity=opacity\n        )\n\n    def save(self, file, format=None, width=None, height=None, scale=None, **kwargs):\n\"\"\"Convert a map to a static image and write it to a file or writeable object\n\n        Args:\n            file (str): A string representing a local file path or a writeable object (e.g. a pathlib.Path object or an open file descriptor)\n            format (str, optional): The desired image format. One of png, jpg, jpeg, webp, svg, pdf, eps. Defaults to None.\n            width (int, optional): The width of the exported image in layout pixels. If the `scale` property is 1.0, this will also be the width of the exported image in physical pixels.. Defaults to None.\n            height (int, optional): The height of the exported image in layout pixels. If the `scale` property is 1.0, this will also be the height of the exported image in physical pixels.. Defaults to None.\n            scale (int, optional): The scale factor to use when exporting the figure. A scale factor larger than 1.0 will increase the image resolution with respect to the figure's layout pixel dimensions. Whereas as scale factor of less than 1.0 will decrease the image resolution.. Defaults to None.\n        \"\"\"\n        self.write_image(\n            file, format=format, width=width, height=height, scale=scale, **kwargs\n        )\n\n    def add_choropleth_map(\n        self, data, name=None, z=None, colorscale=\"Viridis\", **kwargs\n    ):\n\"\"\"Adds a choropleth map to the map.\n\n        Args:\n            data (str): File path to vector data, e.g., https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/countries.geojson\n            name (str, optional): Name of the layer. Defaults to None.\n            z (str, optional): Z value of the data. Defaults to None.\n            colorscale (str, optional): Color scale of the data. Defaults to \"Viridis\".\n        \"\"\"\n        check_package(\"geopandas\")\n        import json\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data).to_crs(epsg=4326)\n        geojson = json.loads(gdf.to_json())\n\n        self.add_choroplethmapbox(\n            geojson=geojson,\n            locations=gdf.index,\n            z=gdf[z],\n            name=name,\n            colorscale=colorscale,\n            **kwargs,\n        )\n\n    def add_scatter_plot_demo(self, **kwargs):\n\"\"\"Adds a scatter plot to the map.\"\"\"\n        lons = np.random.random(1000) * 360.0\n        lats = np.random.random(1000) * 180.0 - 90.0\n        z = np.random.random(1000) * 50.0\n        self.add_scattermapbox(\n            lon=lons, lat=lats, marker={\"color\": z}, name=\"Random points\", **kwargs\n        )\n\n    def add_heatmap(\n        self,\n        data,\n        latitude=\"latitude\",\n        longitude=\"longitude\",\n        z=\"value\",\n        radius=10,\n        colorscale=None,\n        name=\"Heat map\",\n        **kwargs,\n    ):\n\"\"\"Adds a heat map to the map. Reference: https://plotly.com/python/mapbox-density-heatmaps\n\n        Args:\n            data (str | pd.DataFrame): File path or HTTP URL to the input file or a . For example, https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            z (str, optional): The column name of z values. Defaults to \"value\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n            colorscale (str, optional): Color scale of the data, e.g., Viridis. See https://plotly.com/python/builtin-colorscales. Defaults to None.\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n\n        \"\"\"\n\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n        elif isinstance(data, pd.DataFrame):\n            df = data\n        else:\n            raise ValueError(\"data must be a DataFrame or a file path.\")\n\n        heatmap = go.Densitymapbox(\n            lat=df[latitude],\n            lon=df[longitude],\n            z=df[z],\n            radius=radius,\n            colorscale=colorscale,\n            name=name,\n            **kwargs,\n        )\n        self.add_trace(heatmap)\n\n    def add_heatmap_demo(self, **kwargs):\n\"\"\"Adds a heatmap to the map.\"\"\"\n        quakes = pd.read_csv(\n            \"https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\"\n        )\n        heatmap = go.Densitymapbox(\n            lat=quakes.Latitude,\n            lon=quakes.Longitude,\n            z=quakes.Magnitude,\n            radius=10,\n            name=\"Earthquake\",\n            **kwargs,\n        )\n\n        self.add_basemap(\"Stamen.Terrain\")\n        self.add_trace(heatmap)\n\n    def add_gdf(\n        self,\n        gdf,\n        label_col=None,\n        color_col=None,\n        labels=None,\n        opacity=1.0,\n        zoom=None,\n        color_continuous_scale=\"Viridis\",\n        **kwargs,\n    ):\n\"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoDataFrame): A GeoDataFrame.\n            label_col (str, optional): The column name of locations. Defaults to None.\n            color_col (str, optional): The column name of color. Defaults to None.\n        \"\"\"\n\n        check_package(\"geopandas\", \"https://geopandas.org\")\n        import geopandas as gpd\n\n        if isinstance(gdf, str):\n            gdf = gpd.read_file(gdf)\n\n        if not isinstance(gdf, gpd.GeoDataFrame):\n            raise ValueError(\"gdf must be a GeoDataFrame.\")\n\n        gdf = gdf.to_crs(epsg=4326)\n        # geom_type = gdf_geom_type(gdf)\n        center_lon, center_lat = gdf_centroid(gdf)\n\n        if isinstance(label_col, str):\n            gdf = gdf.set_index(label_col)\n            if label_col == color_col:\n                gdf[label_col] = gdf.index\n            label_col = gdf.index\n        elif label_col is None:\n            label_col = gdf.index\n\n        if isinstance(color_col, str):\n            if color_col not in gdf.columns:\n                raise ValueError(\n                    f\"color must be a column name in the GeoDataFrame. Can be one of {','.join(gdf.columns)} \"\n                )\n        fig = px.choropleth_mapbox(\n            gdf,\n            geojson=gdf.geometry,\n            locations=label_col,\n            color=color_col,\n            color_continuous_scale=color_continuous_scale,\n            opacity=opacity,\n            labels=labels,\n            # mapbox_style=\"carto-positron\",\n            **kwargs,\n        )\n\n        self.add_traces(fig.data)\n        self.set_center(center_lat, center_lon, zoom)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.__init__","title":"<code>__init__(self, center=(20, 0), zoom=1, basemap='open-street-map', height=600, **kwargs)</code>  <code>special</code>","text":"<p>Initializes a map. More info at https://plotly.com/python/mapbox-layers/</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>Center of the map. Defaults to (20, 0).</p> <code>(20, 0)</code> <code>zoom</code> <code>int</code> <p>Zoom level of the map. Defaults to 1.</p> <code>1</code> <code>basemap</code> <code>str</code> <p>Can be one of string from \"open-street-map\", \"carto-positron\", \"carto-darkmatter\", \"stamen-terrain\", \"stamen-toner\" or \"stamen-watercolor\" . Defaults to 'open-street-map'.</p> <code>'open-street-map'</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def __init__(\n    self, center=(20, 0), zoom=1, basemap=\"open-street-map\", height=600, **kwargs\n):\n\"\"\"Initializes a map. More info at https://plotly.com/python/mapbox-layers/\n\n    Args:\n        center (tuple, optional): Center of the map. Defaults to (20, 0).\n        zoom (int, optional): Zoom level of the map. Defaults to 1.\n        basemap (str, optional): Can be one of string from \"open-street-map\", \"carto-positron\", \"carto-darkmatter\", \"stamen-terrain\", \"stamen-toner\" or \"stamen-watercolor\" . Defaults to 'open-street-map'.\n        height (int, optional): Height of the map. Defaults to 600.\n    \"\"\"\n    # Authenticates Earth Engine and initializes an Earth Engine session\n    if \"ee_initialize\" not in kwargs.keys():\n        kwargs[\"ee_initialize\"] = True\n\n    if kwargs[\"ee_initialize\"]:\n        ee_initialize()\n\n    kwargs.pop(\"ee_initialize\")\n\n    super().__init__(**kwargs)\n    self.add_scattermapbox()\n    self.update_layout(\n        {\n            \"mapbox\": {\n                \"style\": basemap,\n                \"center\": {\"lat\": center[0], \"lon\": center[1]},\n                \"zoom\": zoom,\n            },\n            \"margin\": {\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0},\n            \"height\": height,\n        }\n    )\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.addLayer","title":"<code>addLayer(self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs)</code>","text":"<p>Adds a given EE object to the map as a layer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer N'.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_ee_layer(\n    self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs\n):\n\"\"\"Adds a given EE object to the map as a layer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer N'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n    from box import Box\n\n    image = None\n\n    if vis_params is None:\n        vis_params = {}\n\n    if name is None:\n        layer_count = len(self.layout.mapbox.layers)\n        name = \"Layer \" + str(layer_count + 1)\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], tuple):\n            vis_params[\"palette\"] = list(vis_params[\"palette\"])\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n    url = map_id_dict[\"tile_fetcher\"].url_format\n    self.add_tile_layer(\n        url, name=name, attribution=\"Google Earth Engine\", opacity=opacity, **kwargs\n    )\n    self.set_layer_visibility(name=name, show=shown)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_basemap","title":"<code>add_basemap(self, basemap='ROADMAP')</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Can be one of string from basemaps. Defaults to 'ROADMAP'.</p> <code>'ROADMAP'</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_basemap(self, basemap=\"ROADMAP\"):\n\"\"\"Adds a basemap to the map.\n\n    Args:\n        basemap (str, optional): Can be one of string from basemaps. Defaults to 'ROADMAP'.\n    \"\"\"\n    if basemap not in basemaps:\n        raise ValueError(\n            f\"Basemap {basemap} not found. Choose from {','.join(basemaps.keys())}\"\n        )\n\n    if basemap in self.get_tile_layers():\n        self.remove_basemap(basemap)\n    layers = list(self.layout.mapbox.layers) + [basemaps[basemap]]\n    self.update_layout(mapbox_layers=layers)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_choropleth_map","title":"<code>add_choropleth_map(self, data, name=None, z=None, colorscale='Viridis', **kwargs)</code>","text":"<p>Adds a choropleth map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>File path to vector data, e.g., https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/countries.geojson</p> required <code>name</code> <code>str</code> <p>Name of the layer. Defaults to None.</p> <code>None</code> <code>z</code> <code>str</code> <p>Z value of the data. Defaults to None.</p> <code>None</code> <code>colorscale</code> <code>str</code> <p>Color scale of the data. Defaults to \"Viridis\".</p> <code>'Viridis'</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_choropleth_map(\n    self, data, name=None, z=None, colorscale=\"Viridis\", **kwargs\n):\n\"\"\"Adds a choropleth map to the map.\n\n    Args:\n        data (str): File path to vector data, e.g., https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/countries.geojson\n        name (str, optional): Name of the layer. Defaults to None.\n        z (str, optional): Z value of the data. Defaults to None.\n        colorscale (str, optional): Color scale of the data. Defaults to \"Viridis\".\n    \"\"\"\n    check_package(\"geopandas\")\n    import json\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data).to_crs(epsg=4326)\n    geojson = json.loads(gdf.to_json())\n\n    self.add_choroplethmapbox(\n        geojson=geojson,\n        locations=gdf.index,\n        z=gdf[z],\n        name=name,\n        colorscale=colorscale,\n        **kwargs,\n    )\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_cog_layer","title":"<code>add_cog_layer(self, url, name='Untitled', attribution='', opacity=1.0, bands=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Adds a COG TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the COG tile layer, e.g., 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'</p> required <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Untitled'.</p> <code>'Untitled'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>bands</code> <code>list</code> <p>The bands to use. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]</p> <code>{}</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_cog_layer(\n    self,\n    url,\n    name=\"Untitled\",\n    attribution=\"\",\n    opacity=1.0,\n    bands=None,\n    titiler_endpoint=None,\n    **kwargs,\n):\n\"\"\"Adds a COG TileLayer to the map.\n\n    Args:\n        url (str): The URL of the COG tile layer, e.g., 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\n        name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        bands (list, optional): The bands to use. Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]\n    \"\"\"\n    tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n    center = cog_center(url, titiler_endpoint)  # (lon, lat)\n    self.add_tile_layer(tile_url, name, attribution, opacity)\n    self.set_center(lon=center[0], lat=center[1], zoom=10)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_controls","title":"<code>add_controls(self, controls)</code>","text":"<p>Adds controls to the map.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>list</code> <p>List of controls to add, e.g., ['drawline', 'drawopenpath', 'drawclosedpath', 'drawcircle', 'drawrect', 'eraseshape'] See https://bit.ly/33Tmqxr</p> required Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_controls(self, controls):\n\"\"\"Adds controls to the map.\n\n    Args:\n        controls (list): List of controls to add, e.g., ['drawline', 'drawopenpath', 'drawclosedpath', 'drawcircle', 'drawrect', 'eraseshape'] See https://bit.ly/33Tmqxr\n    \"\"\"\n    if isinstance(controls, str):\n        controls = [controls]\n    elif not isinstance(controls, list):\n        raise ValueError(\n            \"Controls must be a string or a list of strings. See https://bit.ly/33Tmqxr\"\n        )\n\n    self.update_layout(modebar_add=controls)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_ee_layer","title":"<code>add_ee_layer(self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs)</code>","text":"<p>Adds a given EE object to the map as a layer.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <code>Collection|Feature|Image|MapId</code> <p>The object to add to the map.</p> required <code>vis_params</code> <code>dict</code> <p>The visualization parameters. Defaults to {}.</p> <code>{}</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to 'Layer N'.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The layer's opacity represented as a number between 0 and 1. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_ee_layer(\n    self, ee_object, vis_params={}, name=None, shown=True, opacity=1.0, **kwargs\n):\n\"\"\"Adds a given EE object to the map as a layer.\n\n    Args:\n        ee_object (Collection|Feature|Image|MapId): The object to add to the map.\n        vis_params (dict, optional): The visualization parameters. Defaults to {}.\n        name (str, optional): The name of the layer. Defaults to 'Layer N'.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): The layer's opacity represented as a number between 0 and 1. Defaults to 1.\n    \"\"\"\n    from box import Box\n\n    image = None\n\n    if vis_params is None:\n        vis_params = {}\n\n    if name is None:\n        layer_count = len(self.layout.mapbox.layers)\n        name = \"Layer \" + str(layer_count + 1)\n\n    if (\n        not isinstance(ee_object, ee.Image)\n        and not isinstance(ee_object, ee.ImageCollection)\n        and not isinstance(ee_object, ee.FeatureCollection)\n        and not isinstance(ee_object, ee.Feature)\n        and not isinstance(ee_object, ee.Geometry)\n    ):\n        err_str = \"\\n\\nThe image argument in 'addLayer' function must be an instance of one of ee.Image, ee.Geometry, ee.Feature or ee.FeatureCollection.\"\n        raise AttributeError(err_str)\n\n    if (\n        isinstance(ee_object, ee.geometry.Geometry)\n        or isinstance(ee_object, ee.feature.Feature)\n        or isinstance(ee_object, ee.featurecollection.FeatureCollection)\n    ):\n        features = ee.FeatureCollection(ee_object)\n\n        width = 2\n\n        if \"width\" in vis_params:\n            width = vis_params[\"width\"]\n\n        color = \"000000\"\n\n        if \"color\" in vis_params:\n            color = vis_params[\"color\"]\n\n        image_fill = features.style(**{\"fillColor\": color}).updateMask(\n            ee.Image.constant(0.5)\n        )\n        image_outline = features.style(\n            **{\"color\": color, \"fillColor\": \"00000000\", \"width\": width}\n        )\n\n        image = image_fill.blend(image_outline)\n    elif isinstance(ee_object, ee.image.Image):\n        image = ee_object\n    elif isinstance(ee_object, ee.imagecollection.ImageCollection):\n        image = ee_object.mosaic()\n\n    if \"palette\" in vis_params:\n        if isinstance(vis_params[\"palette\"], tuple):\n            vis_params[\"palette\"] = list(vis_params[\"palette\"])\n        if isinstance(vis_params[\"palette\"], Box):\n            try:\n                vis_params[\"palette\"] = vis_params[\"palette\"][\"default\"]\n            except Exception as e:\n                print(\"The provided palette is invalid.\")\n                raise Exception(e)\n        elif isinstance(vis_params[\"palette\"], str):\n            vis_params[\"palette\"] = check_cmap(vis_params[\"palette\"])\n        elif not isinstance(vis_params[\"palette\"], list):\n            raise ValueError(\n                \"The palette must be a list of colors or a string or a Box object.\"\n            )\n\n    map_id_dict = ee.Image(image).getMapId(vis_params)\n    url = map_id_dict[\"tile_fetcher\"].url_format\n    self.add_tile_layer(\n        url, name=name, attribution=\"Google Earth Engine\", opacity=opacity, **kwargs\n    )\n    self.set_layer_visibility(name=name, show=shown)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_gdf","title":"<code>add_gdf(self, gdf, label_col=None, color_col=None, labels=None, opacity=1.0, zoom=None, color_continuous_scale='Viridis', **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>label_col</code> <code>str</code> <p>The column name of locations. Defaults to None.</p> <code>None</code> <code>color_col</code> <code>str</code> <p>The column name of color. Defaults to None.</p> <code>None</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_gdf(\n    self,\n    gdf,\n    label_col=None,\n    color_col=None,\n    labels=None,\n    opacity=1.0,\n    zoom=None,\n    color_continuous_scale=\"Viridis\",\n    **kwargs,\n):\n\"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoDataFrame): A GeoDataFrame.\n        label_col (str, optional): The column name of locations. Defaults to None.\n        color_col (str, optional): The column name of color. Defaults to None.\n    \"\"\"\n\n    check_package(\"geopandas\", \"https://geopandas.org\")\n    import geopandas as gpd\n\n    if isinstance(gdf, str):\n        gdf = gpd.read_file(gdf)\n\n    if not isinstance(gdf, gpd.GeoDataFrame):\n        raise ValueError(\"gdf must be a GeoDataFrame.\")\n\n    gdf = gdf.to_crs(epsg=4326)\n    # geom_type = gdf_geom_type(gdf)\n    center_lon, center_lat = gdf_centroid(gdf)\n\n    if isinstance(label_col, str):\n        gdf = gdf.set_index(label_col)\n        if label_col == color_col:\n            gdf[label_col] = gdf.index\n        label_col = gdf.index\n    elif label_col is None:\n        label_col = gdf.index\n\n    if isinstance(color_col, str):\n        if color_col not in gdf.columns:\n            raise ValueError(\n                f\"color must be a column name in the GeoDataFrame. Can be one of {','.join(gdf.columns)} \"\n            )\n    fig = px.choropleth_mapbox(\n        gdf,\n        geojson=gdf.geometry,\n        locations=label_col,\n        color=color_col,\n        color_continuous_scale=color_continuous_scale,\n        opacity=opacity,\n        labels=labels,\n        # mapbox_style=\"carto-positron\",\n        **kwargs,\n    )\n\n    self.add_traces(fig.data)\n    self.set_center(center_lat, center_lon, zoom)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', z='value', radius=10, colorscale=None, name='Heat map', **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://plotly.com/python/mapbox-density-heatmaps</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a . For example, https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>z</code> <code>str</code> <p>The column name of z values. Defaults to \"value\".</p> <code>'value'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>10</code> <code>colorscale</code> <code>str</code> <p>Color scale of the data, e.g., Viridis. See https://plotly.com/python/builtin-colorscales. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_heatmap(\n    self,\n    data,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    z=\"value\",\n    radius=10,\n    colorscale=None,\n    name=\"Heat map\",\n    **kwargs,\n):\n\"\"\"Adds a heat map to the map. Reference: https://plotly.com/python/mapbox-density-heatmaps\n\n    Args:\n        data (str | pd.DataFrame): File path or HTTP URL to the input file or a . For example, https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        z (str, optional): The column name of z values. Defaults to \"value\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n        colorscale (str, optional): Color scale of the data, e.g., Viridis. See https://plotly.com/python/builtin-colorscales. Defaults to None.\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n\n    \"\"\"\n\n    if isinstance(data, str):\n        df = pd.read_csv(data)\n    elif isinstance(data, pd.DataFrame):\n        df = data\n    else:\n        raise ValueError(\"data must be a DataFrame or a file path.\")\n\n    heatmap = go.Densitymapbox(\n        lat=df[latitude],\n        lon=df[longitude],\n        z=df[z],\n        radius=radius,\n        colorscale=colorscale,\n        name=name,\n        **kwargs,\n    )\n    self.add_trace(heatmap)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_heatmap_demo","title":"<code>add_heatmap_demo(self, **kwargs)</code>","text":"<p>Adds a heatmap to the map.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_heatmap_demo(self, **kwargs):\n\"\"\"Adds a heatmap to the map.\"\"\"\n    quakes = pd.read_csv(\n        \"https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\"\n    )\n    heatmap = go.Densitymapbox(\n        lat=quakes.Latitude,\n        lon=quakes.Longitude,\n        z=quakes.Magnitude,\n        radius=10,\n        name=\"Earthquake\",\n        **kwargs,\n    )\n\n    self.add_basemap(\"Stamen.Terrain\")\n    self.add_trace(heatmap)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_layer","title":"<code>add_layer(self, layer, name=None, **kwargs)</code>","text":"<p>Adds a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>plotly.graph_objects</code> <p>Layer to add.</p> required <code>name</code> <code>str</code> <p>Name of the layer. Defaults to None.</p> <code>None</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_layer(self, layer, name=None, **kwargs):\n\"\"\"Adds a layer to the map.\n\n    Args:\n        layer (plotly.graph_objects): Layer to add.\n        name (str, optional): Name of the layer. Defaults to None.\n    \"\"\"\n    if isinstance(name, str):\n        layer.name = name\n    self.add_trace(layer, **kwargs)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_mapbox_layer","title":"<code>add_mapbox_layer(self, style, access_token=None)</code>","text":"<p>Adds a mapbox layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>str | dict</code> <p>Layer to add. Can be \"basic\", \"streets\", \"outdoors\", \"light\", \"dark\", \"satellite\", or \"satellite-streets\". See https://plotly.com/python/mapbox-layers/ and https://docs.mapbox.com/mapbox-gl-js/style-spec/</p> required <code>access_token</code> <code>str</code> <p>The Mapbox Access token. It can be set as an environment variable \"MAPBOX_TOKEN\". Defaults to None.</p> <code>None</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_mapbox_layer(self, style, access_token=None):\n\"\"\"Adds a mapbox layer to the map.\n\n    Args:\n        layer (str | dict): Layer to add. Can be \"basic\", \"streets\", \"outdoors\", \"light\", \"dark\", \"satellite\", or \"satellite-streets\". See https://plotly.com/python/mapbox-layers/ and https://docs.mapbox.com/mapbox-gl-js/style-spec/\n        access_token (str, optional): The Mapbox Access token. It can be set as an environment variable \"MAPBOX_TOKEN\". Defaults to None.\n    \"\"\"\n\n    if access_token is None:\n        access_token = os.environ.get(\"MAPBOX_TOKEN\")\n\n    self.update_layout(\n        mapbox_style=style, mapbox_layers=[], mapbox_accesstoken=access_token\n    )\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_planet_by_month","title":"<code>add_planet_by_month(self, year=2016, month=1, api_key=None, token_name='PLANET_API_KEY', name=None, attribution='', opacity=1.0)</code>","text":"<p>Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>name</code> <code>str</code> <p>Name of the layer. Defaults to 'TileLayer'.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to \"\".</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_planet_by_month(\n    self,\n    year=2016,\n    month=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    name=None,\n    attribution=\"\",\n    opacity=1.0,\n):\n\"\"\"Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n        attribution (str): The attribution to use. Defaults to \"\".\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n    \"\"\"\n    if name is None:\n        name = str(year) + \"-\" + str(month).zfill(2)\n    tile_url = planet_by_month(year, month, api_key, token_name)\n    self.add_tile_layer(\n        tile_url, name=name, attribution=attribution, opacity=opacity\n    )\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_planet_by_quarter","title":"<code>add_planet_by_quarter(self, year=2016, quarter=1, api_key=None, token_name='PLANET_API_KEY', name=None, attribution='', opacity=1.0)</code>","text":"<p>Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>name</code> <code>str</code> <p>Name of the layer. Defaults to 'TileLayer'.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to \"\".</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_planet_by_quarter(\n    self,\n    year=2016,\n    quarter=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    name=None,\n    attribution=\"\",\n    opacity=1.0,\n):\n\"\"\"Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n        attribution (str): The attribution to use. Defaults to \"\".\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n    \"\"\"\n    if name is None:\n        name = str(year) + \"-\" + \"q\" + str(quarter)\n    tile_url = planet_by_quarter(year, quarter, api_key, token_name)\n    self.add_tile_layer(\n        tile_url, name=name, attribution=attribution, opacity=opacity\n    )\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_scatter_plot_demo","title":"<code>add_scatter_plot_demo(self, **kwargs)</code>","text":"<p>Adds a scatter plot to the map.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_scatter_plot_demo(self, **kwargs):\n\"\"\"Adds a scatter plot to the map.\"\"\"\n    lons = np.random.random(1000) * 360.0\n    lats = np.random.random(1000) * 180.0 - 90.0\n    z = np.random.random(1000) * 50.0\n    self.add_scattermapbox(\n        lon=lons, lat=lats, marker={\"color\": z}, name=\"Random points\", **kwargs\n    )\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_stac_layer","title":"<code>add_stac_layer(self, url=None, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, name='STAC Layer', attribution='', opacity=1.0, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'STAC Layer'.</p> <code>'STAC Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_stac_layer(\n    self,\n    url=None,\n    collection=None,\n    item=None,\n    assets=None,\n    bands=None,\n    titiler_endpoint=None,\n    name=\"STAC Layer\",\n    attribution=\"\",\n    opacity=1.0,\n    **kwargs,\n):\n\"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n    \"\"\"\n    tile_url = stac_tile(\n        url, collection, item, assets, bands, titiler_endpoint, **kwargs\n    )\n    center = stac_center(url, collection, item, titiler_endpoint)\n    self.add_tile_layer(tile_url, name, attribution, opacity)\n    self.set_center(lon=center[0], lat=center[1], zoom=10)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.add_tile_layer","title":"<code>add_tile_layer(self, url, name='TileLayer', attribution='', opacity=1.0, **kwargs)</code>","text":"<p>Adds a TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer.</p> required <code>name</code> <code>str</code> <p>Name of the layer. Defaults to 'TileLayer'.</p> <code>'TileLayer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to \"\".</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def add_tile_layer(\n    self,\n    url,\n    name=\"TileLayer\",\n    attribution=\"\",\n    opacity=1.0,\n    **kwargs,\n):\n\"\"\"Adds a TileLayer to the map.\n\n    Args:\n        url (str): The URL of the tile layer.\n        name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n        attribution (str): The attribution to use. Defaults to \"\".\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n    \"\"\"\n\n    layer = {\n        \"below\": \"traces\",\n        \"sourcetype\": \"raster\",\n        \"sourceattribution\": attribution,\n        \"source\": [url],\n        \"opacity\": opacity,\n        \"name\": name,\n    }\n    layers = list(self.layout.mapbox.layers) + [layer]\n    self.update_layout(mapbox_layers=layers)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.clear_controls","title":"<code>clear_controls(self)</code>","text":"<p>Removes all controls from the map.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def clear_controls(self):\n\"\"\"Removes all controls from the map.\"\"\"\n    config = {\n        \"scrollZoom\": True,\n        \"displayModeBar\": False,\n        \"editable\": True,\n        \"showLink\": False,\n        \"displaylogo\": False,\n    }\n    self.show(toolbar=False, config=config)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.clear_layers","title":"<code>clear_layers(self, clear_basemap=False)</code>","text":"<p>Clears all layers from the map.</p> <p>Parameters:</p> Name Type Description Default <code>clear_basemap</code> <code>bool</code> <p>If True, clears the basemap. Defaults to False.</p> <code>False</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def clear_layers(self, clear_basemap=False):\n\"\"\"Clears all layers from the map.\n\n    Args:\n        clear_basemap (bool, optional): If True, clears the basemap. Defaults to False.\n    \"\"\"\n    if clear_basemap:\n        self.data = []\n    else:\n        if len(self.data) &gt; 1:\n            self.data = self.data[:1]\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.find_layer_index","title":"<code>find_layer_index(self, name)</code>","text":"<p>Finds the index of a layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to find.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the layer.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def find_layer_index(self, name):\n\"\"\"Finds the index of a layer.\n\n    Args:\n        name (str): Name of the layer to find.\n\n    Returns:\n        int: Index of the layer.\n    \"\"\"\n    for i, layer in enumerate(self.data):\n        if layer.name == name:\n            return i\n\n    for i, layer in enumerate(self.layout.mapbox.layers):\n        if layer[\"name\"] == name:\n            return i\n\n    return None\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.get_data_layers","title":"<code>get_data_layers(self)</code>","text":"<p>Returns a dictionary of data layers in the map.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of data layers in the map.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def get_data_layers(self):\n\"\"\"Returns a dictionary of data layers in the map.\n\n    Returns:\n        dict: A dictionary of data layers in the map.\n    \"\"\"\n\n    layers = {}\n\n    for layer in self.data:\n        if layer.name is not None and layer.name != \"trace 0\":\n            layers[layer.name] = layer\n\n    return layers\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.get_layers","title":"<code>get_layers(self)</code>","text":"<p>Returns a dictionary of all layers in the map.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of all layers in the map.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def get_layers(self):\n\"\"\"Returns a dictionary of all layers in the map.\n    Returns:\n        dict: A dictionary of all layers in the map.\n    \"\"\"\n    layers = {}\n\n    for layer in self.layout.mapbox.layers:\n        if layer[\"name\"] is not None:\n            layers[layer[\"name\"]] = layer\n\n    for layer in self.data:\n        if layer.name is not None and layer.name != \"trace 0\":\n            layers[layer.name] = layer\n\n    return layers\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.get_tile_layers","title":"<code>get_tile_layers(self)</code>","text":"<p>Returns a dictionary of tile layers in the map.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of tile layers in the map.</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def get_tile_layers(self):\n\"\"\"Returns a dictionary of tile layers in the map.\n\n    Returns:\n        dict: A dictionary of tile layers in the map.\n    \"\"\"\n\n    layers = {}\n\n    for layer in self.layout.mapbox.layers:\n        if layer[\"name\"] is not None:\n            layers[layer[\"name\"]] = layer\n\n    return layers\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.remove_basemap","title":"<code>remove_basemap(self, name)</code>","text":"<p>Removes a basemap from the map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the basemap to remove.</p> required Source code in <code>geemap/plotlymap.py</code> <pre><code>def remove_basemap(self, name):\n\"\"\"Removes a basemap from the map.\n\n    Args:\n        name (str): Name of the basemap to remove.\n    \"\"\"\n    layers = list(self.layout.mapbox.layers)\n    layers = [layer for layer in layers if layer[\"name\"] != name]\n    self.layout.mapbox.layers = layers\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.remove_controls","title":"<code>remove_controls(self, controls)</code>","text":"<p>Removes controls to the map.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>list</code> <p>List of controls to remove, e.g., [\"zoomin\", \"zoomout\", \"toimage\", \"pan\", \"resetview\"]. See https://bit.ly/3Jk7wkb</p> required Source code in <code>geemap/plotlymap.py</code> <pre><code>def remove_controls(self, controls):\n\"\"\"Removes controls to the map.\n\n    Args:\n        controls (list): List of controls to remove, e.g., [\"zoomin\", \"zoomout\", \"toimage\", \"pan\", \"resetview\"]. See https://bit.ly/3Jk7wkb\n    \"\"\"\n    if isinstance(controls, str):\n        controls = [controls]\n    elif not isinstance(controls, list):\n        raise ValueError(\n            \"Controls must be a string or a list of strings. See https://bit.ly/3Jk7wkb\"\n        )\n\n    self.update_layout(modebar_remove=controls)\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.remove_layer","title":"<code>remove_layer(self, name)</code>","text":"<p>Removes a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to remove.</p> required Source code in <code>geemap/plotlymap.py</code> <pre><code>def remove_layer(self, name):\n\"\"\"Removes a layer from the map.\n\n    Args:\n        name (str): Name of the layer to remove.\n    \"\"\"\n    if name in self.get_data_layers():\n        self.data = [layer for layer in self.data if layer.name != name]\n    elif name in self.get_tile_layers():\n        self.layout.mapbox.layers = [\n            layer for layer in self.layout.mapbox.layers if layer[\"name\"] != name\n        ]\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.save","title":"<code>save(self, file, format=None, width=None, height=None, scale=None, **kwargs)</code>","text":"<p>Convert a map to a static image and write it to a file or writeable object</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>A string representing a local file path or a writeable object (e.g. a pathlib.Path object or an open file descriptor)</p> required <code>format</code> <code>str</code> <p>The desired image format. One of png, jpg, jpeg, webp, svg, pdf, eps. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>The width of the exported image in layout pixels. If the <code>scale</code> property is 1.0, this will also be the width of the exported image in physical pixels.. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>The height of the exported image in layout pixels. If the <code>scale</code> property is 1.0, this will also be the height of the exported image in physical pixels.. Defaults to None.</p> <code>None</code> <code>scale</code> <code>int</code> <p>The scale factor to use when exporting the figure. A scale factor larger than 1.0 will increase the image resolution with respect to the figure's layout pixel dimensions. Whereas as scale factor of less than 1.0 will decrease the image resolution.. Defaults to None.</p> <code>None</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def save(self, file, format=None, width=None, height=None, scale=None, **kwargs):\n\"\"\"Convert a map to a static image and write it to a file or writeable object\n\n    Args:\n        file (str): A string representing a local file path or a writeable object (e.g. a pathlib.Path object or an open file descriptor)\n        format (str, optional): The desired image format. One of png, jpg, jpeg, webp, svg, pdf, eps. Defaults to None.\n        width (int, optional): The width of the exported image in layout pixels. If the `scale` property is 1.0, this will also be the width of the exported image in physical pixels.. Defaults to None.\n        height (int, optional): The height of the exported image in layout pixels. If the `scale` property is 1.0, this will also be the height of the exported image in physical pixels.. Defaults to None.\n        scale (int, optional): The scale factor to use when exporting the figure. A scale factor larger than 1.0 will increase the image resolution with respect to the figure's layout pixel dimensions. Whereas as scale factor of less than 1.0 will decrease the image resolution.. Defaults to None.\n    \"\"\"\n    self.write_image(\n        file, format=format, width=width, height=height, scale=scale, **kwargs\n    )\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.set_center","title":"<code>set_center(self, lat, lon, zoom=None)</code>","text":"<p>Sets the center of the map.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>lon</code> <code>float</code> <p>Longitude.</p> required <code>zoom</code> <code>int</code> <p>Zoom level of the map. Defaults to None.</p> <code>None</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def set_center(self, lat, lon, zoom=None):\n\"\"\"Sets the center of the map.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        zoom (int, optional): Zoom level of the map. Defaults to None.\n    \"\"\"\n    self.update_layout(\n        mapbox=dict(\n            center=dict(lat=lat, lon=lon),\n            zoom=zoom if zoom is not None else self.layout.mapbox.zoom,\n        )\n    )\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.set_layer_opacity","title":"<code>set_layer_opacity(self, name, opacity=1)</code>","text":"<p>Sets the visibility of a layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to set.</p> required <code>opacity</code> <code>float</code> <p>Opacity of the layer. Defaults to 1.</p> <code>1</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def set_layer_opacity(self, name, opacity=1):\n\"\"\"Sets the visibility of a layer.\n\n    Args:\n        name (str): Name of the layer to set.\n        opacity (float, optional): Opacity of the layer. Defaults to 1.\n    \"\"\"\n\n    if name in self.get_tile_layers():\n        index = self.find_layer_index(name)\n        self.layout.mapbox.layers[index].opacity = opacity\n    elif name in self.get_data_layers():\n        index = self.find_layer_index(name)\n        layer = self.data[index]\n        if hasattr(layer, \"opacity\"):\n            layer.opacity = opacity\n        elif hasattr(layer, \"marker\"):\n            layer.marker.opacity = opacity\n    else:\n        print(f\"Layer {name} not found.\")\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.set_layer_visibility","title":"<code>set_layer_visibility(self, name, show=True)</code>","text":"<p>Sets the visibility of a layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to set.</p> required <code>show</code> <code>bool</code> <p>If True, shows the layer. Defaults to True.</p> <code>True</code> Source code in <code>geemap/plotlymap.py</code> <pre><code>def set_layer_visibility(self, name, show=True):\n\"\"\"Sets the visibility of a layer.\n\n    Args:\n        name (str): Name of the layer to set.\n        show (bool, optional): If True, shows the layer. Defaults to True.\n    \"\"\"\n\n    if name in self.get_tile_layers():\n        index = self.find_layer_index(name)\n        self.layout.mapbox.layers[index].visible = show\n    elif name in self.get_data_layers():\n        index = self.find_layer_index(name)\n        self.data[index].visible = show\n    else:\n        print(f\"Layer {name} not found.\")\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.Map.show","title":"<code>show(self, toolbar=True, map_min_width='91%', map_max_width='98%', refresh=False, **kwargs)</code>","text":"<p>Shows the map.</p> <p>Parameters:</p> Name Type Description Default <code>toolbar</code> <code>bool</code> <p>Whether to show the toolbar. Defaults to True.</p> <code>True</code> <code>map_min_width</code> <code>str</code> <p>The minimum width of the map. Defaults to '91%'.</p> <code>'91%'</code> <code>map_max_width</code> <code>str</code> <p>The maximum width of the map. Defaults to '98%'.</p> <code>'98%'</code> <code>refresh</code> <code>bool</code> <p>Whether to refresh the map when the map is resized. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Canvas</code> <p>[description]</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def show(\n    self,\n    toolbar=True,\n    map_min_width=\"91%\",\n    map_max_width=\"98%\",\n    refresh=False,\n    **kwargs,\n):\n\"\"\"Shows the map.\n\n    Args:\n        toolbar (bool, optional): Whether to show the toolbar. Defaults to True.\n        map_min_width (str, optional): The minimum width of the map. Defaults to '91%'.\n        map_max_width (str, optional): The maximum width of the map. Defaults to '98%'.\n        refresh (bool, optional): Whether to refresh the map when the map is resized. Defaults to False.\n\n    Returns:\n        Canvas: [description]\n    \"\"\"\n    if not toolbar:\n        super().show(**kwargs)\n    else:\n        canvas = Canvas(\n            self,\n            map_min_width=map_min_width,\n            map_max_width=map_max_width,\n            map_refresh=refresh,\n        )\n        return canvas.canvas\n</code></pre>"},{"location":"plotlymap/#geemap.plotlymap.fix_widget_error","title":"<code>fix_widget_error()</code>","text":"<p>Fix FigureWidget - 'mapbox._derived' Value Error. Adopted from: https://github.com/plotly/plotly.py/issues/2570#issuecomment-738735816</p> Source code in <code>geemap/plotlymap.py</code> <pre><code>def fix_widget_error():\n\"\"\"\n    Fix FigureWidget - 'mapbox._derived' Value Error.\n    Adopted from: https://github.com/plotly/plotly.py/issues/2570#issuecomment-738735816\n    \"\"\"\n    import shutil\n\n    basedatatypesPath = os.path.join(\n        os.path.dirname(os.__file__), \"site-packages\", \"plotly\", \"basedatatypes.py\"\n    )\n\n    backup_file = basedatatypesPath.replace(\".py\", \"_bk.py\")\n    shutil.copyfile(basedatatypesPath, backup_file)\n\n    # read basedatatypes.py\n    with open(basedatatypesPath, \"r\") as f:\n        lines = f.read()\n\n    find = \"if not BaseFigure._is_key_path_compatible(key_path_str, self.layout):\"\n\n    replace = \"\"\"if not BaseFigure._is_key_path_compatible(key_path_str, self.layout):\n                if key_path_str == \"mapbox._derived\":\n                    return\"\"\"\n\n    # add new text\n    lines = lines.replace(find, replace)\n\n    # overwrite old 'basedatatypes.py'\n    with open(basedatatypesPath, \"w\") as f:\n        f.write(lines)\n</code></pre>"},{"location":"search_bk/","title":"Search bk","text":"<p> Search <p></p>"},{"location":"timelapse/","title":"timelapse module","text":"<p>Module for creating timelapse from various Earth Engine ImageCollection.</p>"},{"location":"timelapse/#geemap.timelapse.add_image_to_gif","title":"<code>add_image_to_gif(in_gif, out_gif, in_image, xy=None, image_size=(80, 80), circle_mask=False)</code>","text":"<p>Adds an image logo to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>Input file path to the GIF image.</p> required <code>out_gif</code> <code>str</code> <p>Output file path to the GIF image.</p> required <code>in_image</code> <code>str</code> <p>Input file path to the image.</p> required <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>image_size</code> <code>tuple</code> <p>Resize image. Defaults to (80, 80).</p> <code>(80, 80)</code> <code>circle_mask</code> <code>bool</code> <p>Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False.</p> <code>False</code> Source code in <code>geemap/timelapse.py</code> <pre><code>def add_image_to_gif(\n    in_gif, out_gif, in_image, xy=None, image_size=(80, 80), circle_mask=False\n):\n\"\"\"Adds an image logo to a GIF image.\n\n    Args:\n        in_gif (str): Input file path to the GIF image.\n        out_gif (str): Output file path to the GIF image.\n        in_image (str): Input file path to the image.\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        image_size (tuple, optional): Resize image. Defaults to (80, 80).\n        circle_mask (bool, optional): Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False.\n    \"\"\"\n    # import io\n    import warnings\n\n    from PIL import Image, ImageDraw, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n\n    in_gif = os.path.abspath(in_gif)\n\n    is_url = False\n    if in_image.startswith(\"http\"):\n        is_url = True\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if (not is_url) and (not os.path.exists(in_image)):\n        print(\"The provided logo file does not exist.\")\n        return\n\n    out_dir = check_dir((os.path.dirname(out_gif)))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    try:\n        gif = Image.open(in_gif)\n    except Exception as e:\n        print(\"An error occurred while opening the image.\")\n        print(e)\n        return\n\n    logo_raw_image = None\n    try:\n        if in_image.startswith(\"http\"):\n            logo_raw_image = open_image_from_url(in_image)\n        else:\n            in_image = os.path.abspath(in_image)\n            logo_raw_image = Image.open(in_image)\n    except Exception as e:\n        print(e)\n\n    logo_raw_size = logo_raw_image.size\n\n    ratio = max(\n        logo_raw_size[0] / image_size[0],\n        logo_raw_size[1] / image_size[1],\n    )\n    image_resize = (int(logo_raw_size[0] / ratio), int(logo_raw_size[1] / ratio))\n    image_size = min(logo_raw_size[0], image_size[0]), min(\n        logo_raw_size[1], image_size[1]\n    )\n\n    logo_image = logo_raw_image.convert(\"RGBA\")\n    logo_image.thumbnail(image_size, Image.ANTIALIAS)\n\n    gif_width, gif_height = gif.size\n    mask_im = None\n\n    if circle_mask:\n        mask_im = Image.new(\"L\", image_size, 0)\n        draw = ImageDraw.Draw(mask_im)\n        draw.ellipse((0, 0, image_size[0], image_size[1]), fill=255)\n\n    if has_transparency(logo_raw_image):\n        mask_im = logo_image.copy()\n\n    if xy is None:\n        # default logo location is 5% width and 5% height of the image.\n        delta = 10\n        xy = (gif_width - image_resize[0] - delta, gif_height - image_resize[1] - delta)\n        # xy = (int(0.05 * gif_width), int(0.05 * gif_height))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        print(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n        return\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; gif_width) and (y &gt; 0) and (y &lt; gif_height):\n            pass\n        else:\n            print(\n                \"xy is out of bounds. x must be within [0, {}], and y must be within [0, {}]\".format(\n                    gif_width, gif_height\n                )\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = int(float(x.replace(\"%\", \"\")) / 100.0 * gif_width)\n                y = int(float(y.replace(\"%\", \"\")) / 100.0 * gif_height)\n                xy = (x, y)\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n\n    else:\n        raise Exception(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n\n    try:\n        frames = []\n        for _, frame in enumerate(ImageSequence.Iterator(gif)):\n            frame = frame.convert(\"RGBA\")\n            frame.paste(logo_image, xy, mask_im)\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n            frames.append(frame)\n\n        frames[0].save(out_gif, save_all=True, append_images=frames[1:])\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.add_overlay","title":"<code>add_overlay(collection, overlay_data, color='black', width=1, opacity=1.0, region=None)</code>","text":"<p>Adds an overlay to an image collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>ee.ImageCollection</code> <p>The image collection to add the overlay to.</p> required <code>overlay_data</code> <code>str | ee.Geometry | ee.FeatureCollection</code> <p>The overlay data to add to the image collection. It can be an HTTP URL to a GeoJSON file.</p> required <code>color</code> <code>str</code> <p>The color of the overlay. Defaults to 'black'.</p> <code>'black'</code> <code>width</code> <code>int</code> <p>The width of the overlay. Defaults to 1.</p> <code>1</code> <code>opacity</code> <code>float</code> <p>The opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region of interest to add the overlay to. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>An ImageCollection with the overlay added.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def add_overlay(\n    collection, overlay_data, color=\"black\", width=1, opacity=1.0, region=None\n):\n\"\"\"Adds an overlay to an image collection.\n\n    Args:\n        collection (ee.ImageCollection): The image collection to add the overlay to.\n        overlay_data (str | ee.Geometry | ee.FeatureCollection): The overlay data to add to the image collection. It can be an HTTP URL to a GeoJSON file.\n        color (str, optional): The color of the overlay. Defaults to 'black'.\n        width (int, optional): The width of the overlay. Defaults to 1.\n        opacity (float, optional): The opacity of the overlay. Defaults to 1.0.\n        region (ee.Geometry | ee.FeatureCollection, optional): The region of interest to add the overlay to. Defaults to None.\n\n    Returns:\n        ee.ImageCollection: An ImageCollection with the overlay added.\n    \"\"\"\n\n    # Some common administrative boundaries.\n    public_assets = [\"continents\", \"countries\", \"us_states\", \"china\"]\n\n    if not isinstance(collection, ee.ImageCollection):\n        raise Exception(\"The collection must be an ee.ImageCollection.\")\n\n    if not isinstance(overlay_data, ee.FeatureCollection):\n        if isinstance(overlay_data, str):\n            try:\n                if overlay_data.lower() in public_assets:\n                    overlay_data = ee.FeatureCollection(\n                        f\"users/giswqs/public/{overlay_data.lower()}\"\n                    )\n                elif overlay_data.startswith(\"http\") and overlay_data.endswith(\n                    \".geojson\"\n                ):\n                    overlay_data = geojson_to_ee(overlay_data)\n                else:\n                    overlay_data = ee.FeatureCollection(overlay_data)\n\n            except Exception as e:\n                print(\n                    \"The overlay_data must be a valid ee.FeatureCollection, a valid ee.FeatureCollection asset id, or http url to a geojson file.\"\n                )\n                raise Exception(e)\n        elif isinstance(overlay_data, ee.Feature):\n            overlay_data = ee.FeatureCollection([overlay_data])\n        elif isinstance(overlay_data, ee.Geometry):\n            overlay_data = ee.FeatureCollection([ee.Feature(overlay_data)])\n        else:\n            raise Exception(\n                \"The overlay_data must be a valid ee.FeatureCollection or a valid ee.FeatureCollection asset id.\"\n            )\n\n    try:\n        if region is not None:\n            overlay_data = overlay_data.filterBounds(region)\n\n        empty = ee.Image().byte()\n        image = empty.paint(\n            **{\n                \"featureCollection\": overlay_data,\n                \"color\": 1,\n                \"width\": width,\n            }\n        ).visualize(**{\"palette\": check_color(color), \"opacity\": opacity})\n        blend_col = collection.map(\n            lambda img: img.blend(image).set(\n                \"system:time_start\", img.get(\"system:time_start\")\n            )\n        )\n        return blend_col\n    except Exception as e:\n        print(\"Error in add_overlay:\")\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.add_progress_bar_to_gif","title":"<code>add_progress_bar_to_gif(in_gif, out_gif, progress_bar_color='blue', progress_bar_height=5, duration=100, loop=0)</code>","text":"<p>Adds a progress bar to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the input GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The file path to the output GIF image.</p> required <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>duration</code> <code>int</code> <p>controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.</p> <code>100</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> Source code in <code>geemap/timelapse.py</code> <pre><code>def add_progress_bar_to_gif(\n    in_gif,\n    out_gif,\n    progress_bar_color=\"blue\",\n    progress_bar_height=5,\n    duration=100,\n    loop=0,\n):\n\"\"\"Adds a progress bar to a GIF image.\n\n    Args:\n        in_gif (str): The file path to the input GIF image.\n        out_gif (str): The file path to the output GIF image.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    \"\"\"\n    import io\n    import warnings\n\n    from PIL import Image, ImageDraw, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n\n    in_gif = os.path.abspath(in_gif)\n    out_gif = os.path.abspath(out_gif)\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    progress_bar_color = check_color(progress_bar_color)\n\n    try:\n        image = Image.open(in_gif)\n    except Exception as e:\n        raise Exception(\"An error occurred while opening the gif.\")\n\n    count = image.n_frames\n    W, H = image.size\n    progress_bar_widths = [i * 1.0 / count * W for i in range(1, count + 1)]\n    progress_bar_shapes = [\n        [(0, H - progress_bar_height), (x, H)] for x in progress_bar_widths\n    ]\n\n    try:\n        frames = []\n        # Loop over each frame in the animated image\n        for index, frame in enumerate(ImageSequence.Iterator(image)):\n            # Draw the text on the frame\n            frame = frame.convert(\"RGB\")\n            draw = ImageDraw.Draw(frame)\n            # w, h = draw.textsize(text[index])\n            draw.rectangle(progress_bar_shapes[index], fill=progress_bar_color)\n            del draw\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n\n            frames.append(frame)\n        # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/\n        # Save the frames as a new image\n\n        frames[0].save(\n            out_gif,\n            save_all=True,\n            append_images=frames[1:],\n            duration=duration,\n            loop=loop,\n            optimize=True,\n        )\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.add_text_to_gif","title":"<code>add_text_to_gif(in_gif, out_gif, xy=None, text_sequence=None, font_type='arial.ttf', font_size=20, font_color='#000000', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, duration=100, loop=0)</code>","text":"<p>Adds animated text to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the input GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The file path to the output GIF image.</p> required <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'#000000'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>duration</code> <code>int</code> <p>controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.</p> <code>100</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> Source code in <code>geemap/timelapse.py</code> <pre><code>def add_text_to_gif(\n    in_gif,\n    out_gif,\n    xy=None,\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"#000000\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    duration=100,\n    loop=0,\n):\n\"\"\"Adds animated text to a GIF image.\n\n    Args:\n        in_gif (str): The file path to the input GIF image.\n        out_gif (str): The file path to the output GIF image.\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    \"\"\"\n    # import io\n    import warnings\n\n    import pkg_resources\n    from PIL import Image, ImageDraw, ImageFont, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"geemap\", \"geemap.py\"))\n    default_font = os.path.join(pkg_dir, \"data/fonts/arial.ttf\")\n\n    in_gif = os.path.abspath(in_gif)\n    out_gif = os.path.abspath(out_gif)\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if font_type == \"arial.ttf\":\n        font = ImageFont.truetype(default_font, font_size)\n    elif font_type == \"alibaba.otf\":\n        default_font = os.path.join(pkg_dir, \"data/fonts/alibaba.otf\")\n        font = ImageFont.truetype(default_font, font_size)\n    else:\n        try:\n            font_list = system_fonts(show_full_path=True)\n            font_names = [os.path.basename(f) for f in font_list]\n            if (font_type in font_list) or (font_type in font_names):\n                font = ImageFont.truetype(font_type, font_size)\n            else:\n                print(\n                    \"The specified font type could not be found on your system. Using the default font instead.\"\n                )\n                font = ImageFont.truetype(default_font, font_size)\n        except Exception as e:\n            print(e)\n            font = ImageFont.truetype(default_font, font_size)\n\n    color = check_color(font_color)\n    progress_bar_color = check_color(progress_bar_color)\n\n    try:\n        image = Image.open(in_gif)\n    except Exception as e:\n        print(\"An error occurred while opening the gif.\")\n        print(e)\n        return\n\n    count = image.n_frames\n    W, H = image.size\n    progress_bar_widths = [i * 1.0 / count * W for i in range(1, count + 1)]\n    progress_bar_shapes = [\n        [(0, H - progress_bar_height), (x, H)] for x in progress_bar_widths\n    ]\n\n    if xy is None:\n        # default text location is 5% width and 5% height of the image.\n        xy = (int(0.05 * W), int(0.05 * H))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        print(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n        return\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; W) and (y &gt; 0) and (y &lt; H):\n            pass\n        else:\n            print(\n                f\"xy is out of bounds. x must be within [0, {W}], and y must be within [0, {H}]\"\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = int(float(x.replace(\"%\", \"\")) / 100.0 * W)\n                y = int(float(y.replace(\"%\", \"\")) / 100.0 * H)\n                xy = (x, y)\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n    else:\n        print(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n        return\n\n    if text_sequence is None:\n        text = [str(x) for x in range(1, count + 1)]\n    elif isinstance(text_sequence, int):\n        text = [str(x) for x in range(text_sequence, text_sequence + count + 1)]\n    elif isinstance(text_sequence, str):\n        try:\n            text_sequence = int(text_sequence)\n            text = [str(x) for x in range(text_sequence, text_sequence + count + 1)]\n        except Exception:\n            text = [text_sequence] * count\n    elif isinstance(text_sequence, list) and len(text_sequence) != count:\n        print(\n            f\"The length of the text sequence must be equal to the number ({count}) of frames in the gif.\"\n        )\n        return\n    else:\n        text = [str(x) for x in text_sequence]\n\n    try:\n        frames = []\n        # Loop over each frame in the animated image\n        for index, frame in enumerate(ImageSequence.Iterator(image)):\n            # Draw the text on the frame\n            frame = frame.convert(\"RGB\")\n            draw = ImageDraw.Draw(frame)\n            # w, h = draw.textsize(text[index])\n            draw.text(xy, text[index], font=font, fill=color)\n            if add_progress_bar:\n                draw.rectangle(progress_bar_shapes[index], fill=progress_bar_color)\n            del draw\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n\n            frames.append(frame)\n        # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/\n        # Save the frames as a new image\n\n        frames[0].save(\n            out_gif,\n            save_all=True,\n            append_images=frames[1:],\n            duration=duration,\n            loop=loop,\n            optimize=True,\n        )\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.create_timelapse","title":"<code>create_timelapse(collection, start_date, end_date, region=None, bands=None, frequency='year', reducer='median', date_format=None, out_gif=None, palette=None, vis_params=None, dimensions=768, frames_per_second=10, crs='EPSG:3857', overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, title=None, title_xy=('2%', '90%'), add_text=True, text_xy=('2%', '2%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='white', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, add_colorbar=False, colorbar_width=6.0, colorbar_height=0.4, colorbar_label=None, colorbar_label_size=12, colorbar_label_weight='normal', colorbar_tick_size=10, colorbar_bg_color=None, colorbar_orientation='horizontal', colorbar_dpi='figure', colorbar_xy=None, colorbar_size=(300, 300), loop=0, mp4=False, fading=False)</code>","text":"<p>Create a timelapse from any ee.ImageCollection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str | ee.ImageCollection</code> <p>The collection of images to create a timeseries from. It can be a string representing the collection ID or an ee.ImageCollection object.</p> required <code>start_date</code> <code>str</code> <p>The start date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.</p> required <code>end_date</code> <code>str</code> <p>The end date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.</p> required <code>region</code> <code>ee.Geometry</code> <p>The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names to use in the timelapse. Defaults to None.</p> <code>None</code> <code>frequency</code> <code>str</code> <p>The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.</p> <code>'year'</code> <code>reducer</code> <code>str</code> <p>The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.</p> <code>'median'</code> <code>drop_empty</code> <code>bool</code> <p>Whether to drop empty images from the timeseries. Defaults to True.</p> required <code>date_format</code> <code>str</code> <p>A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.</p> <code>None</code> <code>out_gif</code> <code>str</code> <p>The output gif file path. Defaults to None.</p> <code>None</code> <code>palette</code> <code>list</code> <p>A list of colors to render a single-band image in the timelapse. Defaults to None.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>A dictionary of visualization parameters to use in the timelapse. Defaults to None. See more at https://developers.google.com/earth-engine/guides/image_visualization.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> <code>10</code> <code>crs</code> <code>str</code> <p>The coordinate reference system to use. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>title</code> <code>str</code> <p>The title of the timelapse. Defaults to None.</p> <code>None</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>add_text</code> <code>bool</code> <p>Whether to add animated text to the timelapse. Defaults to True.</p> <code>True</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'white'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar to the timelapse. Defaults to False.</p> <code>False</code> <code>colorbar_width</code> <code>float</code> <p>Width of the colorbar. Defaults to 6.0.</p> <code>6.0</code> <code>colorbar_height</code> <code>float</code> <p>Height of the colorbar. Defaults to 0.4.</p> <code>0.4</code> <code>colorbar_label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>colorbar_label_size</code> <code>int</code> <p>Font size for the colorbar label. Defaults to 12.</p> <code>12</code> <code>colorbar_label_weight</code> <code>str</code> <p>Font weight for the colorbar label. Defaults to 'normal'.</p> <code>'normal'</code> <code>colorbar_tick_size</code> <code>int</code> <p>Font size for the colorbar ticks. Defaults to 10.</p> <code>10</code> <code>colorbar_bg_color</code> <code>str</code> <p>Background color for the colorbar, can be color like \"white\", \"black\". Defaults to None.</p> <code>None</code> <code>colorbar_orientation</code> <code>str</code> <p>Orientation of the colorbar. Defaults to 'horizontal'.</p> <code>'horizontal'</code> <code>colorbar_dpi</code> <code>str</code> <p>DPI for the colorbar, can be numbers like 100, 300. Defaults to 'figure'.</p> <code>'figure'</code> <code>colorbar_xy</code> <code>tuple</code> <p>Lower left corner of the colorbar. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>colorbar_size</code> <code>tuple</code> <p>Size of the colorbar. It can be formatted like this: (300, 300). Defaults to (300, 300).</p> <code>(300, 300)</code> <code>loop</code> <code>int</code> <p>Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to create an mp4 file. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>File path to the timelapse gif.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def create_timelapse(\n    collection,\n    start_date,\n    end_date,\n    region=None,\n    bands=None,\n    frequency=\"year\",\n    reducer=\"median\",\n    date_format=None,\n    out_gif=None,\n    palette=None,\n    vis_params=None,\n    dimensions=768,\n    frames_per_second=10,\n    crs=\"EPSG:3857\",\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    title=None,\n    title_xy=(\"2%\", \"90%\"),\n    add_text=True,\n    text_xy=(\"2%\", \"2%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"white\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    add_colorbar=False,\n    colorbar_width=6.0,\n    colorbar_height=0.4,\n    colorbar_label=None,\n    colorbar_label_size=12,\n    colorbar_label_weight=\"normal\",\n    colorbar_tick_size=10,\n    colorbar_bg_color=None,\n    colorbar_orientation=\"horizontal\",\n    colorbar_dpi=\"figure\",\n    colorbar_xy=None,\n    colorbar_size=(300, 300),\n    loop=0,\n    mp4=False,\n    fading=False,\n):\n\"\"\"Create a timelapse from any ee.ImageCollection.\n\n    Args:\n        collection (str | ee.ImageCollection): The collection of images to create a timeseries from. It can be a string representing the collection ID or an ee.ImageCollection object.\n        start_date (str): The start date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.\n        end_date (str): The end date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.\n        region (ee.Geometry, optional): The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.\n        bands (list, optional): A list of band names to use in the timelapse. Defaults to None.\n        frequency (str, optional): The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.\n        reducer (str, optional):  The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.\n        drop_empty (bool, optional): Whether to drop empty images from the timeseries. Defaults to True.\n        date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.\n        out_gif (str): The output gif file path. Defaults to None.\n        palette (list, optional): A list of colors to render a single-band image in the timelapse. Defaults to None.\n        vis_params (dict, optional): A dictionary of visualization parameters to use in the timelapse. Defaults to None. See more at https://developers.google.com/earth-engine/guides/image_visualization.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        crs (str, optional): The coordinate reference system to use. Defaults to \"EPSG:3857\".\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        title (str, optional): The title of the timelapse. Defaults to None.\n        title_xy (tuple, optional): Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        add_text (bool, optional): Whether to add animated text to the timelapse. Defaults to True.\n        title_xy (tuple, optional): Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        add_colorbar (bool, optional): Whether to add a colorbar to the timelapse. Defaults to False.\n        colorbar_width (float, optional): Width of the colorbar. Defaults to 6.0.\n        colorbar_height (float, optional): Height of the colorbar. Defaults to 0.4.\n        colorbar_label (str, optional): Label for the colorbar. Defaults to None.\n        colorbar_label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n        colorbar_label_weight (str, optional): Font weight for the colorbar label. Defaults to 'normal'.\n        colorbar_tick_size (int, optional): Font size for the colorbar ticks. Defaults to 10.\n        colorbar_bg_color (str, optional): Background color for the colorbar, can be color like \"white\", \"black\". Defaults to None.\n        colorbar_orientation (str, optional): Orientation of the colorbar. Defaults to 'horizontal'.\n        colorbar_dpi (str, optional): DPI for the colorbar, can be numbers like 100, 300. Defaults to 'figure'.\n        colorbar_xy (tuple, optional): Lower left corner of the colorbar. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        colorbar_size (tuple, optional): Size of the colorbar. It can be formatted like this: (300, 300). Defaults to (300, 300).\n        loop (int, optional): Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        mp4 (bool, optional): Whether to create an mp4 file. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n\n    Returns:\n        str: File path to the timelapse gif.\n    \"\"\"\n    import geemap.colormaps as cm\n\n    if not isinstance(collection, ee.ImageCollection):\n        if isinstance(collection, str):\n            collection = ee.ImageCollection(collection)\n        else:\n            raise Exception(\n                \"The collection must be an ee.ImageCollection object or asset id.\"\n            )\n\n    col = create_timeseries(\n        collection,\n        start_date,\n        end_date,\n        region=region,\n        bands=bands,\n        frequency=frequency,\n        reducer=reducer,\n        drop_empty=True,\n        date_format=date_format,\n    )\n\n    # rename the bands to remove the '_reducer' characters from the band names.\n    col = col.map(\n        lambda img: img.rename(\n            img.bandNames().map(lambda name: ee.String(name).replace(f\"_{reducer}\", \"\"))\n        )\n    )\n\n    if out_gif is None:\n        out_gif = temp_file_path(\".gif\")\n    else:\n        out_gif = check_file_path(out_gif)\n\n    out_dir = os.path.dirname(out_gif)\n\n    if bands is None:\n        names = col.first().bandNames().getInfo()\n        if len(names) &lt; 3:\n            bands = [names[0]]\n        else:\n            bands = names[:3][::-1]\n    elif isinstance(bands, str):\n        bands = [bands]\n    elif not isinstance(bands, list):\n        raise Exception(\"The bands must be a string or a list of strings.\")\n\n    if isinstance(palette, str):\n        palette = cm.get_palette(palette, 15)\n    elif isinstance(palette, list) or isinstance(palette, tuple):\n        pass\n    elif palette is not None:\n        raise Exception(\"The palette must be a string or a list of strings.\")\n\n    if vis_params is None:\n        img = col.first().select(bands)\n        scale = collection.first().select(0).projection().nominalScale().multiply(10)\n        min_value = min(\n            image_min_value(img, region=region, scale=scale).getInfo().values()\n        )\n        max_value = max(\n            image_max_value(img, region=region, scale=scale).getInfo().values()\n        )\n        vis_params = {\"bands\": bands, \"min\": min_value, \"max\": max_value}\n\n        if len(bands) == 1:\n            if palette is not None:\n                vis_params[\"palette\"] = palette\n            else:\n                vis_params[\"palette\"] = cm.palettes.ndvi\n    elif isinstance(vis_params, dict):\n        if \"bands\" not in vis_params:\n            vis_params[\"bands\"] = bands\n        if \"min\" not in vis_params:\n            img = col.first().select(bands)\n            scale = (\n                collection.first().select(0).projection().nominalScale().multiply(10)\n            )\n            vis_params[\"min\"] = min(\n                image_min_value(img, region=region, scale=scale).getInfo().values()\n            )\n        if \"max\" not in vis_params:\n            img = col.first().select(bands)\n            scale = (\n                collection.first().select(0).projection().nominalScale().multiply(10)\n            )\n            vis_params[\"max\"] = max(\n                image_max_value(img, region=region, scale=scale).getInfo().values()\n            )\n        if palette is None and (len(bands) == 1) and (\"palette\" not in vis_params):\n            vis_params[\"palette\"] = cm.palettes.ndvi\n        elif palette is not None and (\"palette\" not in vis_params):\n            vis_params[\"palette\"] = palette\n        if len(bands) &gt; 1 and \"palette\" in vis_params:\n            del vis_params[\"palette\"]\n    else:\n        raise Exception(\"The vis_params must be a dictionary.\")\n\n    col = col.select(bands).map(\n        lambda img: img.visualize(**vis_params).set(\n            {\n                \"system:time_start\": img.get(\"system:time_start\"),\n                \"system:date\": img.get(\"system:date\"),\n            }\n        )\n    )\n\n    if overlay_data is not None:\n        col = add_overlay(\n            col, overlay_data, overlay_color, overlay_width, overlay_opacity\n        )\n\n    video_args = {}\n    video_args[\"dimensions\"] = dimensions\n    video_args[\"region\"] = region\n    video_args[\"framesPerSecond\"] = frames_per_second\n    video_args[\"crs\"] = crs\n    video_args[\"min\"] = 0\n    video_args[\"max\"] = 255\n\n    # if crs is not None:\n    #     video_args[\"crs\"] = crs\n\n    if \"palette\" in vis_params or len(bands) &gt; 1:\n        video_args[\"bands\"] = [\"vis-red\", \"vis-green\", \"vis-blue\"]\n    else:\n        video_args[\"bands\"] = [\"vis-gray\"]\n\n    if isinstance(dimensions, int) and dimensions &gt; 768 or isinstance(dimensions, str) and any(dim&gt;768 for dim in list(map(int,dimensions.split('x')))):\n        count = col.size().getInfo()\n        basename = os.path.basename(out_gif)[:-4]\n        names = [\n            os.path.join(\n                out_dir, f\"{basename}_{str(i+1).zfill(int(len(str(count))))}.jpg\"\n            )\n            for i in range(count)\n        ]\n        get_image_collection_thumbnails(\n            col,\n            out_dir,\n            vis_params={\n                \"min\": 0,\n                \"max\": 255,\n                \"bands\": video_args[\"bands\"],\n            },\n            dimensions=dimensions,\n            names=names,\n        )\n        make_gif(\n            names,\n            out_gif,\n            fps=frames_per_second,\n            loop=loop,\n            mp4=False,\n            clean_up=True,\n        )\n    else:\n        download_ee_video(col, video_args, out_gif)\n\n    if title is not None and isinstance(title, str):\n        add_text_to_gif(\n            out_gif,\n            out_gif,\n            xy=title_xy,\n            text_sequence=title,\n            font_type=font_type,\n            font_size=font_size,\n            font_color=font_color,\n            add_progress_bar=add_progress_bar,\n            progress_bar_color=progress_bar_color,\n            progress_bar_height=progress_bar_height,\n            duration=1000 / frames_per_second,\n            loop=loop,\n        )\n    if add_text:\n        if text_sequence is None:\n            text_sequence = col.aggregate_array(\"system:date\").getInfo()\n        add_text_to_gif(\n            out_gif,\n            out_gif,\n            xy=text_xy,\n            text_sequence=text_sequence,\n            font_type=font_type,\n            font_size=font_size,\n            font_color=font_color,\n            add_progress_bar=add_progress_bar,\n            progress_bar_color=progress_bar_color,\n            progress_bar_height=progress_bar_height,\n            duration=1000 / frames_per_second,\n            loop=loop,\n        )\n    if add_colorbar:\n        colorbar = save_colorbar(\n            None,\n            colorbar_width,\n            colorbar_height,\n            vis_params[\"min\"],\n            vis_params[\"max\"],\n            vis_params[\"palette\"],\n            label=colorbar_label,\n            label_size=colorbar_label_size,\n            label_weight=colorbar_label_weight,\n            tick_size=colorbar_tick_size,\n            bg_color=colorbar_bg_color,\n            orientation=colorbar_orientation,\n            dpi=colorbar_dpi,\n            show_colorbar=False,\n        )\n        add_image_to_gif(out_gif, out_gif, colorbar, colorbar_xy, colorbar_size)\n\n    if os.path.exists(out_gif):\n        reduce_gif_size(out_gif)\n\n    if isinstance(fading, bool):\n        fading = int(fading)\n    if fading &gt; 0:\n        gif_fading(out_gif, out_gif, duration=fading, verbose=False)\n\n    if mp4:\n        out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n        gif_to_mp4(out_gif, out_mp4)\n\n    return out_gif\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.create_timeseries","title":"<code>create_timeseries(collection, start_date, end_date, region=None, bands=None, frequency='year', reducer='median', drop_empty=True, date_format=None)</code>","text":"<p>Creates a timeseries from a collection of images by a specified frequency and reducer.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str | ee.ImageCollection</code> <p>The collection of images to create a timeseries from. It can be a string representing the collection ID or an ee.ImageCollection object.</p> required <code>start_date</code> <code>str</code> <p>The start date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.</p> required <code>end_date</code> <code>str</code> <p>The end date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.</p> required <code>region</code> <code>ee.Geometry</code> <p>The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.</p> <code>None</code> <code>bands</code> <code>list</code> <p>The list of bands to use to create the timeseries. It must be a list of strings. Defaults to None.</p> <code>None</code> <code>frequency</code> <code>str</code> <p>The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.</p> <code>'year'</code> <code>reducer</code> <code>str</code> <p>The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.</p> <code>'median'</code> <code>drop_empty</code> <code>bool</code> <p>Whether to drop empty images from the timeseries. Defaults to True.</p> <code>True</code> <code>date_format</code> <code>str</code> <p>A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>The timeseries.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def create_timeseries(\n    collection,\n    start_date,\n    end_date,\n    region=None,\n    bands=None,\n    frequency=\"year\",\n    reducer=\"median\",\n    drop_empty=True,\n    date_format=None,\n):\n\"\"\"Creates a timeseries from a collection of images by a specified frequency and reducer.\n\n    Args:\n        collection (str | ee.ImageCollection): The collection of images to create a timeseries from. It can be a string representing the collection ID or an ee.ImageCollection object.\n        start_date (str): The start date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.\n        end_date (str): The end date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.\n        region (ee.Geometry, optional): The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.\n        bands (list, optional): The list of bands to use to create the timeseries. It must be a list of strings. Defaults to None.\n        frequency (str, optional): The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.\n        reducer (str, optional):  The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.\n        drop_empty (bool, optional): Whether to drop empty images from the timeseries. Defaults to True.\n        date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.\n\n    Returns:\n        ee.ImageCollection: The timeseries.\n    \"\"\"\n    if not isinstance(collection, ee.ImageCollection):\n        if isinstance(collection, str):\n            collection = ee.ImageCollection(collection)\n        else:\n            raise Exception(\n                \"The collection must be an ee.ImageCollection object or asset id.\"\n            )\n\n    if bands is not None:\n        collection = collection.select(bands)\n    else:\n        bands = collection.first().bandNames()\n\n    feq_dict = {\n        \"year\": \"YYYY\",\n        \"month\": \"YYYY-MM\",\n        \"quarter\": \"YYYY-MM\",\n        \"week\": \"YYYY-MM-dd\",\n        \"day\": \"YYYY-MM-dd\",\n        \"hour\": \"YYYY-MM-dd HH\",\n        \"minute\": \"YYYY-MM-dd HH:mm\",\n        \"second\": \"YYYY-MM-dd HH:mm:ss\",\n    }\n\n    if date_format is None:\n        date_format = feq_dict[frequency]\n\n    dates = date_sequence(start_date, end_date, frequency, date_format)\n\n    try:\n        reducer = eval(f\"ee.Reducer.{reducer}()\")\n    except Exception as e:\n        print(\"The provided reducer is invalid.\")\n        raise Exception(e)\n\n    def create_image(date):\n        start = ee.Date(date)\n        if frequency == \"quarter\":\n            end = start.advance(3, \"month\")\n        else:\n            end = start.advance(1, frequency)\n\n        if region is None:\n            sub_col = collection.filterDate(start, end)\n            image = sub_col.reduce(reducer)\n\n        else:\n            sub_col = collection.filterDate(start, end).filterBounds(region)\n            image = sub_col.reduce(reducer).clip(region)\n        return image.set(\n            {\n                \"system:time_start\": ee.Date(date).millis(),\n                \"system:date\": ee.Date(date).format(date_format),\n                \"empty\": sub_col.size().eq(0),\n            }\n        ).rename(bands)\n\n    try:\n        images = ee.ImageCollection(dates.map(create_image))\n        if drop_empty:\n            return images.filterMetadata(\"empty\", \"equals\", 0)\n        else:\n            return images\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.dynamic_world_timeseries","title":"<code>dynamic_world_timeseries(region, start_date='2016-01-01', end_date='2021-12-31', cloud_pct=30, frequency='year', reducer='mode', drop_empty=True, date_format=None, return_type='hillshade')</code>","text":"<p>Create Dynamic World timeseries.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>ee.Geometry | ee.FeatureCollection</code> <p>The region of interest.</p> required <code>start_date</code> <code>str | ee.Date</code> <p>The start date of the query. Default to \"2016-01-01\".</p> <code>'2016-01-01'</code> <code>end_date</code> <code>str | ee.Date</code> <p>The end date of the query. Default to \"2021-12-31\".</p> <code>'2021-12-31'</code> <code>cloud_pct</code> <code>int</code> <p>The cloud percentage threshold (&lt;=). Defaults to 30.</p> <code>30</code> <code>frequency</code> <code>str</code> <p>The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.</p> <code>'year'</code> <code>reducer</code> <code>str</code> <p>The reducer to be used. Defaults to \"mode\".</p> <code>'mode'</code> <code>drop_empty</code> <code>bool</code> <p>Whether to drop empty images from the timeseries. Defaults to True.</p> <code>True</code> <code>date_format</code> <code>str</code> <p>A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.</p> <code>None</code> <code>return_type</code> <code>str</code> <p>The type of image to be returned. Can be one of 'hillshade', 'visualize', 'class', or 'probability'. Default to \"hillshade\".</p> <code>'hillshade'</code> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>An ImageCollection of the Dynamic World land cover timeseries.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def dynamic_world_timeseries(\n    region,\n    start_date=\"2016-01-01\",\n    end_date=\"2021-12-31\",\n    cloud_pct=30,\n    frequency=\"year\",\n    reducer=\"mode\",\n    drop_empty=True,\n    date_format=None,\n    return_type=\"hillshade\",\n):\n\"\"\"Create Dynamic World timeseries.\n\n    Args:\n        region (ee.Geometry | ee.FeatureCollection): The region of interest.\n        start_date (str | ee.Date): The start date of the query. Default to \"2016-01-01\".\n        end_date (str | ee.Date): The end date of the query. Default to \"2021-12-31\".\n        cloud_pct (int, optional): The cloud percentage threshold (&lt;=). Defaults to 30.\n        frequency (str, optional): The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.\n        reducer (str, optional): The reducer to be used. Defaults to \"mode\".\n        drop_empty (bool, optional): Whether to drop empty images from the timeseries. Defaults to True.\n        date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.\n        return_type (str, optional): The type of image to be returned. Can be one of 'hillshade', 'visualize', 'class', or 'probability'. Default to \"hillshade\".\n\n    Returns:\n        ee.ImageCollection: An ImageCollection of the Dynamic World land cover timeseries.\n    \"\"\"\n    if return_type not in [\"hillshade\", \"visualize\", \"class\", \"probability\"]:\n        raise ValueError(\n            f\"{return_type} must be one of 'hillshade', 'visualize', 'class', or 'probability'.\"\n        )\n\n    if (\n        isinstance(region, ee.FeatureCollection)\n        or isinstance(region, ee.Feature)\n        or isinstance(region, ee.Geometry)\n    ):\n        pass\n    else:\n        raise ValueError(\n            f\"{region} must be one of ee.FeatureCollection, ee.Feature, or ee.Geometry.\"\n        )\n\n    if cloud_pct &lt; 0 or cloud_pct &gt; 100:\n        raise ValueError(f\"{cloud_pct} must be between 0 and 100.\")\n\n    s2 = (\n        ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\")\n        .filterDate(start_date, end_date)\n        .filterBounds(region)\n        .filter(ee.Filter.lte(\"CLOUDY_PIXEL_PERCENTAGE\", cloud_pct))\n    )\n\n    ids = s2.aggregate_array(\"system:index\")\n\n    dw = ee.ImageCollection(\"GOOGLE/DYNAMICWORLD/V1\").filter(\n        ee.Filter.inList(\"system:index\", ids)\n    )\n\n    collection = dw.select(\"label\")\n\n    dwVisParams = {\n        \"min\": 0,\n        \"max\": 8,\n        \"palette\": [\n            \"#419BDF\",\n            \"#397D49\",\n            \"#88B053\",\n            \"#7A87C6\",\n            \"#E49635\",\n            \"#DFC35A\",\n            \"#C4281B\",\n            \"#A59B8F\",\n            \"#B39FE1\",\n        ],\n    }\n\n    images = create_timeseries(\n        collection,\n        start_date,\n        end_date,\n        region,\n        None,\n        frequency,\n        reducer,\n        drop_empty,\n        date_format,\n    )\n\n    if return_type == \"class\":\n        return images\n    elif return_type == \"visualize\":\n        result = images.map(lambda img: img.visualize(**dwVisParams))\n        return result\n    else:\n        # Create a Top-1 Probability Hillshade Visualization\n        probabilityBands = [\n            \"water\",\n            \"trees\",\n            \"grass\",\n            \"flooded_vegetation\",\n            \"crops\",\n            \"shrub_and_scrub\",\n            \"built\",\n            \"bare\",\n            \"snow_and_ice\",\n        ]\n\n        # Select probability bands\n        probabilityCol = dw.select(probabilityBands)\n\n        prob_col = create_timeseries(\n            probabilityCol,\n            start_date,\n            end_date,\n            region,\n            None,\n            frequency,\n            \"mean\",\n            drop_empty,\n            date_format,\n        )\n\n        prob_images = ee.ImageCollection(\n            prob_col.map(\n                lambda img: img.reduce(ee.Reducer.max()).set(\n                    \"system:time_start\", img.get(\"system:time_start\")\n                )\n            )\n        )\n\n        if return_type == \"probability\":\n            return prob_images\n\n        elif return_type == \"hillshade\":\n            count = prob_images.size()\n            nums = ee.List.sequence(0, count.subtract(1))\n\n            def create_hillshade(d):\n                proj = ee.Projection(\"EPSG:3857\").atScale(10)\n                img = ee.Image(images.toList(images.size()).get(d))\n                prob_img = ee.Image(prob_images.toList(prob_images.size()).get(d))\n                prob_img = prob_img.setDefaultProjection(proj)\n                top1Confidence = prob_img.multiply(100).int()\n                hillshade = ee.Terrain.hillshade(top1Confidence).divide(255)\n                rgbImage = img.visualize(**dwVisParams).divide(255)\n                probabilityHillshade = rgbImage.multiply(hillshade)\n                return probabilityHillshade.set(\n                    \"system:time_start\", img.get(\"system:time_start\")\n                )\n\n            result = ee.ImageCollection(nums.map(create_hillshade))\n            return result\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.gif_fading","title":"<code>gif_fading(in_gif, out_gif, duration=1, verbose=True)</code>","text":"<p>Fade in/out the gif.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"</p> required <code>out_gif</code> <code>str</code> <p>The output gif file.</p> required <code>duration</code> <code>float</code> <p>The duration of the fading. Defaults to 1.</p> <code>1</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>Raise exception when the input gif does not exist.</p> <code>Exception</code> <p>Raise exception when ffmpeg is not installed.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def gif_fading(in_gif, out_gif, duration=1, verbose=True):\n\"\"\"Fade in/out the gif.\n\n    Args:\n        in_gif (str): The input gif file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"\n        out_gif (str): The output gif file.\n        duration (float, optional): The duration of the fading. Defaults to 1.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n\n    Raises:\n        FileNotFoundError: Raise exception when the input gif does not exist.\n        Exception: Raise exception when ffmpeg is not installed.\n    \"\"\"\n    import glob\n    import tempfile\n\n    current_dir = os.getcwd()\n\n    if isinstance(in_gif, str) and in_gif.startswith(\"http\"):\n        ext = os.path.splitext(in_gif)[1]\n        file_path = temp_file_path(ext)\n        download_from_url(in_gif, file_path, verbose=verbose)\n        in_gif = file_path\n\n    in_gif = os.path.abspath(in_gif)\n    if not in_gif.endswith(\".gif\"):\n        raise Exception(\"in_gif must be a gif file.\")\n\n    if \" \" in in_gif:\n        raise Exception(\"The filename cannot contain spaces.\")\n\n    out_gif = os.path.abspath(out_gif)\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    basename = os.path.basename(in_gif).replace(\".gif\", \"\")\n    temp_dir = os.path.join(tempfile.gettempdir(), basename)\n    if os.path.exists(temp_dir):\n        shutil.rmtree(temp_dir)\n\n    gif_to_png(in_gif, temp_dir, verbose=verbose)\n\n    os.chdir(temp_dir)\n\n    images = list(glob.glob(os.path.join(temp_dir, \"*.png\")))\n    count = len(images)\n\n    files = []\n    for i in range(1, count + 1):\n        files.append(f\"-loop 1 -t {duration} -i {i}.png\")\n    inputs = \" \".join(files)\n\n    filters = []\n    for i in range(1, count):\n        if i == 1:\n            filters.append(\n                f\"\\\"[1:v][0:v]blend=all_expr='A*(if(gte(T,3),1,T/3))+B*(1-(if(gte(T,3),1,T/3)))'[v0];\"\n            )\n        else:\n            filters.append(\n                f\"[{i}:v][{i-1}:v]blend=all_expr='A*(if(gte(T,3),1,T/3))+B*(1-(if(gte(T,3),1,T/3)))'[v{i-1}];\"\n            )\n\n    last_filter = \"\"\n    for i in range(count - 1):\n        last_filter += f\"[v{i}]\"\n    last_filter += f'concat=n={count-1}:v=1:a=0[v]\" -map \"[v]\"'\n    filters.append(last_filter)\n    filters = \" \".join(filters)\n\n    cmd = f\"ffmpeg -y -loglevel error {inputs} -filter_complex {filters} {out_gif}\"\n\n    # if fade &gt;= duration:\n    #     duration = fade + 1\n\n    # files = []\n    # for i in range(1, count + 1):\n    #     files.append(f\"-framerate {framerate} -loop 1 -t {duration} -i {i}.png\")\n\n    # inputs = \" \".join(files)\n\n    # filters = []\n    # for i in range(count):\n    #     if i == 0:\n    #         filters.append(f'\"[0:v]fade=t=out:st=4:d={fade}[v0];')\n    #     else:\n    #         filters.append(\n    #             f\"[{i}:v]fade=t=in:st=0:d={fade},fade=t=out:st=4:d={fade}[v{i}];\"\n    #         )\n\n    # last_filter = \"\"\n    # for i in range(count):\n    #     last_filter += f\"[v{i}]\"\n    # last_filter += f\"concat=n={count}:v=1:a=0,split[v0][v1];\"\n    # filters.append(last_filter)\n    # palette = f'[v0]palettegen[p];[v1][p]paletteuse[v]\" -map \"[v]\"'\n    # filters.append(palette)\n    # filters = \" \".join(filters)\n\n    # cmd = f\"ffmpeg -y {inputs} -filter_complex {filters} {out_gif}\"\n\n    os.system(cmd)\n    try:\n        shutil.rmtree(temp_dir)\n    except Exception as e:\n        print(e)\n\n    os.chdir(current_dir)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.gif_to_mp4","title":"<code>gif_to_mp4(in_gif, out_mp4)</code>","text":"<p>Converts a gif to mp4.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file.</p> required <code>out_mp4</code> <code>str</code> <p>The output mp4 file.</p> required Source code in <code>geemap/timelapse.py</code> <pre><code>def gif_to_mp4(in_gif, out_mp4):\n\"\"\"Converts a gif to mp4.\n\n    Args:\n        in_gif (str): The input gif file.\n        out_mp4 (str): The output mp4 file.\n    \"\"\"\n    from PIL import Image\n\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    out_mp4 = os.path.abspath(out_mp4)\n    if not out_mp4.endswith(\".mp4\"):\n        out_mp4 = out_mp4 + \".mp4\"\n\n    if not os.path.exists(os.path.dirname(out_mp4)):\n        os.makedirs(os.path.dirname(out_mp4))\n\n    if not is_tool(\"ffmpeg\"):\n        print(\"ffmpeg is not installed on your computer.\")\n        return\n\n    width, height = Image.open(in_gif).size\n\n    if width % 2 == 0 and height % 2 == 0:\n        cmd = f\"ffmpeg -loglevel error -i {in_gif} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n        os.system(cmd)\n    else:\n        width += width % 2\n        height += height % 2\n        cmd = f\"ffmpeg -loglevel error -i {in_gif} -vf scale={width}:{height} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n        os.system(cmd)\n\n    if not os.path.exists(out_mp4):\n        raise Exception(f\"Failed to create mp4 file.\")\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.gif_to_png","title":"<code>gif_to_png(in_gif, out_dir=None, prefix='', verbose=True)</code>","text":"<p>Converts a gif to png.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>The prefix of the output png files. Defaults to None.</p> <code>''</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>Raise exception when the input gif does not exist.</p> <code>Exception</code> <p>Raise exception when ffmpeg is not installed.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def gif_to_png(in_gif, out_dir=None, prefix=\"\", verbose=True):\n\"\"\"Converts a gif to png.\n\n    Args:\n        in_gif (str): The input gif file.\n        out_dir (str, optional): The output directory. Defaults to None.\n        prefix (str, optional): The prefix of the output png files. Defaults to None.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n\n    Raises:\n        FileNotFoundError: Raise exception when the input gif does not exist.\n        Exception: Raise exception when ffmpeg is not installed.\n    \"\"\"\n    import tempfile\n\n    in_gif = os.path.abspath(in_gif)\n    if \" \" in in_gif:\n        raise Exception(\"in_gif cannot contain spaces.\")\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    basename = os.path.basename(in_gif).replace(\".gif\", \"\")\n    if out_dir is None:\n        out_dir = os.path.join(tempfile.gettempdir(), basename)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n    elif isinstance(out_dir, str) and not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n    elif not isinstance(out_dir, str):\n        raise Exception(\"out_dir must be a string.\")\n\n    out_dir = os.path.abspath(out_dir)\n    cmd = f\"ffmpeg -loglevel error -i {in_gif} -vsync 0 {out_dir}/{prefix}%d.png\"\n    os.system(cmd)\n\n    if verbose:\n        print(f\"Images are saved to {out_dir}\")\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.goes_fire_timelapse","title":"<code>goes_fire_timelapse(roi=None, out_gif=None, start_date='2020-09-05T15:00', end_date='2020-09-06T02:00', data='GOES-17', scan='full_disk', dimensions=768, framesPerSecond=10, date_format='YYYY-MM-dd HH:mm', xy=('3%', '3%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='#ffffff', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, loop=0, crs=None, overlay_data=None, overlay_color='#000000', overlay_width=1, overlay_opacity=1.0, mp4=False, fading=False, **kwargs)</code>","text":"<p>Create a timelapse of GOES fire data. The code is adapted from Justin Braaten's code: https://code.earthengine.google.com/8a083a7fb13b95ad4ba148ed9b65475e. Credits to Justin Braaten. See also https://jstnbraaten.medium.com/goes-in-earth-engine-53fbc8783c16</p> <p>Parameters:</p> Name Type Description Default <code>out_gif</code> <code>str</code> <p>The file path to save the gif.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>The start date of the time series. Defaults to \"2021-10-24T14:00:00\".</p> <code>'2020-09-05T15:00'</code> <code>end_date</code> <code>str</code> <p>The end date of the time series. Defaults to \"2021-10-25T01:00:00\".</p> <code>'2020-09-06T02:00'</code> <code>data</code> <code>str</code> <p>The GOES satellite data to use. Defaults to \"GOES-17\".</p> <code>'GOES-17'</code> <code>scan</code> <code>str</code> <p>The GOES scan to use. Defaults to \"full_disk\".</p> <code>'full_disk'</code> <code>region</code> <code>ee.Geometry</code> <p>The region of interest. Defaults to None.</p> required <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> required <code>date_format</code> <code>str</code> <p>The date format to use. Defaults to \"YYYY-MM-dd HH:mm\".</p> <code>'YYYY-MM-dd HH:mm'</code> <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('3%', '3%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'#ffffff'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>crs</code> <code>str</code> <p>The coordinate reference system to use, e.g., \"EPSG:3857\". Defaults to None.</p> <code>None</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'#000000'</code> <code>overlay_width</code> <code>int</code> <p>Width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the GIF to MP4. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <p>Exceptions:</p> Type Description <code>Exception</code> <p>Raise exception.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def goes_fire_timelapse(\n    roi=None,\n    out_gif=None,\n    start_date=\"2020-09-05T15:00\",\n    end_date=\"2020-09-06T02:00\",\n    data=\"GOES-17\",\n    scan=\"full_disk\",\n    dimensions=768,\n    framesPerSecond=10,\n    date_format=\"YYYY-MM-dd HH:mm\",\n    xy=(\"3%\", \"3%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"#ffffff\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    loop=0,\n    crs=None,\n    overlay_data=None,\n    overlay_color=\"#000000\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    mp4=False,\n    fading=False,\n    **kwargs,\n):\n\"\"\"Create a timelapse of GOES fire data. The code is adapted from Justin Braaten's code: https://code.earthengine.google.com/8a083a7fb13b95ad4ba148ed9b65475e.\n    Credits to Justin Braaten. See also https://jstnbraaten.medium.com/goes-in-earth-engine-53fbc8783c16\n\n    Args:\n        out_gif (str): The file path to save the gif.\n        start_date (str, optional): The start date of the time series. Defaults to \"2021-10-24T14:00:00\".\n        end_date (str, optional): The end date of the time series. Defaults to \"2021-10-25T01:00:00\".\n        data (str, optional): The GOES satellite data to use. Defaults to \"GOES-17\".\n        scan (str, optional): The GOES scan to use. Defaults to \"full_disk\".\n        region (ee.Geometry, optional): The region of interest. Defaults to None.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        date_format (str, optional): The date format to use. Defaults to \"YYYY-MM-dd HH:mm\".\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        crs (str, optional): The coordinate reference system to use, e.g., \"EPSG:3857\". Defaults to None.\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        mp4 (bool, optional): Whether to convert the GIF to MP4. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n\n    Raises:\n        Exception: Raise exception.\n    \"\"\"\n\n    try:\n        if \"region\" in kwargs:\n            roi = kwargs[\"region\"]\n\n        if out_gif is None:\n            out_gif = os.path.abspath(f\"goes_fire_{random_string(3)}.gif\")\n\n        if roi is None:\n            roi = ee.Geometry.BBox(-123.17, 36.56, -118.22, 40.03)\n\n        col = goes_fire_timeseries(start_date, end_date, data, scan, roi)\n        if overlay_data is not None:\n            col = add_overlay(\n                col, overlay_data, overlay_color, overlay_width, overlay_opacity\n            )\n\n        # visParams = {\n        #     \"bands\": [\"CMI_C02\", \"CMI_GREEN\", \"CMI_C01\"],\n        #     \"min\": 0,\n        #     \"max\": 0.8,\n        #     \"dimensions\": dimensions,\n        #     \"framesPerSecond\": framesPerSecond,\n        #     \"region\": region,\n        #     \"crs\": col.first().projection(),\n        # }\n\n        if crs is None:\n            crs = col.first().projection()\n\n        cmiFdcVisParams = {\n            \"dimensions\": dimensions,\n            \"framesPerSecond\": framesPerSecond,\n            \"region\": roi,\n            \"crs\": crs,\n        }\n\n        if text_sequence is None:\n            text_sequence = image_dates(col, date_format=date_format).getInfo()\n\n        download_ee_video(col, cmiFdcVisParams, out_gif)\n\n        if os.path.exists(out_gif):\n            add_text_to_gif(\n                out_gif,\n                out_gif,\n                xy,\n                text_sequence,\n                font_type,\n                font_size,\n                font_color,\n                add_progress_bar,\n                progress_bar_color,\n                progress_bar_height,\n                duration=1000 / framesPerSecond,\n                loop=loop,\n            )\n\n            try:\n                reduce_gif_size(out_gif)\n                if isinstance(fading, bool):\n                    fading = int(fading)\n                if fading &gt; 0:\n                    gif_fading(out_gif, out_gif, duration=fading, verbose=False)\n\n            except Exception as _:\n                pass\n\n            if mp4:\n                out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n                gif_to_mp4(out_gif, out_mp4)\n\n            return out_gif\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.goes_fire_timeseries","title":"<code>goes_fire_timeseries(start_date='2020-09-05T15:00', end_date='2020-09-06T02:00', data='GOES-17', scan='full_disk', region=None, merge=True)</code>","text":"<p>Create a time series of GOES Fire data. The code is adapted from Justin Braaten's code: https://code.earthengine.google.com/8a083a7fb13b95ad4ba148ed9b65475e. Credits to Justin Braaten. See also https://jstnbraaten.medium.com/goes-in-earth-engine-53fbc8783c16</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The start date of the time series. Defaults to \"2020-09-05T15:00\".</p> <code>'2020-09-05T15:00'</code> <code>end_date</code> <code>str</code> <p>The end date of the time series. Defaults to \"2020-09-06T02:00\".</p> <code>'2020-09-06T02:00'</code> <code>data</code> <code>str</code> <p>The GOES satellite data to use. Defaults to \"GOES-17\".</p> <code>'GOES-17'</code> <code>scan</code> <code>str</code> <p>The GOES scan to use. Defaults to \"full_disk\".</p> <code>'full_disk'</code> <code>region</code> <code>ee.Geometry</code> <p>The region of interest. Defaults to None.</p> <code>None</code> <code>merge</code> <code>bool</code> <p>Whether to merge the fire timeseries with GOES CMI timeseries. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The data must be either GOES-16 or GOES-17.</p> <code>ValueError</code> <p>The scan must be either full_disk or conus.</p> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>GOES fire timeseries.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def goes_fire_timeseries(\n    start_date=\"2020-09-05T15:00\",\n    end_date=\"2020-09-06T02:00\",\n    data=\"GOES-17\",\n    scan=\"full_disk\",\n    region=None,\n    merge=True,\n):\n\"\"\"Create a time series of GOES Fire data. The code is adapted from Justin Braaten's code: https://code.earthengine.google.com/8a083a7fb13b95ad4ba148ed9b65475e.\n    Credits to Justin Braaten. See also https://jstnbraaten.medium.com/goes-in-earth-engine-53fbc8783c16\n\n    Args:\n        start_date (str, optional): The start date of the time series. Defaults to \"2020-09-05T15:00\".\n        end_date (str, optional): The end date of the time series. Defaults to \"2020-09-06T02:00\".\n        data (str, optional): The GOES satellite data to use. Defaults to \"GOES-17\".\n        scan (str, optional): The GOES scan to use. Defaults to \"full_disk\".\n        region (ee.Geometry, optional): The region of interest. Defaults to None.\n        merge (bool, optional): Whether to merge the fire timeseries with GOES CMI timeseries. Defaults to True.\n\n    Raises:\n        ValueError: The data must be either GOES-16 or GOES-17.\n        ValueError: The scan must be either full_disk or conus.\n\n    Returns:\n        ee.ImageCollection: GOES fire timeseries.\n    \"\"\"\n\n    if data not in [\"GOES-16\", \"GOES-17\"]:\n        raise ValueError(\"The data must be either GOES-16 or GOES-17.\")\n\n    if scan.lower() not in [\"full_disk\", \"conus\"]:\n        raise ValueError(\"The scan must be either full_disk or conus.\")\n\n    scan_types = {\n        \"full_disk\": \"FDCF\",\n        \"conus\": \"FDCC\",\n    }\n\n    if region is None:\n        region = ee.Geometry.BBox(-123.17, 36.56, -118.22, 40.03)\n\n    # Get the fire/hotspot characterization dataset.\n    col = ee.ImageCollection(f\"NOAA/GOES/{data[-2:]}/{scan_types[scan.lower()]}\")\n    fdcCol = col.filterDate(start_date, end_date)\n\n    # Identify fire-detected pixels of medium to high confidence.\n    fireMaskCodes = [10, 30, 11, 31, 12, 32, 13, 33, 14, 34, 15, 35]\n    confVals = [1.0, 1.0, 0.9, 0.9, 0.8, 0.8, 0.5, 0.5, 0.3, 0.3, 0.1, 0.1]\n    defaultConfVal = 0\n\n    def fdcVis(img):\n        confImg = img.remap(fireMaskCodes, confVals, defaultConfVal, \"Mask\")\n        return (\n            confImg.gte(0.3)\n            .selfMask()\n            .set(\"system:time_start\", img.get(\"system:time_start\"))\n        )\n\n    fdcVisCol = fdcCol.map(fdcVis)\n    if not merge:\n        return fdcVisCol\n    else:\n        geosVisCol = goes_timeseries(start_date, end_date, data, scan, region)\n        # Join the fire collection to the CMI collection.\n        joinFilter = ee.Filter.equals(\n            **{\"leftField\": \"system:time_start\", \"rightField\": \"system:time_start\"}\n        )\n        joinedCol = ee.Join.saveFirst(\"match\").apply(geosVisCol, fdcVisCol, joinFilter)\n\n        def overlayVis(img):\n            cmi = ee.Image(img).visualize(\n                **{\n                    \"bands\": [\"CMI_C02\", \"CMI_GREEN\", \"CMI_C01\"],\n                    \"min\": 0,\n                    \"max\": 0.8,\n                    \"gamma\": 0.8,\n                }\n            )\n            fdc = ee.Image(img.get(\"match\")).visualize(\n                **{\"palette\": [\"ff5349\"], \"min\": 0, \"max\": 1, \"opacity\": 0.7}\n            )\n            return cmi.blend(fdc).set(\"system:time_start\", img.get(\"system:time_start\"))\n\n        cmiFdcVisCol = ee.ImageCollection(joinedCol.map(overlayVis))\n        return cmiFdcVisCol\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.goes_timelapse","title":"<code>goes_timelapse(roi=None, out_gif=None, start_date='2021-10-24T14:00:00', end_date='2021-10-25T01:00:00', data='GOES-17', scan='full_disk', bands=['CMI_C02', 'CMI_GREEN', 'CMI_C01'], dimensions=768, framesPerSecond=10, date_format='YYYY-MM-dd HH:mm', xy=('3%', '3%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='#ffffff', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, loop=0, crs=None, overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, mp4=False, fading=False, **kwargs)</code>","text":"<p>Create a timelapse of GOES data. The code is adapted from Justin Braaten's code: https://code.earthengine.google.com/57245f2d3d04233765c42fb5ef19c1f4. Credits to Justin Braaten. See also https://jstnbraaten.medium.com/goes-in-earth-engine-53fbc8783c16</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>ee.Geometry</code> <p>The region of interest. Defaults to None.</p> <code>None</code> <code>out_gif</code> <code>str</code> <p>The file path to save the gif.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>The start date of the time series. Defaults to \"2021-10-24T14:00:00\".</p> <code>'2021-10-24T14:00:00'</code> <code>end_date</code> <code>str</code> <p>The end date of the time series. Defaults to \"2021-10-25T01:00:00\".</p> <code>'2021-10-25T01:00:00'</code> <code>data</code> <code>str</code> <p>The GOES satellite data to use. Defaults to \"GOES-17\".</p> <code>'GOES-17'</code> <code>scan</code> <code>str</code> <p>The GOES scan to use. Defaults to \"full_disk\".</p> <code>'full_disk'</code> <code>bands</code> <code>list</code> <p>The bands to visualize. Defaults to [\"CMI_C02\", \"CMI_GREEN\", \"CMI_C01\"].</p> <code>['CMI_C02', 'CMI_GREEN', 'CMI_C01']</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> required <code>date_format</code> <code>str</code> <p>The date format to use. Defaults to \"YYYY-MM-dd HH:mm\".</p> <code>'YYYY-MM-dd HH:mm'</code> <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('3%', '3%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'#ffffff'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>5</code> <code>crs</code> <code>str</code> <p>The coordinate reference system to use, e.g., \"EPSG:3857\". Defaults to None.</p> <code>None</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Line width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>mp4</code> <code>bool</code> <p>Whether to save the animation as an mp4 file. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <p>Exceptions:</p> Type Description <code>Exception</code> <p>Raise exception.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def goes_timelapse(\n    roi=None,\n    out_gif=None,\n    start_date=\"2021-10-24T14:00:00\",\n    end_date=\"2021-10-25T01:00:00\",\n    data=\"GOES-17\",\n    scan=\"full_disk\",\n    bands=[\"CMI_C02\", \"CMI_GREEN\", \"CMI_C01\"],\n    dimensions=768,\n    framesPerSecond=10,\n    date_format=\"YYYY-MM-dd HH:mm\",\n    xy=(\"3%\", \"3%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"#ffffff\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    loop=0,\n    crs=None,\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    mp4=False,\n    fading=False,\n    **kwargs,\n):\n\"\"\"Create a timelapse of GOES data. The code is adapted from Justin Braaten's code: https://code.earthengine.google.com/57245f2d3d04233765c42fb5ef19c1f4.\n    Credits to Justin Braaten. See also https://jstnbraaten.medium.com/goes-in-earth-engine-53fbc8783c16\n\n    Args:\n        roi (ee.Geometry, optional): The region of interest. Defaults to None.\n        out_gif (str): The file path to save the gif.\n        start_date (str, optional): The start date of the time series. Defaults to \"2021-10-24T14:00:00\".\n        end_date (str, optional): The end date of the time series. Defaults to \"2021-10-25T01:00:00\".\n        data (str, optional): The GOES satellite data to use. Defaults to \"GOES-17\".\n        scan (str, optional): The GOES scan to use. Defaults to \"full_disk\".\n        bands (list, optional): The bands to visualize. Defaults to [\"CMI_C02\", \"CMI_GREEN\", \"CMI_C01\"].\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        date_format (str, optional): The date format to use. Defaults to \"YYYY-MM-dd HH:mm\".\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        crs (str, optional): The coordinate reference system to use, e.g., \"EPSG:3857\". Defaults to None.\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Line width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        mp4 (bool, optional): Whether to save the animation as an mp4 file. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n    Raises:\n        Exception: Raise exception.\n    \"\"\"\n\n    try:\n        if \"region\" in kwargs:\n            roi = kwargs[\"region\"]\n\n        if out_gif is None:\n            out_gif = os.path.abspath(f\"goes_{random_string(3)}.gif\")\n\n        visParams = {\n            \"bands\": bands,\n            \"min\": 0,\n            \"max\": 0.8,\n        }\n        col = goes_timeseries(start_date, end_date, data, scan, roi)\n        col = col.select(bands).map(\n            lambda img: img.visualize(**visParams).set(\n                {\n                    \"system:time_start\": img.get(\"system:time_start\"),\n                }\n            )\n        )\n        if overlay_data is not None:\n            col = add_overlay(\n                col, overlay_data, overlay_color, overlay_width, overlay_opacity\n            )\n\n        if roi is None:\n            roi = ee.Geometry.Polygon(\n                [\n                    [\n                        [-159.5954, 60.4088],\n                        [-159.5954, 24.5178],\n                        [-114.2438, 24.5178],\n                        [-114.2438, 60.4088],\n                    ]\n                ],\n                None,\n                False,\n            )\n\n        if crs is None:\n            crs = col.first().projection()\n\n        videoParams = {\n            \"bands\": [\"vis-red\", \"vis-green\", \"vis-blue\"],\n            \"min\": 0,\n            \"max\": 255,\n            \"dimensions\": dimensions,\n            \"framesPerSecond\": framesPerSecond,\n            \"region\": roi,\n            \"crs\": crs,\n        }\n\n        if text_sequence is None:\n            text_sequence = image_dates(col, date_format=date_format).getInfo()\n\n        download_ee_video(col, videoParams, out_gif)\n\n        if os.path.exists(out_gif):\n            add_text_to_gif(\n                out_gif,\n                out_gif,\n                xy,\n                text_sequence,\n                font_type,\n                font_size,\n                font_color,\n                add_progress_bar,\n                progress_bar_color,\n                progress_bar_height,\n                duration=1000 / framesPerSecond,\n                loop=loop,\n            )\n\n            try:\n                reduce_gif_size(out_gif)\n\n                if isinstance(fading, bool):\n                    fading = int(fading)\n                if fading &gt; 0:\n                    gif_fading(out_gif, out_gif, duration=fading, verbose=False)\n\n            except Exception as _:\n                pass\n\n            if mp4:\n                out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n                gif_to_mp4(out_gif, out_mp4)\n\n            return out_gif\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.goes_timeseries","title":"<code>goes_timeseries(start_date='2021-10-24T14:00:00', end_date='2021-10-25T01:00:00', data='GOES-17', scan='full_disk', region=None, show_night=[False, 'a_mode'])</code>","text":"<p>Create a time series of GOES data. The code is adapted from Justin Braaten's code: https://code.earthengine.google.com/57245f2d3d04233765c42fb5ef19c1f4. Credits to Justin Braaten. See also https://jstnbraaten.medium.com/goes-in-earth-engine-53fbc8783c16</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The start date of the time series. Defaults to \"2021-10-24T14:00:00\".</p> <code>'2021-10-24T14:00:00'</code> <code>end_date</code> <code>str</code> <p>The end date of the time series. Defaults to \"2021-10-25T01:00:00\".</p> <code>'2021-10-25T01:00:00'</code> <code>data</code> <code>str</code> <p>The GOES satellite data to use. Defaults to \"GOES-17\".</p> <code>'GOES-17'</code> <code>scan</code> <code>str</code> <p>The GOES scan to use. Defaults to \"full_disk\".</p> <code>'full_disk'</code> <code>region</code> <code>ee.Geometry</code> <p>The region of interest. Defaults to None.</p> <code>None</code> <code>show_night</code> <code>list</code> <p>Show the clouds at night through [True, \"a_mode\"] o [True, \"b_mode\"].  Defaults to [False, \"a_mode\"]</p> <code>[False, 'a_mode']</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The data must be either GOES-16 or GOES-17.</p> <code>ValueError</code> <p>The scan must be either full_disk, conus, or mesoscale.</p> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>GOES timeseries.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def goes_timeseries(\n    start_date=\"2021-10-24T14:00:00\",\n    end_date=\"2021-10-25T01:00:00\",\n    data=\"GOES-17\",\n    scan=\"full_disk\",\n    region=None,\n    show_night=[False, \"a_mode\"],\n):\n\"\"\"Create a time series of GOES data. The code is adapted from Justin Braaten's code: https://code.earthengine.google.com/57245f2d3d04233765c42fb5ef19c1f4.\n    Credits to Justin Braaten. See also https://jstnbraaten.medium.com/goes-in-earth-engine-53fbc8783c16\n\n    Args:\n        start_date (str, optional): The start date of the time series. Defaults to \"2021-10-24T14:00:00\".\n        end_date (str, optional): The end date of the time series. Defaults to \"2021-10-25T01:00:00\".\n        data (str, optional): The GOES satellite data to use. Defaults to \"GOES-17\".\n        scan (str, optional): The GOES scan to use. Defaults to \"full_disk\".\n        region (ee.Geometry, optional): The region of interest. Defaults to None.\n        show_night (list, optional): Show the clouds at night through [True, \"a_mode\"] o [True, \"b_mode\"].  Defaults to [False, \"a_mode\"]\n    Raises:\n        ValueError: The data must be either GOES-16 or GOES-17.\n        ValueError: The scan must be either full_disk, conus, or mesoscale.\n\n    Returns:\n        ee.ImageCollection: GOES timeseries.\n    \"\"\"\n\n    if data not in [\"GOES-16\", \"GOES-17\"]:\n        raise ValueError(\"The data must be either GOES-16 or GOES-17.\")\n\n    if scan.lower() not in [\"full_disk\", \"conus\", \"mesoscale\"]:\n        raise ValueError(\"The scan must be either full_disk, conus, or mesoscale.\")\n\n    scan_types = {\n        \"full_disk\": \"MCMIPF\",\n        \"conus\": \"MCMIPC\",\n        \"mesoscale\": \"MCMIPM\",\n    }\n\n    col = ee.ImageCollection(f\"NOAA/GOES/{data[-2:]}/{scan_types[scan.lower()]}\")\n\n    if region is None:\n        region = ee.Geometry.Polygon(\n            [\n                [\n                    [-159.5954379282731, 60.40883060191719],\n                    [-159.5954379282731, 24.517881970830725],\n                    [-114.2438754282731, 24.517881970830725],\n                    [-114.2438754282731, 60.40883060191719],\n                ]\n            ],\n            None,\n            False,\n        )\n\n    # Applies scaling factors.\n    def applyScaleAndOffset(img):\n        def getFactorImg(factorNames):\n            factorList = img.toDictionary().select(factorNames).values()\n            return ee.Image.constant(factorList)\n\n        scaleImg = getFactorImg([\"CMI_C.._scale\"])\n        offsetImg = getFactorImg([\"CMI_C.._offset\"])\n        scaled = img.select(\"CMI_C..\").multiply(scaleImg).add(offsetImg)\n        return img.addBands(**{\"srcImg\": scaled, \"overwrite\": True})\n\n    # Adds a synthetic green band.\n    def addGreenBand(img):\n        green = img.expression(\n            \"CMI_GREEN = 0.45 * red + 0.10 * nir + 0.45 * blue\",\n            {\n                \"blue\": img.select(\"CMI_C01\"),\n                \"red\": img.select(\"CMI_C02\"),\n                \"nir\": img.select(\"CMI_C03\"),\n            },\n        )\n        return img.addBands(green)\n\n    # Show at clouds at night (a-mode)\n    def showNighta(img):\n        # Make normalized infrared\n        IR_n = img.select(\"CMI_C13\").unitScale(ee.Number(90), ee.Number(313))\n        IR_n = IR_n.expression(\n            \"ir_p = (1 -IR_n)/1.4\",\n            {\n                \"IR_n\": IR_n.select(\"CMI_C13\"),\n            },\n        )\n\n        # Add infrared to rgb bands\n        R_ir = img.select(\"CMI_C02\").max(IR_n)\n        G_ir = img.select(\"CMI_GREEN\").max(IR_n)\n        B_ir = img.select(\"CMI_C01\").max(IR_n)\n\n        return img.addBands([R_ir, G_ir, B_ir], overwrite=True)\n\n    # Show at clouds at night (b-mode)\n    def showNightb(img):\n        night = img.select(\"CMI_C03\").unitScale(0, 0.016).subtract(1).multiply(-1)\n\n        cmi11 = img.select(\"CMI_C11\").unitScale(100, 310)\n        cmi13 = img.select(\"CMI_C13\").unitScale(100, 300)\n        cmi15 = img.select(\"CMI_C15\").unitScale(100, 310)\n        iNight = cmi15.addBands([cmi13, cmi11]).clamp(0, 1).subtract(1).multiply(-1)\n\n        iRGBNight = iNight.visualize(**{\"min\": 0, \"max\": 1, \"gamma\": 1.4}).updateMask(\n            night\n        )\n\n        iRGB = img.visualize(\n            **{\n                \"bands\": [\"CMI_C02\", \"CMI_C03\", \"CMI_C01\"],\n                \"min\": 0.15,\n                \"max\": 1,\n                \"gamma\": 1.4,\n            }\n        )\n        return iRGB.blend(iRGBNight).set(\n            \"system:time_start\", img.get(\"system:time_start\")\n        )\n\n    # Scales select bands for visualization.\n    def scaleForVis(img):\n        return (\n            img.select([\"CMI_C01\", \"CMI_GREEN\", \"CMI_C02\", \"CMI_C03\", \"CMI_C05\"])\n            .resample(\"bicubic\")\n            .log10()\n            .interpolate([-1.6, 0.176], [0, 1], \"clamp\")\n            .unmask(0)\n            .set(\"system:time_start\", img.get(\"system:time_start\"))\n        )\n\n    # Wraps previous functions.\n    def processForVis(img):\n        if show_night[0]:\n            if show_night[1] == \"a_mode\":\n                return scaleForVis(showNighta(addGreenBand(applyScaleAndOffset(img))))\n\n            else:\n                return showNightb(applyScaleAndOffset(img))\n\n        else:\n            return scaleForVis(addGreenBand(applyScaleAndOffset(img)))\n\n    return col.filterDate(start_date, end_date).filterBounds(region).map(processForVis)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.landsat_timelapse","title":"<code>landsat_timelapse(roi=None, out_gif=None, start_year=1984, end_year=None, start_date='06-10', end_date='09-20', bands=['NIR', 'Red', 'Green'], vis_params=None, dimensions=768, frames_per_second=5, crs='EPSG:3857', apply_fmask=True, nd_bands=None, nd_threshold=0, nd_palette=['black', 'blue'], overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, frequency='year', date_format=None, title=None, title_xy=('2%', '90%'), add_text=True, text_xy=('2%', '2%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='white', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, loop=0, mp4=False, fading=False)</code>","text":"<p>Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to None.</p> <code>None</code> <code>out_gif</code> <code>str</code> <p>File path to the output animated GIF. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 1984.</p> <code>1984</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to None, which will use the current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.</p> <code>'06-10'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.</p> <code>'09-20'</code> <code>bands</code> <code>list</code> <p>Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green'].</p> <code>['NIR', 'Red', 'Green']</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters. Defaults to None.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 5.</p> <code>5</code> <code>crs</code> <code>str</code> <p>The coordinate reference system to use. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>apply_fmask</code> <code>bool</code> <p>Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.</p> <code>True</code> <code>nd_bands</code> <code>list</code> <p>A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1).</p> <code>None</code> <code>nd_threshold</code> <code>float</code> <p>The threshold for extacting pixels from the normalized difference band.</p> <code>0</code> <code>nd_palette</code> <code>list</code> <p>The color palette to use for displaying the normalized difference band.</p> <code>['black', 'blue']</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Line width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>frequency</code> <code>str</code> <p>Frequency of the timelapse. Defaults to 'year'.</p> <code>'year'</code> <code>date_format</code> <code>str</code> <p>Date format for the timelapse. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the timelapse. Defaults to None.</p> <code>None</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>add_text</code> <code>bool</code> <p>Whether to add animated text to the timelapse. Defaults to True.</p> <code>True</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'white'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the GIF to MP4. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>File path to the output GIF image.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def landsat_timelapse(\n    roi=None,\n    out_gif=None,\n    start_year=1984,\n    end_year=None,\n    start_date=\"06-10\",\n    end_date=\"09-20\",\n    bands=[\"NIR\", \"Red\", \"Green\"],\n    vis_params=None,\n    dimensions=768,\n    frames_per_second=5,\n    crs=\"EPSG:3857\",\n    apply_fmask=True,\n    nd_bands=None,\n    nd_threshold=0,\n    nd_palette=[\"black\", \"blue\"],\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    frequency=\"year\",\n    date_format=None,\n    title=None,\n    title_xy=(\"2%\", \"90%\"),\n    add_text=True,\n    text_xy=(\"2%\", \"2%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"white\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    loop=0,\n    mp4=False,\n    fading=False,\n):\n\"\"\"Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work.\n\n    Args:\n        roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n        out_gif (str, optional): File path to the output animated GIF. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 1984.\n        end_year (int, optional): Ending year for the timelapse. Defaults to None, which will use the current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.\n        bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green'].\n        vis_params (dict, optional): Visualization parameters. Defaults to None.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 5.\n        crs (str, optional): The coordinate reference system to use. Defaults to \"EPSG:3857\".\n        apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.\n        nd_bands (list, optional): A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1).\n        nd_threshold (float, optional): The threshold for extacting pixels from the normalized difference band.\n        nd_palette (list, optional): The color palette to use for displaying the normalized difference band.\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Line width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        frequency (str, optional): Frequency of the timelapse. Defaults to 'year'.\n        date_format (str, optional): Date format for the timelapse. Defaults to None.\n        title (str, optional): The title of the timelapse. Defaults to None.\n        title_xy (tuple, optional): Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        add_text (bool, optional): Whether to add animated text to the timelapse. Defaults to True.\n        title_xy (tuple, optional): Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        loop (int, optional): Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        mp4 (bool, optional): Whether to convert the GIF to MP4. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n\n    Returns:\n        str: File path to the output GIF image.\n    \"\"\"\n\n    if roi is None:\n        roi = ee.Geometry.Polygon(\n            [\n                [\n                    [-115.471773, 35.892718],\n                    [-115.471773, 36.409454],\n                    [-114.271283, 36.409454],\n                    [-114.271283, 35.892718],\n                    [-115.471773, 35.892718],\n                ]\n            ],\n            None,\n            False,\n        )\n    elif isinstance(roi, ee.Feature) or isinstance(roi, ee.FeatureCollection):\n        roi = roi.geometry()\n    elif isinstance(roi, ee.Geometry):\n        pass\n    else:\n        raise ValueError(\"The provided roi is invalid. It must be an ee.Geometry\")\n\n    if out_gif is None:\n        out_gif = temp_file_path(\".gif\")\n    elif not out_gif.endswith(\".gif\"):\n        raise ValueError(\"The output file must end with .gif\")\n    else:\n        out_gif = os.path.abspath(out_gif)\n    out_dir = os.path.dirname(out_gif)\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if end_year is None:\n        end_year = get_current_year()\n\n    allowed_bands = [\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\", \"pixel_qa\"]\n\n    if len(bands) == 3 and all(x in allowed_bands for x in bands):\n        pass\n    else:\n        raise Exception(\n            \"You can only select 3 bands from the following: {}\".format(\n                \", \".join(allowed_bands)\n            )\n        )\n\n    if nd_bands is not None:\n        if len(nd_bands) == 2 and all(x in allowed_bands[:-1] for x in nd_bands):\n            pass\n        else:\n            raise Exception(\n                \"You can only select two bands from the following: {}\".format(\n                    \", \".join(allowed_bands[:-1])\n                )\n            )\n\n    try:\n        if vis_params is None:\n            vis_params = {}\n            vis_params[\"bands\"] = bands\n            vis_params[\"min\"] = 0\n            vis_params[\"max\"] = 0.4\n            vis_params[\"gamma\"] = [1, 1, 1]\n        raw_col = landsat_timeseries(\n            roi,\n            start_year,\n            end_year,\n            start_date,\n            end_date,\n            apply_fmask,\n            frequency,\n            date_format,\n        )\n\n        col = raw_col.select(bands).map(\n            lambda img: img.visualize(**vis_params).set(\n                {\n                    \"system:time_start\": img.get(\"system:time_start\"),\n                    \"system:date\": img.get(\"system:date\"),\n                }\n            )\n        )\n        if overlay_data is not None:\n            col = add_overlay(\n                col, overlay_data, overlay_color, overlay_width, overlay_opacity\n            )\n\n        if isinstance(dimensions, int) and dimensions &gt; 768 or isinstance(dimensions, str) and any(dim&gt;768 for dim in list(map(int,dimensions.split('x')))):\n            count = col.size().getInfo()\n            basename = os.path.basename(out_gif)[:-4]\n            names = [\n                os.path.join(\n                    out_dir, f\"{basename}_{str(i+1).zfill(int(len(str(count))))}.jpg\"\n                )\n                for i in range(count)\n            ]\n            get_image_collection_thumbnails(\n                col,\n                out_dir,\n                vis_params={\n                    \"min\": 0,\n                    \"max\": 255,\n                    \"bands\": [\"vis-red\", \"vis-green\", \"vis-blue\"],\n                },\n                dimensions=dimensions,\n                names=names,\n            )\n            make_gif(\n                names,\n                out_gif,\n                fps=frames_per_second,\n                loop=loop,\n                mp4=False,\n                clean_up=True,\n            )\n\n        else:\n            video_args = vis_params.copy()\n            video_args[\"dimensions\"] = dimensions\n            video_args[\"region\"] = roi\n            video_args[\"framesPerSecond\"] = frames_per_second\n            video_args[\"crs\"] = crs\n            video_args[\"bands\"] = [\"vis-red\", \"vis-green\", \"vis-blue\"]\n            video_args[\"min\"] = 0\n            video_args[\"max\"] = 255\n\n            download_ee_video(col, video_args, out_gif)\n\n        if os.path.exists(out_gif):\n            if title is not None and isinstance(title, str):\n                add_text_to_gif(\n                    out_gif,\n                    out_gif,\n                    xy=title_xy,\n                    text_sequence=title,\n                    font_type=font_type,\n                    font_size=font_size,\n                    font_color=font_color,\n                    add_progress_bar=add_progress_bar,\n                    progress_bar_color=progress_bar_color,\n                    progress_bar_height=progress_bar_height,\n                    duration=1000 / frames_per_second,\n                    loop=loop,\n                )\n            if add_text:\n                if text_sequence is None:\n                    text_sequence = col.aggregate_array(\"system:date\").getInfo()\n                add_text_to_gif(\n                    out_gif,\n                    out_gif,\n                    xy=text_xy,\n                    text_sequence=text_sequence,\n                    font_type=font_type,\n                    font_size=font_size,\n                    font_color=font_color,\n                    add_progress_bar=add_progress_bar,\n                    progress_bar_color=progress_bar_color,\n                    progress_bar_height=progress_bar_height,\n                    duration=1000 / frames_per_second,\n                    loop=loop,\n                )\n\n        if nd_bands is not None:\n            nd_images = landsat_ts_norm_diff(\n                raw_col, bands=nd_bands, threshold=nd_threshold\n            )\n            out_nd_gif = out_gif.replace(\".gif\", \"_nd.gif\")\n            landsat_ts_norm_diff_gif(\n                nd_images,\n                out_gif=out_nd_gif,\n                vis_params=None,\n                palette=nd_palette,\n                dimensions=dimensions,\n                frames_per_second=frames_per_second,\n            )\n\n        if os.path.exists(out_gif):\n            reduce_gif_size(out_gif)\n\n        if isinstance(fading, bool):\n            fading = int(fading)\n        if fading &gt; 0:\n            gif_fading(out_gif, out_gif, duration=fading, verbose=False)\n\n        if mp4:\n            out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n            gif_to_mp4(out_gif, out_mp4)\n\n        return out_gif\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.landsat_timelapse_legacy","title":"<code>landsat_timelapse_legacy(roi=None, out_gif=None, start_year=1984, end_year=None, start_date='06-10', end_date='09-20', bands=['NIR', 'Red', 'Green'], vis_params=None, dimensions=768, frames_per_second=5, crs='EPSG:3857', apply_fmask=True, nd_bands=None, nd_threshold=0, nd_palette=['black', 'blue'], overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, frequency='year', date_format=None, title=None, title_xy=('2%', '90%'), add_text=True, text_xy=('2%', '2%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='white', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, loop=0, mp4=False, fading=False)</code>","text":"<p>Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to None.</p> <code>None</code> <code>out_gif</code> <code>str</code> <p>File path to the output animated GIF. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 1984.</p> <code>1984</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to None, which means the current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.</p> <code>'06-10'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.</p> <code>'09-20'</code> <code>bands</code> <code>list</code> <p>Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green'].</p> <code>['NIR', 'Red', 'Green']</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters. Defaults to None.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 5.</p> <code>5</code> <code>crs</code> <code>str</code> <p>The coordinate reference system to use. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>apply_fmask</code> <code>bool</code> <p>Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.</p> <code>True</code> <code>nd_bands</code> <code>list</code> <p>A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1).</p> <code>None</code> <code>nd_threshold</code> <code>float</code> <p>The threshold for extacting pixels from the normalized difference band.</p> <code>0</code> <code>nd_palette</code> <code>list</code> <p>The color palette to use for displaying the normalized difference band.</p> <code>['black', 'blue']</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Line width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>frequency</code> <code>str</code> <p>Frequency of the timelapse. Defaults to 'year'.</p> <code>'year'</code> <code>date_format</code> <code>str</code> <p>Date format for the timelapse. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the timelapse. Defaults to None.</p> <code>None</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>add_text</code> <code>bool</code> <p>Whether to add animated text to the timelapse. Defaults to True.</p> <code>True</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'white'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the GIF to MP4. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>File path to the output GIF image.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def landsat_timelapse_legacy(\n    roi=None,\n    out_gif=None,\n    start_year=1984,\n    end_year=None,\n    start_date=\"06-10\",\n    end_date=\"09-20\",\n    bands=[\"NIR\", \"Red\", \"Green\"],\n    vis_params=None,\n    dimensions=768,\n    frames_per_second=5,\n    crs=\"EPSG:3857\",\n    apply_fmask=True,\n    nd_bands=None,\n    nd_threshold=0,\n    nd_palette=[\"black\", \"blue\"],\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    frequency=\"year\",\n    date_format=None,\n    title=None,\n    title_xy=(\"2%\", \"90%\"),\n    add_text=True,\n    text_xy=(\"2%\", \"2%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"white\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    loop=0,\n    mp4=False,\n    fading=False,\n):\n\"\"\"Generates a Landsat timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work.\n\n    Args:\n        roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n        out_gif (str, optional): File path to the output animated GIF. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 1984.\n        end_year (int, optional): Ending year for the timelapse. Defaults to None, which means the current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.\n        bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'pixel_qa']. Defaults to ['NIR', 'Red', 'Green'].\n        vis_params (dict, optional): Visualization parameters. Defaults to None.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 5.\n        crs (str, optional): The coordinate reference system to use. Defaults to \"EPSG:3857\".\n        apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.\n        nd_bands (list, optional): A list of names specifying the bands to use, e.g., ['Green', 'SWIR1']. The normalized difference is computed as (first \u2212 second) / (first + second). Note that negative input values are forced to 0 so that the result is confined to the range (-1, 1).\n        nd_threshold (float, optional): The threshold for extacting pixels from the normalized difference band.\n        nd_palette (list, optional): The color palette to use for displaying the normalized difference band.\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Line width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        frequency (str, optional): Frequency of the timelapse. Defaults to 'year'.\n        date_format (str, optional): Date format for the timelapse. Defaults to None.\n        title (str, optional): The title of the timelapse. Defaults to None.\n        title_xy (tuple, optional): Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        add_text (bool, optional): Whether to add animated text to the timelapse. Defaults to True.\n        title_xy (tuple, optional): Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        loop (int, optional): Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        mp4 (bool, optional): Whether to convert the GIF to MP4. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n\n    Returns:\n        str: File path to the output GIF image.\n    \"\"\"\n\n    if end_year is None:\n        end_year = get_current_year()\n\n    if roi is None:\n        roi = ee.Geometry.Polygon(\n            [\n                [\n                    [-115.471773, 35.892718],\n                    [-115.471773, 36.409454],\n                    [-114.271283, 36.409454],\n                    [-114.271283, 35.892718],\n                    [-115.471773, 35.892718],\n                ]\n            ],\n            None,\n            False,\n        )\n    elif isinstance(roi, ee.Feature) or isinstance(roi, ee.FeatureCollection):\n        roi = roi.geometry()\n    elif isinstance(roi, ee.Geometry):\n        pass\n    else:\n        raise ValueError(\"The provided roi is invalid. It must be an ee.Geometry\")\n\n    if out_gif is None:\n        out_gif = temp_file_path(\".gif\")\n    elif not out_gif.endswith(\".gif\"):\n        raise ValueError(\"The output file must end with .gif\")\n    else:\n        out_gif = os.path.abspath(out_gif)\n    out_dir = os.path.dirname(out_gif)\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    allowed_bands = [\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\", \"pixel_qa\"]\n\n    if len(bands) == 3 and all(x in allowed_bands for x in bands):\n        pass\n    else:\n        raise Exception(\n            \"You can only select 3 bands from the following: {}\".format(\n                \", \".join(allowed_bands)\n            )\n        )\n\n    if nd_bands is not None:\n        if len(nd_bands) == 2 and all(x in allowed_bands[:-1] for x in nd_bands):\n            pass\n        else:\n            raise Exception(\n                \"You can only select two bands from the following: {}\".format(\n                    \", \".join(allowed_bands[:-1])\n                )\n            )\n\n    try:\n        if vis_params is None:\n            vis_params = {}\n            vis_params[\"bands\"] = bands\n            vis_params[\"min\"] = 0\n            vis_params[\"max\"] = 4000\n            vis_params[\"gamma\"] = [1, 1, 1]\n        raw_col = landsat_timeseries(\n            roi,\n            start_year,\n            end_year,\n            start_date,\n            end_date,\n            apply_fmask,\n            frequency,\n            date_format,\n        )\n\n        col = raw_col.select(bands).map(\n            lambda img: img.visualize(**vis_params).set(\n                {\n                    \"system:time_start\": img.get(\"system:time_start\"),\n                    \"system:date\": img.get(\"system:date\"),\n                }\n            )\n        )\n        if overlay_data is not None:\n            col = add_overlay(\n                col, overlay_data, overlay_color, overlay_width, overlay_opacity\n            )\n\n        if isinstance(dimensions, int) and dimensions &gt; 768 or isinstance(dimensions, str) and any(dim&gt;768 for dim in list(map(int,dimensions.split('x')))):\n            count = col.size().getInfo()\n            basename = os.path.basename(out_gif)[:-4]\n            names = [\n                os.path.join(\n                    out_dir, f\"{basename}_{str(i+1).zfill(int(len(str(count))))}.jpg\"\n                )\n                for i in range(count)\n            ]\n            get_image_collection_thumbnails(\n                col,\n                out_dir,\n                vis_params={\n                    \"min\": 0,\n                    \"max\": 255,\n                    \"bands\": [\"vis-red\", \"vis-green\", \"vis-blue\"],\n                },\n                dimensions=dimensions,\n                names=names,\n            )\n            make_gif(\n                names,\n                out_gif,\n                fps=frames_per_second,\n                loop=loop,\n                mp4=False,\n                clean_up=True,\n            )\n\n        else:\n            video_args = vis_params.copy()\n            video_args[\"dimensions\"] = dimensions\n            video_args[\"region\"] = roi\n            video_args[\"framesPerSecond\"] = frames_per_second\n            video_args[\"crs\"] = crs\n            video_args[\"bands\"] = [\"vis-red\", \"vis-green\", \"vis-blue\"]\n            video_args[\"min\"] = 0\n            video_args[\"max\"] = 255\n\n            download_ee_video(col, video_args, out_gif)\n\n        if os.path.exists(out_gif):\n            if title is not None and isinstance(title, str):\n                add_text_to_gif(\n                    out_gif,\n                    out_gif,\n                    xy=title_xy,\n                    text_sequence=title,\n                    font_type=font_type,\n                    font_size=font_size,\n                    font_color=font_color,\n                    add_progress_bar=add_progress_bar,\n                    progress_bar_color=progress_bar_color,\n                    progress_bar_height=progress_bar_height,\n                    duration=1000 / frames_per_second,\n                    loop=loop,\n                )\n            if add_text:\n                if text_sequence is None:\n                    text_sequence = col.aggregate_array(\"system:date\").getInfo()\n                add_text_to_gif(\n                    out_gif,\n                    out_gif,\n                    xy=text_xy,\n                    text_sequence=text_sequence,\n                    font_type=font_type,\n                    font_size=font_size,\n                    font_color=font_color,\n                    add_progress_bar=add_progress_bar,\n                    progress_bar_color=progress_bar_color,\n                    progress_bar_height=progress_bar_height,\n                    duration=1000 / frames_per_second,\n                    loop=loop,\n                )\n\n        if nd_bands is not None:\n            nd_images = landsat_ts_norm_diff(\n                raw_col, bands=nd_bands, threshold=nd_threshold\n            )\n            out_nd_gif = out_gif.replace(\".gif\", \"_nd.gif\")\n            landsat_ts_norm_diff_gif(\n                nd_images,\n                out_gif=out_nd_gif,\n                vis_params=None,\n                palette=nd_palette,\n                dimensions=dimensions,\n                frames_per_second=frames_per_second,\n            )\n\n        if os.path.exists(out_gif):\n            reduce_gif_size(out_gif)\n\n        if isinstance(fading, bool):\n            fading = int(fading)\n        if fading &gt; 0:\n            gif_fading(out_gif, out_gif, duration=fading, verbose=False)\n\n        if mp4:\n            out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n            gif_to_mp4(out_gif, out_mp4)\n\n        return out_gif\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.landsat_timeseries","title":"<code>landsat_timeseries(roi=None, start_year=1984, end_year=None, start_date='06-10', end_date='09-20', apply_fmask=True, frequency='year', date_format=None)</code>","text":"<p>Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 1984.</p> <code>1984</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to None, which means the current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.</p> <code>'06-10'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.</p> <code>'09-20'</code> <code>apply_fmask</code> <code>bool</code> <p>Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.</p> <code>True</code> <code>frequency</code> <code>str</code> <p>Frequency of the timelapse. Defaults to 'year'.</p> <code>'year'</code> <code>date_format</code> <code>str</code> <p>Format of the date. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns an ImageCollection containing annual Landsat images.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def landsat_timeseries(\n    roi=None,\n    start_year=1984,\n    end_year=None,\n    start_date=\"06-10\",\n    end_date=\"09-20\",\n    apply_fmask=True,\n    frequency=\"year\",\n    date_format=None,\n):\n\"\"\"Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work.\n\n    Args:\n        roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 1984.\n        end_year (int, optional): Ending year for the timelapse. Defaults to None, which means the current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.\n        apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.\n        frequency (str, optional): Frequency of the timelapse. Defaults to 'year'.\n        date_format (str, optional): Format of the date. Defaults to None.\n    Returns:\n        object: Returns an ImageCollection containing annual Landsat images.\n    \"\"\"\n\n    # Input and output parameters.\n    import re\n\n    if roi is None:\n        roi = ee.Geometry.Polygon(\n            [\n                [\n                    [-115.471773, 35.892718],\n                    [-115.471773, 36.409454],\n                    [-114.271283, 36.409454],\n                    [-114.271283, 35.892718],\n                    [-115.471773, 35.892718],\n                ]\n            ],\n            None,\n            False,\n        )\n\n    if end_year is None:\n        end_year = get_current_year()\n\n    if not isinstance(roi, ee.Geometry):\n        try:\n            roi = roi.geometry()\n        except Exception as e:\n            print(\"Could not convert the provided roi to ee.Geometry\")\n            print(e)\n            return\n\n    feq_dict = {\n        \"year\": \"YYYY\",\n        \"month\": \"YYYY-MM\",\n        \"quarter\": \"YYYY-MM\",\n    }\n\n    if date_format is None:\n        date_format = feq_dict[frequency]\n\n    if frequency not in feq_dict:\n        raise ValueError(\"frequency must be year, quarter, or month.\")\n\n    # Setup vars to get dates.\n    if (\n        isinstance(start_year, int)\n        and (start_year &gt;= 1984)\n        and (start_year &lt; get_current_year())\n    ):\n        pass\n    else:\n        print(\"The start year must be an integer &gt;= 1984.\")\n        return\n\n    if (\n        isinstance(end_year, int)\n        and (end_year &gt; 1984)\n        and (end_year &lt;= get_current_year())\n    ):\n        pass\n    else:\n        print(f\"The end year must be an integer &lt;= {get_current_year()}.\")\n        return\n\n    if re.match(\"[0-9]{2}\\-[0-9]{2}\", start_date) and re.match(\n        \"[0-9]{2}\\-[0-9]{2}\", end_date\n    ):\n        pass\n    else:\n        print(\"The start date and end date must be month-day, such as 06-10, 09-20\")\n        return\n\n    try:\n        datetime.datetime(int(start_year), int(start_date[:2]), int(start_date[3:5]))\n        datetime.datetime(int(end_year), int(end_date[:2]), int(end_date[3:5]))\n    except Exception as e:\n        print(\"The input dates are invalid.\")\n        raise Exception(e)\n\n    def days_between(d1, d2):\n        d1 = datetime.datetime.strptime(d1, \"%Y-%m-%d\")\n        d2 = datetime.datetime.strptime(d2, \"%Y-%m-%d\")\n        return abs((d2 - d1).days)\n\n    n_days = days_between(\n        str(start_year) + \"-\" + start_date, str(start_year) + \"-\" + end_date\n    )\n    start_month = int(start_date[:2])\n    start_day = int(start_date[3:5])\n\n    # Landsat collection preprocessingEnabled\n    # Get Landsat surface reflectance collections for OLI, ETM+ and TM sensors.\n    LC09col = ee.ImageCollection(\"LANDSAT/LC09/C02/T1_L2\")\n    LC08col = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")\n    LE07col = ee.ImageCollection(\"LANDSAT/LE07/C02/T1_L2\")\n    LT05col = ee.ImageCollection(\"LANDSAT/LT05/C02/T1_L2\")\n    LT04col = ee.ImageCollection(\"LANDSAT/LT04/C02/T1_L2\")\n\n    # Define a collection filter by date, bounds, and quality.\n    def colFilter(col, roi, start_date, end_date):\n        return col.filterBounds(roi).filterDate(start_date, end_date)\n\n    # Function to get and rename bands of interest from OLI.\n    def renameOli(img):\n        return img.select(\n            [\"SR_B2\", \"SR_B3\", \"SR_B4\", \"SR_B5\", \"SR_B6\", \"SR_B7\"],\n            [\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\"],\n        )\n\n    # Function to get and rename bands of interest from ETM+.\n    def renameEtm(img):\n        return img.select(\n            [\"SR_B1\", \"SR_B2\", \"SR_B3\", \"SR_B4\", \"SR_B5\", \"SR_B7\"],\n            [\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\"],\n        )\n\n    def fmask(image):\n        # see https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T1_L2\n        # Bit 0 - Fill\n        # Bit 1 - Dilated Cloud\n        # Bit 2 - Cirrus\n        # Bit 3 - Cloud\n        # Bit 4 - Cloud Shadow\n        qaMask = image.select(\"QA_PIXEL\").bitwiseAnd(int(\"11111\", 2)).eq(0)\n\n        # Apply the scaling factors to the appropriate bands.\n        opticalBands = image.select(\"SR_B.\").multiply(0.0000275).add(-0.2)\n\n        # Replace the original bands with the scaled ones and apply the masks.\n        return image.addBands(opticalBands, None, True).updateMask(qaMask)\n\n    # Define function to prepare OLI images.\n    def prepOli(img):\n        orig = img\n        if apply_fmask:\n            img = fmask(img)\n        else:\n            img = img.select(\"SR_B.\").multiply(0.0000275).add(-0.2)\n        img = renameOli(img)\n        return ee.Image(img.copyProperties(orig, orig.propertyNames())).resample(\n            \"bicubic\"\n        )\n\n    # Define function to prepare ETM+ images.\n    def prepEtm(img):\n        orig = img\n        if apply_fmask:\n            img = fmask(img)\n        else:\n            img = img.select(\"SR_B.\").multiply(0.0000275).add(-0.2)\n        img = renameEtm(img)\n        return ee.Image(img.copyProperties(orig, orig.propertyNames())).resample(\n            \"bicubic\"\n        )\n\n    # Get annual median collection.\n    def getAnnualComp(y):\n        startDate = ee.Date.fromYMD(\n            ee.Number(y), ee.Number(start_month), ee.Number(start_day)\n        )\n        endDate = startDate.advance(ee.Number(n_days), \"day\")\n\n        # Filter collections and prepare them for merging.\n        LC09coly = colFilter(LC09col, roi, startDate, endDate).map(prepOli)\n        LC08coly = colFilter(LC08col, roi, startDate, endDate).map(prepOli)\n        LE07coly = colFilter(LE07col, roi, startDate, endDate).map(prepEtm)\n        LT05coly = colFilter(LT05col, roi, startDate, endDate).map(prepEtm)\n        LT04coly = colFilter(LT04col, roi, startDate, endDate).map(prepEtm)\n\n        # Merge the collections.\n        col = LC09coly.merge(LC08coly).merge(LE07coly).merge(LT05coly).merge(LT04coly)\n\n        yearImg = col.median()\n        nBands = yearImg.bandNames().size()\n        yearImg = ee.Image(ee.Algorithms.If(nBands, yearImg, dummyImg))\n        return yearImg.set(\n            {\n                \"year\": y,\n                \"system:time_start\": startDate.millis(),\n                \"nBands\": nBands,\n                \"system:date\": ee.Date(startDate).format(date_format),\n            }\n        )\n\n    # Get monthly median collection.\n    def getMonthlyComp(startDate):\n        startDate = ee.Date(startDate)\n        endDate = startDate.advance(1, \"month\")\n\n        # Filter collections and prepare them for merging.\n        LC09coly = colFilter(LC09col, roi, startDate, endDate).map(prepOli)\n        LC08coly = colFilter(LC08col, roi, startDate, endDate).map(prepOli)\n        LE07coly = colFilter(LE07col, roi, startDate, endDate).map(prepEtm)\n        LT05coly = colFilter(LT05col, roi, startDate, endDate).map(prepEtm)\n        LT04coly = colFilter(LT04col, roi, startDate, endDate).map(prepEtm)\n\n        # Merge the collections.\n        col = LC09coly.merge(LC08coly).merge(LE07coly).merge(LT05coly).merge(LT04coly)\n\n        monthImg = col.median()\n        nBands = monthImg.bandNames().size()\n        monthImg = ee.Image(ee.Algorithms.If(nBands, monthImg, dummyImg))\n        return monthImg.set(\n            {\n                \"system:time_start\": startDate.millis(),\n                \"nBands\": nBands,\n                \"system:date\": ee.Date(startDate).format(date_format),\n            }\n        )\n\n    # Get quarterly median collection.\n    def getQuarterlyComp(startDate):\n        startDate = ee.Date(startDate)\n\n        endDate = startDate.advance(3, \"month\")\n\n        # Filter collections and prepare them for merging.\n        LC09coly = colFilter(LC09col, roi, startDate, endDate).map(prepOli)\n        LC08coly = colFilter(LC08col, roi, startDate, endDate).map(prepOli)\n        LE07coly = colFilter(LE07col, roi, startDate, endDate).map(prepEtm)\n        LT05coly = colFilter(LT05col, roi, startDate, endDate).map(prepEtm)\n        LT04coly = colFilter(LT04col, roi, startDate, endDate).map(prepEtm)\n\n        # Merge the collections.\n        col = LC09coly.merge(LC08coly).merge(LE07coly).merge(LT05coly).merge(LT04coly)\n\n        quarter = col.median()\n        nBands = quarter.bandNames().size()\n        quarter = ee.Image(ee.Algorithms.If(nBands, quarter, dummyImg))\n        return quarter.set(\n            {\n                \"system:time_start\": startDate.millis(),\n                \"nBands\": nBands,\n                \"system:date\": ee.Date(startDate).format(date_format),\n            }\n        )\n\n    # Make a dummy image for missing years.\n    bandNames = ee.List([\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\", \"pixel_qa\"])\n    fillerValues = ee.List.repeat(0, bandNames.size())\n    dummyImg = ee.Image.constant(fillerValues).rename(bandNames).selfMask().int16()\n\n    # Make list of /quarterly/monthly image composites.\n\n    if frequency == \"year\":\n        years = ee.List.sequence(start_year, end_year)\n        imgList = years.map(getAnnualComp)\n    elif frequency == \"quarter\":\n        quarters = date_sequence(\n            str(start_year) + \"-01-01\", str(end_year) + \"-12-31\", \"quarter\", date_format\n        )\n        imgList = quarters.map(getQuarterlyComp)\n    elif frequency == \"month\":\n        months = date_sequence(\n            str(start_year) + \"-01-01\", str(end_year) + \"-12-31\", \"month\", date_format\n        )\n        imgList = months.map(getMonthlyComp)\n\n    # Convert image composite list to collection\n    imgCol = ee.ImageCollection.fromImages(imgList)\n\n    imgCol = imgCol.map(\n        lambda img: img.clip(roi).set({\"coordinates\": roi.coordinates()})\n    )\n\n    return imgCol\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.landsat_timeseries_legacy","title":"<code>landsat_timeseries_legacy(roi=None, start_year=1984, end_year=2021, start_date='06-10', end_date='09-20', apply_fmask=True, frequency='year', date_format=None)</code>","text":"<p>Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 1984.</p> <code>1984</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to 2021.</p> <code>2021</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.</p> <code>'06-10'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.</p> <code>'09-20'</code> <code>apply_fmask</code> <code>bool</code> <p>Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.</p> <code>True</code> <code>frequency</code> <code>str</code> <p>Frequency of the timelapse. Defaults to 'year'.</p> <code>'year'</code> <code>date_format</code> <code>str</code> <p>Format of the date. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns an ImageCollection containing annual Landsat images.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def landsat_timeseries_legacy(\n    roi=None,\n    start_year=1984,\n    end_year=2021,\n    start_date=\"06-10\",\n    end_date=\"09-20\",\n    apply_fmask=True,\n    frequency=\"year\",\n    date_format=None,\n):\n\"\"\"Generates an annual Landsat ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work.\n    Args:\n        roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 1984.\n        end_year (int, optional): Ending year for the timelapse. Defaults to 2021.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.\n        apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.\n        frequency (str, optional): Frequency of the timelapse. Defaults to 'year'.\n        date_format (str, optional): Format of the date. Defaults to None.\n    Returns:\n        object: Returns an ImageCollection containing annual Landsat images.\n    \"\"\"\n\n    ################################################################################\n    # Input and output parameters.\n    import re\n\n    # import datetime\n\n    if roi is None:\n        roi = ee.Geometry.Polygon(\n            [\n                [\n                    [-115.471773, 35.892718],\n                    [-115.471773, 36.409454],\n                    [-114.271283, 36.409454],\n                    [-114.271283, 35.892718],\n                    [-115.471773, 35.892718],\n                ]\n            ],\n            None,\n            False,\n        )\n\n    if not isinstance(roi, ee.Geometry):\n        try:\n            roi = roi.geometry()\n        except Exception as e:\n            print(\"Could not convert the provided roi to ee.Geometry\")\n            print(e)\n            return\n\n    feq_dict = {\n        \"year\": \"YYYY\",\n        \"month\": \"YYYY-MM\",\n        \"quarter\": \"YYYY-MM\",\n    }\n\n    if date_format is None:\n        date_format = feq_dict[frequency]\n\n    if frequency not in feq_dict:\n        raise ValueError(\"frequency must be year, quarter, or month.\")\n\n    ################################################################################\n\n    # Setup vars to get dates.\n    if isinstance(start_year, int) and (start_year &gt;= 1984) and (start_year &lt; 2021):\n        pass\n    else:\n        print(\"The start year must be an integer &gt;= 1984.\")\n        return\n\n    if isinstance(end_year, int) and (end_year &gt; 1984) and (end_year &lt;= 2021):\n        pass\n    else:\n        print(\"The end year must be an integer &lt;= 2021.\")\n        return\n\n    if re.match(\"[0-9]{2}\\-[0-9]{2}\", start_date) and re.match(\n        \"[0-9]{2}\\-[0-9]{2}\", end_date\n    ):\n        pass\n    else:\n        print(\"The start date and end date must be month-day, such as 06-10, 09-20\")\n        return\n\n    try:\n        datetime.datetime(int(start_year), int(start_date[:2]), int(start_date[3:5]))\n        datetime.datetime(int(end_year), int(end_date[:2]), int(end_date[3:5]))\n    except Exception as e:\n        print(\"The input dates are invalid.\")\n        raise Exception(e)\n\n    def days_between(d1, d2):\n        d1 = datetime.datetime.strptime(d1, \"%Y-%m-%d\")\n        d2 = datetime.datetime.strptime(d2, \"%Y-%m-%d\")\n        return abs((d2 - d1).days)\n\n    n_days = days_between(\n        str(start_year) + \"-\" + start_date, str(start_year) + \"-\" + end_date\n    )\n    start_month = int(start_date[:2])\n    start_day = int(start_date[3:5])\n    # start_date = str(start_year) + \"-\" + start_date\n    # end_date = str(end_year) + \"-\" + end_date\n\n    # # Define a collection filter by date, bounds, and quality.\n    # def colFilter(col, aoi):  # , startDate, endDate):\n    #     return(col.filterBounds(aoi))\n\n    # Landsat collection preprocessingEnabled\n    # Get Landsat surface reflectance collections for OLI, ETM+ and TM sensors.\n    LC08col = ee.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\")\n    LE07col = ee.ImageCollection(\"LANDSAT/LE07/C01/T1_SR\")\n    LT05col = ee.ImageCollection(\"LANDSAT/LT05/C01/T1_SR\")\n    LT04col = ee.ImageCollection(\"LANDSAT/LT04/C01/T1_SR\")\n\n    # Define a collection filter by date, bounds, and quality.\n    def colFilter(col, roi, start_date, end_date):\n        return col.filterBounds(roi).filterDate(start_date, end_date)\n        # .filter('CLOUD_COVER &lt; 5')\n        # .filter('GEOMETRIC_RMSE_MODEL &lt; 15')\n        # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9'))\n\n    # Function to get and rename bands of interest from OLI.\n    def renameOli(img):\n        return img.select(\n            [\"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"pixel_qa\"],\n            [\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\", \"pixel_qa\"],\n        )\n\n    # Function to get and rename bands of interest from ETM+.\n    def renameEtm(img):\n        return img.select(\n            [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\", \"pixel_qa\"],\n            [\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\", \"pixel_qa\"],\n        )\n\n    # Add NBR for LandTrendr segmentation.\n    def calcNbr(img):\n        return img.addBands(\n            img.normalizedDifference([\"NIR\", \"SWIR2\"]).multiply(-10000).rename(\"NBR\")\n        ).int16()\n\n    # Define function to mask out clouds and cloud shadows in images.\n    # Use CFmask band included in USGS Landsat SR image product.\n    def fmask(img):\n        cloudShadowBitMask = 1 &lt;&lt; 3\n        cloudsBitMask = 1 &lt;&lt; 5\n        qa = img.select(\"pixel_qa\")\n        mask = (\n            qa.bitwiseAnd(cloudShadowBitMask)\n            .eq(0)\n            .And(qa.bitwiseAnd(cloudsBitMask).eq(0))\n        )\n        return img.updateMask(mask)\n\n    # Define function to prepare OLI images.\n    def prepOli(img):\n        orig = img\n        img = renameOli(img)\n        if apply_fmask:\n            img = fmask(img)\n        return ee.Image(img.copyProperties(orig, orig.propertyNames())).resample(\n            \"bicubic\"\n        )\n\n    # Define function to prepare ETM+ images.\n    def prepEtm(img):\n        orig = img\n        img = renameEtm(img)\n        if apply_fmask:\n            img = fmask(img)\n        return ee.Image(img.copyProperties(orig, orig.propertyNames())).resample(\n            \"bicubic\"\n        )\n\n    # Get annual median collection.\n    def getAnnualComp(y):\n        startDate = ee.Date.fromYMD(\n            ee.Number(y), ee.Number(start_month), ee.Number(start_day)\n        )\n        endDate = startDate.advance(ee.Number(n_days), \"day\")\n\n        # Filter collections and prepare them for merging.\n        LC08coly = colFilter(LC08col, roi, startDate, endDate).map(prepOli)\n        LE07coly = colFilter(LE07col, roi, startDate, endDate).map(prepEtm)\n        LT05coly = colFilter(LT05col, roi, startDate, endDate).map(prepEtm)\n        LT04coly = colFilter(LT04col, roi, startDate, endDate).map(prepEtm)\n\n        # Merge the collections.\n        col = LC08coly.merge(LE07coly).merge(LT05coly).merge(LT04coly)\n\n        yearImg = col.median()\n        nBands = yearImg.bandNames().size()\n        yearImg = ee.Image(ee.Algorithms.If(nBands, yearImg, dummyImg))\n        return calcNbr(yearImg).set(\n            {\n                \"year\": y,\n                \"system:time_start\": startDate.millis(),\n                \"nBands\": nBands,\n                \"system:date\": ee.Date(startDate).format(date_format),\n            }\n        )\n\n    # Get monthly median collection.\n    def getMonthlyComp(startDate):\n        startDate = ee.Date(startDate)\n        endDate = startDate.advance(1, \"month\")\n\n        # Filter collections and prepare them for merging.\n        LC08coly = colFilter(LC08col, roi, startDate, endDate).map(prepOli)\n        LE07coly = colFilter(LE07col, roi, startDate, endDate).map(prepEtm)\n        LT05coly = colFilter(LT05col, roi, startDate, endDate).map(prepEtm)\n        LT04coly = colFilter(LT04col, roi, startDate, endDate).map(prepEtm)\n\n        # Merge the collections.\n        col = LC08coly.merge(LE07coly).merge(LT05coly).merge(LT04coly)\n\n        monthImg = col.median()\n        nBands = monthImg.bandNames().size()\n        monthImg = ee.Image(ee.Algorithms.If(nBands, monthImg, dummyImg))\n        return calcNbr(monthImg).set(\n            {\n                \"system:time_start\": startDate.millis(),\n                \"nBands\": nBands,\n                \"system:date\": ee.Date(startDate).format(date_format),\n            }\n        )\n\n    # Get quarterly median collection.\n    def getQuarterlyComp(startDate):\n        startDate = ee.Date(startDate)\n\n        endDate = startDate.advance(3, \"month\")\n\n        # Filter collections and prepare them for merging.\n        LC08coly = colFilter(LC08col, roi, startDate, endDate).map(prepOli)\n        LE07coly = colFilter(LE07col, roi, startDate, endDate).map(prepEtm)\n        LT05coly = colFilter(LT05col, roi, startDate, endDate).map(prepEtm)\n        LT04coly = colFilter(LT04col, roi, startDate, endDate).map(prepEtm)\n\n        # Merge the collections.\n        col = LC08coly.merge(LE07coly).merge(LT05coly).merge(LT04coly)\n\n        quarter = col.median()\n        nBands = quarter.bandNames().size()\n        quarter = ee.Image(ee.Algorithms.If(nBands, quarter, dummyImg))\n        return calcNbr(quarter).set(\n            {\n                \"system:time_start\": startDate.millis(),\n                \"nBands\": nBands,\n                \"system:date\": ee.Date(startDate).format(date_format),\n            }\n        )\n\n    ################################################################################\n\n    # Make a dummy image for missing years.\n    bandNames = ee.List([\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\", \"pixel_qa\"])\n    fillerValues = ee.List.repeat(0, bandNames.size())\n    dummyImg = ee.Image.constant(fillerValues).rename(bandNames).selfMask().int16()\n\n    # ################################################################################\n    # # Get a list of years\n    # years = ee.List.sequence(start_year, end_year)\n\n    # ################################################################################\n    # # Make list of annual image composites.\n    # imgList = years.map(getAnnualComp)\n\n    if frequency == \"year\":\n        years = ee.List.sequence(start_year, end_year)\n        imgList = years.map(getAnnualComp)\n    elif frequency == \"quarter\":\n        quarters = date_sequence(\n            str(start_year) + \"-01-01\", str(end_year) + \"-12-31\", \"quarter\", date_format\n        )\n        imgList = quarters.map(getQuarterlyComp)\n    elif frequency == \"month\":\n        months = date_sequence(\n            str(start_year) + \"-01-01\", str(end_year) + \"-12-31\", \"month\", date_format\n        )\n        imgList = months.map(getMonthlyComp)\n\n    # Convert image composite list to collection\n    imgCol = ee.ImageCollection.fromImages(imgList)\n\n    imgCol = imgCol.map(\n        lambda img: img.clip(roi).set({\"coordinates\": roi.coordinates()})\n    )\n\n    return imgCol\n\n    # ################################################################################\n    # # Run LandTrendr.\n    # lt = ee.Algorithms.TemporalSegmentation.LandTrendr(\n    #     timeSeries=imgCol.select(['NBR', 'SWIR1', 'NIR', 'Green']),\n    #     maxSegments=10,\n    #     spikeThreshold=0.7,\n    #     vertexCountOvershoot=3,\n    #     preventOneYearRecovery=True,\n    #     recoveryThreshold=0.5,\n    #     pvalThreshold=0.05,\n    #     bestModelProportion=0.75,\n    #     minObservationsNeeded=6)\n\n    # ################################################################################\n    # # Get fitted imagery. This starts export tasks.\n    # def getYearStr(year):\n    #     return(ee.String('yr_').cat(ee.Algorithms.String(year).slice(0,4)))\n\n    # yearsStr = years.map(getYearStr)\n\n    # r = lt.select(['SWIR1_fit']).arrayFlatten([yearsStr]).toShort()\n    # g = lt.select(['NIR_fit']).arrayFlatten([yearsStr]).toShort()\n    # b = lt.select(['Green_fit']).arrayFlatten([yearsStr]).toShort()\n\n    # for i, c in zip([r, g, b], ['r', 'g', 'b']):\n    #     descr = 'mamore-river-'+c\n    #     name = 'users/user/'+descr\n    #     print(name)\n    #     task = ee.batch.Export.image.toAsset(\n    #     image=i,\n    #     region=roi.getInfo()['coordinates'],\n    #     assetId=name,\n    #     description=descr,\n    #     scale=30,\n    #     crs='EPSG:3857',\n    #     maxPixels=1e13)\n    #     task.start()\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.landsat_ts_norm_diff","title":"<code>landsat_ts_norm_diff(collection, bands=['Green', 'SWIR1'], threshold=0)</code>","text":"<p>Computes a normalized difference index based on a Landsat timeseries.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>ee.ImageCollection</code> <p>A Landsat timeseries.</p> required <code>bands</code> <code>list</code> <p>The bands to use for computing normalized difference. Defaults to ['Green', 'SWIR1'].</p> <code>['Green', 'SWIR1']</code> <code>threshold</code> <code>float</code> <p>The threshold to extract features. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>An ImageCollection containing images with values greater than the specified threshold.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def landsat_ts_norm_diff(collection, bands=[\"Green\", \"SWIR1\"], threshold=0):\n\"\"\"Computes a normalized difference index based on a Landsat timeseries.\n\n    Args:\n        collection (ee.ImageCollection): A Landsat timeseries.\n        bands (list, optional): The bands to use for computing normalized difference. Defaults to ['Green', 'SWIR1'].\n        threshold (float, optional): The threshold to extract features. Defaults to 0.\n\n    Returns:\n        ee.ImageCollection: An ImageCollection containing images with values greater than the specified threshold.\n    \"\"\"\n    nd_images = collection.map(\n        lambda img: img.normalizedDifference(bands)\n        .gt(threshold)\n        .copyProperties(img, img.propertyNames())\n    )\n    return nd_images\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.landsat_ts_norm_diff_gif","title":"<code>landsat_ts_norm_diff_gif(collection, out_gif=None, vis_params=None, palette=['black', 'blue'], dimensions=768, frames_per_second=10, mp4=False)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>ee.ImageCollection</code> <p>The normalized difference Landsat timeseires.</p> required <code>out_gif</code> <code>str</code> <p>File path to the output animated GIF. Defaults to None.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters. Defaults to None.</p> <code>None</code> <code>palette</code> <code>list</code> <p>The palette to use for visualizing the timelapse. Defaults to ['black', 'blue']. The first color in the list is the background color.</p> <code>['black', 'blue']</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> <code>10</code> <code>mp4</code> <code>bool</code> <p>If True, the output gif will be converted to mp4. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>File path to the output animated GIF.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def landsat_ts_norm_diff_gif(\n    collection,\n    out_gif=None,\n    vis_params=None,\n    palette=[\"black\", \"blue\"],\n    dimensions=768,\n    frames_per_second=10,\n    mp4=False,\n):\n\"\"\"[summary]\n\n    Args:\n        collection (ee.ImageCollection): The normalized difference Landsat timeseires.\n        out_gif (str, optional): File path to the output animated GIF. Defaults to None.\n        vis_params (dict, optional): Visualization parameters. Defaults to None.\n        palette (list, optional): The palette to use for visualizing the timelapse. Defaults to ['black', 'blue']. The first color in the list is the background color.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        mp4 (bool, optional): If True, the output gif will be converted to mp4. Defaults to False.\n\n    Returns:\n        str: File path to the output animated GIF.\n    \"\"\"\n    coordinates = ee.Image(collection.first()).get(\"coordinates\")\n    roi = ee.Geometry.Polygon(coordinates, None, False)\n\n    if out_gif is None:\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        filename = \"landsat_ts_nd_\" + random_string() + \".gif\"\n        out_gif = os.path.join(out_dir, filename)\n    elif not out_gif.endswith(\".gif\"):\n        raise Exception(\"The output file must end with .gif\")\n\n    bands = [\"nd\"]\n    if vis_params is None:\n        vis_params = {}\n        vis_params[\"bands\"] = bands\n        vis_params[\"palette\"] = palette\n\n    video_args = vis_params.copy()\n    video_args[\"dimensions\"] = dimensions\n    video_args[\"region\"] = roi\n    video_args[\"framesPerSecond\"] = frames_per_second\n    video_args[\"crs\"] = \"EPSG:3857\"\n\n    if \"bands\" not in video_args.keys():\n        video_args[\"bands\"] = bands\n\n    download_ee_video(collection, video_args, out_gif)\n\n    if os.path.exists(out_gif):\n        reduce_gif_size(out_gif)\n\n    if mp4:\n        out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n        gif_to_mp4(out_gif, out_mp4)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.make_gif","title":"<code>make_gif(images, out_gif, ext='jpg', fps=10, loop=0, mp4=False, clean_up=False)</code>","text":"<p>Creates a gif from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list | str</code> <p>The list of images or input directory to create the gif from.</p> required <code>out_gif</code> <code>str</code> <p>File path to the output gif.</p> required <code>ext</code> <code>str</code> <p>The extension of the images. Defaults to 'jpg'.</p> <code>'jpg'</code> <code>fps</code> <code>int</code> <p>The frames per second of the gif. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>int</code> <p>The number of times to loop the gif. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> Source code in <code>geemap/timelapse.py</code> <pre><code>def make_gif(images, out_gif, ext=\"jpg\", fps=10, loop=0, mp4=False, clean_up=False):\n\"\"\"Creates a gif from a list of images.\n\n    Args:\n        images (list | str): The list of images or input directory to create the gif from.\n        out_gif (str): File path to the output gif.\n        ext (str, optional): The extension of the images. Defaults to 'jpg'.\n        fps (int, optional): The frames per second of the gif. Defaults to 10.\n        loop (int, optional): The number of times to loop the gif. Defaults to 0.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n\n    \"\"\"\n    import glob\n    from PIL import Image\n\n    if isinstance(images, str) and os.path.isdir(images):\n        images = list(glob.glob(os.path.join(images, f\"*.{ext}\")))\n        if len(images) == 0:\n            raise ValueError(\"No images found in the input directory.\")\n    elif not isinstance(images, list):\n        raise ValueError(\"images must be a list or a path to the image directory.\")\n\n    images.sort()\n\n    frames = [Image.open(image) for image in images]\n    frame_one = frames[0]\n    frame_one.save(\n        out_gif,\n        format=\"GIF\",\n        append_images=frames,\n        save_all=True,\n        duration=int(1000 / fps),\n        loop=loop,\n    )\n\n    if mp4:\n        if not is_tool(\"ffmpeg\"):\n            print(\"ffmpeg is not installed on your computer.\")\n            return\n\n        if os.path.exists(out_gif):\n            out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n            cmd = f\"ffmpeg -loglevel error -i {out_gif} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n            os.system(cmd)\n            if not os.path.exists(out_mp4):\n                raise Exception(f\"Failed to create mp4 file.\")\n    if clean_up:\n        for image in images:\n            os.remove(image)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.merge_gifs","title":"<code>merge_gifs(in_gifs, out_gif)</code>","text":"<p>Merge multiple gifs into one.</p> <p>Parameters:</p> Name Type Description Default <code>in_gifs</code> <code>str | list</code> <p>The input gifs as a list or a directory path.</p> required <code>out_gif</code> <code>str</code> <p>The output gif.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>Raise exception when gifsicle is not installed.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def merge_gifs(in_gifs, out_gif):\n\"\"\"Merge multiple gifs into one.\n\n    Args:\n        in_gifs (str | list): The input gifs as a list or a directory path.\n        out_gif (str): The output gif.\n\n    Raises:\n        Exception:  Raise exception when gifsicle is not installed.\n    \"\"\"\n    import glob\n\n    try:\n        if isinstance(in_gifs, str) and os.path.isdir(in_gifs):\n            in_gifs = glob.glob(os.path.join(in_gifs, \"*.gif\"))\n        elif not isinstance(in_gifs, list):\n            raise Exception(\"in_gifs must be a list.\")\n\n        in_gifs = \" \".join(in_gifs)\n\n        cmd = f\"gifsicle {in_gifs} &gt; {out_gif}\"\n        os.system(cmd)\n\n    except Exception as e:\n        print(\n            \"gifsicle is not installed. Run 'sudo apt-get install -y gifsicle' to install it.\"\n        )\n        print(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.modis_ndvi_doy_ts","title":"<code>modis_ndvi_doy_ts(data='Terra', band='NDVI', start_date=None, end_date=None, region=None)</code>","text":"<p>Create MODIS NDVI timeseries. The source code is adapted from https://developers.google.com/earth-engine/tutorials/community/modis-ndvi-time-series-animation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Either \"Terra\" or \"Aqua\". Defaults to \"Terra\".</p> <code>'Terra'</code> <code>band</code> <code>str</code> <p>Either the \"NDVI\" or \"EVI\" band. Defaults to \"NDVI\".</p> <code>'NDVI'</code> <code>start_date</code> <code>str</code> <p>The start date used to filter the image collection, e.g., \"2013-01-01\". Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date used to filter the image collection. Defaults to None.</p> <code>None</code> <code>region</code> <code>ee.Geometry</code> <p>The geometry used to filter the image collection. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>The MODIS NDVI time series.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def modis_ndvi_doy_ts(\n    data=\"Terra\", band=\"NDVI\", start_date=None, end_date=None, region=None\n):\n\"\"\"Create MODIS NDVI timeseries. The source code is adapted from https://developers.google.com/earth-engine/tutorials/community/modis-ndvi-time-series-animation.\n\n    Args:\n        data (str, optional): Either \"Terra\" or \"Aqua\". Defaults to \"Terra\".\n        band (str, optional): Either the \"NDVI\" or \"EVI\" band. Defaults to \"NDVI\".\n        start_date (str, optional): The start date used to filter the image collection, e.g., \"2013-01-01\". Defaults to None.\n        end_date (str, optional): The end date used to filter the image collection. Defaults to None.\n        region (ee.Geometry, optional): The geometry used to filter the image collection. Defaults to None.\n\n    Returns:\n        ee.ImageCollection: The MODIS NDVI time series.\n    \"\"\"\n    if data not in [\"Terra\", \"Aqua\"]:\n        raise Exception(\"data must be 'Terra' or 'Aqua'.\")\n\n    if band not in [\"NDVI\", \"EVI\"]:\n        raise Exception(\"band must be 'NDVI' or 'EVI'.\")\n\n    if region is not None:\n        if isinstance(region, ee.Geometry) or isinstance(region, ee.FeatureCollection):\n            pass\n        else:\n            raise Exception(\"region must be an ee.Geometry or ee.FeatureCollection.\")\n\n    if data == \"Terra\":\n        col = ee.ImageCollection(\"MODIS/006/MOD13A2\").select(band)\n    else:\n        col = ee.ImageCollection(\"MODIS/006/MYD13A2\").select(band)\n\n    if (start_date is not None) and (end_date is not None):\n        col = col.filterDate(start_date, end_date)\n\n    def set_doy(img):\n        doy = ee.Date(img.get(\"system:time_start\")).getRelative(\"day\", \"year\")\n        return img.set(\"doy\", doy)\n\n    col = col.map(set_doy)\n\n    # Get a collection of distinct images by 'doy'.\n    distinctDOY = col.filterDate(\"2013-01-01\", \"2014-01-01\")\n\n    # Define a filter that identifies which images from the complete\n    # collection match the DOY from the distinct DOY collection.\n    filter = ee.Filter.equals(**{\"leftField\": \"doy\", \"rightField\": \"doy\"})\n\n    # Define a join.\n    join = ee.Join.saveAll(\"doy_matches\")\n\n    # Apply the join and convert the resulting FeatureCollection to an\n    # ImageCollection.\n    joinCol = ee.ImageCollection(join.apply(distinctDOY, col, filter))\n\n    # Apply median reduction among matching DOY collections.\n\n    def match_doy(img):\n        doyCol = ee.ImageCollection.fromImages(img.get(\"doy_matches\"))\n        return doyCol.reduce(ee.Reducer.median())\n\n    comp = joinCol.map(match_doy)\n\n    if region is not None:\n        return comp.map(lambda img: img.clip(region))\n    else:\n        return comp\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.modis_ndvi_timelapse","title":"<code>modis_ndvi_timelapse(roi=None, out_gif=None, data='Terra', band='NDVI', start_date=None, end_date=None, dimensions=768, framesPerSecond=10, crs='EPSG:3857', xy=('3%', '3%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='#ffffff', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, loop=0, overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, mp4=False, fading=False, **kwargs)</code>","text":"<p>Create MODIS NDVI timelapse. The source code is adapted from https://developers.google.com/earth-engine/tutorials/community/modis-ndvi-time-series-animation.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>ee.Geometry</code> <p>The geometry used to filter the image collection. Defaults to None.</p> <code>None</code> <code>out_gif</code> <code>str</code> <p>The output gif file path. Defaults to None.</p> <code>None</code> <code>data</code> <code>str</code> <p>Either \"Terra\" or \"Aqua\". Defaults to \"Terra\".</p> <code>'Terra'</code> <code>band</code> <code>str</code> <p>Either the \"NDVI\" or \"EVI\" band. Defaults to \"NDVI\".</p> <code>'NDVI'</code> <code>start_date</code> <code>str</code> <p>The start date used to filter the image collection, e.g., \"2013-01-01\". Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date used to filter the image collection. Defaults to None.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> required <code>crs</code> <code>str</code> <p>The coordinate reference system to use. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('3%', '3%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'#ffffff'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the output gif to mp4. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> Source code in <code>geemap/timelapse.py</code> <pre><code>def modis_ndvi_timelapse(\n    roi=None,\n    out_gif=None,\n    data=\"Terra\",\n    band=\"NDVI\",\n    start_date=None,\n    end_date=None,\n    dimensions=768,\n    framesPerSecond=10,\n    crs=\"EPSG:3857\",\n    xy=(\"3%\", \"3%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"#ffffff\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    loop=0,\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    mp4=False,\n    fading=False,\n    **kwargs,\n):\n\"\"\"Create MODIS NDVI timelapse. The source code is adapted from https://developers.google.com/earth-engine/tutorials/community/modis-ndvi-time-series-animation.\n\n    Args:\n        roi (ee.Geometry, optional): The geometry used to filter the image collection. Defaults to None.\n        out_gif (str): The output gif file path. Defaults to None.\n        data (str, optional): Either \"Terra\" or \"Aqua\". Defaults to \"Terra\".\n        band (str, optional): Either the \"NDVI\" or \"EVI\" band. Defaults to \"NDVI\".\n        start_date (str, optional): The start date used to filter the image collection, e.g., \"2013-01-01\". Defaults to None.\n        end_date (str, optional): The end date used to filter the image collection. Defaults to None.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        crs (str, optional): The coordinate reference system to use. Defaults to \"EPSG:3857\".\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        mp4 (bool, optional): Whether to convert the output gif to mp4. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n\n    \"\"\"\n\n    if roi is None:\n        roi = ee.Geometry.Polygon(\n            [\n                [\n                    [-18.6983, 38.1446],\n                    [-18.6983, -36.1630],\n                    [52.2293, -36.1630],\n                    [52.2293, 38.1446],\n                ]\n            ],\n            None,\n            False,\n        )\n\n    if out_gif is None:\n        out_gif = os.path.abspath(f\"modis_ndvi_{random_string(3)}.gif\")\n\n    try:\n        col = modis_ndvi_doy_ts(data, band, start_date, end_date, roi)\n\n        # Define RGB visualization parameters.\n        visParams = {\n            \"min\": 0.0,\n            \"max\": 9000.0,\n            \"palette\": [\n                \"FFFFFF\",\n                \"CE7E45\",\n                \"DF923D\",\n                \"F1B555\",\n                \"FCD163\",\n                \"99B718\",\n                \"74A901\",\n                \"66A000\",\n                \"529400\",\n                \"3E8601\",\n                \"207401\",\n                \"056201\",\n                \"004C00\",\n                \"023B01\",\n                \"012E01\",\n                \"011D01\",\n                \"011301\",\n            ],\n        }\n\n        # Create RGB visualization images for use as animation frames.\n        rgbVis = col.map(lambda img: img.visualize(**visParams).clip(roi))\n\n        if overlay_data is not None:\n            rgbVis = add_overlay(\n                rgbVis,\n                overlay_data,\n                overlay_color,\n                overlay_width,\n                overlay_opacity,\n                roi,\n            )\n\n        # Define GIF visualization arguments.\n        videoArgs = {\n            \"region\": roi,\n            \"dimensions\": dimensions,\n            \"crs\": crs,\n            \"framesPerSecond\": framesPerSecond,\n        }\n\n        download_ee_video(rgbVis, videoArgs, out_gif)\n\n        if text_sequence is None:\n            text = rgbVis.aggregate_array(\"system:index\").getInfo()\n            text_sequence = [d.replace(\"_\", \"-\")[5:] for d in text]\n\n        if os.path.exists(out_gif):\n            add_text_to_gif(\n                out_gif,\n                out_gif,\n                xy,\n                text_sequence,\n                font_type,\n                font_size,\n                font_color,\n                add_progress_bar,\n                progress_bar_color,\n                progress_bar_height,\n                duration=1000 / framesPerSecond,\n                loop=loop,\n            )\n\n            try:\n                reduce_gif_size(out_gif)\n                if isinstance(fading, bool):\n                    fading = int(fading)\n                if fading &gt; 0:\n                    gif_fading(out_gif, out_gif, duration=fading, verbose=False)\n\n            except Exception as _:\n                pass\n\n        if mp4:\n            out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n            gif_to_mp4(out_gif, out_mp4)\n\n        return out_gif\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.modis_ocean_color_timelapse","title":"<code>modis_ocean_color_timelapse(satellite, start_date, end_date, roi=None, bands=None, frequency='year', reducer='median', date_format=None, out_gif=None, palette='coolwarm', vis_params=None, dimensions=768, frames_per_second=5, crs='EPSG:3857', overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, title=None, title_xy=('2%', '90%'), add_text=True, text_xy=('2%', '2%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='white', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, add_colorbar=True, colorbar_width=6.0, colorbar_height=0.4, colorbar_label='Sea Surface Temperature (\u00b0C)', colorbar_label_size=12, colorbar_label_weight='normal', colorbar_tick_size=10, colorbar_bg_color='white', colorbar_orientation='horizontal', colorbar_dpi='figure', colorbar_xy=None, colorbar_size=(300, 300), loop=0, mp4=False, fading=False)</code>","text":"<p>Creates a ocean color timelapse from MODIS. https://developers.google.com/earth-engine/datasets/catalog/NASA_OCEANDATA_MODIS-Aqua_L3SMI</p> <p>Parameters:</p> Name Type Description Default <code>satellite</code> <code>str</code> <p>The satellite to use, can be either \"Terra\" or \"Aqua\".</p> required <code>start_date</code> <code>str</code> <p>The start date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.</p> required <code>end_date</code> <code>str</code> <p>The end date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.</p> required <code>roi</code> <code>ee.Geometry</code> <p>The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names to use in the timelapse. Defaults to None.</p> <code>None</code> <code>frequency</code> <code>str</code> <p>The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.</p> <code>'year'</code> <code>reducer</code> <code>str</code> <p>The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.</p> <code>'median'</code> <code>drop_empty</code> <code>bool</code> <p>Whether to drop empty images from the timeseries. Defaults to True.</p> required <code>date_format</code> <code>str</code> <p>A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.</p> <code>None</code> <code>out_gif</code> <code>str</code> <p>The output gif file path. Defaults to None.</p> <code>None</code> <code>palette</code> <code>list</code> <p>A list of colors to render a single-band image in the timelapse. Defaults to None.</p> <code>'coolwarm'</code> <code>vis_params</code> <code>dict</code> <p>A dictionary of visualization parameters to use in the timelapse. Defaults to None. See more at https://developers.google.com/earth-engine/guides/image_visualization.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> <code>5</code> <code>crs</code> <code>str</code> <p>The coordinate reference system to use. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>title</code> <code>str</code> <p>The title of the timelapse. Defaults to None.</p> <code>None</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>add_text</code> <code>bool</code> <p>Whether to add animated text to the timelapse. Defaults to True.</p> <code>True</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'white'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar to the timelapse. Defaults to False.</p> <code>True</code> <code>colorbar_width</code> <code>float</code> <p>Width of the colorbar. Defaults to 6.0.</p> <code>6.0</code> <code>colorbar_height</code> <code>float</code> <p>Height of the colorbar. Defaults to 0.4.</p> <code>0.4</code> <code>colorbar_label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>'Sea Surface Temperature (\u00b0C)'</code> <code>colorbar_label_size</code> <code>int</code> <p>Font size for the colorbar label. Defaults to 12.</p> <code>12</code> <code>colorbar_label_weight</code> <code>str</code> <p>Font weight for the colorbar label. Defaults to 'normal'.</p> <code>'normal'</code> <code>colorbar_tick_size</code> <code>int</code> <p>Font size for the colorbar ticks. Defaults to 10.</p> <code>10</code> <code>colorbar_bg_color</code> <code>str</code> <p>Background color for the colorbar, can be color like \"white\", \"black\". Defaults to None.</p> <code>'white'</code> <code>colorbar_orientation</code> <code>str</code> <p>Orientation of the colorbar. Defaults to 'horizontal'.</p> <code>'horizontal'</code> <code>colorbar_dpi</code> <code>str</code> <p>DPI for the colorbar, can be numbers like 100, 300. Defaults to 'figure'.</p> <code>'figure'</code> <code>colorbar_xy</code> <code>tuple</code> <p>Lower left corner of the colorbar. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>colorbar_size</code> <code>tuple</code> <p>Size of the colorbar. It can be formatted like this: (300, 300). Defaults to (300, 300).</p> <code>(300, 300)</code> <code>loop</code> <code>int</code> <p>Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to create an mp4 file. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>File path to the timelapse gif.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def modis_ocean_color_timelapse(\n    satellite,\n    start_date,\n    end_date,\n    roi=None,\n    bands=None,\n    frequency=\"year\",\n    reducer=\"median\",\n    date_format=None,\n    out_gif=None,\n    palette=\"coolwarm\",\n    vis_params=None,\n    dimensions=768,\n    frames_per_second=5,\n    crs=\"EPSG:3857\",\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    title=None,\n    title_xy=(\"2%\", \"90%\"),\n    add_text=True,\n    text_xy=(\"2%\", \"2%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"white\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    add_colorbar=True,\n    colorbar_width=6.0,\n    colorbar_height=0.4,\n    colorbar_label=\"Sea Surface Temperature (\u00b0C)\",\n    colorbar_label_size=12,\n    colorbar_label_weight=\"normal\",\n    colorbar_tick_size=10,\n    colorbar_bg_color=\"white\",\n    colorbar_orientation=\"horizontal\",\n    colorbar_dpi=\"figure\",\n    colorbar_xy=None,\n    colorbar_size=(300, 300),\n    loop=0,\n    mp4=False,\n    fading=False,\n):\n\"\"\"Creates a ocean color timelapse from MODIS. https://developers.google.com/earth-engine/datasets/catalog/NASA_OCEANDATA_MODIS-Aqua_L3SMI\n\n    Args:\n        satellite (str): The satellite to use, can be either \"Terra\" or \"Aqua\".\n        start_date (str): The start date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.\n        end_date (str): The end date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.\n        roi (ee.Geometry, optional): The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.\n        bands (list, optional): A list of band names to use in the timelapse. Defaults to None.\n        frequency (str, optional): The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.\n        reducer (str, optional):  The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.\n        drop_empty (bool, optional): Whether to drop empty images from the timeseries. Defaults to True.\n        date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.\n        out_gif (str): The output gif file path. Defaults to None.\n        palette (list, optional): A list of colors to render a single-band image in the timelapse. Defaults to None.\n        vis_params (dict, optional): A dictionary of visualization parameters to use in the timelapse. Defaults to None. See more at https://developers.google.com/earth-engine/guides/image_visualization.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        crs (str, optional): The coordinate reference system to use. Defaults to \"EPSG:3857\".\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        title (str, optional): The title of the timelapse. Defaults to None.\n        title_xy (tuple, optional): Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        add_text (bool, optional): Whether to add animated text to the timelapse. Defaults to True.\n        title_xy (tuple, optional): Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        add_colorbar (bool, optional): Whether to add a colorbar to the timelapse. Defaults to False.\n        colorbar_width (float, optional): Width of the colorbar. Defaults to 6.0.\n        colorbar_height (float, optional): Height of the colorbar. Defaults to 0.4.\n        colorbar_label (str, optional): Label for the colorbar. Defaults to None.\n        colorbar_label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n        colorbar_label_weight (str, optional): Font weight for the colorbar label. Defaults to 'normal'.\n        colorbar_tick_size (int, optional): Font size for the colorbar ticks. Defaults to 10.\n        colorbar_bg_color (str, optional): Background color for the colorbar, can be color like \"white\", \"black\". Defaults to None.\n        colorbar_orientation (str, optional): Orientation of the colorbar. Defaults to 'horizontal'.\n        colorbar_dpi (str, optional): DPI for the colorbar, can be numbers like 100, 300. Defaults to 'figure'.\n        colorbar_xy (tuple, optional): Lower left corner of the colorbar. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        colorbar_size (tuple, optional): Size of the colorbar. It can be formatted like this: (300, 300). Defaults to (300, 300).\n        loop (int, optional): Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        mp4 (bool, optional): Whether to create an mp4 file. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n\n    Returns:\n        str: File path to the timelapse gif.\n    \"\"\"\n    collection = modis_ocean_color_timeseries(\n        satellite, start_date, end_date, roi, bands, frequency, reducer, date_format\n    )\n\n    if bands is None:\n        bands = [\"sst\"]\n\n    if len(bands) == 1 and palette is None:\n        palette = \"coolwarm\"\n\n    if roi is None:\n        roi = ee.Geometry.BBox(-99.755133, 18.316722, -79.761194, 31.206929)\n\n    out_gif = create_timelapse(\n        collection,\n        start_date,\n        end_date,\n        roi,\n        bands,\n        frequency,\n        reducer,\n        date_format,\n        out_gif,\n        palette,\n        vis_params,\n        dimensions,\n        frames_per_second,\n        crs,\n        overlay_data,\n        overlay_color,\n        overlay_width,\n        overlay_opacity,\n        title,\n        title_xy,\n        add_text,\n        text_xy,\n        text_sequence,\n        font_type,\n        font_size,\n        font_color,\n        add_progress_bar,\n        progress_bar_color,\n        progress_bar_height,\n        add_colorbar,\n        colorbar_width,\n        colorbar_height,\n        colorbar_label,\n        colorbar_label_size,\n        colorbar_label_weight,\n        colorbar_tick_size,\n        colorbar_bg_color,\n        colorbar_orientation,\n        colorbar_dpi,\n        colorbar_xy,\n        colorbar_size,\n        loop,\n        mp4,\n        fading,\n    )\n\n    return out_gif\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.modis_ocean_color_timeseries","title":"<code>modis_ocean_color_timeseries(satellite, start_date, end_date, region=None, bands=None, frequency='year', reducer='median', drop_empty=True, date_format=None)</code>","text":"<p>Creates a ocean color timeseries from MODIS. https://developers.google.com/earth-engine/datasets/catalog/NASA_OCEANDATA_MODIS-Aqua_L3SMI</p> <p>Parameters:</p> Name Type Description Default <code>satellite</code> <code>str</code> <p>The satellite to use, can be either \"Terra\" or \"Aqua\".</p> required <code>start_date</code> <code>str</code> <p>The start date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.</p> required <code>end_date</code> <code>str</code> <p>The end date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.</p> required <code>region</code> <code>ee.Geometry</code> <p>The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.</p> <code>None</code> <code>bands</code> <code>list</code> <p>The list of bands to use to create the timeseries. It must be a list of strings. Defaults to None.</p> <code>None</code> <code>frequency</code> <code>str</code> <p>The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day'. Defaults to 'year'.</p> <code>'year'</code> <code>reducer</code> <code>str</code> <p>The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.</p> <code>'median'</code> <code>drop_empty</code> <code>bool</code> <p>Whether to drop empty images from the timeseries. Defaults to True.</p> <code>True</code> <code>date_format</code> <code>str</code> <p>A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.</p> <code>None</code> <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>The timeseries.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def modis_ocean_color_timeseries(\n    satellite,\n    start_date,\n    end_date,\n    region=None,\n    bands=None,\n    frequency=\"year\",\n    reducer=\"median\",\n    drop_empty=True,\n    date_format=None,\n):\n\"\"\"Creates a ocean color timeseries from MODIS. https://developers.google.com/earth-engine/datasets/catalog/NASA_OCEANDATA_MODIS-Aqua_L3SMI\n\n    Args:\n        satellite (str): The satellite to use, can be either \"Terra\" or \"Aqua\".\n        start_date (str): The start date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.\n        end_date (str): The end date of the timeseries. It must be formatted like this: 'YYYY-MM-dd'.\n        region (ee.Geometry, optional): The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.\n        bands (list, optional): The list of bands to use to create the timeseries. It must be a list of strings. Defaults to None.\n        frequency (str, optional): The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day'. Defaults to 'year'.\n        reducer (str, optional):  The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.\n        drop_empty (bool, optional): Whether to drop empty images from the timeseries. Defaults to True.\n        date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.\n\n    Returns:\n        ee.ImageCollection: The timeseries.\n    \"\"\"\n\n    if satellite not in [\"Terra\", \"Aqua\"]:\n        raise Exception(\"Satellite must be 'Terra' or 'Aqua'.\")\n\n    allowed_frequency = [\"year\", \"quarter\", \"month\", \"week\", \"day\"]\n    if frequency not in allowed_frequency:\n        raise Exception(\n            \"Frequency must be one of the following: {}\".format(allowed_frequency)\n        )\n\n    if region is not None:\n        if isinstance(region, ee.Geometry) or isinstance(region, ee.FeatureCollection):\n            pass\n        else:\n            raise Exception(\"region must be an ee.Geometry or ee.FeatureCollection.\")\n\n    col = ee.ImageCollection(f\"NASA/OCEANDATA/MODIS-{satellite}/L3SMI\").filterDate(\n        start_date, end_date\n    )\n\n    ts = create_timeseries(\n        col,\n        start_date,\n        end_date,\n        region,\n        bands,\n        frequency,\n        reducer,\n        drop_empty,\n        date_format,\n    )\n\n    return ts\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.modis_timeseries","title":"<code>modis_timeseries(asset_id='MODIS/006/MOD13A2', band_name=None, roi=None, start_year=2001, end_year=None, start_date='01-01', end_date='12-31')</code>","text":"<p>Generates a Monthly MODIS ImageCollection.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>The asset id the MODIS ImageCollection.</p> <code>'MODIS/006/MOD13A2'</code> <code>band_name</code> <code>str</code> <p>The band name of the image to use.</p> <code>None</code> <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 1984.</p> <code>2001</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to None, which is the current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.</p> <code>'01-01'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.</p> <code>'12-31'</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns an ImageCollection containing month MODIS images.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def modis_timeseries(\n    asset_id=\"MODIS/006/MOD13A2\",\n    band_name=None,\n    roi=None,\n    start_year=2001,\n    end_year=None,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n):\n\"\"\"Generates a Monthly MODIS ImageCollection.\n    Args:\n        asset_id (str, optional): The asset id the MODIS ImageCollection.\n        band_name (str, optional): The band name of the image to use.\n        roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 1984.\n        end_year (int, optional): Ending year for the timelapse. Defaults to None, which is the current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.\n    Returns:\n        object: Returns an ImageCollection containing month MODIS images.\n    \"\"\"\n\n    try:\n        if end_year is None:\n            end_year = datetime.datetime.now().year\n\n        collection = ee.ImageCollection(asset_id)\n        if band_name is None:\n            band_name = collection.first().bandNames().getInfo()[0]\n        collection = collection.select(band_name)\n        if roi is not None:\n            if isinstance(roi, ee.Geometry):\n                collection = ee.ImageCollection(\n                    collection.map(lambda img: img.clip(roi))\n                )\n            elif isinstance(roi, ee.FeatureCollection):\n                collection = ee.ImageCollection(\n                    collection.map(lambda img: img.clipToCollection(roi))\n                )\n\n        start = str(start_year) + \"-\" + start_date\n        end = str(end_year) + \"-\" + end_date\n\n        seq = date_sequence(start, end, \"month\")\n\n        def monthly_modis(start_d):\n            end_d = ee.Date(start_d).advance(1, \"month\")\n            return ee.Image(collection.filterDate(start_d, end_d).mean())\n\n        images = ee.ImageCollection(seq.map(monthly_modis))\n        return images\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.naip_timelapse","title":"<code>naip_timelapse(roi, start_year=2003, end_year=None, out_gif=None, bands=None, palette=None, vis_params=None, dimensions=768, frames_per_second=3, crs='EPSG:3857', overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, title=None, title_xy=('2%', '90%'), add_text=True, text_xy=('2%', '2%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='white', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, loop=0, mp4=False, fading=False)</code>","text":"<p>Create a timelapse from NAIP imagery.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>ee.Geometry</code> <p>The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.</p> required <code>start_year</code> <code>int | str</code> <p>The start year of the timeseries. It must be formatted like this: 'YYYY'. Defaults to 2003.</p> <code>2003</code> <code>end_year</code> <code>int | str</code> <p>The end year of the timeseries. It must be formatted like this: 'YYYY'. Defaults to None, which will use the current year.</p> <code>None</code> <code>out_gif</code> <code>str</code> <p>The output gif file path. Defaults to None.</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names to use in the timelapse. Defaults to None.</p> <code>None</code> <code>palette</code> <code>list</code> <p>A list of colors to render a single-band image in the timelapse. Defaults to None.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>A dictionary of visualization parameters to use in the timelapse. Defaults to None. See more at https://developers.google.com/earth-engine/guides/image_visualization.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> <code>3</code> <code>crs</code> <code>str</code> <p>The coordinate reference system to use. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>title</code> <code>str</code> <p>The title of the timelapse. Defaults to None.</p> <code>None</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>add_text</code> <code>bool</code> <p>Whether to add animated text to the timelapse. Defaults to True.</p> <code>True</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'white'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to create an mp4 file. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>File path to the timelapse gif.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def naip_timelapse(\n    roi,\n    start_year=2003,\n    end_year=None,\n    out_gif=None,\n    bands=None,\n    palette=None,\n    vis_params=None,\n    dimensions=768,\n    frames_per_second=3,\n    crs=\"EPSG:3857\",\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    title=None,\n    title_xy=(\"2%\", \"90%\"),\n    add_text=True,\n    text_xy=(\"2%\", \"2%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"white\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    loop=0,\n    mp4=False,\n    fading=False,\n):\n\"\"\"Create a timelapse from NAIP imagery.\n\n    Args:\n        roi (ee.Geometry): The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.\n        start_year (int | str, optional): The start year of the timeseries. It must be formatted like this: 'YYYY'. Defaults to 2003.\n        end_year (int | str, optional): The end year of the timeseries. It must be formatted like this: 'YYYY'. Defaults to None, which will use the current year.\n        out_gif (str): The output gif file path. Defaults to None.\n        bands (list, optional): A list of band names to use in the timelapse. Defaults to None.\n        palette (list, optional): A list of colors to render a single-band image in the timelapse. Defaults to None.\n        vis_params (dict, optional): A dictionary of visualization parameters to use in the timelapse. Defaults to None. See more at https://developers.google.com/earth-engine/guides/image_visualization.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        crs (str, optional): The coordinate reference system to use. Defaults to \"EPSG:3857\".\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        title (str, optional): The title of the timelapse. Defaults to None.\n        title_xy (tuple, optional): Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        add_text (bool, optional): Whether to add animated text to the timelapse. Defaults to True.\n        title_xy (tuple, optional): Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        loop (int, optional): Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        mp4 (bool, optional): Whether to create an mp4 file. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n\n\n    Returns:\n        str: File path to the timelapse gif.\n    \"\"\"\n\n    try:\n        if end_year is None:\n            end_year = datetime.datetime.now().year\n\n        collection = ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n        start_date = str(start_year) + \"-01-01\"\n        end_date = str(end_year) + \"-12-31\"\n        frequency = \"year\"\n        reducer = \"median\"\n        date_format = \"YYYY\"\n\n        if bands is not None and isinstance(bands, list) and \"N\" in bands:\n            collection = collection.filter(\n                ee.Filter.listContains(\"system:band_names\", \"N\")\n            )\n\n        return create_timelapse(\n            collection,\n            start_date,\n            end_date,\n            roi,\n            bands,\n            frequency,\n            reducer,\n            date_format,\n            out_gif,\n            palette,\n            vis_params,\n            dimensions,\n            frames_per_second,\n            crs,\n            overlay_data,\n            overlay_color,\n            overlay_width,\n            overlay_opacity,\n            title,\n            title_xy,\n            add_text,\n            text_xy,\n            text_sequence,\n            font_type,\n            font_size,\n            font_color,\n            add_progress_bar,\n            progress_bar_color,\n            progress_bar_height,\n            loop=loop,\n            mp4=mp4,\n            fading=fading,\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.naip_timeseries","title":"<code>naip_timeseries(roi=None, start_year=2003, end_year=None, RGBN=False)</code>","text":"<p>Creates NAIP annual timeseries</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>An ee.Geometry representing the region of interest. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timeseries. Defaults to 2003.</p> <code>2003</code> <code>end_year</code> <code>int</code> <p>Ending year for the timeseries. Defaults to None, which will use the current year.</p> <code>None</code> <code>RGBN</code> <code>bool</code> <p>Whether to retrieve 4-band NAIP imagery only.</p> <code>False</code> <p>Returns:</p> Type Description <code>object</code> <p>An ee.ImageCollection representing annual NAIP imagery.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def naip_timeseries(roi=None, start_year=2003, end_year=None, RGBN=False):\n\"\"\"Creates NAIP annual timeseries\n\n    Args:\n        roi (object, optional): An ee.Geometry representing the region of interest. Defaults to None.\n        start_year (int, optional): Starting year for the timeseries. Defaults to 2003.\n        end_year (int, optional): Ending year for the timeseries. Defaults to None, which will use the current year.\n        RGBN (bool, optional): Whether to retrieve 4-band NAIP imagery only.\n    Returns:\n        object: An ee.ImageCollection representing annual NAIP imagery.\n    \"\"\"\n    try:\n        if end_year is None:\n            end_year = datetime.datetime.now().year\n\n        def get_annual_NAIP(year):\n            try:\n                collection = ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n                if roi is not None:\n                    collection = collection.filterBounds(roi)\n                start_date = ee.Date.fromYMD(year, 1, 1)\n                end_date = ee.Date.fromYMD(year, 12, 31)\n                naip = collection.filterDate(start_date, end_date)\n                if RGBN:\n                    naip = naip.filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n                if roi is not None:\n                    if isinstance(roi, ee.Geometry):\n                        image = ee.Image(ee.ImageCollection(naip).mosaic().clip(roi))\n                    elif isinstance(roi, ee.FeatureCollection):\n                        image = ee.Image(\n                            ee.ImageCollection(naip).mosaic().clipToCollection(roi)\n                        )\n                else:\n                    image = ee.Image(ee.ImageCollection(naip).mosaic())\n                return image.set(\n                    {\n                        \"system:time_start\": ee.Date(start_date).millis(),\n                        \"system:time_end\": ee.Date(end_date).millis(),\n                        \"empty\": naip.size().eq(0),\n                    }\n                )\n            except Exception as e:\n                raise Exception(e)\n\n        years = ee.List.sequence(start_year, end_year)\n        collection = ee.ImageCollection(years.map(get_annual_NAIP))\n        return collection.filterMetadata(\"empty\", \"equals\", 0)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.reduce_gif_size","title":"<code>reduce_gif_size(in_gif, out_gif=None)</code>","text":"<p>Reduces a GIF image using ffmpeg.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input file path to the GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The output file path to the GIF image. Defaults to None.</p> <code>None</code> Source code in <code>geemap/timelapse.py</code> <pre><code>def reduce_gif_size(in_gif, out_gif=None):\n\"\"\"Reduces a GIF image using ffmpeg.\n\n    Args:\n        in_gif (str): The input file path to the GIF image.\n        out_gif (str, optional): The output file path to the GIF image. Defaults to None.\n    \"\"\"\n    import ffmpeg\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n\n    if not is_tool(\"ffmpeg\"):\n        print(\"ffmpeg is not installed on your computer.\")\n        return\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if out_gif is None:\n        out_gif = in_gif\n    elif not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if in_gif == out_gif:\n        tmp_gif = in_gif.replace(\".gif\", \"_tmp.gif\")\n        shutil.copyfile(in_gif, tmp_gif)\n        stream = ffmpeg.input(tmp_gif)\n        stream = ffmpeg.output(stream, in_gif, loglevel=\"quiet\").overwrite_output()\n        ffmpeg.run(stream)\n        os.remove(tmp_gif)\n\n    else:\n        stream = ffmpeg.input(in_gif)\n        stream = ffmpeg.output(stream, out_gif, loglevel=\"quiet\").overwrite_output()\n        ffmpeg.run(stream)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.sentinel1_filtering","title":"<code>sentinel1_filtering(collection, band='VV', instrumentMode=None, orbitProperties_pass=None, transmitterReceiverPolarisation=None, remove_outliers=True, **kwargs)</code>","text":"<p>Sentinel-1 data is collected with several different instrument configurations, resolutions, band combinations during both ascending and descending orbits. Because of this heterogeneity, it's usually necessary to filter the data down to a homogeneous subset before starting processing.</p> <p>For more details, see https://developers.google.com/earth-engine/guides/sentinel1</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <p>A Sentinel1 ImageCollection to filter.</p> required <code>band</code> <code>str</code> <p>Collection band. Can be one of ['HH','HV','VV','VH']. Defaults to 'VV' which is most commonly available on land.</p> <code>'VV'</code> <code>instrumentMode</code> <code>str</code> <p>Collection property. Can be one of ['IW','EW','SM']. Defaults to band default availability (IW for ['VV','VH'], EW for ['HH','HV']). IW is typically available for land. EW for icy regions.</p> <code>None</code> <code>orbitProperties_pass</code> <code>str|None</code> <p>Collection property. Can be one of ['ASCENDING', 'DESCENDING', None]. Default to 'ASCENDING'. Will return mixed property if set to None, which dampen elevation, and increase surface roughness/fractality visibility.</p> <code>None</code> <code>transmitterReceiverPolarisation</code> <p>Collection property List contains this value. Can be one of ['HH','HV','VV','VH']. Defaults to band.</p> <code>None</code> <code>remove_outliers</code> <code>bool</code> <p>Remove pixels with extreme values (&lt; -30). These can occur near the edge of an image. Default to True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>All other arguments will be applied as filters to collection properties. F.e. {'resolution_meters':10} Full list properties: https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S1_GRD#image-properties</p> <code>{}</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns a homogeneous ImageCollection of Sentinel 1 images.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def sentinel1_filtering(\n    collection,\n    band=\"VV\",\n    instrumentMode=None,\n    orbitProperties_pass=None,\n    transmitterReceiverPolarisation=None,\n    remove_outliers=True,\n    **kwargs,\n):\n\"\"\"\n    Sentinel-1 data is collected with several different instrument configurations, resolutions,\n    band combinations during both ascending and descending orbits. Because of this heterogeneity,\n    it's usually necessary to filter the data down to a homogeneous subset before starting processing.\n\n    For more details, see https://developers.google.com/earth-engine/guides/sentinel1\n\n    Args:\n        collection: A Sentinel1 ImageCollection to filter.\n        band (str): Collection band. Can be one of ['HH','HV','VV','VH']. Defaults to 'VV' which is most commonly available on land.\n        instrumentMode (str, optional): Collection property. Can be one of ['IW','EW','SM']. Defaults to band default availability (IW for ['VV','VH'], EW for ['HH','HV']). IW is typically available for land. EW for icy regions.\n        orbitProperties_pass (str|None, optional): Collection property. Can be one of ['ASCENDING', 'DESCENDING', None]. Default to 'ASCENDING'.\n            Will return mixed property if set to None, which dampen elevation, and increase surface roughness/fractality visibility.\n        transmitterReceiverPolarisation: Collection property List contains this value. Can be one of ['HH','HV','VV','VH']. Defaults to band.\n        remove_outliers (bool, optional): Remove pixels with extreme values (&lt; -30). These can occur near the edge of an image. Default to True.\n        **kwargs (dict, optional): All other arguments will be applied as filters to collection properties. F.e. {'resolution_meters':10}\n            Full list properties: https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S1_GRD#image-properties\n\n    Returns:\n        object: Returns a homogeneous ImageCollection of Sentinel 1 images.\n    \"\"\"\n\n    transmitterReceiverPolarisation = transmitterReceiverPolarisation or band\n    instrumentMode = (\n        instrumentMode or {\"VV\": \"IW\", \"VH\": \"IW\", \"HH\": \"EW\", \"HV\": \"EW\"}[band]\n    )\n\n    def remove_outliers(image):\n        if not remove_outliers:\n            return image\n        edge = image.select(band).lt(-30.0)\n        maskedimage = image.mask().And(edge.Not())\n        return image.updateMask(maskedimage)\n\n    col = (\n        collection.filter(ee.Filter.eq(\"instrumentMode\", instrumentMode))\n        .filter(\n            ee.Filter.listContains(\n                \"transmitterReceiverPolarisation\", transmitterReceiverPolarisation\n            )\n        )\n        .map(remove_outliers)\n    )\n    for k, v in kwargs.items():\n        col = col.filter(ee.Filter.eq(k, v))\n    if orbitProperties_pass:\n        col = col.filter(ee.Filter.eq(\"orbitProperties_pass\", orbitProperties_pass))\n\n    return col\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.sentinel1_timelapse","title":"<code>sentinel1_timelapse(roi, out_gif=None, start_year=2015, end_year=None, start_date='01-01', end_date='12-31', bands=['VV'], frequency='year', reducer='median', date_format=None, palette='Greys', vis_params=None, dimensions=768, frames_per_second=10, crs='EPSG:3857', overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, title=None, title_xy=('2%', '90%'), add_text=True, text_xy=('2%', '2%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='white', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, add_colorbar=False, colorbar_width=6.0, colorbar_height=0.4, colorbar_label=None, colorbar_label_size=12, colorbar_label_weight='normal', colorbar_tick_size=10, colorbar_bg_color=None, colorbar_orientation='horizontal', colorbar_dpi='figure', colorbar_xy=None, colorbar_size=(300, 300), loop=0, mp4=False, fading=False, **kwargs)</code>","text":"<p>Create a timelapse from any ee.ImageCollection.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>ee.Geometry</code> <p>The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.</p> required <code>out_gif</code> <code>str</code> <p>The output gif file path. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 2015.</p> <code>2015</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to the current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.</p> <code>'01-01'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.</p> <code>'12-31'</code> <code>bands</code> <code>list</code> <p>A list of band names to use in the timelapse. Can be one of ['VV'],['HV'],['VH'],['HH'],['VV','VH'] or ['HH','HV']</p> <code>['VV']</code> <code>frequency</code> <code>str</code> <p>The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.</p> <code>'year'</code> <code>reducer</code> <code>str</code> <p>The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.</p> <code>'median'</code> <code>drop_empty</code> <code>bool</code> <p>Whether to drop empty images from the timeseries. Defaults to True.</p> required <code>date_format</code> <code>str</code> <p>A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.</p> <code>None</code> <code>palette</code> <code>list</code> <p>A list of colors to render a single-band image in the timelapse. Defaults to None.</p> <code>'Greys'</code> <code>vis_params</code> <code>dict</code> <p>A dictionary of visualization parameters to use in the timelapse. Defaults to None. See more at https://developers.google.com/earth-engine/guides/image_visualization.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> <code>10</code> <code>crs</code> <code>str</code> <p>The coordinate reference system to use. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>title</code> <code>str</code> <p>The title of the timelapse. Defaults to None.</p> <code>None</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>add_text</code> <code>bool</code> <p>Whether to add animated text to the timelapse. Defaults to True.</p> <code>True</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'white'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar to the timelapse. Defaults to False.</p> <code>False</code> <code>colorbar_width</code> <code>float</code> <p>Width of the colorbar. Defaults to 6.0.</p> <code>6.0</code> <code>colorbar_height</code> <code>float</code> <p>Height of the colorbar. Defaults to 0.4.</p> <code>0.4</code> <code>colorbar_label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>colorbar_label_size</code> <code>int</code> <p>Font size for the colorbar label. Defaults to 12.</p> <code>12</code> <code>colorbar_label_weight</code> <code>str</code> <p>Font weight for the colorbar label. Defaults to 'normal'.</p> <code>'normal'</code> <code>colorbar_tick_size</code> <code>int</code> <p>Font size for the colorbar ticks. Defaults to 10.</p> <code>10</code> <code>colorbar_bg_color</code> <code>str</code> <p>Background color for the colorbar, can be color like \"white\", \"black\". Defaults to None.</p> <code>None</code> <code>colorbar_orientation</code> <code>str</code> <p>Orientation of the colorbar. Defaults to 'horizontal'.</p> <code>'horizontal'</code> <code>colorbar_dpi</code> <code>str</code> <p>DPI for the colorbar, can be numbers like 100, 300. Defaults to 'figure'.</p> <code>'figure'</code> <code>colorbar_xy</code> <code>tuple</code> <p>Lower left corner of the colorbar. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>colorbar_size</code> <code>tuple</code> <p>Size of the colorbar. It can be formatted like this: (300, 300). Defaults to (300, 300).</p> <code>(300, 300)</code> <code>loop</code> <code>int</code> <p>Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to create an mp4 file. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <code>**kwargs</code> <p>Arguments for sentinel1_filtering(). Same filters will be applied to all bands.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>File path to the timelapse gif.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def sentinel1_timelapse(\n    roi,\n    out_gif=None,\n    start_year=2015,\n    end_year=None,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n    bands=[\"VV\"],\n    frequency=\"year\",\n    reducer=\"median\",\n    date_format=None,\n    palette=\"Greys\",\n    vis_params=None,\n    dimensions=768,\n    frames_per_second=10,\n    crs=\"EPSG:3857\",\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    title=None,\n    title_xy=(\"2%\", \"90%\"),\n    add_text=True,\n    text_xy=(\"2%\", \"2%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"white\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    add_colorbar=False,\n    colorbar_width=6.0,\n    colorbar_height=0.4,\n    colorbar_label=None,\n    colorbar_label_size=12,\n    colorbar_label_weight=\"normal\",\n    colorbar_tick_size=10,\n    colorbar_bg_color=None,\n    colorbar_orientation=\"horizontal\",\n    colorbar_dpi=\"figure\",\n    colorbar_xy=None,\n    colorbar_size=(300, 300),\n    loop=0,\n    mp4=False,\n    fading=False,\n    **kwargs,\n):\n\"\"\"Create a timelapse from any ee.ImageCollection.\n\n    Args:\n        roi (ee.Geometry, optional): The region to use to filter the collection of images. It must be an ee.Geometry object. Defaults to None.\n        out_gif (str): The output gif file path. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 2015.\n        end_year (int, optional): Ending year for the timelapse. Defaults to the current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.\n        bands (list, optional): A list of band names to use in the timelapse. Can be one of ['VV'],['HV'],['VH'],['HH'],['VV','VH'] or ['HH','HV']\n        frequency (str, optional): The frequency of the timeseries. It must be one of the following: 'year', 'month', 'day', 'hour', 'minute', 'second'. Defaults to 'year'.\n        reducer (str, optional):  The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.\n        drop_empty (bool, optional): Whether to drop empty images from the timeseries. Defaults to True.\n        date_format (str, optional): A pattern, as described at http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html. Defaults to 'YYYY-MM-dd'.\n        palette (list, optional): A list of colors to render a single-band image in the timelapse. Defaults to None.\n        vis_params (dict, optional): A dictionary of visualization parameters to use in the timelapse. Defaults to None. See more at https://developers.google.com/earth-engine/guides/image_visualization.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        crs (str, optional): The coordinate reference system to use. Defaults to \"EPSG:3857\".\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        title (str, optional): The title of the timelapse. Defaults to None.\n        title_xy (tuple, optional): Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        add_text (bool, optional): Whether to add animated text to the timelapse. Defaults to True.\n        title_xy (tuple, optional): Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        add_colorbar (bool, optional): Whether to add a colorbar to the timelapse. Defaults to False.\n        colorbar_width (float, optional): Width of the colorbar. Defaults to 6.0.\n        colorbar_height (float, optional): Height of the colorbar. Defaults to 0.4.\n        colorbar_label (str, optional): Label for the colorbar. Defaults to None.\n        colorbar_label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n        colorbar_label_weight (str, optional): Font weight for the colorbar label. Defaults to 'normal'.\n        colorbar_tick_size (int, optional): Font size for the colorbar ticks. Defaults to 10.\n        colorbar_bg_color (str, optional): Background color for the colorbar, can be color like \"white\", \"black\". Defaults to None.\n        colorbar_orientation (str, optional): Orientation of the colorbar. Defaults to 'horizontal'.\n        colorbar_dpi (str, optional): DPI for the colorbar, can be numbers like 100, 300. Defaults to 'figure'.\n        colorbar_xy (tuple, optional): Lower left corner of the colorbar. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        colorbar_size (tuple, optional): Size of the colorbar. It can be formatted like this: (300, 300). Defaults to (300, 300).\n        loop (int, optional): Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        mp4 (bool, optional): Whether to create an mp4 file. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n        **kwargs: Arguments for sentinel1_filtering(). Same filters will be applied to all bands.\n\n    Returns:\n        str: File path to the timelapse gif.\n    \"\"\"\n    from datetime import date\n\n    assert bands in (\n        [\"VV\"],\n        [\"VH\"],\n        [\"HH\"],\n        [\"HV\"],\n        [\"VV\", \"VH\"],\n        [\"HH\", \"HV\"],\n        [\"VH\", \"VV\"],\n        [\"HV\", \"HH\"],\n    ), \"Not all Sentinel1 bands are available together.\"\n    if bands in ([\"VH\", \"VV\"], [\"HV\", \"HH\"]):\n        bands[0], bands[1] = bands[1], bands[0]\n    band = bands[0]\n\n    if end_year is None:\n        end_year = date.today().year\n\n    start = f\"{start_year}-{start_date}\"\n    end = f\"{end_year}-{end_date}\"\n\n    if vis_params is None:\n        vis_params = {\"min\": -30, \"max\": 0}\n\n    collection = (\n        ee.ImageCollection(\"COPERNICUS/S1_GRD\").filterDate(start, end).filterBounds(roi)\n    )\n    collection = sentinel1_filtering(collection, band, **kwargs)\n\n    return create_timelapse(\n        collection,\n        start,\n        end,\n        roi,\n        bands,\n        frequency,\n        reducer,\n        date_format,\n        out_gif,\n        palette,\n        vis_params,\n        dimensions,\n        frames_per_second,\n        crs,\n        overlay_data,\n        overlay_color,\n        overlay_width,\n        overlay_opacity,\n        title,\n        title_xy,\n        add_text,\n        text_xy,\n        text_sequence,\n        font_type,\n        font_size,\n        font_color,\n        add_progress_bar,\n        progress_bar_color,\n        progress_bar_height,\n        add_colorbar,\n        colorbar_width,\n        colorbar_height,\n        colorbar_label,\n        colorbar_label_size,\n        colorbar_label_weight,\n        colorbar_tick_size,\n        colorbar_bg_color,\n        colorbar_orientation,\n        colorbar_dpi,\n        colorbar_xy,\n        colorbar_size,\n        loop,\n        mp4,\n        fading,\n    )\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.sentinel1_timelapse_legacy","title":"<code>sentinel1_timelapse_legacy(roi=None, out_gif=None, start_year=2015, end_year=None, start_date='01-01', end_date='12-31', vis_params=None, dimensions=768, frames_per_second=5, crs='EPSG:3857', overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, frequency='year', title=None, title_xy=('2%', '90%'), add_text=True, text_xy=('2%', '2%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='white', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, loop=0, mp4=False, fading=False)</code>","text":"<p>Generates a Sentinel-1 timelapse animated GIF or MP4.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to LV &amp; Lake Mead.</p> <code>None</code> <code>out_gif</code> <code>str</code> <p>File path to the output animated GIF. Defaults to user\\Downloads\\s1_ts_*.gif.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 2015.</p> <code>2015</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.</p> <code>'01-01'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.</p> <code>'12-31'</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters. Defaults to {'min':-18, 'max': -4}.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 5.</p> <code>5</code> <code>crs</code> <code>str</code> <p>Coordinate reference system. Defaults to 'EPSG:3857'.</p> <code>'EPSG:3857'</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Line width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>frequency</code> <code>str</code> <p>Frequency of the timelapse. Defaults to 'year'. Can be year, quarter or month.</p> <code>'year'</code> <code>title</code> <code>str</code> <p>The title of the timelapse. Defaults to None.</p> <code>None</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>add_text</code> <code>bool</code> <p>Whether to add animated text to the timelapse. Defaults to True.</p> <code>True</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to image start dates.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to 'white'.</p> <code>'white'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the GIF to MP4. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>File path to the output GIF image.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def sentinel1_timelapse_legacy(\n    roi=None,\n    out_gif=None,\n    start_year=2015,\n    end_year=None,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n    vis_params=None,\n    dimensions=768,\n    frames_per_second=5,\n    crs=\"EPSG:3857\",\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    frequency=\"year\",\n    title=None,\n    title_xy=(\"2%\", \"90%\"),\n    add_text=True,\n    text_xy=(\"2%\", \"2%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"white\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    loop=0,\n    mp4=False,\n    fading=False,\n):\n\"\"\"Generates a Sentinel-1 timelapse animated GIF or MP4.\n\n    Args:\n        roi (object, optional): Region of interest to create the timelapse. Defaults to LV &amp; Lake Mead.\n        out_gif (str, optional): File path to the output animated GIF. Defaults to user\\Downloads\\s1_ts_*.gif.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 2015.\n        end_year (int, optional): Ending year for the timelapse. Defaults to current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.\n        vis_params (dict, optional): Visualization parameters. Defaults to {'min':-18, 'max': -4}.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 5.\n        crs (str, optional): Coordinate reference system. Defaults to 'EPSG:3857'.\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Line width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        frequency (str, optional): Frequency of the timelapse. Defaults to 'year'. Can be year, quarter or month.\n        title (str, optional): The title of the timelapse. Defaults to None.\n        title_xy (tuple, optional): Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        add_text (bool, optional): Whether to add animated text to the timelapse. Defaults to True.\n        title_xy (tuple, optional): Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to image start dates.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to 'white'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        loop (int, optional): Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        mp4 (bool, optional): Whether to convert the GIF to MP4. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n\n    Returns:\n        str: File path to the output GIF image.\n    \"\"\"\n\n    CURRENT_YEAR, ROI_DEFAULT = sentinel1_defaults()\n    roi = roi or ROI_DEFAULT\n    end_year = end_year or CURRENT_YEAR\n\n    col = sentinel1_timeseries(\n        roi=roi,\n        start_year=start_year,\n        end_year=end_year,\n        start_date=start_date,\n        end_date=end_date,\n        frequency=frequency,\n        clip=True,\n    )\n\n    vis_params = vis_params or {\"min\": -25, \"max\": 5}\n\n    if out_gif is None:\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        filename = \"s1_ts_\" + random_string() + \".gif\"\n        out_gif = os.path.join(out_dir, filename)\n    elif not out_gif.endswith(\".gif\"):\n        print(\"The output file must end with .gif\")\n        return\n    else:\n        out_gif = os.path.abspath(out_gif)\n        out_dir = os.path.dirname(out_gif)\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if overlay_data is not None:\n        col = add_overlay(\n            col, overlay_data, overlay_color, overlay_width, overlay_opacity\n        )\n\n    if isinstance(dimensions, int) and dimensions &gt; 768 or isinstance(dimensions, str) and any(dim&gt;768 for dim in list(map(int,dimensions.split('x')))):\n        count = col.size().getInfo()\n        basename = os.path.basename(out_gif)[:-4]\n        names = [\n            os.path.join(\n                out_dir, f\"{basename}_{str(i+1).zfill(int(len(str(count))))}.jpg\"\n            )\n            for i in range(count)\n        ]\n        get_image_collection_thumbnails(\n            col,\n            out_dir,\n            vis_params=vis_params,\n            dimensions=dimensions,\n            names=names,\n        )\n        make_gif(\n            names,\n            out_gif,\n            fps=frames_per_second,\n            loop=loop,\n            mp4=False,\n            clean_up=True,\n        )\n    else:\n        video_args = vis_params.copy()\n        video_args[\"dimensions\"] = dimensions\n        video_args[\"region\"] = roi\n        video_args[\"framesPerSecond\"] = frames_per_second\n        video_args[\"crs\"] = crs\n        video_args[\"min\"] = vis_params[\"min\"]\n        video_args[\"max\"] = vis_params[\"max\"]\n\n        download_ee_video(col, video_args, out_gif)\n\n    if os.path.exists(out_gif):\n        if title is not None and isinstance(title, str):\n            add_text_to_gif(\n                out_gif,\n                out_gif,\n                xy=title_xy,\n                text_sequence=title,\n                font_type=font_type,\n                font_size=font_size,\n                font_color=font_color,\n                add_progress_bar=add_progress_bar,\n                progress_bar_color=progress_bar_color,\n                progress_bar_height=progress_bar_height,\n                duration=1000 / frames_per_second,\n                loop=loop,\n            )\n        if add_text:\n            if text_sequence is None:\n                text_sequence = col.aggregate_array(\"system:date\").getInfo()\n            add_text_to_gif(\n                out_gif,\n                out_gif,\n                xy=text_xy,\n                text_sequence=text_sequence,\n                font_type=font_type,\n                font_size=font_size,\n                font_color=font_color,\n                add_progress_bar=add_progress_bar,\n                progress_bar_color=progress_bar_color,\n                progress_bar_height=progress_bar_height,\n                duration=1000 / frames_per_second,\n                loop=loop,\n            )\n        if os.path.exists(out_gif):\n            reduce_gif_size(out_gif)\n        if isinstance(fading, bool):\n            fading = int(fading)\n        if fading &gt; 0:\n            gif_fading(out_gif, out_gif, duration=fading, verbose=False)\n        if mp4:\n            out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n            gif_to_mp4(out_gif, out_mp4)\n\n    return out_gif\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.sentinel1_timeseries","title":"<code>sentinel1_timeseries(roi=None, start_year=2015, end_year=None, start_date='01-01', end_date='12-31', frequency='year', clip=False, band='VV', **kwargs)</code>","text":"<pre><code>Generates a Sentinel 1 ImageCollection,\nbased on mean composites following a steady frequency (f.e. 1 image per month)\n</code></pre> <p>Adapted from https://code.earthengine.google.com/?scriptPath=Examples:Datasets/COPERNICUS_S1_GRD</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to a polygon partially covering Las Vegas and Lake Mead.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 2015.</p> <code>2015</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.</p> <code>'01-01'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.</p> <code>'12-31'</code> <code>frequency</code> <code>str</code> <p>Frequency of the timelapse. Defaults to 'year'.  Can be 'year', 'quarter' or 'month'.</p> <code>'year'</code> <code>band</code> <code>str</code> <p>Collection band. Can be one of ['HH','HV','VV','VH']. Defaults to 'VV' which is most commonly available on land.</p> <code>'VV'</code> <code>**kwargs</code> <p>Arguments for sentinel1_filtering().</p> <code>{}</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns an ImageCollection of Sentinel 1 images.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def sentinel1_timeseries(\n    roi=None,\n    start_year=2015,\n    end_year=None,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n    frequency=\"year\",\n    clip=False,\n    band=\"VV\",\n    **kwargs,\n):\n\"\"\"\n        Generates a Sentinel 1 ImageCollection,\n        based on mean composites following a steady frequency (f.e. 1 image per month)\n    Adapted from https://code.earthengine.google.com/?scriptPath=Examples:Datasets/COPERNICUS_S1_GRD\n\n    Args:\n        roi (object, optional): Region of interest to create the timelapse. Defaults to a polygon partially covering Las Vegas and Lake Mead.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 2015.\n        end_year (int, optional): Ending year for the timelapse. Defaults to current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.\n        frequency (str, optional): Frequency of the timelapse. Defaults to 'year'.  Can be 'year', 'quarter' or 'month'.\n        band (str): Collection band. Can be one of ['HH','HV','VV','VH']. Defaults to 'VV' which is most commonly available on land.\n        **kwargs: Arguments for sentinel1_filtering().\n\n    Returns:\n        object: Returns an ImageCollection of Sentinel 1 images.\n    \"\"\"\n\n    CURRENT_YEAR, ROI_DEFAULT = sentinel1_defaults()\n    roi = roi or ROI_DEFAULT\n    end_year = end_year or CURRENT_YEAR\n    roi = valid_roi(roi)\n\n    start = f\"{start_year}-{start_date}\"\n    end = f\"{end_year}-{end_date}\"\n\n    dates = date_sequence(start, end, frequency)\n    col = ee.ImageCollection(\"COPERNICUS/S1_GRD\").filterBounds(roi)\n    col = sentinel1_filtering(col, band=band, **kwargs).select(band)\n\n    n = 1\n    if frequency == \"quarter\":\n        n = 3\n        frequency = \"month\"\n\n    def transform(date):  # coll, frequency\n        start = date\n        end = ee.Date(date).advance(n, frequency).advance(-1, \"day\")\n        return (\n            col.filterDate(start, end)\n            .mean()\n            .set(\n                {\n                    \"system:time_start\": ee.Date(start).millis(),\n                    \"system:time_end\": ee.Date(end).millis(),\n                    \"system:date\": start,\n                }\n            )\n        )\n\n    imgList = dates.map(lambda date: transform(date))\n    imgColl = ee.ImageCollection.fromImages(imgList)\n    if clip:\n        imgColl = imgColl.map(lambda img: img.clip(roi))\n    return imgColl\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.sentinel2_timelapse","title":"<code>sentinel2_timelapse(roi=None, out_gif=None, start_year=2015, end_year=None, start_date='06-10', end_date='09-20', bands=['NIR', 'Red', 'Green'], vis_params=None, dimensions=768, frames_per_second=5, crs='EPSG:3857', apply_fmask=True, overlay_data=None, overlay_color='black', overlay_width=1, overlay_opacity=1.0, frequency='year', date_format=None, title=None, title_xy=('2%', '90%'), add_text=True, text_xy=('2%', '2%'), text_sequence=None, font_type='arial.ttf', font_size=20, font_color='white', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, loop=0, mp4=False, fading=False)</code>","text":"<p>Generates a Sentinel-2 timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to None.</p> <code>None</code> <code>out_gif</code> <code>str</code> <p>File path to the output animated GIF. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 2015.</p> <code>2015</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to None, which means the current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.</p> <code>'06-10'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.</p> <code>'09-20'</code> <code>bands</code> <code>list</code> <p>Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'Red Edge 1', 'Red Edge 2', 'Red Edge 3', 'Red Edge 4']. Defaults to ['NIR', 'Red', 'Green'].</p> <code>['NIR', 'Red', 'Green']</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters. Defaults to None.</p> <code>None</code> <code>dimensions</code> <code>int</code> <p>a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.</p> <code>768</code> <code>frames_per_second</code> <code>int</code> <p>Animation speed. Defaults to 10.</p> <code>5</code> <code>crs</code> <code>str</code> <p>Coordinate reference system. Defaults to 'EPSG:3857'.</p> <code>'EPSG:3857'</code> <code>apply_fmask</code> <code>bool</code> <p>Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.</p> <code>True</code> <code>overlay_data</code> <code>int, str, list</code> <p>Administrative boundary to be drawn on the timelapse. Defaults to None.</p> <code>None</code> <code>overlay_color</code> <code>str</code> <p>Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.</p> <code>'black'</code> <code>overlay_width</code> <code>int</code> <p>Line width of the overlay. Defaults to 1.</p> <code>1</code> <code>overlay_opacity</code> <code>float</code> <p>Opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <code>frequency</code> <code>str</code> <p>Frequency of the timelapse. Defaults to 'year'.</p> <code>'year'</code> <code>date_format</code> <code>str</code> <p>Date format for the timelapse. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the timelapse. Defaults to None.</p> <code>None</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>add_text</code> <code>bool</code> <p>Whether to add animated text to the timelapse. Defaults to True.</p> <code>True</code> <code>title_xy</code> <code>tuple</code> <p>Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>('2%', '90%')</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'white'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the GIF to MP4. Defaults to False.</p> <code>False</code> <code>fading</code> <code>int | bool</code> <p>If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>File path to the output GIF image.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def sentinel2_timelapse(\n    roi=None,\n    out_gif=None,\n    start_year=2015,\n    end_year=None,\n    start_date=\"06-10\",\n    end_date=\"09-20\",\n    bands=[\"NIR\", \"Red\", \"Green\"],\n    vis_params=None,\n    dimensions=768,\n    frames_per_second=5,\n    crs=\"EPSG:3857\",\n    apply_fmask=True,\n    overlay_data=None,\n    overlay_color=\"black\",\n    overlay_width=1,\n    overlay_opacity=1.0,\n    frequency=\"year\",\n    date_format=None,\n    title=None,\n    title_xy=(\"2%\", \"90%\"),\n    add_text=True,\n    text_xy=(\"2%\", \"2%\"),\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"white\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    loop=0,\n    mp4=False,\n    fading=False,\n):\n\"\"\"Generates a Sentinel-2 timelapse GIF image. This function is adapted from https://emaprlab.users.earthengine.app/view/lt-gee-time-series-animator. A huge thank you to Justin Braaten for sharing his fantastic work.\n\n    Args:\n        roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n        out_gif (str, optional): File path to the output animated GIF. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 2015.\n        end_year (int, optional): Ending year for the timelapse. Defaults to None, which means the current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '06-10'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '09-20'.\n        bands (list, optional): Three bands selected from ['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2', 'Red Edge 1', 'Red Edge 2', 'Red Edge 3', 'Red Edge 4']. Defaults to ['NIR', 'Red', 'Green'].\n        vis_params (dict, optional): Visualization parameters. Defaults to None.\n        dimensions (int, optional): a number or pair of numbers (in format 'WIDTHxHEIGHT') Maximum dimensions of the thumbnail to render, in pixels. If only one number is passed, it is used as the maximum, and the other dimension is computed by proportional scaling. Defaults to 768.\n        frames_per_second (int, optional): Animation speed. Defaults to 10.\n        crs (str, optional): Coordinate reference system. Defaults to 'EPSG:3857'.\n        apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.\n        overlay_data (int, str, list, optional): Administrative boundary to be drawn on the timelapse. Defaults to None.\n        overlay_color (str, optional): Color for the overlay data. Can be any color name or hex color code. Defaults to 'black'.\n        overlay_width (int, optional): Line width of the overlay. Defaults to 1.\n        overlay_opacity (float, optional): Opacity of the overlay. Defaults to 1.0.\n        frequency (str, optional): Frequency of the timelapse. Defaults to 'year'.\n        date_format (str, optional): Date format for the timelapse. Defaults to None.\n        title (str, optional): The title of the timelapse. Defaults to None.\n        title_xy (tuple, optional): Lower left corner of the title. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        add_text (bool, optional): Whether to add animated text to the timelapse. Defaults to True.\n        title_xy (tuple, optional): Lower left corner of the text sequency. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        loop (int, optional): Controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n        mp4 (bool, optional): Whether to convert the GIF to MP4. Defaults to False.\n        fading (int | bool, optional): If True, add fading effect to the timelapse. Defaults to False, no fading. To add fading effect, set it to True (1 second fading duration) or to an integer value (fading duration).\n\n    Returns:\n        str: File path to the output GIF image.\n    \"\"\"\n\n    if end_year is None:\n        end_year = datetime.datetime.now().year\n\n    if roi is None:\n        roi = ee.Geometry.Polygon(\n            [\n                [\n                    [-115.471773, 35.892718],\n                    [-115.471773, 36.409454],\n                    [-114.271283, 36.409454],\n                    [-114.271283, 35.892718],\n                    [-115.471773, 35.892718],\n                ]\n            ],\n            None,\n            False,\n        )\n    elif isinstance(roi, ee.Feature) or isinstance(roi, ee.FeatureCollection):\n        roi = roi.geometry()\n    elif isinstance(roi, ee.Geometry):\n        pass\n    else:\n        print(\"The provided roi is invalid. It must be an ee.Geometry\")\n        return\n\n    if out_gif is None:\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        filename = \"s2_ts_\" + random_string() + \".gif\"\n        out_gif = os.path.join(out_dir, filename)\n    elif not out_gif.endswith(\".gif\"):\n        print(\"The output file must end with .gif\")\n        return\n    else:\n        out_gif = os.path.abspath(out_gif)\n        out_dir = os.path.dirname(out_gif)\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    allowed_bands = [\n        \"Blue\",\n        \"Green\",\n        \"Red\",\n        \"Red Edge 1\",\n        \"Red Edge 2\",\n        \"Red Edge 3\",\n        \"NIR\",\n        \"Red Edge 4\",\n        \"SWIR1\",\n        \"SWIR2\",\n        \"QA60\",\n    ]\n\n    if len(bands) == 3 and all(x in allowed_bands for x in bands):\n        pass\n    else:\n        raise Exception(\n            \"You can only select 3 bands from the following: {}\".format(\n                \", \".join(allowed_bands)\n            )\n        )\n\n    try:\n        if vis_params is None:\n            vis_params = {}\n            vis_params[\"bands\"] = bands\n            vis_params[\"min\"] = 0\n            vis_params[\"max\"] = 4000\n            vis_params[\"gamma\"] = [1, 1, 1]\n        col = sentinel2_timeseries_legacy(\n            roi,\n            start_year,\n            end_year,\n            start_date,\n            end_date,\n            apply_fmask,\n            frequency,\n            date_format,\n        )\n\n        col = col.select(bands).map(\n            lambda img: img.visualize(**vis_params).set(\n                {\n                    \"system:time_start\": img.get(\"system:time_start\"),\n                    \"system:date\": img.get(\"system:date\"),\n                }\n            )\n        )\n        if overlay_data is not None:\n            col = add_overlay(\n                col, overlay_data, overlay_color, overlay_width, overlay_opacity\n            )\n\n        if isinstance(dimensions, int) and dimensions &gt; 768 or isinstance(dimensions, str) and any(dim&gt;768 for dim in list(map(int,dimensions.split('x')))):\n            count = col.size().getInfo()\n            basename = os.path.basename(out_gif)[:-4]\n            names = [\n                os.path.join(\n                    out_dir, f\"{basename}_{str(i+1).zfill(int(len(str(count))))}.jpg\"\n                )\n                for i in range(count)\n            ]\n            get_image_collection_thumbnails(\n                col,\n                out_dir,\n                vis_params={\n                    \"min\": 0,\n                    \"max\": 255,\n                    \"bands\": [\"vis-red\", \"vis-green\", \"vis-blue\"],\n                },\n                dimensions=dimensions,\n                names=names,\n            )\n            make_gif(\n                names,\n                out_gif,\n                fps=frames_per_second,\n                loop=loop,\n                mp4=False,\n                clean_up=True,\n            )\n        else:\n            video_args = vis_params.copy()\n            video_args[\"dimensions\"] = dimensions\n            video_args[\"region\"] = roi\n            video_args[\"framesPerSecond\"] = frames_per_second\n            video_args[\"crs\"] = crs\n            video_args[\"bands\"] = [\"vis-red\", \"vis-green\", \"vis-blue\"]\n            video_args[\"min\"] = 0\n            video_args[\"max\"] = 255\n\n            download_ee_video(col, video_args, out_gif)\n\n        if os.path.exists(out_gif):\n            if title is not None and isinstance(title, str):\n                add_text_to_gif(\n                    out_gif,\n                    out_gif,\n                    xy=title_xy,\n                    text_sequence=title,\n                    font_type=font_type,\n                    font_size=font_size,\n                    font_color=font_color,\n                    add_progress_bar=add_progress_bar,\n                    progress_bar_color=progress_bar_color,\n                    progress_bar_height=progress_bar_height,\n                    duration=1000 / frames_per_second,\n                    loop=loop,\n                )\n            if add_text:\n                if text_sequence is None:\n                    text_sequence = col.aggregate_array(\"system:date\").getInfo()\n                add_text_to_gif(\n                    out_gif,\n                    out_gif,\n                    xy=text_xy,\n                    text_sequence=text_sequence,\n                    font_type=font_type,\n                    font_size=font_size,\n                    font_color=font_color,\n                    add_progress_bar=add_progress_bar,\n                    progress_bar_color=progress_bar_color,\n                    progress_bar_height=progress_bar_height,\n                    duration=1000 / frames_per_second,\n                    loop=loop,\n                )\n\n        if os.path.exists(out_gif):\n            reduce_gif_size(out_gif)\n\n        if isinstance(fading, bool):\n            fading = int(fading)\n        if fading &gt; 0:\n            gif_fading(out_gif, out_gif, duration=fading, verbose=False)\n\n        if mp4:\n            out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n            gif_to_mp4(out_gif, out_mp4)\n\n        return out_gif\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.sentinel2_timeseries","title":"<code>sentinel2_timeseries(roi, start_year=2015, end_year=None, start_date='01-01', end_date='12-31', bands=None, mask_cloud=True, cloud_pct=30, frequency='year', reducer='median', drop_empty=True, date_format=None)</code>","text":"<p>Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work.    Images include both level 1C and level 2A imagery.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to None.</p> required <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 2015.</p> <code>2015</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to None, which will use the current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.</p> <code>'01-01'</code> <code>mask_cloud</code> <code>bool</code> <p>Whether to mask clouds. Defaults to True.</p> <code>True</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.</p> <code>'12-31'</code> <code>bands</code> <code>list</code> <p>The list of bands to use to create the timeseries. It must be a list of strings. Defaults to None.</p> <code>None</code> <code>cloud_pct</code> <code>int</code> <p>Maximum cloud percentage to include in the timelapse. Defaults to 30.</p> <code>30</code> <code>frequency</code> <code>str</code> <p>Frequency of the timelapse. Defaults to 'year'.</p> <code>'year'</code> <code>reducer</code> <code>str</code> <p>The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.</p> <code>'median'</code> <code>drop_empty</code> <code>bool</code> <p>Whether to drop empty images from the timeseries. Defaults to True.</p> <code>True</code> <code>date_format</code> <code>str</code> <p>Format of the date. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns an ImageCollection containing annual Sentinel 2 images.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def sentinel2_timeseries(\n    roi,\n    start_year=2015,\n    end_year=None,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n    bands=None,\n    mask_cloud=True,\n    cloud_pct=30,\n    frequency=\"year\",\n    reducer=\"median\",\n    drop_empty=True,\n    date_format=None,\n):\n\"\"\"Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work.\n       Images include both level 1C and level 2A imagery.\n    Args:\n\n        roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 2015.\n        end_year (int, optional): Ending year for the timelapse. Defaults to None, which will use the current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.\n        mask_cloud (bool, optional): Whether to mask clouds. Defaults to True.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.\n        bands (list, optional): The list of bands to use to create the timeseries. It must be a list of strings. Defaults to None.\n        cloud_pct (int, optional): Maximum cloud percentage to include in the timelapse. Defaults to 30.\n        frequency (str, optional): Frequency of the timelapse. Defaults to 'year'.\n        reducer (str, optional):  The reducer to use to reduce the collection of images to a single value. It can be one of the following: 'median', 'mean', 'min', 'max', 'variance', 'sum'. Defaults to 'median'.\n        drop_empty (bool, optional): Whether to drop empty images from the timeseries. Defaults to True.\n        date_format (str, optional): Format of the date. Defaults to None.\n\n    Returns:\n        object: Returns an ImageCollection containing annual Sentinel 2 images.\n    \"\"\"\n    if end_year is None:\n        end_year = datetime.date.today().year\n\n    def maskS2clouds(image):\n        qa = image.select(\"QA60\")\n\n        # Bits 10 and 11 are clouds and cirrus, respectively.\n        cloudBitMask = 1 &lt;&lt; 10\n        cirrusBitMask = 1 &lt;&lt; 11\n\n        # Both flags should be set to zero, indicating clear conditions.\n        mask = qa.bitwiseAnd(cloudBitMask).eq(0).And(qa.bitwiseAnd(cirrusBitMask).eq(0))\n\n        return (\n            image.updateMask(mask)\n            .divide(10000)\n            .set(image.toDictionary(image.propertyNames()))\n        )\n\n    start = f\"{start_year}-{start_date}\"\n    end = f\"{end_year}-{end_date}\"\n    doy_start = ee.Number.parse(ee.Date(start).format(\"D\"))\n    doy_end = ee.Number.parse(ee.Date(end).format(\"D\"))\n    collection = (\n        ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")\n        .filterDate(start, end)\n        .filter(ee.Filter.calendarRange(doy_start, doy_end, \"day_of_year\"))\n        .filter(ee.Filter.lt(\"CLOUDY_PIXEL_PERCENTAGE\", cloud_pct))\n        .filterBounds(roi)\n    )\n\n    if bands is not None:\n        collection = collection.select(bands)\n\n    if mask_cloud:\n        collection = collection.map(maskS2clouds)\n    print(collection.size().getInfo())\n\n    ts = create_timeseries(\n        collection, start, end, roi, bands, frequency, reducer, drop_empty, date_format\n    )\n    return ts\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.sentinel2_timeseries_legacy","title":"<code>sentinel2_timeseries_legacy(roi=None, start_year=2015, end_year=None, start_date='01-01', end_date='12-31', apply_fmask=True, frequency='year', date_format=None)</code>","text":"<p>Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work.    Images include both level 1C and level 2A imagery.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>object</code> <p>Region of interest to create the timelapse. Defaults to None.</p> <code>None</code> <code>start_year</code> <code>int</code> <p>Starting year for the timelapse. Defaults to 2015.</p> <code>2015</code> <code>end_year</code> <code>int</code> <p>Ending year for the timelapse. Defaults to None, which will use the current year.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.</p> <code>'01-01'</code> <code>end_date</code> <code>str</code> <p>Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.</p> <code>'12-31'</code> <code>apply_fmask</code> <code>bool</code> <p>Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.</p> <code>True</code> <code>frequency</code> <code>str</code> <p>Frequency of the timelapse. Defaults to 'year'.</p> <code>'year'</code> <code>date_format</code> <code>str</code> <p>Format of the date. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns an ImageCollection containing annual Sentinel 2 images.</p> Source code in <code>geemap/timelapse.py</code> <pre><code>def sentinel2_timeseries_legacy(\n    roi=None,\n    start_year=2015,\n    end_year=None,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n    apply_fmask=True,\n    frequency=\"year\",\n    date_format=None,\n):\n\"\"\"Generates an annual Sentinel 2 ImageCollection. This algorithm is adapted from https://gist.github.com/jdbcode/76b9ac49faf51627ebd3ff988e10adbc. A huge thank you to Justin Braaten for sharing his fantastic work.\n       Images include both level 1C and level 2A imagery.\n    Args:\n\n        roi (object, optional): Region of interest to create the timelapse. Defaults to None.\n        start_year (int, optional): Starting year for the timelapse. Defaults to 2015.\n        end_year (int, optional): Ending year for the timelapse. Defaults to None, which will use the current year.\n        start_date (str, optional): Starting date (month-day) each year for filtering ImageCollection. Defaults to '01-01'.\n        end_date (str, optional): Ending date (month-day) each year for filtering ImageCollection. Defaults to '12-31'.\n        apply_fmask (bool, optional): Whether to apply Fmask (Function of mask) for automated clouds, cloud shadows, snow, and water masking.\n        frequency (str, optional): Frequency of the timelapse. Defaults to 'year'.\n        date_format (str, optional): Format of the date. Defaults to None.\n\n    Returns:\n        object: Returns an ImageCollection containing annual Sentinel 2 images.\n    \"\"\"\n    ################################################################################\n\n    ################################################################################\n    # Input and output parameters.\n\n    import re\n\n    # import datetime\n\n    if end_year is None:\n        end_year = datetime.date.today().year\n\n    if roi is None:\n        # roi = ee.Geometry.Polygon(\n        #     [[[-180, -80],\n        #       [-180, 80],\n        #         [180, 80],\n        #         [180, -80],\n        #         [-180, -80]]], None, False)\n        roi = ee.Geometry.Polygon(\n            [\n                [\n                    [-115.471773, 35.892718],\n                    [-115.471773, 36.409454],\n                    [-114.271283, 36.409454],\n                    [-114.271283, 35.892718],\n                    [-115.471773, 35.892718],\n                ]\n            ],\n            None,\n            False,\n        )\n\n    if not isinstance(roi, ee.Geometry):\n        try:\n            roi = roi.geometry()\n        except Exception as e:\n            print(\"Could not convert the provided roi to ee.Geometry\")\n            print(e)\n            return\n\n    # Adjusts longitudes less than -180 degrees or greater than 180 degrees.\n    geojson = ee_to_geojson(roi)\n    geojson = adjust_longitude(geojson)\n    roi = ee.Geometry(geojson)\n\n    feq_dict = {\n        \"year\": \"YYYY\",\n        \"month\": \"YYYY-MM\",\n        \"quarter\": \"YYYY-MM\",\n    }\n\n    if date_format is None:\n        date_format = feq_dict[frequency]\n\n    if frequency not in feq_dict:\n        raise ValueError(\"frequency must be year, quarter, or month.\")\n\n    ################################################################################\n    # Setup vars to get dates.\n    if (\n        isinstance(start_year, int)\n        and (start_year &gt;= 2015)\n        and (start_year &lt;= get_current_year())\n    ):\n        pass\n    else:\n        print(\"The start year must be an integer &gt;= 2015.\")\n        return\n\n    if (\n        isinstance(end_year, int)\n        and (end_year &gt;= 2015)\n        and (end_year &lt;= get_current_year())\n    ):\n        pass\n    else:\n        print(f\"The end year must be an integer &lt;= {get_current_year()}.\")\n        return\n\n    if re.match(\"[0-9]{2}\\-[0-9]{2}\", start_date) and re.match(\n        \"[0-9]{2}\\-[0-9]{2}\", end_date\n    ):\n        pass\n    else:\n        print(\"The start data and end date must be month-day, such as 06-10, 09-20\")\n        return\n\n    try:\n        datetime.datetime(int(start_year), int(start_date[:2]), int(start_date[3:5]))\n        datetime.datetime(int(end_year), int(end_date[:2]), int(end_date[3:5]))\n    except Exception as e:\n        raise ValueError(\"The input dates are invalid.\")\n\n    try:\n        start_test = datetime.datetime(\n            int(start_year), int(start_date[:2]), int(start_date[3:5])\n        )\n        end_test = datetime.datetime(\n            int(end_year), int(end_date[:2]), int(end_date[3:5])\n        )\n        if start_test &gt; end_test:\n            raise ValueError(\"Start date must be prior to end date\")\n    except Exception as e:\n        raise Exception(e)\n\n    def days_between(d1, d2):\n        d1 = datetime.datetime.strptime(d1, \"%Y-%m-%d\")\n        d2 = datetime.datetime.strptime(d2, \"%Y-%m-%d\")\n        return abs((d2 - d1).days)\n\n    n_days = days_between(\n        str(start_year) + \"-\" + start_date, str(start_year) + \"-\" + end_date\n    )\n    start_month = int(start_date[:2])\n    start_day = int(start_date[3:5])\n    # start_date = str(start_year) + \"-\" + start_date\n    # end_date = str(end_year) + \"-\" + end_date\n\n    # # Define a collection filter by date, bounds, and quality.\n    # def colFilter(col, aoi):  # , startDate, endDate):\n    #     return(col.filterBounds(aoi))\n\n    # Get Sentinel 2 collections, both Level-1C (top of atmophere) and Level-2A (surface reflectance)\n    MSILCcol = ee.ImageCollection(\"COPERNICUS/S2\")\n    MSI2Acol = ee.ImageCollection(\"COPERNICUS/S2_SR\")\n\n    # Define a collection filter by date, bounds, and quality.\n    def colFilter(col, roi, start_date, end_date):\n        return col.filterBounds(roi).filterDate(start_date, end_date)\n        # .filter('CLOUD_COVER &lt; 5')\n        # .filter('GEOMETRIC_RMSE_MODEL &lt; 15')\n        # .filter('IMAGE_QUALITY == 9 || IMAGE_QUALITY_OLI == 9'))\n\n    # Function to get and rename bands of interest from MSI\n    def renameMSI(img):\n        return img.select(\n            [\"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B11\", \"B12\", \"QA60\"],\n            [\n                \"Blue\",\n                \"Green\",\n                \"Red\",\n                \"Red Edge 1\",\n                \"Red Edge 2\",\n                \"Red Edge 3\",\n                \"NIR\",\n                \"Red Edge 4\",\n                \"SWIR1\",\n                \"SWIR2\",\n                \"QA60\",\n            ],\n        )\n\n    # Add NBR for LandTrendr segmentation.\n\n    def calcNbr(img):\n        return img.addBands(\n            img.normalizedDifference([\"NIR\", \"SWIR2\"]).multiply(-10000).rename(\"NBR\")\n        ).int16()\n\n    # Define function to mask out clouds and cloud shadows in images.\n    # Use CFmask band included in USGS Landsat SR image product.\n\n    def fmask(img):\n        cloudOpaqueBitMask = 1 &lt;&lt; 10\n        cloudCirrusBitMask = 1 &lt;&lt; 11\n        qa = img.select(\"QA60\")\n        mask = (\n            qa.bitwiseAnd(cloudOpaqueBitMask)\n            .eq(0)\n            .And(qa.bitwiseAnd(cloudCirrusBitMask).eq(0))\n        )\n        return img.updateMask(mask)\n\n    # Define function to prepare MSI images.\n    def prepMSI(img):\n        orig = img\n        img = renameMSI(img)\n        if apply_fmask:\n            img = fmask(img)\n        return ee.Image(img.copyProperties(orig, orig.propertyNames())).resample(\n            \"bicubic\"\n        )\n\n    # Get annual median collection.\n    def getAnnualComp(y):\n        startDate = ee.Date.fromYMD(\n            ee.Number(y), ee.Number(start_month), ee.Number(start_day)\n        )\n        endDate = startDate.advance(ee.Number(n_days), \"day\")\n\n        # Filter collections and prepare them for merging.\n        MSILCcoly = colFilter(MSILCcol, roi, startDate, endDate).map(prepMSI)\n        MSI2Acoly = colFilter(MSI2Acol, roi, startDate, endDate).map(prepMSI)\n\n        # Merge the collections.\n        col = MSILCcoly.merge(MSI2Acoly)\n\n        yearImg = col.median()\n        nBands = yearImg.bandNames().size()\n        yearImg = ee.Image(ee.Algorithms.If(nBands, yearImg, dummyImg))\n        return calcNbr(yearImg).set(\n            {\n                \"year\": y,\n                \"system:time_start\": startDate.millis(),\n                \"nBands\": nBands,\n                \"system:date\": ee.Date(startDate).format(date_format),\n            }\n        )\n\n    # Get quarterly median collection.\n    def getQuarterlyComp(startDate):\n        startDate = ee.Date(startDate)\n        endDate = startDate.advance(3, \"month\")\n\n        # Filter collections and prepare them for merging.\n        MSILCcoly = colFilter(MSILCcol, roi, startDate, endDate).map(prepMSI)\n        MSI2Acoly = colFilter(MSI2Acol, roi, startDate, endDate).map(prepMSI)\n\n        # Merge the collections.\n        col = MSILCcoly.merge(MSI2Acoly)\n\n        yearImg = col.median()\n        nBands = yearImg.bandNames().size()\n        yearImg = ee.Image(ee.Algorithms.If(nBands, yearImg, dummyImg))\n        return calcNbr(yearImg).set(\n            {\n                \"system:time_start\": startDate.millis(),\n                \"nBands\": nBands,\n                \"system:date\": ee.Date(startDate).format(date_format),\n            }\n        )\n\n    # Get monthly median collection.\n    def getMonthlyComp(startDate):\n        startDate = ee.Date(startDate)\n        endDate = startDate.advance(1, \"month\")\n\n        # Filter collections and prepare them for merging.\n        MSILCcoly = colFilter(MSILCcol, roi, startDate, endDate).map(prepMSI)\n        MSI2Acoly = colFilter(MSI2Acol, roi, startDate, endDate).map(prepMSI)\n\n        # Merge the collections.\n        col = MSILCcoly.merge(MSI2Acoly)\n\n        yearImg = col.median()\n        nBands = yearImg.bandNames().size()\n        yearImg = ee.Image(ee.Algorithms.If(nBands, yearImg, dummyImg))\n        return calcNbr(yearImg).set(\n            {\n                \"system:time_start\": startDate.millis(),\n                \"nBands\": nBands,\n                \"system:date\": ee.Date(startDate).format(date_format),\n            }\n        )\n\n    ################################################################################\n\n    # Make a dummy image for missing years.\n    bandNames = ee.List(\n        [\n            \"Blue\",\n            \"Green\",\n            \"Red\",\n            \"Red Edge 1\",\n            \"Red Edge 2\",\n            \"Red Edge 3\",\n            \"NIR\",\n            \"Red Edge 4\",\n            \"SWIR1\",\n            \"SWIR2\",\n            \"QA60\",\n        ]\n    )\n    fillerValues = ee.List.repeat(0, bandNames.size())\n    dummyImg = ee.Image.constant(fillerValues).rename(bandNames).selfMask().int16()\n\n    # ################################################################################\n    # # Get a list of years\n    # years = ee.List.sequence(start_year, end_year)\n\n    # ################################################################################\n    # # Make list of annual image composites.\n    # imgList = years.map(getAnnualComp)\n\n    if frequency == \"year\":\n        years = ee.List.sequence(start_year, end_year)\n        imgList = years.map(getAnnualComp)\n    elif frequency == \"quarter\":\n        quarters = date_sequence(\n            str(start_year) + \"-01-01\", str(end_year) + \"-12-31\", \"quarter\", date_format\n        )\n        imgList = quarters.map(getQuarterlyComp)\n    elif frequency == \"month\":\n        months = date_sequence(\n            str(start_year) + \"-01-01\", str(end_year) + \"-12-31\", \"month\", date_format\n        )\n        imgList = months.map(getMonthlyComp)\n\n    # Convert image composite list to collection\n    imgCol = ee.ImageCollection.fromImages(imgList)\n\n    imgCol = imgCol.map(lambda img: img.clip(roi))\n\n    return imgCol\n</code></pre>"},{"location":"timelapse/#geemap.timelapse.vector_to_gif","title":"<code>vector_to_gif(filename, out_gif, colname, vmin=None, vmax=None, step=1, facecolor='black', figsize=(10, 8), padding=3, title=None, add_text=True, xy=('1%', '1%'), fontsize=20, add_progress_bar=True, progress_bar_color='blue', progress_bar_height=5, dpi=300, fps=10, loop=0, mp4=False, keep_png=False, verbose=True, open_args={}, plot_args={})</code>","text":"<p>Convert a vector to a gif. This function was inspired by by Johannes Uhl's shapefile2gif repo at         https://github.com/johannesuhl/shapefile2gif. Credits to Johannes Uhl.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input vector file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"</p> required <code>out_gif</code> <code>str</code> <p>The output gif file.</p> required <code>colname</code> <code>str</code> <p>The column name of the vector that contains numerical values.</p> required <code>vmin</code> <code>float</code> <p>The minimum value to filter the data. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to filter the data. Defaults to None.</p> <code>None</code> <code>step</code> <code>float</code> <p>The step to filter the data. Defaults to 1.</p> <code>1</code> <code>facecolor</code> <code>str</code> <p>The color to visualize the data. Defaults to \"black\".</p> <code>'black'</code> <code>figsize</code> <code>tuple</code> <p>The figure size. Defaults to (10, 8).</p> <code>(10, 8)</code> <code>padding</code> <code>int</code> <p>The padding of the figure tight_layout. Defaults to 3.</p> <code>3</code> <code>title</code> <code>str</code> <p>The title of the figure. Defaults to None.</p> <code>None</code> <code>add_text</code> <code>bool</code> <p>Whether to add text to the figure. Defaults to True.</p> <code>True</code> <code>xy</code> <code>tuple</code> <p>The position of the text from the lower-left corner. Defaults to (\"1%\", \"1%\").</p> <code>('1%', '1%')</code> <code>fontsize</code> <code>int</code> <p>The font size of the text. Defaults to 20.</p> <code>20</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar to the figure. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>The color of the progress bar. Defaults to \"blue\".</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>The height of the progress bar. Defaults to 5.</p> <code>5</code> <code>dpi</code> <code>int</code> <p>The dpi of the figure. Defaults to 300.</p> <code>300</code> <code>fps</code> <code>int</code> <p>The frames per seconc (fps) of the gif. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>int</code> <p>The number of loops of the gif. Defaults to 0, infinite loop.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> <code>keep_png</code> <code>bool</code> <p>Whether to keep the png files. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <code>open_args</code> <code>dict</code> <p>The arguments for the geopandas.read_file() function. Defaults to {}.</p> <code>{}</code> <code>plot_args</code> <code>dict</code> <p>The arguments for the geopandas.GeoDataFrame.plot() function. Defaults to {}.</p> <code>{}</code> Source code in <code>geemap/timelapse.py</code> <pre><code>def vector_to_gif(\n    filename,\n    out_gif,\n    colname,\n    vmin=None,\n    vmax=None,\n    step=1,\n    facecolor=\"black\",\n    figsize=(10, 8),\n    padding=3,\n    title=None,\n    add_text=True,\n    xy=(\"1%\", \"1%\"),\n    fontsize=20,\n    add_progress_bar=True,\n    progress_bar_color=\"blue\",\n    progress_bar_height=5,\n    dpi=300,\n    fps=10,\n    loop=0,\n    mp4=False,\n    keep_png=False,\n    verbose=True,\n    open_args={},\n    plot_args={},\n):\n\"\"\"Convert a vector to a gif. This function was inspired by by Johannes Uhl's shapefile2gif repo at\n            https://github.com/johannesuhl/shapefile2gif. Credits to Johannes Uhl.\n\n    Args:\n        filename (str): The input vector file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"\n        out_gif (str): The output gif file.\n        colname (str): The column name of the vector that contains numerical values.\n        vmin (float, optional): The minimum value to filter the data. Defaults to None.\n        vmax (float, optional): The maximum value to filter the data. Defaults to None.\n        step (float, optional): The step to filter the data. Defaults to 1.\n        facecolor (str, optional): The color to visualize the data. Defaults to \"black\".\n        figsize (tuple, optional): The figure size. Defaults to (10, 8).\n        padding (int, optional): The padding of the figure tight_layout. Defaults to 3.\n        title (str, optional): The title of the figure. Defaults to None.\n        add_text (bool, optional): Whether to add text to the figure. Defaults to True.\n        xy (tuple, optional): The position of the text from the lower-left corner. Defaults to (\"1%\", \"1%\").\n        fontsize (int, optional): The font size of the text. Defaults to 20.\n        add_progress_bar (bool, optional): Whether to add a progress bar to the figure. Defaults to True.\n        progress_bar_color (str, optional): The color of the progress bar. Defaults to \"blue\".\n        progress_bar_height (int, optional): The height of the progress bar. Defaults to 5.\n        dpi (int, optional): The dpi of the figure. Defaults to 300.\n        fps (int, optional): The frames per seconc (fps) of the gif. Defaults to 10.\n        loop (int, optional): The number of loops of the gif. Defaults to 0, infinite loop.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n        keep_png (bool, optional): Whether to keep the png files. Defaults to False.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n        open_args (dict, optional): The arguments for the geopandas.read_file() function. Defaults to {}.\n        plot_args (dict, optional): The arguments for the geopandas.GeoDataFrame.plot() function. Defaults to {}.\n\n    \"\"\"\n    import geopandas as gpd\n    import matplotlib.pyplot as plt\n\n    out_dir = os.path.dirname(out_gif)\n    tmp_dir = os.path.join(out_dir, \"tmp_png\")\n    if not os.path.exists(tmp_dir):\n        os.makedirs(tmp_dir)\n\n    if isinstance(filename, str):\n        gdf = gpd.read_file(filename, **open_args)\n    elif isinstance(filename, gpd.GeoDataFrame):\n        gdf = filename\n    else:\n        raise ValueError(\n            \"filename must be a string or a geopandas.GeoDataFrame object.\"\n        )\n\n    bbox = gdf.total_bounds\n\n    if colname not in gdf.columns:\n        raise Exception(\n            f\"{colname} is not in the columns of the GeoDataFrame. It must be one of {gdf.columns}\"\n        )\n\n    values = gdf[colname].unique().tolist()\n    values.sort()\n\n    if vmin is None:\n        vmin = values[0]\n    if vmax is None:\n        vmax = values[-1]\n\n    options = range(vmin, vmax + step, step)\n\n    W = bbox[2] - bbox[0]\n    H = bbox[3] - bbox[1]\n\n    if xy is None:\n        # default text location is 5% width and 5% height of the image.\n        xy = (int(0.05 * W), int(0.05 * H))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        raise Exception(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; W) and (y &gt; 0) and (y &lt; H):\n            pass\n        else:\n            print(\n                f\"xy is out of bounds. x must be within [0, {W}], and y must be within [0, {H}]\"\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = float(x.replace(\"%\", \"\")) / 100.0 * W\n                y = float(y.replace(\"%\", \"\")) / 100.0 * H\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n    else:\n        raise Exception(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n\n    x = bbox[0] + x\n    y = bbox[1] + y\n\n    for index, v in enumerate(options):\n        if verbose:\n            print(f\"Processing {index+1}/{len(options)}: {v}...\")\n        yrdf = gdf[gdf[colname] &lt;= v]\n        fig, ax = plt.subplots()\n        ax = yrdf.plot(facecolor=facecolor, figsize=figsize, **plot_args)\n        ax.set_title(title, fontsize=fontsize)\n        ax.set_axis_off()\n        ax.set_xlim([bbox[0], bbox[2]])\n        ax.set_ylim([bbox[1], bbox[3]])\n        if add_text:\n            ax.text(x, y, v, fontsize=fontsize)\n        fig = ax.get_figure()\n        plt.tight_layout(pad=padding)\n        fig.savefig(tmp_dir + os.sep + \"%s.png\" % v, dpi=dpi)\n        plt.clf()\n        plt.close(\"all\")\n\n    png_to_gif(tmp_dir, out_gif, fps=fps, loop=loop)\n\n    if add_progress_bar:\n        add_progress_bar_to_gif(\n            out_gif,\n            out_gif,\n            progress_bar_color,\n            progress_bar_height,\n            duration=1000 / fps,\n            loop=loop,\n        )\n\n    if mp4:\n        gif_to_mp4(out_gif, out_gif.replace(\".gif\", \".mp4\"))\n\n    if not keep_png:\n        shutil.rmtree(tmp_dir)\n\n    if verbose:\n        print(f\"Done. The GIF is saved to {out_gif}.\")\n</code></pre>"},{"location":"toolbar/","title":"toolbar module","text":"<p>Module for dealing with the toolbar.</p>"},{"location":"toolbar/#geemap.toolbar.build_toolbox","title":"<code>build_toolbox(tools_dict, max_width='1080px', max_height='600px')</code>","text":"<p>Build the GEE toolbox.</p> <p>Parameters:</p> Name Type Description Default <code>tools_dict</code> <code>dict</code> <p>A dictionary containing information for all tools.</p> required <code>max_width</code> <code>str</code> <p>The maximum width of the widget.</p> <code>'1080px'</code> <code>max_height</code> <code>str</code> <p>The maximum height of the widget.</p> <code>'600px'</code> <p>Returns:</p> Type Description <code>object</code> <p>An ipywidget representing the toolbox.</p> Source code in <code>geemap/toolbar.py</code> <pre><code>def build_toolbox(tools_dict, max_width=\"1080px\", max_height=\"600px\"):\n\"\"\"Build the GEE toolbox.\n\n    Args:\n        tools_dict (dict): A dictionary containing information for all tools.\n        max_width (str, optional): The maximum width of the widget.\n        max_height (str, optional): The maximum height of the widget.\n\n    Returns:\n        object: An ipywidget representing the toolbox.\n    \"\"\"\n    left_widget = widgets.VBox(layout=widgets.Layout(min_width=\"175px\"))\n    center_widget = widgets.VBox(\n        layout=widgets.Layout(min_width=\"200px\", max_width=\"200px\")\n    )\n    right_widget = widgets.Output(\n        layout=widgets.Layout(width=\"630px\", max_height=max_height)\n    )\n    full_widget = widgets.HBox(\n        [left_widget, center_widget, right_widget],\n        layout=widgets.Layout(max_width=max_width, max_height=max_height),\n    )\n\n    search_widget = widgets.Text(\n        placeholder=\"Search tools ...\", layout=widgets.Layout(width=\"170px\")\n    )\n    label_widget = widgets.Label(layout=widgets.Layout(width=\"170px\"))\n    label_widget.value = f\"{len(tools_dict)} Available Tools\"\n    close_btn = widgets.Button(\n        description=\"Close Toolbox\", icon=\"close\", layout=widgets.Layout(width=\"170px\")\n    )\n\n    categories = {}\n    categories[\"All Tools\"] = []\n    for key in tools_dict.keys():\n        category = tools_dict[key][\"category\"]\n        if category not in categories.keys():\n            categories[category] = []\n        categories[category].append(tools_dict[key][\"name\"])\n        categories[\"All Tools\"].append(tools_dict[key][\"name\"])\n\n    options = list(categories.keys())\n    all_tools = categories[\"All Tools\"]\n    all_tools.sort()\n    category_widget = widgets.Select(\n        options=options, layout=widgets.Layout(width=\"170px\", height=\"165px\")\n    )\n    tools_widget = widgets.Select(\n        options=[], layout=widgets.Layout(width=\"195px\", height=\"400px\")\n    )\n\n    def category_selected(change):\n        if change[\"new\"]:\n            selected = change[\"owner\"].value\n            options = categories[selected]\n            options.sort()\n            tools_widget.options = options\n            label_widget.value = f\"{len(options)} Available Tools\"\n\n    category_widget.observe(category_selected, \"value\")\n\n    def tool_selected(change):\n        if change[\"new\"]:\n            selected = change[\"owner\"].value\n            tool_dict = tools_dict[selected]\n            with right_widget:\n                right_widget.clear_output()\n                display(tool_gui(tool_dict, max_height=max_height))\n\n    tools_widget.observe(tool_selected, \"value\")\n\n    def search_changed(change):\n        if change[\"new\"]:\n            keyword = change[\"owner\"].value\n            if len(keyword) &gt; 0:\n                selected_tools = []\n                for tool in all_tools:\n                    if keyword.lower() in tool.lower():\n                        selected_tools.append(tool)\n                if len(selected_tools) &gt; 0:\n                    tools_widget.options = selected_tools\n                label_widget.value = f\"{len(selected_tools)} Available Tools\"\n        else:\n            tools_widget.options = all_tools\n            label_widget.value = f\"{len(tools_dict)} Available Tools\"\n\n    search_widget.observe(search_changed, \"value\")\n\n    def close_btn_clicked(b):\n        full_widget.close()\n\n    close_btn.on_click(close_btn_clicked)\n\n    category_widget.value = list(categories.keys())[0]\n    tools_widget.options = all_tools\n    left_widget.children = [category_widget, search_widget, label_widget, close_btn]\n    center_widget.children = [tools_widget]\n\n    return full_widget\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.change_basemap","title":"<code>change_basemap(m)</code>","text":"<p>Widget for change basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>geemap.Map()</p> required Source code in <code>geemap/toolbar.py</code> <pre><code>def change_basemap(m):\n\"\"\"Widget for change basemaps.\n\n    Args:\n        m (object): geemap.Map()\n    \"\"\"\n    from .geemap import basemaps\n\n    dropdown = widgets.Dropdown(\n        options=list(basemaps.keys()),\n        value=\"ROADMAP\",\n        layout=widgets.Layout(width=\"200px\")\n        # description=\"Basemaps\",\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the basemap widget\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    basemap_widget = widgets.HBox([dropdown, close_btn])\n\n    def on_click(change):\n        basemap_name = change[\"new\"]\n\n        if len(m.layers) == 1:\n            old_basemap = m.layers[0]\n        else:\n            old_basemap = m.layers[1]\n        m.substitute_layer(old_basemap, basemaps[basemap_name])\n\n    dropdown.observe(on_click, \"value\")\n\n    def close_click(change):\n        m.toolbar_reset()\n        if m.basemap_ctrl is not None and m.basemap_ctrl in m.controls:\n            m.remove_control(m.basemap_ctrl)\n        basemap_widget.close()\n\n    close_btn.on_click(close_click)\n\n    basemap_control = ipyleaflet.WidgetControl(\n        widget=basemap_widget, position=\"topright\"\n    )\n    m.add_control(basemap_control)\n    m.basemap_ctrl = basemap_control\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.convert_js2py","title":"<code>convert_js2py(m)</code>","text":"<p>A widget for converting Earth Engine JavaScript to Python.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>geemap.Map</p> required Source code in <code>geemap/toolbar.py</code> <pre><code>def convert_js2py(m):\n\"\"\"A widget for converting Earth Engine JavaScript to Python.\n\n    Args:\n        m (object): geemap.Map\n    \"\"\"\n\n    full_widget = widgets.VBox(layout=widgets.Layout(width=\"465px\", height=\"350px\"))\n\n    text_widget = widgets.Textarea(\n        placeholder=\"Paste your Earth Engine JavaScript into this textbox and click the Convert button below to convert the Javascript to Python\",\n        layout=widgets.Layout(width=\"455px\", height=\"310px\"),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Convert\", \"Clear\", \"Close\"],\n        tooltips=[\"Convert\", \"Clear\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"128px\"\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Convert\":\n            from .conversion import create_new_cell, js_snippet_to_py\n\n            if len(text_widget.value) &gt; 0:\n                out_lines = js_snippet_to_py(\n                    text_widget.value,\n                    add_new_cell=False,\n                    import_ee=False,\n                    import_geemap=False,\n                    show_map=False,\n                )\n                if len(out_lines) &gt; 0 and len(out_lines[0].strip()) == 0:\n                    out_lines = out_lines[1:]\n\n                prefix = \"# The code has been copied to the clipboard. \\n# Press Ctrl+V to in a code cell to paste it.\\n\"\n                text_widget.value = \"\".join([prefix] + out_lines)\n                create_code_cell(\"\".join(out_lines))\n\n        elif change[\"new\"] == \"Clear\":\n            text_widget.value = \"\"\n        elif change[\"new\"] == \"Close\":\n            m.toolbar_reset()\n            if m.convert_ctrl is not None and m.convert_ctrl in m.controls:\n                m.remove_control(m.convert_ctrl)\n            full_widget.close()\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    full_widget.children = [text_widget, buttons]\n    widget_control = ipyleaflet.WidgetControl(widget=full_widget, position=\"topright\")\n    m.add_control(widget_control)\n    m.convert_ctrl = widget_control\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.inspector_gui","title":"<code>inspector_gui(m=None)</code>","text":"<p>Generates a tool GUI template using ipywidgets.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>geemap.Map</code> <p>The leaflet Map object. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>geemap/toolbar.py</code> <pre><code>def inspector_gui(m=None):\n\"\"\"Generates a tool GUI template using ipywidgets.\n\n    Args:\n        m (geemap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import pandas as pd\n\n    widget_width = \"250px\"\n    padding = \"0px 5px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    if m is not None:\n        marker_cluster = ipyleaflet.MarkerCluster(name=\"Inspector Markers\")\n        setattr(m, \"pixel_values\", [])\n        setattr(m, \"marker_cluster\", marker_cluster)\n\n        if not hasattr(m, \"interact_mode\"):\n            setattr(m, \"interact_mode\", False)\n\n        if not hasattr(m, \"inspector_output\"):\n            inspector_output = widgets.Output(\n                layout=widgets.Layout(width=widget_width, padding=\"0px 5px 5px 5px\")\n            )\n            setattr(m, \"inspector_output\", inspector_output)\n\n        output = m.inspector_output\n        output.clear_output()\n\n        if not hasattr(m, \"inspector_add_marker\"):\n            inspector_add_marker = widgets.Checkbox(\n                description=\"Add Marker at clicked location\",\n                value=True,\n                indent=False,\n                layout=widgets.Layout(padding=padding, width=widget_width),\n            )\n            setattr(m, \"inspector_add_marker\", inspector_add_marker)\n        add_marker = m.inspector_add_marker\n\n        if not hasattr(m, \"inspector_bands_chk\"):\n            inspector_bands_chk = widgets.Checkbox(\n                description=\"Get pixel value for visible bands only\",\n                indent=False,\n                layout=widgets.Layout(padding=padding, width=widget_width),\n            )\n            setattr(m, \"inspector_bands_chk\", inspector_bands_chk)\n        bands_chk = m.inspector_bands_chk\n\n        if not hasattr(m, \"inspector_class_label\"):\n            inspector_label = widgets.Text(\n                value=\"\",\n                description=\"Class label:\",\n                placeholder=\"Add a label to the marker\",\n                style=style,\n                layout=widgets.Layout(width=widget_width, padding=padding),\n            )\n            setattr(m, \"inspector_class_label\", inspector_label)\n        label = m.inspector_class_label\n\n        options = []\n        if hasattr(m, \"cog_layer_dict\"):\n            options = list(m.cog_layer_dict.keys())\n            options.sort()\n        if len(options) == 0:\n            default_option = None\n        else:\n            default_option = options[0]\n        if not hasattr(m, \"inspector_dropdown\"):\n            inspector_dropdown = widgets.Dropdown(\n                options=options,\n                value=default_option,\n                description=\"Select a layer:\",\n                layout=widgets.Layout(width=widget_width, padding=padding),\n                style=style,\n            )\n            setattr(m, \"inspector_dropdown\", inspector_dropdown)\n\n        dropdown = m.inspector_dropdown\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"info-circle\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Download\", \"Reset\", \"Close\"],\n        tooltips=[\"Download\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    if len(options) == 0:\n        with output:\n            print(\"No COG/STAC layers available\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        add_marker,\n        label,\n        dropdown,\n        bands_chk,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def chk_change(change):\n        if hasattr(m, \"pixel_values\"):\n            m.pixel_values = []\n        if hasattr(m, \"marker_cluster\"):\n            m.marker_cluster.markers = []\n        output.clear_output()\n\n    bands_chk.observe(chk_change, \"value\")\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                if hasattr(m, \"inspector_mode\"):\n                    delattr(m, \"inspector_mode\")\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.default_style = {\"cursor\": \"default\"}\n\n                m.marker_cluster.markers = []\n                m.pixel_values = []\n                marker_cluster_layer = m.find_layer(\"Inspector Markers\")\n                if marker_cluster_layer is not None:\n                    m.remove_layer(marker_cluster_layer)\n\n                if hasattr(m, \"pixel_values\"):\n                    delattr(m, \"pixel_values\")\n\n                if hasattr(m, \"marker_cluster\"):\n                    delattr(m, \"marker_cluster\")\n\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Download\":\n            with output:\n                output.clear_output()\n                if len(m.pixel_values) == 0:\n                    print(\n                        \"No pixel values available. Click on the map to start collection data.\"\n                    )\n                else:\n                    print(\"Downloading pixel values...\")\n                    df = pd.DataFrame(m.pixel_values)\n                    temp_csv = temp_file_path(\"csv\")\n                    df.to_csv(temp_csv, index=False)\n                    link = create_download_link(temp_csv)\n                    with output:\n                        output.clear_output()\n                        display(link)\n        elif change[\"new\"] == \"Reset\":\n            label.value = \"\"\n            output.clear_output()\n            if hasattr(m, \"pixel_values\"):\n                m.pixel_values = []\n            if hasattr(m, \"marker_cluster\"):\n                m.marker_cluster.markers = []\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                if hasattr(m, \"inspector_mode\"):\n                    delattr(m, \"inspector_mode\")\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.default_style = {\"cursor\": \"default\"}\n                m.marker_cluster.markers = []\n                marker_cluster_layer = m.find_layer(\"Inspector Markers\")\n                if marker_cluster_layer is not None:\n                    m.remove_layer(marker_cluster_layer)\n                m.pixel_values = []\n\n                if hasattr(m, \"pixel_values\"):\n                    delattr(m, \"pixel_values\")\n\n                if hasattr(m, \"marker_cluster\"):\n                    delattr(m, \"marker_cluster\")\n\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n\n    def handle_interaction(**kwargs):\n        latlon = kwargs.get(\"coordinates\")\n        lat = round(latlon[0], 4)\n        lon = round(latlon[1], 4)\n        if (\n            kwargs.get(\"type\") == \"click\"\n            and hasattr(m, \"inspector_mode\")\n            and m.inspector_mode\n        ):\n            m.default_style = {\"cursor\": \"wait\"}\n\n            with output:\n                output.clear_output()\n                print(\"Getting pixel value ...\")\n\n                layer_dict = m.cog_layer_dict[dropdown.value]\n\n            if layer_dict[\"type\"] == \"STAC\":\n                if bands_chk.value:\n                    assets = layer_dict[\"assets\"]\n                else:\n                    assets = None\n\n                result = stac_pixel_value(\n                    lon,\n                    lat,\n                    layer_dict[\"url\"],\n                    layer_dict[\"collection\"],\n                    layer_dict[\"items\"],\n                    assets,\n                    layer_dict[\"titiler_endpoint\"],\n                    verbose=False,\n                )\n                if result is not None:\n                    with output:\n                        output.clear_output()\n                        print(f\"lat/lon: {lat:.4f}, {lon:.4f}\\n\")\n                        for key in result:\n                            print(f\"{key}: {result[key]}\")\n\n                        result[\"latitude\"] = lat\n                        result[\"longitude\"] = lon\n                        result[\"label\"] = label.value\n                        m.pixel_values.append(result)\n                    if add_marker.value:\n                        markers = list(m.marker_cluster.markers)\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        m.marker_cluster.markers = markers\n\n                else:\n                    with output:\n                        output.clear_output()\n                        print(\"No pixel value available\")\n                        bounds = m.cog_layer_dict[m.inspector_dropdown.value][\"bounds\"]\n                        m.zoom_to_bounds(bounds)\n            elif layer_dict[\"type\"] == \"COG\":\n                result = cog_pixel_value(lon, lat, layer_dict[\"url\"], verbose=False)\n                if result is not None:\n                    with output:\n                        output.clear_output()\n                        print(f\"lat/lon: {lat:.4f}, {lon:.4f}\\n\")\n                        for key in result:\n                            print(f\"{key}: {result[key]}\")\n\n                        result[\"latitude\"] = lat\n                        result[\"longitude\"] = lon\n                        result[\"label\"] = label.value\n                        m.pixel_values.append(result)\n                    if add_marker.value:\n                        markers = list(m.marker_cluster.markers)\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        m.marker_cluster.markers = markers\n                else:\n                    with output:\n                        output.clear_output()\n                        print(\"No pixel value available\")\n                        bounds = m.cog_layer_dict[m.inspector_dropdown.value][\"bounds\"]\n                        m.zoom_to_bounds(bounds)\n\n            elif layer_dict[\"type\"] == \"LOCAL\":\n                result = local_tile_pixel_value(\n                    lon, lat, layer_dict[\"tile_client\"], verbose=False\n                )\n                if result is not None:\n                    if m.inspector_bands_chk.value:\n                        band = m.cog_layer_dict[m.inspector_dropdown.value][\"band\"]\n                        band_names = m.cog_layer_dict[m.inspector_dropdown.value][\n                            \"band_names\"\n                        ]\n                        if band is not None:\n                            sel_bands = [band_names[b - 1] for b in band]\n                            result = {k: v for k, v in result.items() if k in sel_bands}\n                    with output:\n                        output.clear_output()\n                        print(f\"lat/lon: {lat:.4f}, {lon:.4f}\\n\")\n                        for key in result:\n                            print(f\"{key}: {result[key]}\")\n\n                        result[\"latitude\"] = lat\n                        result[\"longitude\"] = lon\n                        result[\"label\"] = label.value\n                        m.pixel_values.append(result)\n                    if add_marker.value:\n                        markers = list(m.marker_cluster.markers)\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        m.marker_cluster.markers = markers\n                else:\n                    with output:\n                        output.clear_output()\n                        print(\"No pixel value available\")\n                        bounds = m.cog_layer_dict[m.inspector_dropdown.value][\"bounds\"]\n                        m.zoom_to_bounds(bounds)\n            m.default_style = {\"cursor\": \"crosshair\"}\n\n    if m is not None:\n        if not hasattr(m, \"marker_cluster\"):\n            setattr(m, \"marker_cluster\", marker_cluster)\n        m.add_layer(marker_cluster)\n\n        if not m.interact_mode:\n            m.on_interaction(handle_interaction)\n            m.interact_mode = True\n\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n            m.tool_control = toolbar_control\n\n        if not hasattr(m, \"inspector_mode\"):\n            if hasattr(m, \"cog_layer_dict\"):\n                setattr(m, \"inspector_mode\", True)\n            else:\n                setattr(m, \"inspector_mode\", False)\n\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.open_data_widget","title":"<code>open_data_widget(m)</code>","text":"<p>A widget for opening local vector/raster data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>geemap.Map</p> required Source code in <code>geemap/toolbar.py</code> <pre><code>def open_data_widget(m):\n\"\"\"A widget for opening local vector/raster data.\n\n    Args:\n        m (object): geemap.Map\n    \"\"\"\n    from .colormaps import list_colormaps\n\n    padding = \"0px 0px 0px 5px\"\n    style = {\"description_width\": \"initial\"}\n\n    tool_output = widgets.Output()\n    tool_output_ctrl = ipyleaflet.WidgetControl(widget=tool_output, position=\"topright\")\n\n    if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n        m.remove_control(m.tool_output_ctrl)\n\n    file_type = widgets.ToggleButtons(\n        options=[\"Shapefile\", \"GeoJSON\", \"CSV\", \"Vector\", \"Raster\"],\n        tooltips=[\n            \"Open a shapefile\",\n            \"Open a GeoJSON file\",\n            \"Open a vector dataset\",\n            \"Create points from CSV\",\n            \"Open a vector dataset\",\n            \"Open a raster dataset\",\n        ],\n    )\n    file_type.style.button_width = \"88px\"\n\n    filepath = widgets.Text(\n        value=\"\",\n        description=\"File path or http URL:\",\n        tooltip=\"Enter a file path or http URL to vector data\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n    http_widget = widgets.HBox()\n\n    file_chooser = FileChooser(\n        os.getcwd(), sandbox_path=m.sandbox_path, layout=widgets.Layout(width=\"454px\")\n    )\n    file_chooser.filter_pattern = \"*.shp\"\n    file_chooser.use_dir_icons = True\n\n    style = {\"description_width\": \"initial\"}\n    layer_name = widgets.Text(\n        value=\"Shapefile\",\n        description=\"Enter a layer name:\",\n        tooltip=\"Enter a layer name for the selected file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=\"0px 0px 0px 5px\"),\n    )\n\n    longitude = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Longitude:\",\n        layout=widgets.Layout(width=\"149px\", padding=\"0px 0px 0px 5px\"),\n        style={\"description_width\": \"initial\"},\n    )\n\n    latitude = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Latitude:\",\n        layout=widgets.Layout(width=\"149px\", padding=\"0px 0px 0px 5px\"),\n        style={\"description_width\": \"initial\"},\n    )\n\n    label = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Label:\",\n        layout=widgets.Layout(width=\"149px\", padding=\"0px 0px 0px 5px\"),\n        style={\"description_width\": \"initial\"},\n    )\n\n    csv_widget = widgets.HBox()\n\n    convert_bool = widgets.Checkbox(\n        description=\"Convert to ee.FeatureCollection?\",\n        indent=False,\n        layout=widgets.Layout(padding=\"0px 0px 0px 5px\"),\n    )\n    convert_hbox = widgets.HBox([convert_bool])\n\n    ok_cancel = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    # ok_cancel.style.button_width = \"133px\"\n\n    bands = widgets.Text(\n        value=None,\n        description=\"Band:\",\n        tooltip=\"Enter a list of band indices\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    vmin = widgets.Text(\n        value=None,\n        description=\"vmin:\",\n        tooltip=\"Minimum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\"),\n    )\n\n    vmax = widgets.Text(\n        value=None,\n        description=\"vmax:\",\n        tooltip=\"Maximum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\"),\n    )\n\n    nodata = widgets.Text(\n        value=None,\n        description=\"Nodata:\",\n        tooltip=\"Nodata the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    palette = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"palette:\",\n        layout=widgets.Layout(width=\"300px\"),\n        style=style,\n    )\n\n    raster_options = widgets.VBox()\n\n    main_widget = widgets.VBox(\n        [\n            file_type,\n            file_chooser,\n            http_widget,\n            csv_widget,\n            layer_name,\n            convert_hbox,\n            raster_options,\n            ok_cancel,\n        ]\n    )\n\n    tool_output.clear_output()\n    with tool_output:\n        display(main_widget)\n\n    def bands_changed(change):\n        if change[\"new\"] and \",\" in change[\"owner\"].value:\n            palette.value = None\n            palette.disabled = True\n        else:\n            palette.disabled = False\n\n    bands.observe(bands_changed, \"value\")\n\n    def chooser_callback(chooser):\n        filepath.value = file_chooser.selected\n\n        if file_type.value == \"CSV\":\n            import pandas as pd\n\n            df = pd.read_csv(filepath.value)\n            col_names = df.columns.values.tolist()\n            longitude.options = col_names\n            latitude.options = col_names\n            label.options = col_names\n\n            if \"longitude\" in col_names:\n                longitude.value = \"longitude\"\n            if \"latitude\" in col_names:\n                latitude.value = \"latitude\"\n            if \"name\" in col_names:\n                label.value = \"name\"\n\n    file_chooser.register_callback(chooser_callback)\n\n    def file_type_changed(change):\n        ok_cancel.value = None\n        file_chooser.default_path = os.getcwd()\n        file_chooser.reset()\n        layer_name.value = file_type.value\n        csv_widget.children = []\n        filepath.value = \"\"\n\n        if change[\"new\"] == \"Shapefile\":\n            file_chooser.filter_pattern = \"*.shp\"\n            raster_options.children = []\n            convert_hbox.children = [convert_bool]\n            http_widget.children = []\n        elif change[\"new\"] == \"GeoJSON\":\n            file_chooser.filter_pattern = \"*.geojson\"\n            raster_options.children = []\n            convert_hbox.children = [convert_bool]\n            http_widget.children = [filepath]\n        elif change[\"new\"] == \"Vector\":\n            file_chooser.filter_pattern = \"*.*\"\n            raster_options.children = []\n            convert_hbox.children = [convert_bool]\n            http_widget.children = [filepath]\n        elif change[\"new\"] == \"CSV\":\n            file_chooser.filter_pattern = [\"*.csv\", \"*.CSV\"]\n            csv_widget.children = [longitude, latitude, label]\n            raster_options.children = []\n            convert_hbox.children = [convert_bool]\n            http_widget.children = [filepath]\n        elif change[\"new\"] == \"Raster\":\n            file_chooser.filter_pattern = [\"*.tif\", \"*.img\"]\n            palette.options = list_colormaps(add_extra=True)\n            palette.value = None\n            raster_options.children = [\n                widgets.HBox([bands, vmin, vmax]),\n                widgets.HBox([nodata, palette]),\n            ]\n            convert_hbox.children = []\n            http_widget.children = [filepath]\n\n    def ok_cancel_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            m.default_style = {\"cursor\": \"wait\"}\n            file_path = filepath.value\n\n            if file_path is not None:\n                ext = os.path.splitext(file_path)[1]\n                with tool_output:\n                    if ext.lower() == \".shp\":\n                        if convert_bool.value:\n                            ee_object = shp_to_ee(file_path)\n                            m.addLayer(ee_object, {}, layer_name.value)\n                        else:\n                            m.add_shapefile(\n                                file_path, style={}, layer_name=layer_name.value\n                            )\n                    elif ext.lower() == \".geojson\":\n                        if convert_bool.value:\n                            ee_object = geojson_to_ee(file_path)\n                            m.addLayer(ee_object, {}, layer_name.value)\n                        else:\n                            m.add_geojson(\n                                file_path, style={}, layer_name=layer_name.value\n                            )\n\n                    elif ext.lower() == \".csv\":\n                        if convert_bool.value:\n                            ee_object = csv_to_ee(\n                                file_path, latitude.value, longitude.value\n                            )\n                            m.addLayer(ee_object, {}, layer_name.value)\n                        else:\n                            m.add_xy_data(\n                                file_path,\n                                x=longitude.value,\n                                y=latitude.value,\n                                label=label.value,\n                                layer_name=layer_name.value,\n                            )\n\n                    elif ext.lower() in [\".tif\", \"img\"] and file_type.value == \"Raster\":\n                        band = None\n                        vis_min = None\n                        vis_max = None\n                        vis_nodata = None\n\n                        try:\n                            if len(bands.value) &gt; 0:\n                                band = bands.value.split(\",\")\n                            if len(vmin.value) &gt; 0:\n                                vis_min = float(vmin.value)\n                            if len(vmax.value) &gt; 0:\n                                vis_max = float(vmax.value)\n                            if len(nodata.value) &gt; 0:\n                                vis_nodata = float(nodata.value)\n                        except Exception as _:\n                            pass\n\n                        m.add_local_tile(\n                            file_path,\n                            layer_name=layer_name.value,\n                            band=band,\n                            palette=palette.value,\n                            vmin=vis_min,\n                            vmax=vis_max,\n                            nodata=vis_nodata,\n                        )\n                    else:\n                        m.add_vector(file_path, style={}, layer_name=layer_name.value)\n            else:\n                print(\"Please select a file to open.\")\n\n            m.toolbar_reset()\n            m.default_style = {\"cursor\": \"default\"}\n\n        elif change[\"new\"] == \"Reset\":\n            file_chooser.reset()\n            tool_output.clear_output()\n            with tool_output:\n                display(main_widget)\n            m.toolbar_reset()\n        elif change[\"new\"] == \"Close\":\n            if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n                m.remove_control(m.tool_output_ctrl)\n                m.tool_output_ctrl = None\n                m.toolbar_reset()\n\n        ok_cancel.value = None\n\n    file_type.observe(file_type_changed, names=\"value\")\n    ok_cancel.observe(ok_cancel_clicked, names=\"value\")\n    # file_chooser.register_callback(chooser_callback)\n\n    m.add_control(tool_output_ctrl)\n    m.tool_output_ctrl = tool_output_ctrl\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.plotly_basemap_gui","title":"<code>plotly_basemap_gui(canvas, map_min_width='78%', map_max_width='98%')</code>","text":"<p>Widget for changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>geemap.Map.</p> required Source code in <code>geemap/toolbar.py</code> <pre><code>def plotly_basemap_gui(canvas, map_min_width=\"78%\", map_max_width=\"98%\"):\n\"\"\"Widget for changing basemaps.\n\n    Args:\n        m (object): geemap.Map.\n    \"\"\"\n    from .plotlymap import basemaps\n\n    m = canvas.map\n    layer_count = len(m.layout.mapbox.layers)\n    container_widget = canvas.container_widget\n    map_widget = canvas.map_widget\n\n    map_widget.layout.width = map_min_width\n\n    value = \"Stamen.Terrain\"\n    m.add_basemap(value)\n\n    dropdown = widgets.Dropdown(\n        options=list(basemaps.keys()),\n        value=value,\n        layout=widgets.Layout(width=\"200px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the basemap widget\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    basemap_widget = widgets.HBox([dropdown, close_btn])\n    container_widget.children = [basemap_widget]\n\n    def on_click(change):\n        basemap_name = change[\"new\"]\n        m.layout.mapbox.layers = m.layout.mapbox.layers[:layer_count]\n        m.add_basemap(basemap_name)\n\n    dropdown.observe(on_click, \"value\")\n\n    def close_click(change):\n        container_widget.children = []\n        basemap_widget.close()\n        map_widget.layout.width = map_max_width\n        canvas.toolbar_reset()\n        canvas.toolbar_button.value = False\n\n    close_btn.on_click(close_click)\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.plotly_search_basemaps","title":"<code>plotly_search_basemaps(canvas)</code>","text":"<p>The widget for search XYZ tile services.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>plotlymap.Map</code> <p>The Plotly Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>geemap/toolbar.py</code> <pre><code>def plotly_search_basemaps(canvas):\n\"\"\"The widget for search XYZ tile services.\n\n    Args:\n        m (plotlymap.Map, optional): The Plotly Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import xyzservices.providers as xyz\n    from xyzservices import TileProvider\n\n    m = canvas.map\n    container_widget = canvas.container_widget\n    map_widget = canvas.map_widget\n    map_widget.layout.width = \"75%\"\n\n    # map_widget.layout.width = map_min_width\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"search\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Search Quick Map Services (QMS)\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    providers = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"XYZ Tile:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    keyword = widgets.Text(\n        value=\"\",\n        description=\"Search keyword:\",\n        placeholder=\"OpenStreetMap\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    def search_callback(change):\n        providers.options = []\n        if keyword.value != \"\":\n            tiles = search_xyz_services(keyword=keyword.value)\n            if checkbox.value:\n                tiles = tiles + search_qms(keyword=keyword.value)\n            providers.options = tiles\n\n    keyword.on_submit(search_callback)\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Reset\", \"Close\"],\n        tooltips=[\"Search\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    def providers_change(change):\n        if change[\"new\"] != \"\":\n            provider = change[\"new\"]\n            if provider is not None:\n                if provider.startswith(\"qms\"):\n                    with output:\n                        output.clear_output()\n                        print(\"Adding data. Please wait...\")\n                    name = provider[4:]\n                    qms_provider = TileProvider.from_qms(name)\n                    url = qms_provider.build_url()\n                    attribution = qms_provider.attribution\n                    m.add_tile_layer(url, name, attribution)\n                    output.clear_output()\n                elif provider.startswith(\"xyz\"):\n                    name = provider[4:]\n                    xyz_provider = xyz.flatten()[name]\n                    url = xyz_provider.build_url()\n                    attribution = xyz_provider.attribution\n                    if xyz_provider.requires_token():\n                        with output:\n                            output.clear_output()\n                            print(f\"{provider} requires an API Key.\")\n                    m.add_tile_layer(url, name, attribution)\n\n    providers.observe(providers_change, \"value\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        checkbox,\n        keyword,\n        providers,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            canvas.toolbar_reset()\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            providers.options = []\n            output.clear_output()\n            if keyword.value != \"\":\n                tiles = search_xyz_services(keyword=keyword.value)\n                if checkbox.value:\n                    tiles = tiles + search_qms(keyword=keyword.value)\n                providers.options = tiles\n            else:\n                with output:\n                    print(\"Please enter a search keyword.\")\n        elif change[\"new\"] == \"Reset\":\n            keyword.value = \"\"\n            providers.options = []\n            output.clear_output()\n        elif change[\"new\"] == \"Close\":\n            canvas.toolbar_reset()\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    container_widget.children = [toolbar_widget]\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.plotly_toolbar","title":"<code>plotly_toolbar(canvas)</code>","text":"<p>Creates the main toolbar and adds it to the map.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>plotlymap.Map</code> <p>The plotly Map object.</p> required Source code in <code>geemap/toolbar.py</code> <pre><code>def plotly_toolbar(\n    canvas,\n):\n\"\"\"Creates the main toolbar and adds it to the map.\n\n    Args:\n        m (plotlymap.Map): The plotly Map object.\n    \"\"\"\n    m = canvas.map\n    map_min_width = canvas.map_min_width\n    map_max_width = canvas.map_max_width\n    map_refresh = canvas.map_refresh\n    map_widget = canvas.map_widget\n\n    if not map_refresh:\n        width = int(map_min_width.replace(\"%\", \"\"))\n        if width &gt; 90:\n            map_min_width = \"90%\"\n\n    tools = {\n        \"map\": {\n            \"name\": \"basemap\",\n            \"tooltip\": \"Change basemap\",\n        },\n        \"search\": {\n            \"name\": \"search_xyz\",\n            \"tooltip\": \"Search XYZ tile services\",\n        },\n        \"gears\": {\n            \"name\": \"whitebox\",\n            \"tooltip\": \"WhiteboxTools for local geoprocessing\",\n        },\n        \"folder-open\": {\n            \"name\": \"vector\",\n            \"tooltip\": \"Open local vector/raster data\",\n        },\n        \"picture-o\": {\n            \"name\": \"raster\",\n            \"tooltip\": \"Open COG/STAC dataset\",\n        },\n        \"question\": {\n            \"name\": \"help\",\n            \"tooltip\": \"Get help\",\n        },\n    }\n\n    icons = list(tools.keys())\n    tooltips = [item[\"tooltip\"] for item in list(tools.values())]\n\n    icon_width = \"32px\"\n    icon_height = \"32px\"\n    n_cols = 3\n    n_rows = math.ceil(len(icons) / n_cols)\n\n    toolbar_grid = widgets.GridBox(\n        children=[\n            widgets.ToggleButton(\n                layout=widgets.Layout(\n                    width=\"auto\", height=\"auto\", padding=\"0px 0px 0px 4px\"\n                ),\n                button_style=\"primary\",\n                icon=icons[i],\n                tooltip=tooltips[i],\n            )\n            for i in range(len(icons))\n        ],\n        layout=widgets.Layout(\n            width=\"115px\",\n            grid_template_columns=(icon_width + \" \") * n_cols,\n            grid_template_rows=(icon_height + \" \") * n_rows,\n            grid_gap=\"1px 1px\",\n            padding=\"5px\",\n        ),\n    )\n    canvas.toolbar = toolbar_grid\n\n    def tool_callback(change):\n        if change[\"new\"]:\n            current_tool = change[\"owner\"]\n            for tool in toolbar_grid.children:\n                if tool is not current_tool:\n                    tool.value = False\n            tool = change[\"owner\"]\n            tool_name = tools[tool.icon][\"name\"]\n            canvas.container_widget.children = []\n\n            if tool_name == \"basemap\":\n                plotly_basemap_gui(canvas)\n            elif tool_name == \"search_xyz\":\n                plotly_search_basemaps(canvas)\n            elif tool_name == \"whitebox\":\n                plotly_whitebox_gui(canvas)\n            elif tool_name == \"vector\":\n                plotly_tool_template(canvas)\n            elif tool_name == \"raster\":\n                plotly_tool_template(canvas)\n            elif tool_name == \"help\":\n                import webbrowser\n\n                webbrowser.open_new_tab(\"https://geemap.org\")\n                tool.value = False\n        else:\n            canvas.container_widget.children = []\n            map_widget.layout.width = map_max_width\n\n    for tool in toolbar_grid.children:\n        tool.observe(tool_callback, \"value\")\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"wrench\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    canvas.toolbar_button = toolbar_button\n\n    layers_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Layers\",\n        icon=\"server\",\n        layout=widgets.Layout(height=\"28px\", width=\"72px\"),\n    )\n    canvas.layers_button = layers_button\n\n    toolbar_widget = widgets.VBox(layout=widgets.Layout(overflow=\"hidden\"))\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox(layout=widgets.Layout(overflow=\"hidden\"))\n    toolbar_header.children = [layers_button, toolbar_button]\n    toolbar_footer = widgets.VBox(layout=widgets.Layout(overflow=\"hidden\"))\n    toolbar_footer.children = [toolbar_grid]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            # map_widget.layout.width = \"85%\"\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                layers_button.value = False\n                # map_widget.layout.width = map_max_width\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            map_widget.layout.width = map_min_width\n            if map_refresh:\n                with map_widget:\n                    map_widget.clear_output()\n                    display(m)\n            layers_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            canvas.toolbar_reset()\n            map_widget.layout.width = map_max_width\n            if not layers_button.value:\n                toolbar_widget.children = [toolbar_button]\n            if map_refresh:\n                with map_widget:\n                    map_widget.clear_output()\n                    display(m)\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def layers_btn_click(change):\n        if change[\"new\"]:\n            layer_names = list(m.get_layers().keys())\n            layers_hbox = []\n            all_layers_chk = widgets.Checkbox(\n                value=True,\n                description=\"All layers on/off\",\n                indent=False,\n                layout=widgets.Layout(height=\"18px\", padding=\"0px 8px 25px 8px\"),\n            )\n            all_layers_chk.layout.width = \"30ex\"\n            layers_hbox.append(all_layers_chk)\n\n            layer_chk_dict = {}\n\n            for name in layer_names:\n                if name in m.get_tile_layers():\n                    index = m.find_layer_index(name)\n                    layer = m.layout.mapbox.layers[index]\n                elif name in m.get_data_layers():\n                    index = m.find_layer_index(name)\n                    layer = m.data[index]\n\n                layer_chk = widgets.Checkbox(\n                    value=layer.visible,\n                    description=name,\n                    indent=False,\n                    layout=widgets.Layout(height=\"18px\"),\n                )\n                layer_chk.layout.width = \"25ex\"\n                layer_chk_dict[name] = layer_chk\n\n                if hasattr(layer, \"opacity\"):\n                    opacity = layer.opacity\n                elif hasattr(layer, \"marker\"):\n                    opacity = layer.marker.opacity\n                else:\n                    opacity = 1.0\n\n                layer_opacity = widgets.FloatSlider(\n                    value=opacity,\n                    description_tooltip=name,\n                    min=0,\n                    max=1,\n                    step=0.01,\n                    readout=False,\n                    layout=widgets.Layout(width=\"80px\"),\n                )\n\n                layer_settings = widgets.ToggleButton(\n                    icon=\"gear\",\n                    tooltip=name,\n                    layout=widgets.Layout(\n                        width=\"25px\", height=\"25px\", padding=\"0px 0px 0px 5px\"\n                    ),\n                )\n\n                def layer_chk_change(change):\n                    if change[\"new\"]:\n                        m.set_layer_visibility(change[\"owner\"].description, True)\n                    else:\n                        m.set_layer_visibility(change[\"owner\"].description, False)\n\n                layer_chk.observe(layer_chk_change, \"value\")\n\n                def layer_opacity_change(change):\n                    if change[\"new\"]:\n                        m.set_layer_opacity(\n                            change[\"owner\"].description_tooltip, change[\"new\"]\n                        )\n\n                layer_opacity.observe(layer_opacity_change, \"value\")\n\n                hbox = widgets.HBox(\n                    [layer_chk, layer_settings, layer_opacity],\n                    layout=widgets.Layout(padding=\"0px 8px 0px 8px\"),\n                )\n                layers_hbox.append(hbox)\n\n            def all_layers_chk_changed(change):\n                if change[\"new\"]:\n                    for name in layer_names:\n                        m.set_layer_visibility(name, True)\n                        layer_chk_dict[name].value = True\n                else:\n                    for name in layer_names:\n                        m.set_layer_visibility(name, False)\n                        layer_chk_dict[name].value = False\n\n            all_layers_chk.observe(all_layers_chk_changed, \"value\")\n\n            toolbar_footer.children = layers_hbox\n            toolbar_button.value = False\n        else:\n            toolbar_footer.children = [toolbar_grid]\n\n    layers_button.observe(layers_btn_click, \"value\")\n\n    return toolbar_widget\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.time_slider","title":"<code>time_slider(m=None)</code>","text":"<p>Creates a time slider for visualizing any ee.ImageCollection.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>geemap.Map</code> <p>A geemap Map instance. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The interactive GUI.</p> Source code in <code>geemap/toolbar.py</code> <pre><code>def time_slider(m=None):\n\"\"\"Creates a time slider for visualizing any ee.ImageCollection.\n\n    Args:\n        m (geemap.Map, optional): A geemap Map instance. Defaults to None.\n\n    Returns:\n        ipywidgets: The interactive GUI.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    widget_width = \"350px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"fast-forward\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    col_options_dict = {\n        \"Landsat TM-ETM-OLI Surface Reflectance\": {\n            \"min\": 0,\n            \"max\": 4000,\n            \"bands\": [\"NIR\", \"Red\", \"Green\"],\n            \"start_year\": 1984,\n            \"end_year\": 2021,\n            \"bandnames\": [\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\", \"pixel_qa\"],\n        },\n        \"MOD13A2.006 Terra Vegetation Indices\": {\n            \"min\": 0,\n            \"max\": 9000,\n            \"start_year\": 2000,\n            \"end_year\": 2021,\n            \"palette\": [\n                \"FFFFFF\",\n                \"CE7E45\",\n                \"DF923D\",\n                \"F1B555\",\n                \"FCD163\",\n                \"99B718\",\n                \"74A901\",\n                \"66A000\",\n                \"529400\",\n                \"3E8601\",\n                \"207401\",\n                \"056201\",\n                \"004C00\",\n                \"023B01\",\n                \"012E01\",\n                \"011D01\",\n                \"011301\",\n            ],\n        },\n        \"Sentinel-2 Surface Relectance\": {\n            \"min\": 0,\n            \"max\": 4000,\n            \"bands\": [\"NIR\", \"Red\", \"Green\"],\n            \"start_year\": 2015,\n            \"end_year\": 2021,\n            \"bandnames\": [\n                \"Blue\",\n                \"Green\",\n                \"Red\",\n                \"Red Edge 1\",\n                \"Red Edge 2\",\n                \"Red Edge 3\",\n                \"NIR\",\n                \"Red Edge 4\",\n                \"SWIR1\",\n                \"SWIR2\",\n                \"QA60\",\n            ],\n        },\n        \"USDA NAIP Imagery\": {\n            \"min\": 0,\n            \"max\": 255,\n            \"bands\": [\"R\", \"G\", \"B\"],\n            \"start_year\": 2003,\n            \"end_year\": 2021,\n            \"bandnames\": [\"R\", \"G\", \"B\", \"N\"],\n        },\n    }\n\n    col_options = list(col_options_dict.keys())\n\n    if m is not None:\n        col_options += m.ee_raster_layer_names\n\n    collection = widgets.Dropdown(\n        options=col_options,\n        value=col_options[0],\n        description=\"Time series:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    region = widgets.Dropdown(\n        options=[\"User-drawn ROI\"] + m.ee_vector_layer_names,\n        value=\"User-drawn ROI\",\n        description=\"Region:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    dropdown_width = \"97px\"\n    landsat_bands = [\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\", \"pixel_qa\"]\n    band1_dropdown = widgets.Dropdown(\n        options=landsat_bands,\n        value=\"NIR\",\n        layout=widgets.Layout(width=dropdown_width),\n    )\n    band2_dropdown = widgets.Dropdown(\n        options=landsat_bands,\n        value=\"Red\",\n        layout=widgets.Layout(width=dropdown_width),\n    )\n    band3_dropdown = widgets.Dropdown(\n        options=landsat_bands,\n        value=\"Green\",\n        layout=widgets.Layout(width=dropdown_width),\n    )\n\n    bands_label = widgets.Label(\"Bands:\", layout=widgets.Layout(padding=padding))\n    bands_hbox = widgets.HBox(\n        [bands_label, band1_dropdown, band2_dropdown, band3_dropdown]\n    )\n\n    vis = widgets.Text(\n        value=\"\",\n        description=\"Vis min value:\",\n        placeholder=\"{'min': 0, 'max': 1, 'palette': ['red', 'blue']}\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    vis_min = widgets.Text(\n        value=\"0\",\n        description=\"Vis min value:\",\n        style=style,\n        layout=widgets.Layout(width=\"172px\", padding=padding),\n    )\n\n    vis_max = widgets.Text(\n        value=\"4000\",\n        description=\"Vis max value:\",\n        style=style,\n        layout=widgets.Layout(width=\"172px\", padding=padding),\n    )\n\n    opacity = widgets.FloatSlider(\n        value=1,\n        min=0,\n        max=1,\n        step=0.01,\n        description=\"Opacity:\",\n        continuous_update=True,\n        readout=False,\n        readout_format=\".2f\",\n        layout=widgets.Layout(width=\"130px\", padding=padding),\n        style={\"description_width\": \"50px\"},\n    )\n\n    opacity_label = widgets.Label(layout=widgets.Layout(width=\"40px\", padding=padding))\n    widgets.jslink((opacity, \"value\"), (opacity_label, \"value\"))\n\n    gamma = widgets.FloatSlider(\n        value=1,\n        min=0.1,\n        max=10,\n        step=0.01,\n        description=\"Gamma:\",\n        continuous_update=True,\n        readout=False,\n        readout_format=\".2f\",\n        layout=widgets.Layout(width=\"123px\", padding=padding),\n        style={\"description_width\": \"50px\"},\n    )\n\n    gamma_label = widgets.Label(layout=widgets.Layout(width=\"40px\", padding=padding))\n    widgets.jslink((gamma, \"value\"), (gamma_label, \"value\"))\n\n    color_picker = widgets.ColorPicker(\n        concise=False,\n        value=\"#000000\",\n        layout=widgets.Layout(width=\"97px\"),\n        style={\"description_width\": \"initial\"},\n    )\n\n    add_color = widgets.Button(\n        icon=\"plus\",\n        tooltip=\"Add a hex color string to the palette\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    del_color = widgets.Button(\n        icon=\"minus\",\n        tooltip=\"Remove a hex color string from the palette\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    reset_color = widgets.Button(\n        icon=\"eraser\",\n        tooltip=\"Remove all color strings from the palette\",\n        layout=widgets.Layout(width=\"34px\"),\n    )\n\n    classes = widgets.Dropdown(\n        options=[\"Any\"] + [str(i) for i in range(3, 13)],\n        description=\"Classes:\",\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n        style={\"description_width\": \"initial\"},\n    )\n\n    colormap = widgets.Dropdown(\n        options=plt.colormaps(),\n        value=None,\n        description=\"Colormap:\",\n        layout=widgets.Layout(width=\"195px\", padding=padding),\n        style={\"description_width\": \"initial\"},\n    )\n\n    def classes_changed(change):\n        if change[\"new\"]:\n            selected = change[\"owner\"].value\n            if colormap.value is not None:\n                n_class = None\n                if selected != \"Any\":\n                    n_class = int(classes.value)\n\n                colors = plt.cm.get_cmap(colormap.value, n_class)\n                cmap_colors = [\n                    mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n                ]\n\n                _, ax = plt.subplots(figsize=(6, 0.4))\n                cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                    \"custom\", to_hex_colors(cmap_colors), N=256\n                )\n\n                vmin = 0\n                vmax = 1\n                try:\n                    if vis_min.value != \"\":\n                        vmin = float(vis_min.value)\n                    if vis_max.value != \"\":\n                        vmax = float(vis_max.value)\n                except Exception as _:\n                    pass\n\n                norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n                mpl.colorbar.ColorbarBase(\n                    ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n                )\n\n                palette.value = \", \".join([color for color in cmap_colors])\n\n                if m.colorbar_widget is None:\n                    m.colorbar_widget = widgets.Output(\n                        layout=widgets.Layout(height=\"60px\")\n                    )\n\n                if m.colorbar_ctrl is None:\n                    m.colorbar_ctrl = ipyleaflet.WidgetControl(\n                        widget=m.colorbar_widget, position=\"bottomright\"\n                    )\n                    m.add_control(m.colorbar_ctrl)\n\n                colorbar_output = m.colorbar_widget\n                with colorbar_output:\n                    colorbar_output.clear_output()\n                    plt.show()\n\n    classes.observe(classes_changed, \"value\")\n\n    palette = widgets.Text(\n        value=\"\",\n        placeholder=\"\",\n        description=\"Palette:\",\n        tooltip=\"Enter a list of hex color code (RRGGBB)\",\n        layout=widgets.Layout(width=\"137px\", padding=padding),\n        style={\"description_width\": \"initial\"},\n    )\n\n    def add_color_clicked(b):\n        if color_picker.value is not None:\n            if len(palette.value) == 0:\n                palette.value = color_picker.value[1:]\n            else:\n                palette.value += \", \" + color_picker.value[1:]\n\n    def del_color_clicked(b):\n        if \",\" in palette.value:\n            items = [item.strip() for item in palette.value.split(\",\")]\n            palette.value = \", \".join(items[:-1])\n        else:\n            palette.value = \"\"\n\n    def reset_color_clicked(b):\n        palette.value = \"\"\n\n    add_color.on_click(add_color_clicked)\n    del_color.on_click(del_color_clicked)\n    reset_color.on_click(reset_color_clicked)\n\n    def colormap_changed(change):\n        if change[\"new\"]:\n            n_class = None\n            if classes.value != \"Any\":\n                n_class = int(classes.value)\n\n            colors = plt.cm.get_cmap(colormap.value, n_class)\n            cmap_colors = [mpl.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)]\n\n            _, ax = plt.subplots(figsize=(6, 0.4))\n            cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                \"custom\", to_hex_colors(cmap_colors), N=256\n            )\n\n            vmin = 0\n            vmax = 1\n            try:\n                if vis_min.value != \"\":\n                    vmin = float(vis_min.value)\n                if vis_max.value != \"\":\n                    vmax = float(vis_max.value)\n            except Exception as _:\n                pass\n\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n            mpl.colorbar.ColorbarBase(\n                ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n            )\n\n            palette.value = \", \".join(cmap_colors)\n\n            if m.colorbar_widget is None:\n                m.colorbar_widget = widgets.Output(layout=widgets.Layout(height=\"60px\"))\n\n            if m.colorbar_ctrl is None:\n                m.colorbar_ctrl = ipyleaflet.WidgetControl(\n                    widget=m.colorbar_widget, position=\"bottomright\"\n                )\n                m.add_control(m.colorbar_ctrl)\n\n            colorbar_output = m.colorbar_widget\n            with colorbar_output:\n                colorbar_output.clear_output()\n                plt.show()\n\n    colormap.observe(colormap_changed, \"value\")\n\n    palette_vbox = widgets.VBox()\n\n    labels = widgets.Text(\n        value=\", \".join([str(i) for i in range(1984, 2021)]),\n        description=\"Labels:\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    speed = widgets.FloatSlider(\n        description=\"Speed (sec):\",\n        tooltip=\"Time interval in seconds\",\n        value=1,\n        min=0.1,\n        max=10,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"160px\", padding=padding),\n    )\n\n    speed_label = widgets.Label(\n        layout=widgets.Layout(width=\"25px\", padding=padding),\n    )\n    widgets.jslink((speed, \"value\"), (speed_label, \"value\"))\n\n    prebuilt_options = widgets.VBox()\n\n    cloud = widgets.Checkbox(\n        value=True,\n        description=\"Apply fmask (remove clouds, shadows, snow)\",\n        tooltip=\"Apply fmask (remove clouds, shadows, snow)\",\n        style=style,\n    )\n\n    start_year = widgets.IntSlider(\n        description=\"Start Year:\",\n        value=1984,\n        min=1984,\n        max=2021,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"138px\", padding=padding),\n    )\n\n    def year_change(change):\n        if change[\"new\"]:\n            if collection.value != \"MOD13A2.006 Terra Vegetation Indices\":\n                labels.value = \", \".join(\n                    str(i)\n                    for i in range(int(start_year.value), int(end_year.value) + 1)\n                )\n            else:\n                modis_labels = []\n                for i in range(int(start_year.value), int(end_year.value) + 1):\n                    for j in range(1, 13):\n                        modis_labels.append(str(i) + \"-\" + str(j).zfill(2))\n                labels.value = \", \".join(modis_labels)\n\n    start_year.observe(year_change, \"value\")\n\n    start_year_label = widgets.Label()\n    widgets.jslink((start_year, \"value\"), (start_year_label, \"value\"))\n\n    end_year = widgets.IntSlider(\n        description=\"End Year:\",\n        value=2020,\n        min=1984,\n        max=2021,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"138px\", padding=padding),\n    )\n\n    end_year.observe(year_change, \"value\")\n\n    end_year_label = widgets.Label()\n    widgets.jslink((end_year, \"value\"), (end_year_label, \"value\"))\n\n    start_month = widgets.IntSlider(\n        description=\"Start Month:\",\n        value=1,\n        min=1,\n        max=12,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"145px\", padding=padding),\n    )\n\n    start_month_label = widgets.Label(\n        layout=widgets.Layout(width=\"20px\", padding=padding),\n    )\n    widgets.jslink((start_month, \"value\"), (start_month_label, \"value\"))\n\n    end_month = widgets.IntSlider(\n        description=\"End Month:\",\n        value=12,\n        min=1,\n        max=12,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"155px\", padding=padding),\n    )\n\n    end_month_label = widgets.Label()\n    widgets.jslink((end_month, \"value\"), (end_month_label, \"value\"))\n\n    prebuilt_options.children = [\n        widgets.HBox([start_year, start_year_label, end_year, end_year_label]),\n        widgets.HBox([start_month, start_month_label, end_month, end_month_label]),\n        cloud,\n    ]\n\n    button_width = \"113px\"\n    apply_btn = widgets.Button(\n        description=\"Apply\",\n        button_style=\"primary\",\n        tooltip=\"Apply the settings to activate the time slider\",\n        style=style,\n        layout=widgets.Layout(padding=\"0px\", width=button_width),\n    )\n\n    def submit_clicked(b):\n        output.clear_output()\n        with output:\n            if start_year.value &gt; end_year.value:\n                print(\"The end year must be great than the start year.\")\n                return\n            if start_month.value &gt; end_month.value:\n                print(\"The end month must be great than the start month.\")\n                return\n\n        if m is not None:\n            roi = None\n            if region.value == \"User-drawn ROI\" and (m.user_roi is not None):\n                roi = m.user_roi\n            elif region.value == \"User-drawn ROI\" and (m.user_roi is None):\n                with output:\n                    print(\"Use the Drawing tool to create an ROI.\")\n                    return\n            elif region.value in m.ee_layer_dict:\n                roi = m.ee_layer_dict[region.value][\"ee_object\"]\n\n            with output:\n                print(\"Computing... Please wait...\")\n\n            layer_labels = None\n            vis_params = {}\n\n            try:\n                if vis_min.value != \"\":\n                    vis_params[\"min\"] = float(vis_min.value)\n\n                if vis_max.value != \"\":\n                    vis_params[\"max\"] = float(vis_max.value)\n\n                vis_params[\"opacity\"] = float(opacity.value)\n\n                if len(bands_hbox.children) &gt; 0 and (\n                    band1_dropdown.value\n                    and band2_dropdown.value\n                    and band3_dropdown.value\n                ):\n                    vis_params[\"bands\"] = [\n                        band1_dropdown.value,\n                        band2_dropdown.value,\n                        band3_dropdown.value,\n                    ]\n                    vis_params[\"gamma\"] = float(gamma.value)\n\n                if len(palette_vbox.children) &gt; 0:\n                    if \",\" in palette.value:\n                        vis_params[\"palette\"] = [\n                            i.strip() for i in palette.value.split(\",\")\n                        ]\n                    elif len(palette.value) &gt; 0:\n                        vis_params[\"palette\"] = palette.value.strip()\n\n            except Exception as _:\n                with output:\n                    print(\"The vis parmas are invalid.\")\n                    return\n\n            if labels.value != \"\" and \",\" in labels.value:\n                try:\n                    layer_labels = [i.strip() for i in labels.value.split(\",\")]\n                except Exception as e:\n                    raise ValueError(e)\n\n            if collection.value in m.ee_raster_layer_names:\n                layer = m.ee_layer_dict[collection.value]\n                ee_object = layer[\"ee_object\"]\n            elif collection.value in col_options_dict:\n                start_date = str(start_month.value).zfill(2) + \"-01\"\n                end_date = str(end_month.value).zfill(2) + \"-30\"\n\n                if collection.value == \"Landsat TM-ETM-OLI Surface Reflectance\":\n                    ee_object = landsat_timeseries(\n                        roi,\n                        int(start_year.value),\n                        int(end_year.value),\n                        start_date,\n                        end_date,\n                        cloud.value,\n                    )\n                elif collection.value == \"MOD13A2.006 Terra Vegetation Indices\":\n                    ee_object = modis_timeseries(\n                        roi=roi,\n                        start_year=int(start_year.value),\n                        end_year=int(end_year.value),\n                        start_date=start_date,\n                        end_date=end_date,\n                    )\n\n                elif collection.value == \"Sentinel-2 Surface Relectance\":\n                    ee_object = sentinel2_timeseries(\n                        roi,\n                        int(start_year.value),\n                        int(end_year.value),\n                        start_date,\n                        end_date,\n                        cloud.value,\n                    )\n                elif collection.value == \"USDA NAIP Imagery\":\n                    if int(start_year.value) &lt; 2009 and (\n                        band1_dropdown.value == \"N\"\n                        or band2_dropdown.value == \"N\"\n                        or band3_dropdown.value == \"N\"\n                    ):\n                        with output:\n                            output.clear_output()\n                            print(\"4-band NAIP imagery not available before 2009.\")\n                            return\n\n                    ee_object = naip_timeseries(roi, start_year.value, end_year.value)\n\n            m.add_time_slider(\n                ee_object,\n                region=roi,\n                vis_params=vis_params,\n                labels=layer_labels,\n                time_interval=speed.value,\n            )\n\n            output.clear_output()\n\n            if m.colorbar_ctrl is not None:\n                m.remove_control(m.colorbar_ctrl)\n                m.colorbar_ctrl = None\n\n    apply_btn.on_click(submit_clicked)\n\n    reset_btn = widgets.Button(\n        description=\"Reset\",\n        button_style=\"primary\",\n        style=style,\n        layout=widgets.Layout(padding=\"0px\", width=button_width),\n    )\n\n    def reset_btn_click(change):\n        output.clear_output()\n        collection.value = col_options[0]\n        region.value = \"User-drawn ROI\"\n        vis.value = \"\"\n        labels.value = \"1, 2, 3\"\n        speed.value = 1\n\n        if m.colorbar_ctrl is not None:\n            m.remove_control(m.colorbar_ctrl)\n            m.colorbar_ctrl = None\n\n    reset_btn.on_click(reset_btn_click)\n\n    close_btn = widgets.Button(\n        description=\"Close\",\n        button_style=\"primary\",\n        style=style,\n        layout=widgets.Layout(padding=\"0px\", width=button_width),\n    )\n\n    def close_click(change):\n        if m is not None:\n            m.toolbar_reset()\n            if m.tool_control is not None and m.tool_control in m.controls:\n                m.remove_control(m.tool_control)\n                m.tool_control = None\n\n            if m.colorbar_ctrl is not None:\n                m.remove_control(m.colorbar_ctrl)\n                m.colorbar_ctrl = None\n        toolbar_widget.close()\n\n    close_btn.on_click(close_click)\n\n    def collection_changed(change):\n        if change[\"new\"]:\n            selected = change[\"owner\"].value\n            if selected in m.ee_layer_dict:\n                prebuilt_options.children = []\n                labels.value = \"\"\n                region.value = None\n\n                ee_object = m.ee_layer_dict[selected][\"ee_object\"]\n                vis_params = m.ee_layer_dict[selected][\"vis_params\"]\n                if isinstance(ee_object, ee.Image):\n                    palette_vbox.children = [\n                        widgets.HBox([classes, colormap]),\n                        widgets.HBox(\n                            [palette, color_picker, add_color, del_color, reset_color]\n                        ),\n                    ]\n                    bands_hbox.children = []\n\n                elif isinstance(ee_object, ee.ImageCollection):\n                    first = ee.Image(ee_object.first())\n                    band_names = first.bandNames().getInfo()\n                    band_count = len(band_names)\n\n                    if band_count &gt; 2:\n                        band1_dropdown.options = band_names\n                        band2_dropdown.options = band_names\n                        band3_dropdown.options = band_names\n\n                        band1_dropdown.value = band_names[2]\n                        band2_dropdown.value = band_names[1]\n                        band3_dropdown.value = band_names[0]\n\n                        palette_vbox.children = []\n                        bands_hbox.children = [\n                            bands_label,\n                            band1_dropdown,\n                            band2_dropdown,\n                            band3_dropdown,\n                        ]\n\n                    else:\n                        palette_vbox.children = [\n                            widgets.HBox([classes, colormap]),\n                            widgets.HBox(\n                                [\n                                    palette,\n                                    color_picker,\n                                    add_color,\n                                    del_color,\n                                    reset_color,\n                                ]\n                            ),\n                        ]\n                        bands_hbox.children = []\n\n                if \"min\" in vis_params:\n                    vis_min.value = str(vis_params[\"min\"])\n                if \"max\" in vis_params:\n                    vis_max.value = str(vis_params[\"max\"])\n                if \"opacity\" in vis_params:\n                    opacity.value = str(vis_params[\"opacity\"])\n                if \"gamma\" in vis_params:\n                    if isinstance(vis_params[\"gamma\"], list):\n                        gamma.value = str(vis_params[\"gamma\"][0])\n                    else:\n                        gamma.value = str(vis_params[\"gamma\"])\n                if \"palette\" in vis_params:\n                    palette.value = \", \".join(vis_params[\"palette\"])\n\n            else:\n                prebuilt_options.children = [\n                    widgets.HBox(\n                        [start_year, start_year_label, end_year, end_year_label]\n                    ),\n                    widgets.HBox(\n                        [start_month, start_month_label, end_month, end_month_label]\n                    ),\n                    cloud,\n                ]\n\n                if selected == \"MOD13A2.006 Terra Vegetation Indices\":\n                    palette_vbox.children = [\n                        widgets.HBox([classes, colormap]),\n                        widgets.HBox(\n                            [\n                                palette,\n                                color_picker,\n                                add_color,\n                                del_color,\n                                reset_color,\n                            ]\n                        ),\n                    ]\n                    bands_hbox.children = []\n\n                    palette.value = \", \".join(col_options_dict[selected][\"palette\"])\n                    modis_labels = []\n                    for i in range(int(start_year.value), int(end_year.value) + 1):\n                        for j in range(1, 13):\n                            modis_labels.append(str(i) + \"-\" + str(j).zfill(2))\n                    labels.value = \", \".join(modis_labels)\n\n                else:\n                    bands_hbox.children = [\n                        bands_label,\n                        band1_dropdown,\n                        band2_dropdown,\n                        band3_dropdown,\n                    ]\n\n                    bandnames = col_options_dict[selected][\"bandnames\"]\n                    band1_dropdown.options = bandnames\n                    band2_dropdown.options = bandnames\n                    band3_dropdown.options = bandnames\n\n                if (\n                    selected == \"Landsat TM-ETM-OLI Surface Reflectance\"\n                    or selected == \"Sentinel-2 Surface Relectance\"\n                ):\n                    band1_dropdown.value = bandnames[2]\n                    band2_dropdown.value = bandnames[1]\n                    band3_dropdown.value = bandnames[0]\n                    palette_vbox.children = []\n                elif selected == \"USDA NAIP Imagery\":\n                    band1_dropdown.value = bandnames[0]\n                    band2_dropdown.value = bandnames[1]\n                    band3_dropdown.value = bandnames[2]\n                    palette_vbox.children = []\n\n                labels.value = \", \".join(\n                    str(i)\n                    for i in range(int(start_year.value), int(end_year.value) + 1)\n                )\n\n                start_year.min = col_options_dict[selected][\"start_year\"]\n                start_year.max = col_options_dict[selected][\"end_year\"]\n                start_year.value = start_year.min\n                end_year.min = col_options_dict[selected][\"start_year\"]\n                end_year.max = col_options_dict[selected][\"end_year\"]\n                end_year.value = end_year.max\n                vis_min.value = str(col_options_dict[selected][\"min\"])\n                vis_max.value = str(col_options_dict[selected][\"max\"])\n\n                if selected == \"MOD13A2.006 Terra Vegetation Indices\":\n                    start_year.value = \"2001\"\n                    end_year.value = \"2020\"\n                elif selected == \"USDA NAIP Imagery\":\n                    start_year.value = \"2009\"\n                    end_year.value = \"2019\"\n\n    collection.observe(collection_changed, \"value\")\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        collection,\n        region,\n        bands_hbox,\n        widgets.HBox([vis_min, vis_max]),\n        widgets.HBox([opacity, opacity_label, gamma, gamma_label]),\n        palette_vbox,\n        widgets.HBox([labels, speed, speed_label]),\n        prebuilt_options,\n        widgets.HBox([apply_btn, reset_btn, close_btn]),\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.toolbar_reset()\n            toolbar_widget.close()\n\n            if m.colorbar_ctrl is not None:\n                m.remove_control(m.colorbar_ctrl)\n                m.colorbar_ctrl = None\n\n    close_button.observe(close_btn_click, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.timelapse_gui","title":"<code>timelapse_gui(m=None)</code>","text":"<p>Creates timelapse animations.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>geemap.Map</code> <p>A geemap Map instance. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The interactive GUI.</p> Source code in <code>geemap/toolbar.py</code> <pre><code>def timelapse_gui(m=None):\n\"\"\"Creates timelapse animations.\n\n    Args:\n        m (geemap.Map, optional): A geemap Map instance. Defaults to None.\n\n    Returns:\n        ipywidgets: The interactive GUI.\n    \"\"\"\n    if m is not None:\n        m.add_basemap(\"HYBRID\")\n\n    widget_width = \"350px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"gear\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    collection = widgets.Dropdown(\n        options=[\n            \"Landsat TM-ETM-OLI Surface Reflectance\",\n            \"Sentinel-2AB Surface Reflectance\",\n            \"MODIS\",\n        ],\n        value=\"Landsat TM-ETM-OLI Surface Reflectance\",\n        description=\"Collection:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    title = widgets.Text(\n        value=\"Timelapse\",\n        description=\"Title:\",\n        style=style,\n        layout=widgets.Layout(width=\"181px\", padding=padding),\n    )\n\n    bands = widgets.Dropdown(\n        description=\"RGB:\",\n        options=[\n            \"Red/Green/Blue\",\n            \"NIR/Red/Green\",\n            \"SWIR2/SWIR1/NIR\",\n            \"NIR/SWIR1/Red\",\n            \"SWIR2/NIR/Red\",\n            \"SWIR2/SWIR1/Red\",\n            \"SWIR1/NIR/Blue\",\n            \"NIR/SWIR1/Blue\",\n            \"SWIR2/NIR/Green\",\n            \"SWIR1/NIR/Red\",\n        ],\n        value=\"NIR/Red/Green\",\n        style=style,\n        layout=widgets.Layout(width=\"165px\", padding=padding),\n    )\n\n    speed = widgets.IntSlider(\n        description=\"Frames/sec:\",\n        tooltip=\"Frames per second\",\n        value=10,\n        min=1,\n        max=30,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"142px\", padding=padding),\n    )\n\n    speed_label = widgets.Label(\n        layout=widgets.Layout(width=\"20px\", padding=padding),\n    )\n    widgets.jslink((speed, \"value\"), (speed_label, \"value\"))\n\n    cloud = widgets.Checkbox(\n        value=True,\n        description=\"Apply fmask (remove clouds, shadows, snow)\",\n        tooltip=\"Apply fmask (remove clouds, shadows, snow)\",\n        style=style,\n    )\n\n    start_year = widgets.IntSlider(\n        description=\"Start Year:\",\n        value=1984,\n        min=1984,\n        max=2021,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"138px\", padding=padding),\n    )\n\n    start_year_label = widgets.Label()\n    widgets.jslink((start_year, \"value\"), (start_year_label, \"value\"))\n\n    end_year = widgets.IntSlider(\n        description=\"End Year:\",\n        value=2020,\n        min=1984,\n        max=2021,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"138px\", padding=padding),\n    )\n    end_year_label = widgets.Label()\n    widgets.jslink((end_year, \"value\"), (end_year_label, \"value\"))\n\n    start_month = widgets.IntSlider(\n        description=\"Start Month:\",\n        value=5,\n        min=1,\n        max=12,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"145px\", padding=padding),\n    )\n\n    start_month_label = widgets.Label(\n        layout=widgets.Layout(width=\"20px\", padding=padding),\n    )\n    widgets.jslink((start_month, \"value\"), (start_month_label, \"value\"))\n\n    end_month = widgets.IntSlider(\n        description=\"End Month:\",\n        value=10,\n        min=1,\n        max=12,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"155px\", padding=padding),\n    )\n\n    end_month_label = widgets.Label()\n    widgets.jslink((end_month, \"value\"), (end_month_label, \"value\"))\n\n    font_size = widgets.IntSlider(\n        description=\"Font size:\",\n        value=30,\n        min=10,\n        max=50,\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"152px\", padding=padding),\n    )\n\n    font_size_label = widgets.Label()\n    widgets.jslink((font_size, \"value\"), (font_size_label, \"value\"))\n\n    font_color = widgets.ColorPicker(\n        concise=False,\n        description=\"Font color:\",\n        value=\"white\",\n        style=style,\n        layout=widgets.Layout(width=\"170px\", padding=padding),\n    )\n\n    progress_bar_color = widgets.ColorPicker(\n        concise=False,\n        description=\"Progress bar:\",\n        value=\"blue\",\n        style=style,\n        layout=widgets.Layout(width=\"180px\", padding=padding),\n    )\n\n    # Normalized Satellite Indices: https://www.usna.edu/Users/oceano/pguth/md_help/html/norm_sat.htm\n\n    nd_options = [\n        \"Vegetation Index (NDVI)\",\n        \"Water Index (NDWI)\",\n        \"Modified Water Index (MNDWI)\",\n        \"Snow Index (NDSI)\",\n        \"Soil Index (NDSI)\",\n        \"Burn Ratio (NBR)\",\n        \"Customized\",\n    ]\n    nd_indices = widgets.Dropdown(\n        options=nd_options,\n        value=None,\n        description=\"Normalized Difference Index:\",\n        style=style,\n        layout=widgets.Layout(width=\"347px\", padding=padding),\n    )\n\n    first_band = widgets.Dropdown(\n        description=\"1st band:\",\n        options=[\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\"],\n        value=None,\n        style=style,\n        layout=widgets.Layout(width=\"171px\", padding=padding),\n    )\n\n    second_band = widgets.Dropdown(\n        description=\"2nd band:\",\n        options=[\"Blue\", \"Green\", \"Red\", \"NIR\", \"SWIR1\", \"SWIR2\"],\n        value=None,\n        style=style,\n        layout=widgets.Layout(width=\"172px\", padding=padding),\n    )\n\n    nd_threshold = widgets.FloatSlider(\n        value=0,\n        min=-1,\n        max=1,\n        step=0.01,\n        description=\"Threshold:\",\n        orientation=\"horizontal\",\n        readout=False,\n        style=style,\n        layout=widgets.Layout(width=\"159px\", padding=padding),\n    )\n\n    nd_threshold_label = widgets.Label(\n        layout=widgets.Layout(width=\"35px\", padding=padding),\n    )\n    widgets.jslink((nd_threshold, \"value\"), (nd_threshold_label, \"value\"))\n\n    nd_color = widgets.ColorPicker(\n        concise=False,\n        description=\"Color:\",\n        value=\"blue\",\n        style=style,\n        layout=widgets.Layout(width=\"145px\", padding=padding),\n    )\n\n    def nd_index_change(change):\n        if nd_indices.value == \"Vegetation Index (NDVI)\":\n            first_band.value = \"NIR\"\n            second_band.value = \"Red\"\n        elif nd_indices.value == \"Water Index (NDWI)\":\n            first_band.value = \"NIR\"\n            second_band.value = \"SWIR1\"\n        elif nd_indices.value == \"Modified Water Index (MNDWI)\":\n            first_band.value = \"Green\"\n            second_band.value = \"SWIR1\"\n        elif nd_indices.value == \"Snow Index (NDSI)\":\n            first_band.value = \"Green\"\n            second_band.value = \"SWIR1\"\n        elif nd_indices.value == \"Soil Index (NDSI)\":\n            first_band.value = \"SWIR1\"\n            second_band.value = \"NIR\"\n        elif nd_indices.value == \"Burn Ratio (NBR)\":\n            first_band.value = \"NIR\"\n            second_band.value = \"SWIR2\"\n        elif nd_indices.value == \"Customized\":\n            first_band.value = None\n            second_band.value = None\n\n    nd_indices.observe(nd_index_change, names=\"value\")\n\n    button_width = \"113px\"\n    create_gif = widgets.Button(\n        description=\"Create timelapse\",\n        button_style=\"primary\",\n        tooltip=\"Click to create timelapse\",\n        style=style,\n        layout=widgets.Layout(padding=\"0px\", width=button_width),\n    )\n\n    def submit_clicked(b):\n        if start_year.value &gt; end_year.value:\n            print(\"The end year must be great than the start year.\")\n            return\n        if start_month.value &gt; end_month.value:\n            print(\"The end month must be great than the start month.\")\n            return\n        if start_year.value == end_year.value:\n            add_progress_bar = False\n        else:\n            add_progress_bar = True\n\n        start_date = str(start_month.value).zfill(2) + \"-01\"\n        end_date = str(end_month.value).zfill(2) + \"-30\"\n\n        with output:\n            print(\"Computing... Please wait...\")\n\n        nd_bands = None\n        if (first_band.value is not None) and (second_band.value is not None):\n            nd_bands = [first_band.value, second_band.value]\n\n        temp_output = widgets.Output()\n\n        if m is not None:\n            out_dir = os.path.expanduser(\"~/Downloads\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            out_gif = os.path.join(out_dir, \"timelapse_\" + random_string(3) + \".gif\")\n\n            with temp_output:\n                temp_output.clear_output()\n                m.add_landsat_ts_gif(\n                    roi=m.user_roi,\n                    label=title.value,\n                    start_year=start_year.value,\n                    end_year=end_year.value,\n                    start_date=start_date,\n                    end_date=end_date,\n                    bands=bands.value.split(\"/\"),\n                    font_color=font_color.value,\n                    frames_per_second=speed.value,\n                    font_size=font_size.value,\n                    add_progress_bar=add_progress_bar,\n                    progress_bar_color=progress_bar_color.value,\n                    out_gif=out_gif,\n                    apply_fmask=cloud.value,\n                    nd_bands=nd_bands,\n                    nd_threshold=nd_threshold.value,\n                    nd_palette=[\"black\", nd_color.value],\n                )\n                if m.user_roi is not None:\n                    m.centerObject(m.user_roi)\n\n            with output:\n                print(\"The timelapse has been added to the map.\")\n                link = create_download_link(\n                    out_gif,\n                    title=\"Click here to download: \",\n                )\n                display(link)\n                if nd_bands is not None:\n                    link_nd = create_download_link(\n                        out_gif.replace(\".gif\", \"_nd.gif\"),\n                        title=\"Click here to download: \",\n                    )\n                    display(link_nd)\n\n    create_gif.on_click(submit_clicked)\n\n    reset_btn = widgets.Button(\n        description=\"Reset\",\n        button_style=\"primary\",\n        style=style,\n        layout=widgets.Layout(padding=\"0px\", width=button_width),\n    )\n\n    def reset_btn_click(change):\n        output.clear_output()\n\n    reset_btn.on_click(reset_btn_click)\n\n    close_btn = widgets.Button(\n        description=\"Close\",\n        button_style=\"primary\",\n        style=style,\n        layout=widgets.Layout(padding=\"0px\", width=button_width),\n    )\n\n    def close_click(change):\n        if m is not None:\n            m.toolbar_reset()\n            if m.tool_control is not None and m.tool_control in m.controls:\n                m.remove_control(m.tool_control)\n                m.tool_control = None\n        toolbar_widget.close()\n\n    close_btn.on_click(close_click)\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        collection,\n        widgets.HBox([title, bands]),\n        widgets.HBox([speed, speed_label, progress_bar_color]),\n        widgets.HBox([start_year, start_year_label, end_year, end_year_label]),\n        widgets.HBox([start_month, start_month_label, end_month, end_month_label]),\n        widgets.HBox([font_size, font_size_label, font_color]),\n        cloud,\n        nd_indices,\n        widgets.HBox([first_band, second_band]),\n        widgets.HBox([nd_threshold, nd_threshold_label, nd_color]),\n        widgets.HBox([create_gif, reset_btn, close_btn]),\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.toolbar_reset()\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#geemap.toolbar.tool_gui","title":"<code>tool_gui(tool_dict, max_width='420px', max_height='600px')</code>","text":"<p>Create a GUI for a tool based on the tool dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>tool_dict</code> <code>dict</code> <p>The dictionary containing the tool info.</p> required <code>max_width</code> <code>str</code> <p>The max width of the tool dialog.</p> <code>'420px'</code> <code>max_height</code> <code>str</code> <p>The max height of the tool dialog.</p> <code>'600px'</code> <p>Returns:</p> Type Description <code>object</code> <p>An ipywidget object representing the tool interface.</p> Source code in <code>geemap/toolbar.py</code> <pre><code>def tool_gui(tool_dict, max_width=\"420px\", max_height=\"600px\"):\n\"\"\"Create a GUI for a tool based on the tool dictionary.\n\n    Args:\n        tool_dict (dict): The dictionary containing the tool info.\n        max_width (str, optional): The max width of the tool dialog.\n        max_height (str, optional): The max height of the tool dialog.\n\n    Returns:\n        object: An ipywidget object representing the tool interface.\n    \"\"\"\n    tool_widget = widgets.VBox(\n        layout=widgets.Layout(max_width=max_width, max_height=max_height)\n    )\n    children = []\n    args = {}\n    required_inputs = []\n    style = {\"description_width\": \"initial\"}\n    max_width = str(int(max_width.replace(\"px\", \"\")) - 10) + \"px\"\n\n    header_width = str(int(max_width.replace(\"px\", \"\")) - 104) + \"px\"\n    header = widgets.Label(\n        value=f'Current Tool: {tool_dict[\"label\"]}',\n        style=style,\n        layout=widgets.Layout(width=header_width),\n    )\n    code_btn = widgets.Button(\n        description=\"View Code\", layout=widgets.Layout(width=\"100px\")\n    )\n\n    children.append(widgets.HBox([header, code_btn]))\n\n    desc = widgets.Textarea(\n        value=f'Description: {tool_dict[\"description\"]}',\n        layout=widgets.Layout(width=\"410px\", max_width=max_width),\n        disabled=True,\n    )\n    children.append(desc)\n\n    run_btn = widgets.Button(description=\"Run\", layout=widgets.Layout(width=\"100px\"))\n    cancel_btn = widgets.Button(\n        description=\"Cancel\", layout=widgets.Layout(width=\"100px\")\n    )\n    help_btn = widgets.Button(description=\"Help\", layout=widgets.Layout(width=\"100px\"))\n    import_btn = widgets.Button(\n        description=\"Import\",\n        tooltip=\"Import the script to a new cell\",\n        layout=widgets.Layout(width=\"98px\"),\n    )\n    tool_output = widgets.Output(layout=widgets.Layout(max_height=\"200px\"))\n    children.append(widgets.HBox([run_btn, cancel_btn, help_btn, import_btn]))\n    children.append(tool_output)\n    tool_widget.children = children\n\n    def run_button_clicked(b):\n        tool_output.clear_output()\n\n        required_params = required_inputs.copy()\n        args2 = []\n        for arg in args:\n            line = \"\"\n            if isinstance(args[arg], FileChooser):\n                if arg in required_params and args[arg].selected is None:\n                    with tool_output:\n                        print(f\"Please provide inputs for required parameters.\")\n                        break\n                elif arg in required_params:\n                    required_params.remove(arg)\n                if arg == \"i\":\n                    line = f\"-{arg}={args[arg].selected}\"\n                else:\n                    line = f\"--{arg}={args[arg].selected}\"\n            elif isinstance(args[arg], widgets.Text):\n                if arg in required_params and len(args[arg].value) == 0:\n                    with tool_output:\n                        print(f\"Please provide inputs for required parameters.\")\n                        break\n                elif arg in required_params:\n                    required_params.remove(arg)\n                if args[arg].value is not None and len(args[arg].value) &gt; 0:\n                    line = f\"--{arg}={args[arg].value}\"\n            elif isinstance(args[arg], widgets.Checkbox):\n                line = f\"--{arg}={args[arg].value}\"\n            args2.append(line)\n\n        if len(required_params) == 0:\n            with tool_output:\n                # wbt.run_tool(tool_dict[\"name\"], args2)\n                pass\n\n    def help_button_clicked(b):\n        import webbrowser\n\n        tool_output.clear_output()\n        with tool_output:\n            html = widgets.HTML(\n                value=f'&lt;a href={tool_dict[\"link\"]} target=\"_blank\"&gt;{tool_dict[\"link\"]}&lt;/a&gt;'\n            )\n            display(html)\n        webbrowser.open_new_tab(tool_dict[\"link\"])\n\n    def code_button_clicked(b):\n        import webbrowser\n\n        with tool_output:\n            html = widgets.HTML(\n                value=f'&lt;a href={tool_dict[\"link\"]} target=\"_blank\"&gt;{tool_dict[\"link\"]}&lt;/a&gt;'\n            )\n            display(html)\n        webbrowser.open_new_tab(tool_dict[\"link\"])\n\n    def cancel_btn_clicked(b):\n        tool_output.clear_output()\n\n    def import_button_clicked(b):\n        tool_output.clear_output()\n\n        content = []\n\n        create_code_cell(\"\\n\".join(content))\n\n    import_btn.on_click(import_button_clicked)\n    run_btn.on_click(run_button_clicked)\n    help_btn.on_click(help_button_clicked)\n    code_btn.on_click(code_button_clicked)\n    cancel_btn.on_click(cancel_btn_clicked)\n\n    return tool_widget\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#youtube-channel","title":"YouTube Channel","text":"<p>More video tutorials for geemap and Earth Engine are available on my YouTube channel. If you can't access YouTube in your country, you can try \u897f\u74dc\u89c6\u9891 or \u54d4\u54e9\u54d4\u54e9\u3002</p> <p></p>"},{"location":"tutorials/#geemap-tutorials","title":"geemap Tutorials","text":"<ol> <li>Introducing the geemap Python package for interactive mapping with Google Earth Engine (video | gif | notebook)</li> <li>Using basemaps in geemap and ipyleaflet for interactive mapping with Google Earth Engine (video | gif | notebook)</li> <li>Introducing the Inspector tool for Earth Engine Python API (video | gif | notebook)</li> <li>Creating a split-panel map for visualizing Earth Engine data (video | gif | notebook)</li> <li>Using drawing tools to interact with Earth Engine data (video | gif | notebook)</li> <li>Creating an interactive map with a marker cluster (video | gif | notebook)</li> <li>Converting data formats between GeoJSON and Earth Engine (video | gif | notebook)</li> <li>Automated conversion from Earth Engine JavaScripts to Python scripts and Jupyter notebooks (video | gif | notebook)</li> <li>Interactive plotting of Earth Engine data with minimal coding (video | gif | notebook)</li> <li>Using shapefiles with Earth Engine without having to upload data to GEE (video | gif | notebook)</li> <li>Exporting Earth Engine Image and ImageCollection as GeoTIFF and Numpy array (video | gif | notebook)</li> <li>Computing zonal statistics with Earth Engine and exporting results as CSV or shapefile (video | gif | notebook)</li> <li>Calculating zonal statistics by group (e.g., analyzing land cover composition of each country/state) (video | gif | notebook)</li> <li>Adding a customized legend for Earth Engine data (video | gif | notebook)</li> <li>Converting Earth Engine JavaScripts to Python code directly within Jupyter notebook (video | gif | notebook)</li> <li>Adding animated text to GIF images generated from Earth Engine data (video | gif | notebook)</li> <li>Adding colorbar and images to GIF animations generated from Earth Engine data (video | gif | notebook)</li> <li>Creating Landsat timelapse animations with animated text using Earth Engine (video | gif | notebook)</li> <li>How to search and import datasets from Earth Engine Data Catalog (video | gif | notebook)</li> <li>Using timeseries inspector to visualize landscape changes over time (video | gif | notebook)</li> <li>Exporting Earth Engine maps as HTML files and PNG images (video | gif | notebook)</li> <li>How to import Earth Engine Python scripts into Jupyter notebook? (video | gif | notebook)</li> <li>How to search Earth Engine API and import assets from GEE personal account? (video | gif | notebook)</li> <li>How to publish interactive Earth Engine maps? (video | gif | notebook)</li> <li>How to load local raster datasets with geemap? (video | gif | notebook)</li> <li>How to create and deploy Earth Engine Apps using Python? (video | gif | notebook)</li> <li>How to create an interactive Earth Engine App for creating Landsat timelapse? (video | gif | notebook)</li> <li>How to use your local computer as a web server for hosting Earth Engine Apps? (video | gif | notebook)</li> <li>How to use pydeck for rendering Earth Engine data (video | gif | notebook)</li> <li>How to get image basic properties and descriptive statistics (video | gif | notebook)</li> <li>Machine Learning with Earth Engine - Unsupervised Classification (video | gif | notebook)</li> <li>Machine Learning with Earth Engine - Supervised Classification (video | gif | notebook)</li> <li>Machine Learning with Earth Engine - Performing Accuracy Assessment for Image Classification (video | gif | notebook)</li> <li>Interactive extraction of pixel values and interactive region reduction (video | gif | notebook)</li> <li>How to use geemap and Earth Engine in Google Colab (video | gif | notebook)</li> <li>How to find out the greenest day of the year (video | gif | notebook)</li> <li>How to use Earth Engine with pydeck for 3D terrain visualization (video | gif | notebook)</li> <li>How to use Cloud Optimized GeoTIFF with Earth Engine (video | gif | notebook)</li> <li>How to create Landsat timelapse animations without coding (video | gif | notebook)</li> <li>How to add interactive widgets to the map (video | gif | notebook)</li> <li>How to develop an Earth Engine app for mapping surface water dynamics (video | gif | notebook)</li> <li>How to upload data to Earth Engine Apps using ipywidgets (video | gif | notebook)</li> <li>How to extract pixel values from an Earth Engine image using a point shapefile (video | gif | notebook)</li> <li>How to use Cloud Optimized GeoTIFF (COG) and SpatioTemporal Asset Catalog (STAC) (video | gif | notebook)</li> <li>How to load a virtual mosaic of Cloud Optimized GeoTIFFs (COG) (video | gif | notebook)</li> <li>How to use locally trained machine learning models with Earth Engine (video | gif | notebook)</li> <li>How to download image thumbnails from Earth Engine (video | gif | notebook)</li> <li>How to add a draggable legend to folium maps (video | gif | notebook)</li> <li>How to add a colorbar to the map (video | gif | notebook)</li> <li>How to create publication quality maps using cartoee (video | gif | notebook)</li> <li>How to create publication quality maps with custom projections (video | gif | notebook)</li> <li>How to create timelapse animations with custom projection, scale bar, and north arrow (video | gif | notebook)</li> <li>How to change layer visualization interactively with a GUI (video | gif | notebook)</li> <li>Visualizing Earth Engine vector data interactively with a GUI (video | gif | notebook)</li> <li>Visualizing Earth Engine raster data interactively with a GUI (video | gif | notebook)</li> <li>Loading local vector and raster data to geemap without coding (video | gif | notebook)</li> <li>Creating publication-quality maps with multiple Earth Engine layers (video | gif | notebook)</li> <li>Loading vector data (e.g., shp, kml, geojson) to the map without coding (video | gif | notebook)</li> <li>Using whitebox with geemap (video | gif | notebook)</li> <li>Visualizing Earth Engine data with over 200 colormaps through dot notation (video | gif | notebook)</li> <li>Adding a scale bar to a cartoee map (video | gif | notebook)</li> <li>Using the time slider for visualizing Earth Engine time-series images (video | gif | notebook)</li> <li>Creating interactive charts from Earth Engine data (video | gif | notebook)</li> <li>Accessing the Earth Engine Data Catalog via dot notation with autocompletion (video | gif | notebook)</li> <li>Styling Earth Engine vector data (video | gif | notebook)</li> <li>Adding a legend to publication quality maps using cartoee (video | gif | notebook)</li> <li>Creating training samples for machine learning and supervised image classification (video | gif | notebook)</li> <li>Converting NetCDF to Earth Engine Image (video | gif | notebook)</li> <li>Plotting Earth Engine vector data with cartoee (video | gif | notebook)</li> <li>Creating linked maps with a few lines of code (video | gif | notebook)</li> <li>Creating Landsat timelapse animations with a few clicks (video | gif | notebook)</li> <li>Creating time-series cloud-free composites with a few clicks (video | gif | notebook)</li> <li>Generating transects along lines with Earth Engine without coding (video | gif | notebook)</li> <li>Creating points from CSV without coding (video | gif | notebook)</li> <li>Visualizing land cover change with interactive Sankey diagrams (video | gif | notebook)</li> <li>Downloading and visualizing OpenStreetMap data (video | gif | notebook)</li> <li>Adding Planet global monthly and quarterly mosaic (video | gif | notebook)</li> <li>Using timeseries inspector with one click (video | gif | notebook)</li> <li>Creating histograms using the geemap chart module (video | gif | notebook)</li> <li>Adding a point layer with popup attributes (video | gif | notebook)</li> <li>Creating timelapse animations from GEOS weather satellites (video | gif | notebook)</li> <li>Creating elevation contours for any location around the globe (video | gif | notebook)</li> <li>Loading local raster datasets and Cloud Optimized GeoTIFF (COG) (notebook)</li> <li>Downloading OpenStreetMap data with a single line of code (notebook)</li> <li>Converting PostGIS data to ee.FeatureCollection (notebook)</li> <li>Adding image overlay to the map (notebook)</li> <li>Adding points from xy data (e.g., CSV, Pandas DataFrame) (notebook)</li> <li>Adding circle markers from xy data (e.g., CSV, Pandas DataFrame) (notebook)</li> <li>Labeling Earth Engine FeatureCollection on the map (notebook)</li> <li>Creating 1-m resolution NAIP imagery timelapse (notebook)</li> <li>Adding Planetary Computer STAC item to the map (notebook)</li> <li>Using plotly with Earth Engine (notebook)</li> <li>Getting pixel values from COG/STAC using the Inspector tool (notebook)</li> <li>Using heremap with Earth Engine (notebook)</li> <li>Creating Cloud Optimized GeoTIFF (COG) (notebook)</li> <li>Exporting thousands of image chips in a few minutes (notebook)</li> <li>Joining attribute tables with only one line of code (notebook)</li> <li>Adding crossfade to satellite timelapse (notebook)</li> <li>Visualizing Landsat 9 data (notebook)</li> <li>Converting numpy array to COG (notebook)</li> <li>Visualizing LiDAR data in 3D with only one line of code (notebook)</li> <li>Creating a shaded relief by blending DEM and hillshade (notebook)</li> <li>Creating a split-panel map with folium (notebook)</li> <li>Clipping an image by mask (notebook)</li> <li>Visualizing NetCDF data (notebook)</li> <li>Using the kepler.gl plotting backend (notebook)</li> <li>Using the pydeck plotting backend (notebook)</li> <li>Calculating zonal statistics with two images (notebook)</li> <li>Creating coordinate grids with one line of code (notebook)</li> <li>Creating choropleth maps with a variety of classification schemes (notebook)</li> <li>Mapping the number of available satellite images for each pixel location (notebook)</li> <li>Adding basemaps to cartoee publication-quality maps (notebook)</li> <li>Calculating global land cover area with only one line of code (notebook)</li> <li>Creating near real-time global 10-m land cover maps with Dynamic World (notebook)</li> <li>Comparing Dynamic World with ESA and ESRI global land cover data (notebook)</li> <li>Creating global land cover timeseries (notebook)</li> <li>Creating a fishnet based on an input vector dataset (notebook)</li> <li>Downloading images directly to a local computer (notebook)</li> <li>Plotting raster data in 3D with only one line of code (notebook)</li> <li>Calling functions in Earth Engine JavaScript libraries from Python (notebook)</li> <li>Styling vector data based on attributes (notebook)</li> <li>LiDAR data analysis and visualization with whitebox and geemap (notebook)</li> <li>Creating Sentinel-1 SAR imagery timelapse (notebook)</li> <li>Searching for awesome GEE community datasets (notebook)</li> <li>Using Earth Engine datasets example code (notebook)</li> <li>Using the improved Inspector GUI (notebook)</li> <li>Creating multiple legends and add them to the map (notebook)</li> <li>Adding text, images, HTML, and widgets to the map (notebook)</li> <li>Creating animated GIF from vector data with only one line of code (notebook)</li> <li>Printing Earth Engine objects without using the getInfo() function (notebook)</li> <li>Using Earth Engine with ArcGIS Pro (notebook)</li> <li>Adding colorbars to a folium map (notebook)</li> <li>Developing interactive web apps with gradio and geemap (notebook)</li> <li>Downloading Earth Engine map tiles as a GeoTIFF (notebook)</li> </ol>"},{"location":"usage/","title":"Usage","text":"<p>Below is a list of some commonly used functions available in the geemap Python package. Please check the API Reference for a complete list of all available functions.</p> <p>To create an ipyleaflet-based interactive map:</p> <pre><code>import geemap\nMap = geemap.Map(center=[40,-100], zoom=4)\nMap\n</code></pre> <p>To create a folium-based interactive map:</p> <pre><code>import geemap.foliumap as geemap\nMap = geemap.Map(center=[40,-100], zoom=4)\nMap\n</code></pre> <p>To add an Earth Engine data layer to the Map:</p> <pre><code>Map.addLayer(ee_object, vis_params, name, shown, opacity)\n</code></pre> <p>To center the map view at a given coordinates with the given zoom level:</p> <pre><code>Map.setCenter(lon, lat, zoom)\n</code></pre> <p>To center the map view around an Earth Engine object:</p> <pre><code>Map.centerObject(ee_object, zoom)\n</code></pre> <p>To add LayerControl to a folium-based Map:</p> <pre><code>Map.addLayerControl()\n</code></pre> <p>To add a minimap (overview) to an ipyleaflet-based Map:</p> <pre><code>Map.add_minimap()\n</code></pre> <p>To add additional basemaps to the Map:</p> <pre><code>Map.add_basemap('Esri.OceanBasemap')\nMap.add_basemap('Esri.NatGeoWorldMap')\n</code></pre> <p>To add an XYZ tile layer to the Map:</p> <pre><code>url = 'https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}'\nMap.add_tile_layer(url, name='Google Map', attribution='Google')\n</code></pre> <p>To add a WMS layer to the Map:</p> <pre><code>naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?'\nMap.add_wms_layer(url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True)\n</code></pre> <p>To convert a shapefile to Earth Engine object and add it to the Map:</p> <pre><code>ee_object = geemap.shp_to_ee(shp_file_path)\nMap.addLayer(ee_object, {}, 'Layer name')\n</code></pre> <p>To convert a GeoJSON file to Earth Engine object and add it to the Map:</p> <pre><code>ee_object = geemap.geojson_to_ee(geojson_file_path)\nMap.addLayer(ee_object, {}, 'Layer name')\n</code></pre> <p>To download an ee.FeatureCollection as a shapefile:</p> <pre><code>geemap.ee_to_csv(ee_object, filename, selectors)\n</code></pre> <p>To export an ee.FeatureCollection to other formats, including shp, csv, json, kml, and kmz:</p> <pre><code>geemap.ee_export_vector(ee_object, filename, selectors)\n</code></pre> <p>To export an ee.Image as a GeoTIFF file:</p> <pre><code>geemap.ee_export_image(ee_object, filename, scale, crs, region, file_per_band)\n</code></pre> <p>To export an ee.ImageCollection as GeoTIFF files:</p> <pre><code>geemap.ee_export_image_collection(ee_object, output, scale, crs, region, file_per_band)\n</code></pre> <p>To extract pixels from an ee.Image into a 3D numpy array:</p> <pre><code>geemap.ee_to_numpy(ee_object, bands, region, properties, default_value)\n</code></pre> <p>To calculate zonal statistics:</p> <pre><code>geemap.zonal_statistics(in_value_raster, in_zone_vector, out_file_path, statistics_type='MEAN')\n</code></pre> <p>To calculate zonal statistics by group:</p> <pre><code>geemap.zonal_statistics_by_group(in_value_raster, in_zone_vector, out_file_path, statistics_type='SUM')\n</code></pre> <p>To create a split-panel Map:</p> <pre><code>Map.split_map(left_layer='HYBRID', right_layer='ESRI')\n</code></pre> <p>To add a marker cluster to the Map:</p> <pre><code>Map.marker_cluster()\nfeature_collection = ee.FeatureCollection(Map.ee_markers)\n</code></pre> <p>To add a customized legend to the Map:</p> <pre><code>legend_dict = {\n    'one': (0, 0, 0),\n    'two': (255,255,0),\n    'three': (127, 0, 127)\n}\nMap.add_legend(legend_title='Legend', legend_dict=legend_dict, position='bottomright')\nMap.add_legend(builtin_legend='NLCD')\n</code></pre> <p>To download a GIF from an Earth Engine ImageCollection:</p> <pre><code>geemap.download_ee_video(tempCol, videoArgs, saved_gif)\n</code></pre> <p>To add animated text to an existing GIF image:</p> <pre><code>geemap.add_text_to_gif(in_gif, out_gif, xy=('5%', '5%'), text_sequence=1984, font_size=30, font_color='#0000ff', duration=100)\n</code></pre> <p>To create a colorbar for an Earth Engine image:</p> <pre><code>palette = ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']\ncreate_colorbar(width=250, height=30, palette=palette, vertical=False,add_labels=True, font_size=20, labels=[-40, 35])\n</code></pre> <p>To create a Landsat timelapse animation and add it to the Map:</p> <pre><code>Map.add_landsat_ts_gif(label='Place name', start_year=1985, bands=['NIR', 'Red', 'Green'], frames_per_second=5)\n</code></pre> <p>To convert all GEE JavaScripts in a folder recursively to Python scripts:</p> <pre><code>from geemap.conversion import *\njs_to_python_dir(in_dir, out_dir)\n</code></pre> <p>To convert all GEE Python scripts in a folder recursively to Jupyter notebooks:</p> <pre><code>from geemap.conversion import *\ntemplate_file = get_nb_template()\npy_to_ipynb_dir(in_dir, template_file, out_dir)\n</code></pre> <p>To execute all Jupyter notebooks in a folder recursively and save output cells:</p> <pre><code>from geemap.conversion import *\nexecute_notebook_dir(in_dir)\n</code></pre> <p>To search Earth Engine API documentation with Jupyter notebooks:</p> <pre><code>import geemap\ngeemap.ee_search()\n</code></pre> <p>To publish an interactive GEE map with Jupyter notebooks:</p> <pre><code>Map.publish(name, headline, visibility)\n</code></pre> <p>To add a local raster dataset to the map:</p> <pre><code>Map.add_raster(image, bands, colormap, layer_name)\n</code></pre> <p>To get image basic properties:</p> <pre><code>geemap.image_props(image).getInfo()\n</code></pre> <p>To get image descriptive statistics:</p> <pre><code>geemap.image_stats(image, region, scale)\n</code></pre> <p>To remove all user-drawn geometries:</p> <pre><code>geemap.remove_drawn_features()\n</code></pre> <p>To extract pixel values based on user-drawn geometries:</p> <pre><code>geemap.extract_values_to_points(out_shp)\n</code></pre>"},{"location":"assets/","title":"Credits","text":"<p>Credits to Khalil Misbah for the original design of the geemap logo.</p> <p></p>"},{"location":"notebooks/00_geemap_key_features/","title":"00 geemap key features","text":"Table of Contents <ul><li>1\u00a0\u00a0Create an interactive map</li><li>2\u00a0\u00a0Add basemaps</li><li>3\u00a0\u00a0Add WMS and XYZ tile layers</li><li>4\u00a0\u00a0Add Earth Engine data layers</li><li>5\u00a0\u00a0Search Earth Engine data catalog</li><li>6\u00a0\u00a0Search Earth Engine API documentation</li><li>7\u00a0\u00a0Use Inspector tool</li><li>8\u00a0\u00a0Use Plotting tool</li><li>9\u00a0\u00a0Create a split-panel map</li><li>10\u00a0\u00a0Add marker cluster</li><li>11\u00a0\u00a0Add customized legends</li><li>12\u00a0\u00a0Use Drawing tools</li><li>13\u00a0\u00a0Convert JavaScripts to Python</li><li>14\u00a0\u00a0Use shapefiles</li><li>15\u00a0\u00a0Create Landsat timelapse</li><li>16\u00a0\u00a0Use time-series inspector</li><li>17\u00a0\u00a0Export images</li></ul> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap('HYBRID')\n</pre> Map.add_basemap('HYBRID') In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap('OpenTopoMap')\n</pre> Map.add_basemap('OpenTopoMap') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.basemap_demo()\nMap\n</pre> Map = geemap.Map() Map.basemap_demo() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># https://viewer.nationalmap.gov/services/\nurl = 'https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}'\nMap.add_tile_layer(url, name='Google Satellite', attribution='Google')\n</pre> # https://viewer.nationalmap.gov/services/ url = 'https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}' Map.add_tile_layer(url, name='Google Satellite', attribution='Google') In\u00a0[\u00a0]: Copied! <pre>naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?'\nMap.add_wms_layer(\n    url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True\n)\n</pre> naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?' Map.add_wms_layer(     url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7'\n)\nMap.addLayer(states, {}, \"US States\")\n</pre> # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7' ) Map.addLayer(states, {}, \"US States\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map.search_locations\n</pre> Map.search_locations In\u00a0[\u00a0]: Copied! <pre>Map.search_loc_geom\n</pre> Map.search_loc_geom In\u00a0[\u00a0]: Copied! <pre>location = Map.search_loc_geom\n# print(location.getInfo())\n</pre> location = Map.search_loc_geom # print(location.getInfo()) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_search()\n</pre> geemap.ee_search() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7'\n)\nMap.addLayer(states, {}, \"US States\")\n\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7' ) Map.addLayer(states, {}, \"US States\")  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select([0, 1, 2, 3, 4, 6])\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat7, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")\n\nhyperion = ee.ImageCollection('EO1/HYPERION').filter(\n    ee.Filter.date('2016-01-01', '2017-03-01')\n)\nhyperion_vis = {\n    'min': 1000.0,\n    'max': 14000.0,\n    'gamma': 2.5,\n}\nMap.addLayer(hyperion, hyperion_vis, 'EO1/HYPERION')\n\nMap\n</pre> Map = geemap.Map()  landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select([0, 1, 2, 3, 4, 6]) landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat7, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")  hyperion = ee.ImageCollection('EO1/HYPERION').filter(     ee.Filter.date('2016-01-01', '2017-03-01') ) hyperion_vis = {     'min': 1000.0,     'max': 14000.0,     'gamma': 2.5, } Map.addLayer(hyperion, hyperion_vis, 'EO1/HYPERION')  Map In\u00a0[\u00a0]: Copied! <pre>Map.set_plot_options(plot_type='bar', add_marker_cluster=True)\n</pre> Map.set_plot_options(plot_type='bar', add_marker_cluster=True) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(left_layer='HYBRID', right_layer='ROADMAP')\nMap\n</pre> Map = geemap.Map() Map.split_map(left_layer='HYBRID', right_layer='ROADMAP') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(\n    left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover'\n)\nMap\n</pre> Map = geemap.Map() Map.split_map(     left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover' ) Map In\u00a0[\u00a0]: Copied! <pre>nlcd_2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover')\nnlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\n\nleft_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001')\nright_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')\n\nMap = geemap.Map()\nMap.split_map(left_layer, right_layer)\nMap\n</pre> nlcd_2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover') nlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')  left_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001') right_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')  Map = geemap.Map() Map.split_map(left_layer, right_layer) Map In\u00a0[\u00a0]: Copied! <pre>import geemap\nimport json\nimport os\nimport requests\nfrom geemap import geojson_to_ee, ee_to_geojson\nfrom ipyleaflet import GeoJSON, Marker, MarkerCluster\n</pre> import geemap import json import os import requests from geemap import geojson_to_ee, ee_to_geojson from ipyleaflet import GeoJSON, Marker, MarkerCluster In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>file_path = os.path.join(os.getcwd(), 'us_cities.json')\n\nif not os.path.exists(file_path):\n    url = 'https://github.com/gee-community/geemap/raw/master/examples/data/us_cities.json'\n    r = requests.get(url)\n    with open(file_path, 'w') as f:\n        f.write(r.content.decode(\"utf-8\"))\n\nwith open(file_path) as f:\n    json_data = json.load(f)\n</pre> file_path = os.path.join(os.getcwd(), 'us_cities.json')  if not os.path.exists(file_path):     url = 'https://github.com/gee-community/geemap/raw/master/examples/data/us_cities.json'     r = requests.get(url)     with open(file_path, 'w') as f:         f.write(r.content.decode(\"utf-8\"))  with open(file_path) as f:     json_data = json.load(f) In\u00a0[\u00a0]: Copied! <pre>maker_cluster = MarkerCluster(\n    markers=[\n        Marker(location=feature['geometry']['coordinates'][::-1])\n        for feature in json_data['features']\n    ],\n    name='Markers',\n)\n</pre> maker_cluster = MarkerCluster(     markers=[         Marker(location=feature['geometry']['coordinates'][::-1])         for feature in json_data['features']     ],     name='Markers', ) In\u00a0[\u00a0]: Copied! <pre>Map.add_layer(maker_cluster)\n</pre> Map.add_layer(maker_cluster) In\u00a0[\u00a0]: Copied! <pre>ee_fc = geojson_to_ee(json_data)\nMap.addLayer(ee_fc, {}, \"US Cities EE\")\n</pre> ee_fc = geojson_to_ee(json_data) Map.addLayer(ee_fc, {}, \"US Cities EE\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover') Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap.add_basemap('FWS NWI Wetlands')\nMap.add_legend(builtin_legend='NWI')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map.add_basemap('FWS NWI Wetlands') Map.add_legend(builtin_legend='NWI') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlegend_dict = {\n    '11 Open Water': '466b9f',\n    '12 Perennial Ice/Snow': 'd1def8',\n    '21 Developed, Open Space': 'dec5c5',\n    '22 Developed, Low Intensity': 'd99282',\n    '23 Developed, Medium Intensity': 'eb0000',\n    '24 Developed High Intensity': 'ab0000',\n    '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',\n    '41 Deciduous Forest': '68ab5f',\n    '42 Evergreen Forest': '1c5f2c',\n    '43 Mixed Forest': 'b5c58f',\n    '51 Dwarf Scrub': 'af963c',\n    '52 Shrub/Scrub': 'ccb879',\n    '71 Grassland/Herbaceous': 'dfdfc2',\n    '72 Sedge/Herbaceous': 'd1d182',\n    '73 Lichens': 'a3cc51',\n    '74 Moss': '82ba9e',\n    '81 Pasture/Hay': 'dcd939',\n    '82 Cultivated Crops': 'ab6c28',\n    '90 Woody Wetlands': 'b8d9eb',\n    '95 Emergent Herbaceous Wetlands': '6c9fb8',\n}\n\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\n\nMap.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n</pre> Map = geemap.Map()  legend_dict = {     '11 Open Water': '466b9f',     '12 Perennial Ice/Snow': 'd1def8',     '21 Developed, Open Space': 'dec5c5',     '22 Developed, Low Intensity': 'd99282',     '23 Developed, Medium Intensity': 'eb0000',     '24 Developed High Intensity': 'ab0000',     '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',     '41 Deciduous Forest': '68ab5f',     '42 Evergreen Forest': '1c5f2c',     '43 Mixed Forest': 'b5c58f',     '51 Dwarf Scrub': 'af963c',     '52 Shrub/Scrub': 'ccb879',     '71 Grassland/Herbaceous': 'dfdfc2',     '72 Sedge/Herbaceous': 'd1d182',     '73 Lichens': 'a3cc51',     '74 Moss': '82ba9e',     '81 Pasture/Hay': 'dcd939',     '82 Cultivated Crops': 'ab6c28',     '90 Woody Wetlands': 'b8d9eb',     '95 Emergent Herbaceous Wetlands': '6c9fb8', }  landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover')  Map.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) Map In\u00a0[\u00a0]: Copied! <pre># https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1\nMap = geemap.Map()\n\nee_class_table = \"\"\"\n\nValue\tColor\tDescription\n0\t1c0dff\tWater\n1\t05450a\tEvergreen needleleaf forest\n2\t086a10\tEvergreen broadleaf forest\n3\t54a708\tDeciduous needleleaf forest\n4\t78d203\tDeciduous broadleaf forest\n5\t009900\tMixed forest\n6\tc6b044\tClosed shrublands\n7\tdcd159\tOpen shrublands\n8\tdade48\tWoody savannas\n9\tfbff13\tSavannas\n10\tb6ff05\tGrasslands\n11\t27ff87\tPermanent wetlands\n12\tc24f44\tCroplands\n13\ta5a5a5\tUrban and built-up\n14\tff6d4c\tCropland/natural vegetation mosaic\n15\t69fff8\tSnow and ice\n16\tf9ffa4\tBarren or sparsely vegetated\n254\tffffff\tUnclassified\n\n\"\"\"\n\nlandcover = ee.Image('MODIS/051/MCD12Q1/2013_01_01').select('Land_Cover_Type_1')\nMap.setCenter(6.746, 46.529, 2)\nMap.addLayer(landcover, {}, 'MODIS Land Cover')\n\nlegend_dict = geemap.legend_from_ee(ee_class_table)\nMap.add_legend(legend_title=\"MODIS Global Land Cover\", legend_dict=legend_dict)\n\nMap\n</pre> # https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1 Map = geemap.Map()  ee_class_table = \"\"\"  Value\tColor\tDescription 0\t1c0dff\tWater 1\t05450a\tEvergreen needleleaf forest 2\t086a10\tEvergreen broadleaf forest 3\t54a708\tDeciduous needleleaf forest 4\t78d203\tDeciduous broadleaf forest 5\t009900\tMixed forest 6\tc6b044\tClosed shrublands 7\tdcd159\tOpen shrublands 8\tdade48\tWoody savannas 9\tfbff13\tSavannas 10\tb6ff05\tGrasslands 11\t27ff87\tPermanent wetlands 12\tc24f44\tCroplands 13\ta5a5a5\tUrban and built-up 14\tff6d4c\tCropland/natural vegetation mosaic 15\t69fff8\tSnow and ice 16\tf9ffa4\tBarren or sparsely vegetated 254\tffffff\tUnclassified  \"\"\"  landcover = ee.Image('MODIS/051/MCD12Q1/2013_01_01').select('Land_Cover_Type_1') Map.setCenter(6.746, 46.529, 2) Map.addLayer(landcover, {}, 'MODIS Land Cover')  legend_dict = geemap.legend_from_ee(ee_class_table) Map.add_legend(legend_title=\"MODIS Global Land Cover\", legend_dict=legend_dict)  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\nimage = ee.Image('USGS/SRTMGL1_003')\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine DEM to map\nMap.addLayer(image, vis_params, 'SRTM DEM')\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\n</pre> # Add Earth Engine dataset image = ee.Image('USGS/SRTMGL1_003')  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine DEM to map Map.addLayer(image, vis_params, 'SRTM DEM')  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') In\u00a0[\u00a0]: Copied! <pre>Map.draw_features\n</pre> Map.draw_features In\u00a0[\u00a0]: Copied! <pre>js_snippet = \"\"\"\n// Load an image.\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\n\n// Define the visualization parameters.\nvar vizParams = {\n  bands: ['B5', 'B4', 'B3'],\n  min: 0,\n  max: 0.5,\n  gamma: [0.95, 1.1, 1]\n};\n\n// Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay\nMap.addLayer(image, vizParams, 'false color composite');\n\n\"\"\"\n</pre> js_snippet = \"\"\" // Load an image. var image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');  // Define the visualization parameters. var vizParams = {   bands: ['B5', 'B4', 'B3'],   min: 0,   max: 0.5,   gamma: [0.95, 1.1, 1] };  // Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay Map.addLayer(image, vizParams, 'false color composite');  \"\"\" In\u00a0[\u00a0]: Copied! <pre>geemap.js_snippet_to_py(\n    js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True\n)\n</pre> geemap.js_snippet_to_py(     js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True ) In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nMap = geemap.Map()\n\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')\n\n# Define the visualization parameters.\nvizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n\n# Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10)\n# San Francisco Bay\nMap.addLayer(image, vizParams, 'False color composite')\nMap\n</pre> import ee import geemap  Map = geemap.Map()  # Load an image. image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')  # Define the visualization parameters. vizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}  # Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10) # San Francisco Bay Map.addLayer(image, vizParams, 'False color composite') Map In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nMap = geemap.Map()\n\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')\n\n# Define the visualization parameters.\nvizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n\n# Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10)\n# San Francisco Bay\nMap.addLayer(image, vizParams, 'False color composite')\nMap\n</pre> import ee import geemap  Map = geemap.Map()  # Load an image. image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')  # Define the visualization parameters. vizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}  # Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10) # San Francisco Bay Map.addLayer(image, vizParams, 'False color composite') Map In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nMap = geemap.Map()\nee.Initialize()\n\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')\n\n# Define the visualization parameters.\nvizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n\n# Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10)\n# San Francisco Bay\nMap.addLayer(image, vizParams, 'False color composite')\nMap\n</pre> import ee import geemap  Map = geemap.Map() ee.Initialize()  # Load an image. image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')  # Define the visualization parameters. vizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}  # Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10) # San Francisco Bay Map.addLayer(image, vizParams, 'False color composite') Map In\u00a0[\u00a0]: Copied! <pre>js_snippet = \"\"\"\n\n// Load an image.\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\n\n// Create an NDWI image, define visualization parameters and display.\nvar ndwi = image.normalizedDifference(['B3', 'B5']);\nvar ndwiViz = {min: 0.5, max: 1, palette: ['00FFFF', '0000FF']};\nMap.addLayer(ndwi, ndwiViz, 'NDWI', false);\n\n\"\"\"\n</pre> js_snippet = \"\"\"  // Load an image. var image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');  // Create an NDWI image, define visualization parameters and display. var ndwi = image.normalizedDifference(['B3', 'B5']); var ndwiViz = {min: 0.5, max: 1, palette: ['00FFFF', '0000FF']}; Map.addLayer(ndwi, ndwiViz, 'NDWI', false);  \"\"\" In\u00a0[\u00a0]: Copied! <pre>geemap.js_snippet_to_py(js_snippet)\n</pre> geemap.js_snippet_to_py(js_snippet) In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nMap = geemap.Map()\n\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')\n\n# Create an NDWI image, define visualization parameters and display.\nndwi = image.normalizedDifference(['B3', 'B5'])\nndwiViz = {'min': 0.5, 'max': 1, 'palette': ['00FFFF', '0000FF']}\nMap.addLayer(ndwi, ndwiViz, 'NDWI', False)\nMap\n</pre> import ee import geemap  Map = geemap.Map()  # Load an image. image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')  # Create an NDWI image, define visualization parameters and display. ndwi = image.normalizedDifference(['B3', 'B5']) ndwiViz = {'min': 0.5, 'max': 1, 'palette': ['00FFFF', '0000FF']} Map.addLayer(ndwi, ndwiViz, 'NDWI', False) Map In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nMap = geemap.Map()\n\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')\n\n# Create an NDWI image, define visualization parameters and display.\nndwi = image.normalizedDifference(['B3', 'B5'])\nndwiViz = {'min': 0.5, 'max': 1, 'palette': ['00FFFF', '0000FF']}\nMap.addLayer(ndwi, ndwiViz, 'NDWI', False)\nMap\n</pre> import ee import geemap  Map = geemap.Map()  # Load an image. image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')  # Create an NDWI image, define visualization parameters and display. ndwi = image.normalizedDifference(['B3', 'B5']) ndwiViz = {'min': 0.5, 'max': 1, 'palette': ['00FFFF', '0000FF']} Map.addLayer(ndwi, ndwiViz, 'NDWI', False) Map In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nMap = geemap.Map()\nee.Initialize()\n\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')\n\n# Create an NDWI image, define visualization parameters and display.\nndwi = image.normalizedDifference(['B3', 'B5'])\nndwiViz = {'min': 0.5, 'max': 1, 'palette': ['00FFFF', '0000FF']}\nMap.addLayer(ndwi, ndwiViz, 'NDWI', False)\nMap\n</pre> import ee import geemap  Map = geemap.Map() ee.Initialize()  # Load an image. image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')  # Create an NDWI image, define visualization parameters and display. ndwi = image.normalizedDifference(['B3', 'B5']) ndwiViz = {'min': 0.5, 'max': 1, 'palette': ['00FFFF', '0000FF']} Map.addLayer(ndwi, ndwiViz, 'NDWI', False) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>countries_shp = '../data/countries.shp'\ncountries = geemap.shp_to_ee(countries_shp)\n</pre> countries_shp = '../data/countries.shp' countries = geemap.shp_to_ee(countries_shp) In\u00a0[\u00a0]: Copied! <pre>countries_shp = '../data/countries.shp'\ncountries = geemap.shp_to_ee(countries_shp)\nMap.addLayer(countries, {}, 'Countries')\n</pre> countries_shp = '../data/countries.shp' countries = geemap.shp_to_ee(countries_shp) Map.addLayer(countries, {}, 'Countries') In\u00a0[\u00a0]: Copied! <pre>states_shp = '../data/us_states.shp'\nstates = geemap.shp_to_ee(states_shp)\nMap.addLayer(states, {}, 'US States')\n</pre> states_shp = '../data/us_states.shp' states = geemap.shp_to_ee(states_shp) Map.addLayer(states, {}, 'US States') In\u00a0[\u00a0]: Copied! <pre>cities_shp = '../data/us_cities.shp'\ncities = geemap.shp_to_ee(cities_shp)\nMap.addLayer(cities, {}, 'US Cities')\n</pre> cities_shp = '../data/us_cities.shp' cities = geemap.shp_to_ee(cities_shp) Map.addLayer(cities, {}, 'US Cities') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_shp(countries, filename='../data/countries_new.shp')\n</pre> geemap.ee_to_shp(countries, filename='../data/countries_new.shp') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_vector(states, filename='../data/states.csv')\n</pre> geemap.ee_export_vector(states, filename='../data/states.csv') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>label = 'Urban Growth in Las Vegas'\nMap.add_landsat_ts_gif(\n    label=label,\n    start_year=1985,\n    bands=['Red', 'Green', 'Blue'],\n    font_color='white',\n    frames_per_second=10,\n    progress_bar_color='blue',\n)\n</pre> label = 'Urban Growth in Las Vegas' Map.add_landsat_ts_gif(     label=label,     start_year=1985,     bands=['Red', 'Green', 'Blue'],     font_color='white',     frames_per_second=10,     progress_bar_color='blue', ) In\u00a0[\u00a0]: Copied! <pre>naip_ts = geemap.naip_timeseries(start_year=2009, end_year=2018)\n</pre> naip_ts = geemap.naip_timeseries(start_year=2009, end_year=2018) In\u00a0[\u00a0]: Copied! <pre>layer_names = ['NAIP ' + str(year) for year in range(2009, 2019)]\nprint(layer_names)\n</pre> layer_names = ['NAIP ' + str(year) for year in range(2009, 2019)] print(layer_names) In\u00a0[\u00a0]: Copied! <pre>naip_vis = {'bands': ['N', 'R', 'G']}\n</pre> naip_vis = {'bands': ['N', 'R', 'G']} In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.ts_inspector(\n    left_ts=naip_ts,\n    right_ts=naip_ts,\n    left_names=layer_names,\n    right_names=layer_names,\n    left_vis=naip_vis,\n    right_vis=naip_vis,\n)\nMap\n</pre> Map = geemap.Map() Map.ts_inspector(     left_ts=naip_ts,     right_ts=naip_ts,     left_names=layer_names,     right_names=layer_names,     left_vis=naip_vis,     right_vis=naip_vis, ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 0.7)\n</pre> image = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 0.7) In\u00a0[\u00a0]: Copied! <pre># Draw any shapes on the map using the Drawing tools before executing this code block\nfeature = Map.draw_last_feature\n\nif feature is None:\n    geom = ee.Geometry.Polygon(\n        [\n            [\n                [-115.413031, 35.889467],\n                [-115.413031, 36.543157],\n                [-114.034328, 36.543157],\n                [-114.034328, 35.889467],\n                [-115.413031, 35.889467],\n            ]\n        ]\n    )\n    feature = ee.Feature(geom, {})\n\nroi = feature.geometry()\n</pre> # Draw any shapes on the map using the Drawing tools before executing this code block feature = Map.draw_last_feature  if feature is None:     geom = ee.Geometry.Polygon(         [             [                 [-115.413031, 35.889467],                 [-115.413031, 36.543157],                 [-114.034328, 36.543157],                 [-114.034328, 35.889467],                 [-115.413031, 35.889467],             ]         ]     )     feature = ee.Feature(geom, {})  roi = feature.geometry() In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nfilename = os.path.join(out_dir, 'landsat.tif')\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') filename = os.path.join(out_dir, 'landsat.tif') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=False\n)\n</pre> geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=False ) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=True\n)\n</pre> geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=True ) In\u00a0[\u00a0]: Copied! <pre>loc = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(loc)\n    .filterDate('2008-01-01', '2020-01-01')\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n</pre> loc = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(loc)     .filterDate('2008-01-01', '2020-01-01')     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection(collection, out_dir=out_dir)\n</pre> geemap.ee_export_image_collection(collection, out_dir=out_dir)"},{"location":"notebooks/00_geemap_key_features/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#add-basemaps","title":"Add basemaps\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#add-wms-and-xyz-tile-layers","title":"Add WMS and XYZ tile layers\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#add-earth-engine-data-layers","title":"Add Earth Engine data layers\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#search-earth-engine-data-catalog","title":"Search Earth Engine data catalog\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#search-earth-engine-api-documentation","title":"Search Earth Engine API documentation\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#use-inspector-tool","title":"Use Inspector tool\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#use-plotting-tool","title":"Use Plotting tool\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#create-a-split-panel-map","title":"Create a split-panel map\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#add-marker-cluster","title":"Add marker cluster\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#add-customized-legends","title":"Add customized legends\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#use-drawing-tools","title":"Use Drawing tools\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#convert-javascripts-to-python","title":"Convert JavaScripts to Python\u00b6","text":"<p>You can simply copy and paste your GEE JavaScripts into a code block wrapped with trip quotes and pass it to a variable.</p> <p>For example, you can grap GEE JavaScripts from GEE Documentation.</p>"},{"location":"notebooks/00_geemap_key_features/#use-shapefiles","title":"Use shapefiles\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#create-landsat-timelapse","title":"Create Landsat timelapse\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#use-time-series-inspector","title":"Use time-series inspector\u00b6","text":""},{"location":"notebooks/00_geemap_key_features/#export-images","title":"Export images\u00b6","text":""},{"location":"notebooks/01_geemap_intro/","title":"01 geemap intro","text":"Table of Contents <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('h0pz3S6Tvx0')\n</pre> geemap.show_youtube('h0pz3S6Tvx0') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4) Map In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap('HYBRID')\n</pre> Map.add_basemap('HYBRID') In\u00a0[\u00a0]: Copied! <pre>basemaps = geemap.basemaps\nfor basemap in basemaps:\n    print(basemap)\n</pre> basemaps = geemap.basemaps for basemap in basemaps:     print(basemap) In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap('OpenTopoMap')\n</pre> Map.add_basemap('OpenTopoMap')"},{"location":"notebooks/02_using_basemaps/","title":"02 using basemaps","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('6J5ZCIUPXfI')\n</pre> geemap.show_youtube('6J5ZCIUPXfI') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap('HYBRID')\n</pre> Map.add_basemap('HYBRID') In\u00a0[\u00a0]: Copied! <pre>naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?'\nMap.add_wms_layer(\n    url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True\n)\n</pre> naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?' Map.add_wms_layer(     url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True ) In\u00a0[\u00a0]: Copied! <pre>url = 'https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}'\nMap.add_tile_layer(url, name='Google Map', attribution='Google')\n</pre> url = 'https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}' Map.add_tile_layer(url, name='Google Map', attribution='Google') In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.basemap_demo()\nm\n</pre> m = geemap.Map() m.basemap_demo() m"},{"location":"notebooks/03_inspector_tool/","title":"03 inspector tool","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('k477ksjkaXw')\n</pre> geemap.show_youtube('k477ksjkaXw') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n</pre> Map = geemap.Map(center=(40, -100), zoom=4) In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\n\nMap\n</pre> # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\")  Map"},{"location":"notebooks/03_inspector_tool/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/03_inspector_tool/#add-earth-engine-python-script","title":"Add Earth Engine Python script\u00b6","text":""},{"location":"notebooks/04_split_panel_map/","title":"04 split panel map","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('9EUTX8j-YVM')\n</pre> geemap.show_youtube('9EUTX8j-YVM') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map()\nMap\n</pre> Map = geemap.Map() Map.split_map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(left_layer='HYBRID', right_layer='ROADMAP')\nMap\n</pre> Map = geemap.Map() Map.split_map(left_layer='HYBRID', right_layer='ROADMAP') Map In\u00a0[\u00a0]: Copied! <pre>basemaps = geemap.basemaps.keys()\nprint(basemaps)\n</pre> basemaps = geemap.basemaps.keys() print(basemaps) In\u00a0[\u00a0]: Copied! <pre>for basemap in basemaps:\n    print(basemap)\n</pre> for basemap in basemaps:     print(basemap) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(\n    left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover'\n)\nMap\n</pre> Map = geemap.Map() Map.split_map(     left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover' ) Map In\u00a0[\u00a0]: Copied! <pre>import ee\n</pre> import ee In\u00a0[\u00a0]: Copied! <pre># https://developers.google.com/earth-engine/datasets/catalog/USGS_NLCD\ncollection = ee.ImageCollection(\"USGS/NLCD\")\nprint(collection.aggregate_array('system:id').getInfo())\n</pre> # https://developers.google.com/earth-engine/datasets/catalog/USGS_NLCD collection = ee.ImageCollection(\"USGS/NLCD\") print(collection.aggregate_array('system:id').getInfo()) In\u00a0[\u00a0]: Copied! <pre>nlcd_2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover')\nnlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\n\nleft_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001')\nright_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')\n\nMap = geemap.Map()\nMap.split_map(left_layer, right_layer)\nMap\n</pre> nlcd_2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover') nlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')  left_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001') right_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')  Map = geemap.Map() Map.split_map(left_layer, right_layer) Map"},{"location":"notebooks/05_drawing_tools/","title":"05 drawing tools","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('N7rK2aV1R4c')\n</pre> geemap.show_youtube('N7rK2aV1R4c') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\nimage = ee.Image('USGS/SRTMGL1_003')\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine DEM to map\nMap.addLayer(image, vis_params, 'SRTM DEM')\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\n</pre> # Add Earth Engine dataset image = ee.Image('USGS/SRTMGL1_003')  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine DEM to map Map.addLayer(image, vis_params, 'SRTM DEM')  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') In\u00a0[\u00a0]: Copied! <pre>Map.draw_features\n</pre> Map.draw_features In\u00a0[\u00a0]: Copied! <pre>Map.draw_last_feature\n</pre> Map.draw_last_feature In\u00a0[\u00a0]: Copied! <pre>roi = ee.FeatureCollection(Map.draw_features)\nselected_states = states.filterBounds(roi)\nMap.addLayer(selected_states, {}, \"Selected states\")\n</pre> roi = ee.FeatureCollection(Map.draw_features) selected_states = states.filterBounds(roi) Map.addLayer(selected_states, {}, \"Selected states\") In\u00a0[\u00a0]: Copied! <pre>clipped_image = image.clip(selected_states)\nMap.addLayer(clipped_image, vis_params, 'Clipped image')\n</pre> clipped_image = image.clip(selected_states) Map.addLayer(clipped_image, vis_params, 'Clipped image')"},{"location":"notebooks/06_marker_cluster/","title":"06 marker cluster","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\nimport json\nimport os\nimport requests\nfrom geemap import geojson_to_ee, ee_to_geojson\nfrom ipyleaflet import GeoJSON, Marker, MarkerCluster\n</pre> import geemap import json import os import requests from geemap import geojson_to_ee, ee_to_geojson from ipyleaflet import GeoJSON, Marker, MarkerCluster In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('4HycJPrwpuo')\n</pre> geemap.show_youtube('4HycJPrwpuo') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>file_path = os.path.abspath('../data/us_cities.json')\n\nif not os.path.exists(file_path):\n    url = 'https://github.com/gee-community/geemap/raw/master/examples/data/us_cities.json'\n    r = requests.get(url)\n    with open(file_path, 'w') as f:\n        f.write(r.content.decode(\"utf-8\"))\n\nwith open(file_path) as f:\n    json_data = json.load(f)\n</pre> file_path = os.path.abspath('../data/us_cities.json')  if not os.path.exists(file_path):     url = 'https://github.com/gee-community/geemap/raw/master/examples/data/us_cities.json'     r = requests.get(url)     with open(file_path, 'w') as f:         f.write(r.content.decode(\"utf-8\"))  with open(file_path) as f:     json_data = json.load(f) In\u00a0[\u00a0]: Copied! <pre>maker_cluster = MarkerCluster(\n    markers=[\n        Marker(location=feature['geometry']['coordinates'][::-1])\n        for feature in json_data['features']\n    ],\n    name='Markers',\n)\n</pre> maker_cluster = MarkerCluster(     markers=[         Marker(location=feature['geometry']['coordinates'][::-1])         for feature in json_data['features']     ],     name='Markers', ) In\u00a0[\u00a0]: Copied! <pre>Map.add_layer(maker_cluster)\n</pre> Map.add_layer(maker_cluster) In\u00a0[\u00a0]: Copied! <pre>ee_fc = geojson_to_ee(json_data)\nMap.addLayer(ee_fc, {}, \"US Cities EE\")\n</pre> ee_fc = geojson_to_ee(json_data) Map.addLayer(ee_fc, {}, \"US Cities EE\")"},{"location":"notebooks/07_geojson/","title":"07 geojson","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\nimport json\nimport os\nimport requests\nfrom geemap import geojson_to_ee, ee_to_geojson\nfrom ipyleaflet import GeoJSON\n</pre> import geemap import json import os import requests from geemap import geojson_to_ee, ee_to_geojson from ipyleaflet import GeoJSON In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('DbK_SRgrCHw')\n</pre> geemap.show_youtube('DbK_SRgrCHw') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>file_path = os.path.abspath('../data/us_states.json')\n\nif not os.path.exists(file_path):\n    url = 'https://github.com/gee-community/geemap/raw/master/examples/data/us_states.json'\n    r = requests.get(url)\n    with open(file_path, 'w') as f:\n        f.write(r.content.decode(\"utf-8\"))\n\nwith open(file_path) as f:\n    json_data = json.load(f)\n</pre> file_path = os.path.abspath('../data/us_states.json')  if not os.path.exists(file_path):     url = 'https://github.com/gee-community/geemap/raw/master/examples/data/us_states.json'     r = requests.get(url)     with open(file_path, 'w') as f:         f.write(r.content.decode(\"utf-8\"))  with open(file_path) as f:     json_data = json.load(f) In\u00a0[\u00a0]: Copied! <pre>json_layer = GeoJSON(\n    data=json_data,\n    name='US States JSON',\n    hover_style={'fillColor': 'red', 'fillOpacity': 0.5},\n)\nMap.add_layer(json_layer)\n</pre> json_layer = GeoJSON(     data=json_data,     name='US States JSON',     hover_style={'fillColor': 'red', 'fillOpacity': 0.5}, ) Map.add_layer(json_layer) In\u00a0[\u00a0]: Copied! <pre>ee_data = geojson_to_ee(json_data)\nMap.addLayer(ee_data, {}, \"US States EE\")\n</pre> ee_data = geojson_to_ee(json_data) Map.addLayer(ee_data, {}, \"US States EE\") In\u00a0[\u00a0]: Copied! <pre>json_data_2 = ee_to_geojson(ee_data)\njson_layer_2 = GeoJSON(\n    data=json_data_2,\n    name='US States EE JSON',\n    hover_style={'fillColor': 'red', 'fillOpacity': 0.5},\n)\nMap.add_layer(json_layer_2)\n</pre> json_data_2 = ee_to_geojson(ee_data) json_layer_2 = GeoJSON(     data=json_data_2,     name='US States EE JSON',     hover_style={'fillColor': 'red', 'fillOpacity': 0.5}, ) Map.add_layer(json_layer_2) In\u00a0[\u00a0]: Copied! <pre>file_path = os.path.abspath('../data/countries.geojson')\n\nif not os.path.exists(file_path):\n    url = 'https://github.com/gee-community/geemap/raw/master/examples/data/countries.geojson'\n    r = requests.get(url)\n    with open(file_path, 'w') as f:\n        f.write(r.content.decode(\"utf-8\"))\n\nwith open(file_path) as f:\n    json_data = json.load(f)\n</pre> file_path = os.path.abspath('../data/countries.geojson')  if not os.path.exists(file_path):     url = 'https://github.com/gee-community/geemap/raw/master/examples/data/countries.geojson'     r = requests.get(url)     with open(file_path, 'w') as f:         f.write(r.content.decode(\"utf-8\"))  with open(file_path) as f:     json_data = json.load(f) In\u00a0[\u00a0]: Copied! <pre>json_layer = GeoJSON(\n    data=json_data,\n    name='Countries',\n    hover_style={'fillColor': 'red', 'fillOpacity': 0.5},\n)\nMap.add_layer(json_layer)\n</pre> json_layer = GeoJSON(     data=json_data,     name='Countries',     hover_style={'fillColor': 'red', 'fillOpacity': 0.5}, ) Map.add_layer(json_layer) In\u00a0[\u00a0]: Copied! <pre>from ipywidgets import Text, HTML\nfrom ipyleaflet import WidgetControl, GeoJSON\n\nhtml1 = HTML(\n'''\n    &lt;h4&gt;Country&lt;/h4&gt;\n    Hover over a country\n'''\n)\nhtml1.layout.margin = '0px 20px 20px 20px'\ncontrol1 = WidgetControl(widget=html1, position='bottomright')\nMap.add_control(control1)\n\n\ndef update_html(feature, **kwargs):\n    html1.value = '''\n        &lt;h4&gt;Country code: &lt;b&gt;{}&lt;/b&gt;&lt;/h4&gt;\n        Country name: {}\n    '''.format(\n        feature['properties']['ISO_A2'], feature['properties']['NAME']\n    )\n\n\njson_layer.on_hover(update_html)\n</pre> from ipywidgets import Text, HTML from ipyleaflet import WidgetControl, GeoJSON  html1 = HTML(     '''     Country     Hover over a country ''' ) html1.layout.margin = '0px 20px 20px 20px' control1 = WidgetControl(widget=html1, position='bottomright') Map.add_control(control1)   def update_html(feature, **kwargs):     html1.value = '''         Country code: {}         Country name: {}     '''.format(         feature['properties']['ISO_A2'], feature['properties']['NAME']     )   json_layer.on_hover(update_html)"},{"location":"notebooks/08_ee_js_to_ipynb/","title":"08 ee js to ipynb","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('RpIaalFk4H8')\n</pre> geemap.show_youtube('RpIaalFk4H8') In\u00a0[\u00a0]: Copied! <pre>import os\nfrom geemap.conversion import *\n\n# Create a temporary working directory\nwork_dir = os.path.join(os.path.expanduser('~'), 'geemap')\n# Get Earth Engine JavaScript examples. There are five examples in the geemap package folder.\n# Change js_dir to your own folder containing your Earth Engine JavaScripts,\n# such as js_dir = '/path/to/your/js/folder'\njs_dir = get_js_examples(out_dir=work_dir)\n\n# Convert all Earth Engine JavaScripts in a folder recursively to Python scripts.\njs_to_python_dir(in_dir=js_dir, out_dir=js_dir, use_qgis=True)\nprint(\"Python scripts saved at: {}\".format(js_dir))\n</pre> import os from geemap.conversion import *  # Create a temporary working directory work_dir = os.path.join(os.path.expanduser('~'), 'geemap') # Get Earth Engine JavaScript examples. There are five examples in the geemap package folder. # Change js_dir to your own folder containing your Earth Engine JavaScripts, # such as js_dir = '/path/to/your/js/folder' js_dir = get_js_examples(out_dir=work_dir)  # Convert all Earth Engine JavaScripts in a folder recursively to Python scripts. js_to_python_dir(in_dir=js_dir, out_dir=js_dir, use_qgis=True) print(\"Python scripts saved at: {}\".format(js_dir)) In\u00a0[\u00a0]: Copied! <pre># Convert all Earth Engine Python scripts in a folder recursively to Jupyter notebooks.\nnb_template = get_nb_template()  # Get the notebook template from the package folder.\npy_to_ipynb_dir(js_dir, nb_template)\n\n# Execute all Jupyter notebooks in a folder recursively and save the output cells.\n# execute_notebook_dir(in_dir=js_dir)\n</pre> # Convert all Earth Engine Python scripts in a folder recursively to Jupyter notebooks. nb_template = get_nb_template()  # Get the notebook template from the package folder. py_to_ipynb_dir(js_dir, nb_template)  # Execute all Jupyter notebooks in a folder recursively and save the output cells. # execute_notebook_dir(in_dir=js_dir)"},{"location":"notebooks/08_ee_js_to_ipynb/#automatic-conversion-from-earth-engine-javascripts-to-python-scripts","title":"Automatic conversion from Earth Engine JavaScripts to Python scripts\u00b6","text":""},{"location":"notebooks/08_ee_js_to_ipynb/#install-earth-engine-api-and-geemap","title":"Install Earth Engine API and geemap\u00b6","text":"<p>Install the Earth Engine Python API and geemap. The geemap Python package is built upon the ipyleaflet and folium packages and implements several methods for interacting with Earth Engine data layers, such as <code>Map.addLayer()</code>, <code>Map.setCenter()</code>, and <code>Map.centerObject()</code>. The following script checks if the geemap package has been installed. If not, it will install geemap, which automatically installs its dependencies, including earthengine-api, folium, and ipyleaflet.</p> <p>Important note: A key difference between folium and ipyleaflet is that ipyleaflet is built upon ipywidgets and allows bidirectional communication between the front-end and the backend enabling the use of the map to capture user input, while folium is meant for displaying static data only (source). Note that Google Colab currently does not support ipyleaflet (source). Therefore, if you are using geemap with Google Colab, you should use <code>import geemap.foliumap</code>. If you are using geemap with binder or a local Jupyter notebook server, you can use <code>import geemap</code>, which provides more functionalities for capturing user input (e.g., mouse-clicking and moving).</p>"},{"location":"notebooks/08_ee_js_to_ipynb/#convert-earth-engine-javascripts-to-python-scripts","title":"Convert Earth Engine JavaScripts to Python scripts\u00b6","text":""},{"location":"notebooks/08_ee_js_to_ipynb/#convert-earth-engine-python-scripts-to-jupyter-notebooks","title":"Convert Earth Engine Python scripts to Jupyter Notebooks\u00b6","text":""},{"location":"notebooks/09_plotting/","title":"09 plotting","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('PDab8mkAFL0')\n</pre> geemap.show_youtube('PDab8mkAFL0') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select([0, 1, 2, 3, 4, 6])\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat7, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")\n\nhyperion = ee.ImageCollection('EO1/HYPERION').filter(\n    ee.Filter.date('2016-01-01', '2017-03-01')\n)\nhyperion_vis = {\n    'min': 1000.0,\n    'max': 14000.0,\n    'gamma': 2.5,\n}\nMap.addLayer(hyperion, hyperion_vis, 'EO1/HYPERION');\n</pre> landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select([0, 1, 2, 3, 4, 6]) landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat7, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")  hyperion = ee.ImageCollection('EO1/HYPERION').filter(     ee.Filter.date('2016-01-01', '2017-03-01') ) hyperion_vis = {     'min': 1000.0,     'max': 14000.0,     'gamma': 2.5, } Map.addLayer(hyperion, hyperion_vis, 'EO1/HYPERION'); In\u00a0[\u00a0]: Copied! <pre>Map.set_plot_options(plot_type='bar', add_marker_cluster=True)\n</pre> Map.set_plot_options(plot_type='bar', add_marker_cluster=True) In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm\n</pre> m = geemap.Map() m In\u00a0[\u00a0]: Copied! <pre># m.plot_demo()\n</pre> # m.plot_demo()"},{"location":"notebooks/100_numpy_to_cog/","title":"100 numpy to cog","text":"<p>Create a fresh conda env to run this example if needed.</p> <pre><code>conda create -n cog python=3.9\nconda install mamba -c conda-forge\nmamba install geemap rio-cogeo -c conda-forge\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap rio-cogeo\n</pre> # !pip install geemap rio-cogeo In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>url = 'https://github.com/giswqs/leafmap/raw/master/examples/data/cog.tif'\nin_cog = 'cog.tif'\nout_cog = \"ndvi.tif\"\n</pre> url = 'https://github.com/giswqs/leafmap/raw/master/examples/data/cog.tif' in_cog = 'cog.tif' out_cog = \"ndvi.tif\" <p>Download a sample dataset.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.download_from_url(url, in_cog)\n</pre> geemap.download_from_url(url, in_cog) <p>Convert image to numpy array.</p> In\u00a0[\u00a0]: Copied! <pre>arr = geemap.image_to_numpy(in_cog)\n</pre> arr = geemap.image_to_numpy(in_cog) In\u00a0[\u00a0]: Copied! <pre>arr.shape\n</pre> arr.shape <p>Computer NDVI.</p> In\u00a0[\u00a0]: Copied! <pre>ndvi = (arr[3] - arr[0]) / (arr[3] + arr[0])\n</pre> ndvi = (arr[3] - arr[0]) / (arr[3] + arr[0]) In\u00a0[\u00a0]: Copied! <pre>ndvi.shape\n</pre> ndvi.shape <p>Convert numpy array to COG.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.numpy_to_cog(ndvi, out_cog, profile=in_cog)\n</pre> geemap.numpy_to_cog(ndvi, out_cog, profile=in_cog) In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_raster(in_cog, band=[4, 1, 2], layer_name=\"Color infrared\")\nm.add_raster(out_cog, palette=\"Greens\", layer_name=\"NDVI\")\nm\n</pre> m = geemap.Map() m.add_raster(in_cog, band=[4, 1, 2], layer_name=\"Color infrared\") m.add_raster(out_cog, palette=\"Greens\", layer_name=\"NDVI\") m <p></p>"},{"location":"notebooks/101_lidar/","title":"101 lidar","text":"<p>Visualizing LiDAR data in 3D with only one line of code</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap[lidar] open3d\n</pre> # !pip install geemap[lidar] open3d In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap\n</pre> import os import geemap <p>Download a sample LiDAR dataset from Google Drive. The zip file is 52.1 MB and the uncompressed LAS file is 109 MB.</p> In\u00a0[\u00a0]: Copied! <pre>url = (\n    'https://drive.google.com/file/d/1H_X1190vL63BoFYa_cVBDxtIa8rG-Usb/view?usp=sharing'\n)\nfilename = 'madison.las'\n</pre> url = (     'https://drive.google.com/file/d/1H_X1190vL63BoFYa_cVBDxtIa8rG-Usb/view?usp=sharing' ) filename = 'madison.las' In\u00a0[\u00a0]: Copied! <pre>if not os.path.exists(filename):\n    geemap.download_file(url, 'madison.zip', unzip=True)\n</pre> if not os.path.exists(filename):     geemap.download_file(url, 'madison.zip', unzip=True) <p>Read the LiDAR data</p> In\u00a0[\u00a0]: Copied! <pre>las = geemap.read_lidar(filename)\n</pre> las = geemap.read_lidar(filename) <p>The LAS header.</p> In\u00a0[\u00a0]: Copied! <pre>las.header\n</pre> las.header <p>The number of points.</p> In\u00a0[\u00a0]: Copied! <pre>las.header.point_count\n</pre> las.header.point_count <p>The list of features.</p> In\u00a0[\u00a0]: Copied! <pre>list(las.point_format.dimension_names)\n</pre> list(las.point_format.dimension_names) <p>Inspect data.</p> In\u00a0[\u00a0]: Copied! <pre>las.X\n</pre> las.X In\u00a0[\u00a0]: Copied! <pre>las.Y\n</pre> las.Y In\u00a0[\u00a0]: Copied! <pre>las.Z\n</pre> las.Z In\u00a0[\u00a0]: Copied! <pre>las.intensity\n</pre> las.intensity <p>Visualize LiDAR data using the pyvista backend.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.view_lidar(filename, cmap='terrain', backend='pyvista')\n</pre> # geemap.view_lidar(filename, cmap='terrain', backend='pyvista') <p></p> <p>Visualize LiDAR data using the ipygany backend.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.view_lidar(filename, backend='ipygany', background='white')\n</pre> # geemap.view_lidar(filename, backend='ipygany', background='white') <p></p> <p>Visualize LiDAR data using the panel backend.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.view_lidar(filename, cmap='terrain', backend='panel', background='white')\n</pre> # geemap.view_lidar(filename, cmap='terrain', backend='panel', background='white') <p></p> <p>Visualize LiDAR data using the open3d backend.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.view_lidar(filename, backend='open3d')\n</pre> # geemap.view_lidar(filename, backend='open3d') <p></p>"},{"location":"notebooks/102_blend_hillshade/","title":"102 blend hillshade","text":"<p>Creating a shaded relief map by blending DEM and hillshade</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p>Import libraries</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport geemap.colormaps as cm\n</pre> import ee import geemap import geemap.colormaps as cm <p>Create an interactive map</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map <p>Add DEM and hillshade to the map</p> In\u00a0[\u00a0]: Copied! <pre>dem = ee.Image(\"CGIAR/SRTM90_V4\")\nhillsahde = ee.Terrain.hillshade(dem)\n</pre> dem = ee.Image(\"CGIAR/SRTM90_V4\") hillsahde = ee.Terrain.hillshade(dem) In\u00a0[\u00a0]: Copied! <pre>vis = {'min': 0, 'max': 6000, 'palette': cm.palettes.dem}\n</pre> vis = {'min': 0, 'max': 6000, 'palette': cm.palettes.dem} In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(hillsahde, {}, 'Hillshade')\nMap.addLayer(dem, vis, 'DEM')\n</pre> Map.addLayer(hillsahde, {}, 'Hillshade') Map.addLayer(dem, vis, 'DEM') <p>Create a blended image by blending DEM and hillshade</p> In\u00a0[\u00a0]: Copied! <pre>blend = geemap.blend(top_layer=dem, top_vis=vis)\n</pre> blend = geemap.blend(top_layer=dem, top_vis=vis) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(blend, {}, 'Blend')\n</pre> Map.addLayer(blend, {}, 'Blend') <p>Add NLCD land cover to the map</p> In\u00a0[\u00a0]: Copied! <pre>nlcd = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover')\nnlcd_vis = {'bands': ['landcover']}\nMap.addLayer(nlcd, nlcd_vis, 'NLCD')\n</pre> nlcd = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover') nlcd_vis = {'bands': ['landcover']} Map.addLayer(nlcd, nlcd_vis, 'NLCD') <p>Create a blended image by blending NLCD and DEM.</p> In\u00a0[\u00a0]: Copied! <pre>result = geemap.blend(nlcd, dem, top_vis=nlcd_vis, expression='a*b')\n</pre> result = geemap.blend(nlcd, dem, top_vis=nlcd_vis, expression='a*b') In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(result, {}, 'Blend NLCD')\n</pre> Map.addLayer(result, {}, 'Blend NLCD')"},{"location":"notebooks/103_split_control/","title":"103 split control","text":"<p>Creating a split-panel map</p> <p>This notebook demonstrates how to add a split-panel map with geemap and folium. It also supports streamlit. Note that the ipyleaflet SplitControl does not support streamlit.</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport folium\nimport geemap.foliumap as geemap\n</pre> import ee import folium import geemap.foliumap as geemap <p>The split-panel map requires two layers: <code>left_layer</code> and <code>right_layer</code>. The layer instance can be a string representing a basemap, or an HTTP URL to a Cloud Optimized GeoTIFF (COG), or a folium TileLayer instance.</p> <p>Using basemaps</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(height=500)\nm.split_map(left_layer='TERRAIN', right_layer='OpenTopoMap')\nm\n</pre> m = geemap.Map(height=500) m.split_map(left_layer='TERRAIN', right_layer='OpenTopoMap') m <p>Show available basemaps.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.basemaps.keys()\n</pre> # geemap.basemaps.keys() <p>Using COG</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(height=600, center=[39.4948, -108.5492], zoom=12)\nurl = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\nurl2 = 'https://opendata.digitalglobe.com/events/california-fire-2020/post-event/2020-08-14/pine-gulch-fire20/10300100AAC8DD00.tif'\nm.split_map(url, url2)\nm\n</pre> m = geemap.Map(height=600, center=[39.4948, -108.5492], zoom=12) url = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif' url2 = 'https://opendata.digitalglobe.com/events/california-fire-2020/post-event/2020-08-14/pine-gulch-fire20/10300100AAC8DD00.tif' m.split_map(url, url2) m <p>Using folium TileLayer</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[40, -100], zoom=4)\n\nurl1 = 'https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2001_Land_Cover_L48/wms?'\nurl2 = 'https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?'\n\nleft_layer = folium.WmsTileLayer(\n    url=url1,\n    layers='NLCD_2001_Land_Cover_L48',\n    name='NLCD 2001',\n    attr='MRLC',\n    fmt=\"image/png\",\n    transparent=True,\n)\nright_layer = folium.WmsTileLayer(\n    url=url2,\n    layers='NLCD_2019_Land_Cover_L48',\n    name='NLCD 2019',\n    attr='MRLC',\n    fmt=\"image/png\",\n    transparent=True,\n)\n\nm.split_map(left_layer, right_layer)\nm\n</pre> m = geemap.Map(center=[40, -100], zoom=4)  url1 = 'https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2001_Land_Cover_L48/wms?' url2 = 'https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?'  left_layer = folium.WmsTileLayer(     url=url1,     layers='NLCD_2001_Land_Cover_L48',     name='NLCD 2001',     attr='MRLC',     fmt=\"image/png\",     transparent=True, ) right_layer = folium.WmsTileLayer(     url=url2,     layers='NLCD_2019_Land_Cover_L48',     name='NLCD 2019',     attr='MRLC',     fmt=\"image/png\",     transparent=True, )  m.split_map(left_layer, right_layer) m <p>Using Earth Engine layers</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[39.3322, -106.7349], zoom=10)\n</pre> m = geemap.Map(center=[39.3322, -106.7349], zoom=10) In\u00a0[\u00a0]: Copied! <pre>srtm = ee.Image(\"USGS/SRTMGL1_003\")\nhillshade = ee.Terrain.hillshade(srtm)\n</pre> srtm = ee.Image(\"USGS/SRTMGL1_003\") hillshade = ee.Terrain.hillshade(srtm) In\u00a0[\u00a0]: Copied! <pre>vis = {\n    'min': 0,\n    'max': 5000,\n    'palette': [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\n</pre> vis = {     'min': 0,     'max': 5000,     'palette': [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"], } In\u00a0[\u00a0]: Copied! <pre>left_layer = geemap.ee_tile_layer(hillshade, name='Hillshade')\nright_layer = geemap.ee_tile_layer(srtm, vis, name='DEM')\n</pre> left_layer = geemap.ee_tile_layer(hillshade, name='Hillshade') right_layer = geemap.ee_tile_layer(srtm, vis, name='DEM') In\u00a0[\u00a0]: Copied! <pre>m.split_map(left_layer, right_layer)\nm\n</pre> m.split_map(left_layer, right_layer) m"},{"location":"notebooks/104_clip_image/","title":"104 clip image","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap rasterio fiona\n</pre> # !pip install geemap rasterio fiona In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap <p>Download a sample raster dataset.</p> In\u00a0[\u00a0]: Copied! <pre>url = 'https://github.com/giswqs/data/raw/main/raster/srtm90.tif'\ndem = 'dem.tif'\n</pre> url = 'https://github.com/giswqs/data/raw/main/raster/srtm90.tif' dem = 'dem.tif' In\u00a0[\u00a0]: Copied! <pre>geemap.download_file(url, dem)\n</pre> geemap.download_file(url, dem) <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_raster(dem, palette='terrain', layer_name=\"DEM\")\nm\n</pre> m = geemap.Map() m.add_raster(dem, palette='terrain', layer_name=\"DEM\") m <p>Define a mask to extract the image. The mask can be a string representing a file path to a vector dataset (e.g., geojson, shp), or a list of coordinates (e.g., <code>[[lon,lat], [lon,lat]]</code>), or a dictionary representing a feature (e.g., m.user_roi).</p> <p>For example, the mask can be a filepath to a vector dataset.</p> In\u00a0[\u00a0]: Copied! <pre># mask = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/mask.geojson'\n</pre> # mask = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/mask.geojson' <p>Or you can draw a polygon on the map, then use <code>m.user_roi</code> as the mask.</p> In\u00a0[\u00a0]: Copied! <pre># mask = m.user_roi\n</pre> # mask = m.user_roi <p>Or specify a list of coordinates <code>[lon, lat]</code> as the mask.</p> In\u00a0[\u00a0]: Copied! <pre>mask = [\n    [-119.679565, 37.256566],\n    [-119.679565, 38.061067],\n    [-118.24585, 38.061067],\n    [-118.24585, 37.256566],\n    [-119.679565, 37.256566],\n]\n</pre> mask = [     [-119.679565, 37.256566],     [-119.679565, 38.061067],     [-118.24585, 38.061067],     [-118.24585, 37.256566],     [-119.679565, 37.256566], ] <p>Specify the output filename.</p> In\u00a0[\u00a0]: Copied! <pre>output = 'clip.tif'\n</pre> output = 'clip.tif' <p>Clip image by mask.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.clip_image(dem, mask, output)\n</pre> geemap.clip_image(dem, mask, output) <p>Add the clipped image to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.add_raster(output, palette='gist_earth', layer_name=\"Clip Image\")\n</pre> m.add_raster(output, palette='gist_earth', layer_name=\"Clip Image\")"},{"location":"notebooks/105_netcdf/","title":"105 netcdf","text":"<p>Visualizing NetCDF data</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap xarray rioxarray netcdf4 localtileserver\n</pre> # !pip install geemap xarray rioxarray netcdf4 localtileserver In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap <p>Download a sample NetCDF dataset.</p> In\u00a0[\u00a0]: Copied! <pre>url = 'https://github.com/giswqs/leafmap/raw/master/examples/data/wind_global.nc'\nfilename = 'wind_global.nc'\n</pre> url = 'https://github.com/giswqs/leafmap/raw/master/examples/data/wind_global.nc' filename = 'wind_global.nc' In\u00a0[\u00a0]: Copied! <pre>geemap.download_file(url, output=filename)\n</pre> geemap.download_file(url, output=filename) <p>Read the NetCDF dataset.</p> In\u00a0[\u00a0]: Copied! <pre>data = geemap.read_netcdf(filename)\ndata\n</pre> data = geemap.read_netcdf(filename) data <p>Convert the NetCDF dataset to GeoTIFF. Note that the longitude range of the NetCDF dataset is <code>[0, 360]</code>. We need to convert it to <code>[-180, 180]</code> by setting <code>shift_lon=True</code> so that it can be displayed on the map.</p> In\u00a0[\u00a0]: Copied! <pre>tif = 'wind_global.tif'\ngeemap.netcdf_to_tif(filename, tif, variables=['u_wind', 'v_wind'], shift_lon=True)\n</pre> tif = 'wind_global.tif' geemap.netcdf_to_tif(filename, tif, variables=['u_wind', 'v_wind'], shift_lon=True) <p>Add the GeoTIFF to the map. We can also overlay the country boundary on the map.</p> In\u00a0[\u00a0]: Copied! <pre>geojson = 'https://github.com/giswqs/leafmap/raw/master/examples/data/countries.geojson'\n</pre> geojson = 'https://github.com/giswqs/leafmap/raw/master/examples/data/countries.geojson' In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(layer_ctrl=True)\nm.add_raster(tif, band=[1], palette='coolwarm', layer_name='u_wind')\nm.add_geojson(geojson, layer_name='Countries')\nm\n</pre> m = geemap.Map(layer_ctrl=True) m.add_raster(tif, band=[1], palette='coolwarm', layer_name='u_wind') m.add_geojson(geojson, layer_name='Countries') m <p>You can also use the <code>add_netcdf()</code> function to add the NetCDF dataset to the map without having to convert it to GeoTIFF explicitly.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(layer_ctrl=True)\nm.add_netcdf(\n    filename,\n    variables=['v_wind'],\n    palette='coolwarm',\n    shift_lon=True,\n    layer_name='v_wind',\n)\nm.add_geojson(geojson, layer_name='Countries')\nm\n</pre> m = geemap.Map(layer_ctrl=True) m.add_netcdf(     filename,     variables=['v_wind'],     palette='coolwarm',     shift_lon=True,     layer_name='v_wind', ) m.add_geojson(geojson, layer_name='Countries') m <p>Visualizing wind velocity.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(layer_ctrl=True)\nm.add_basemap('CartoDB.DarkMatter')\nm.add_velocity(filename, zonal_speed='u_wind', meridional_speed='v_wind')\nm\n</pre> m = geemap.Map(layer_ctrl=True) m.add_basemap('CartoDB.DarkMatter') m.add_velocity(filename, zonal_speed='u_wind', meridional_speed='v_wind') m <p></p>"},{"location":"notebooks/106_kepler_gl/","title":"106 kepler gl","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import geemap.kepler as geemap\n</pre> import geemap.kepler as geemap <p>Create an interactive map. You can specify various parameters to initialize the map, such as <code>center</code>, <code>zoom</code>, <code>height</code>, and <code>widescreen</code>.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[40, -100], zoom=2, height=600, widescreen=False)\nm\n</pre> m = geemap.Map(center=[40, -100], zoom=2, height=600, widescreen=False) m <p>Save the map to an interactive html. To hide the side panel and disable map customization. Set <code>read_only=False</code></p> In\u00a0[\u00a0]: Copied! <pre>m.to_html(filename=\"kepler.html\", read_only=False)\n</pre> m.to_html(filename=\"kepler.html\", read_only=False) <p>Display the interactive map in a notebook cell.</p> In\u00a0[\u00a0]: Copied! <pre># m.static_map(width=950, height=600, read_only=True)\n</pre> # m.static_map(width=950, height=600, read_only=True) <p>Add a GeoJSON to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[20, 0], zoom=1)\nlines = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/cable_geo.geojson'\nm.add_geojson(lines, layer_name=\"Cable lines\")\nm\n</pre> m = geemap.Map(center=[20, 0], zoom=1) lines = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/cable_geo.geojson' m.add_geojson(lines, layer_name=\"Cable lines\") m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"kepler_lines.html\")\n</pre> m.to_html(\"kepler_lines.html\") <p>Add a GeoJSON with US state boundaries to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[50, -110], zoom=2)\npolygons = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/us_states.json'\nm.add_geojson(polygons, layer_name=\"Countries\")\nm\n</pre> m = geemap.Map(center=[50, -110], zoom=2) polygons = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/us_states.json' m.add_geojson(polygons, layer_name=\"Countries\") m <p>Add a shapefile to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[20, 0], zoom=1)\nin_shp = \"https://github.com/gee-community/geemap/raw/master/examples/data/countries.zip\"\nm.add_shp(in_shp, \"Countries\")\nm\n</pre> m = geemap.Map(center=[20, 0], zoom=1) in_shp = \"https://github.com/gee-community/geemap/raw/master/examples/data/countries.zip\" m.add_shp(in_shp, \"Countries\") m <p>Add a GeoPandas GeoDataFrame to the map.</p> In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\n</pre> import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>gdf = gpd.read_file(\n    \"https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/world_cities.geojson\"\n)\n</pre> gdf = gpd.read_file(     \"https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/world_cities.geojson\" ) In\u00a0[\u00a0]: Copied! <pre>gdf\n</pre> gdf In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[20, 0], zoom=1)\nm.add_gdf(gdf, \"World cities\")\nm\n</pre> m = geemap.Map(center=[20, 0], zoom=1) m.add_gdf(gdf, \"World cities\") m"},{"location":"notebooks/107_pydeck/","title":"107 pydeck","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap.deck as geemap\n</pre> import ee import geemap.deck as geemap <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=(40, -100), zoom=3)\nm\n</pre> m = geemap.Map(center=(40, -100), zoom=3) m <p>Add basemap.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"HYBRID\")\nm\n</pre> m = geemap.Map() m.add_basemap(\"HYBRID\") m <p>Add vector data to the map. It supports any GeoPandas supported format, such as GeoJSON, shapefile, KML.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nfilename = (\n    \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_states.geojson\"\n)\nm.add_vector(filename, random_color_column=\"STATEFP\")\nm\n</pre> m = geemap.Map() filename = (     \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_states.geojson\" ) m.add_vector(filename, random_color_column=\"STATEFP\") m <p>Add a GeoPandas GeoDataFrame to the map.</p> In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\n</pre> import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>url = (\n    \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_counties.geojson\"\n)\ngdf = gpd.read_file(url)\n</pre> url = (     \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_counties.geojson\" ) gdf = gpd.read_file(url) In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_gdf(gdf, random_color_column=\"STATEFP\")\nm\n</pre> m = geemap.Map() m.add_gdf(gdf, random_color_column=\"STATEFP\") m <p>Create a 3D view of the map. Press Ctrl and hold down the left mouse button to rotate the 3D view.</p> In\u00a0[\u00a0]: Copied! <pre>initial_view_state = {\n    \"latitude\": 40,\n    \"longitude\": -100,\n    \"zoom\": 3,\n    \"pitch\": 45,\n    \"bearing\": 10,\n}\nm = geemap.Map(initial_view_state=initial_view_state)\nfilename = (\n    \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_states.geojson\"\n)\nm.add_vector(\n    filename,\n    random_color_column=\"STATEFP\",\n    extruded=True,\n    get_elevation=\"ALAND\",\n    elevation_scale=0.000001,\n)\nm\n</pre> initial_view_state = {     \"latitude\": 40,     \"longitude\": -100,     \"zoom\": 3,     \"pitch\": 45,     \"bearing\": 10, } m = geemap.Map(initial_view_state=initial_view_state) filename = (     \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_states.geojson\" ) m.add_vector(     filename,     random_color_column=\"STATEFP\",     extruded=True,     get_elevation=\"ALAND\",     elevation_scale=0.000001, ) m <p></p> <p>Add Earth Engine layers.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=3)\n\ndem = ee.Image('USGS/SRTMGL1_003')\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=3)  dem = ee.Image('USGS/SRTMGL1_003')  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM') Map"},{"location":"notebooks/108_image_zonal_stats/","title":"108 image zonal stats","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p>Import libraries.</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport geemap.colormaps as cm\n</pre> import ee import geemap import geemap.colormaps as cm <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map <p>Add a DEM to the map.</p> In\u00a0[\u00a0]: Copied! <pre>dem = ee.Image('USGS/3DEP/10m')\nvis = {'min': 0, 'max': 4000, 'palette': cm.palettes.dem}\n</pre> dem = ee.Image('USGS/3DEP/10m') vis = {'min': 0, 'max': 4000, 'palette': cm.palettes.dem} In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(dem, vis, 'DEM')\n</pre> Map.addLayer(dem, vis, 'DEM') <p>Add NLCD land cover data and legend to the map.</p> In\u00a0[\u00a0]: Copied! <pre>landcover = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover')\n</pre> landcover = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover') In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(landcover, {}, 'NLCD 2019')\nMap.add_legend(builtin_legend='NLCD')\n</pre> Map.addLayer(landcover, {}, 'NLCD 2019') Map.add_legend(builtin_legend='NLCD') <p>Calculate image zonal statistics by zone. In this case, we are going to calculate the mean elevation by each land cover type. The result can be returned as a Panda DataFrame or saved as a CSV.</p> In\u00a0[\u00a0]: Copied! <pre>stats = geemap.image_stats_by_zone(dem, landcover, reducer='MEAN')\nstats\n</pre> stats = geemap.image_stats_by_zone(dem, landcover, reducer='MEAN') stats <p>Save the resulting Pandas DataFrame as a CSV.</p> In\u00a0[\u00a0]: Copied! <pre>stats.to_csv('mean.csv', index=False)\n</pre> stats.to_csv('mean.csv', index=False) <p>Calculate the standard deviation of elevation by each land cover type and save the result as a CSV.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.image_stats_by_zone(dem, landcover, out_csv=\"std.csv\", reducer='STD')\n</pre> geemap.image_stats_by_zone(dem, landcover, out_csv=\"std.csv\", reducer='STD')"},{"location":"notebooks/109_coordinate_grids/","title":"109 coordinate grids","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p>Import libraries.</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() <p>Create a latitude grid.</p> In\u00a0[\u00a0]: Copied! <pre>lat_grid = geemap.latitude_grid(step=5.0, west=-180, east=180, south=-85, north=85)\n</pre> lat_grid = geemap.latitude_grid(step=5.0, west=-180, east=180, south=-85, north=85) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(lat_grid, {}, 'Latitude Grid')\n</pre> Map.addLayer(lat_grid, {}, 'Latitude Grid') In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map <p>Convert <code>ee.FeatureCollection</code> to <code>pandas.DataFrame</code>.</p> In\u00a0[\u00a0]: Copied! <pre>df = geemap.ee_to_df(lat_grid)\ndf\n</pre> df = geemap.ee_to_df(lat_grid) df <p>Create a longitude grid.</p> In\u00a0[\u00a0]: Copied! <pre>lon_grid = geemap.longitude_grid(step=5.0, west=-180, east=180, south=-85, north=85)\n</pre> lon_grid = geemap.longitude_grid(step=5.0, west=-180, east=180, south=-85, north=85) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(lon_grid, {}, 'Longitude Grid')\nMap\n</pre> Map = geemap.Map() Map.addLayer(lon_grid, {}, 'Longitude Grid') Map <p>Create a rectangular grid.</p> In\u00a0[\u00a0]: Copied! <pre>grid = geemap.latlon_grid(\n    lat_step=10, lon_step=10, west=-180, east=180, south=-85, north=85\n)\n</pre> grid = geemap.latlon_grid(     lat_step=10, lon_step=10, west=-180, east=180, south=-85, north=85 ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(grid, {}, 'Coordinate Grid')\nMap\n</pre> Map = geemap.Map() Map.addLayer(grid, {}, 'Coordinate Grid') Map <p></p>"},{"location":"notebooks/10_shapefiles/","title":"10 shapefiles","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('OlNlqfj4uHo')\n</pre> geemap.show_youtube('OlNlqfj4uHo') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>countries_shp = '../data/countries.shp'\ncountries = geemap.shp_to_ee(countries_shp)\nMap.addLayer(countries, {}, 'Countries')\n</pre> countries_shp = '../data/countries.shp' countries = geemap.shp_to_ee(countries_shp) Map.addLayer(countries, {}, 'Countries') In\u00a0[\u00a0]: Copied! <pre>states_shp = '../data/us_states.shp'\nstates = geemap.shp_to_ee(states_shp)\nMap.addLayer(states, {}, 'US States')\n</pre> states_shp = '../data/us_states.shp' states = geemap.shp_to_ee(states_shp) Map.addLayer(states, {}, 'US States') In\u00a0[\u00a0]: Copied! <pre>cities_shp = '../data/us_cities.shp'\ncities = geemap.shp_to_ee(cities_shp)\nMap.addLayer(cities, {}, 'US Cities')\n</pre> cities_shp = '../data/us_cities.shp' cities = geemap.shp_to_ee(cities_shp) Map.addLayer(cities, {}, 'US Cities') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_shp(countries, filename='../data/countries_new.shp')\n</pre> geemap.ee_to_shp(countries, filename='../data/countries_new.shp') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_vector(states, filename='../data/states.csv')\n</pre> geemap.ee_export_vector(states, filename='../data/states.csv') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_vector(states, filename='../data/states.kml')\n</pre> geemap.ee_export_vector(states, filename='../data/states.kml') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_vector(states, filename='../data/states.kmz')\n</pre> geemap.ee_export_vector(states, filename='../data/states.kmz')"},{"location":"notebooks/110_choropleth/","title":"110 choropleth","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>data = geemap.examples.datasets.countries_geojson\n</pre> data = geemap.examples.datasets.countries_geojson <p>Available classification schemes:</p> <ul> <li>BoxPlot</li> <li>EqualInterval</li> <li>FisherJenks</li> <li>FisherJenksSampled</li> <li>HeadTailBreaks</li> <li>JenksCaspall</li> <li>JenksCaspallForced</li> <li>JenksCaspallSampled</li> <li>MaxP</li> <li>MaximumBreaks</li> <li>NaturalBreaks</li> <li>Quantiles</li> <li>Percentiles</li> <li>StdMean</li> <li>UserDefined</li> </ul> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_data(\n    data, column='POP_EST', scheme='Quantiles', cmap='Blues', legend_title='Population'\n)\nm\n</pre> m = geemap.Map() m.add_data(     data, column='POP_EST', scheme='Quantiles', cmap='Blues', legend_title='Population' ) m In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_data(\n    data,\n    column='POP_EST',\n    scheme='EqualInterval',\n    cmap='Blues',\n    legend_title='Population',\n)\nm\n</pre> m = geemap.Map() m.add_data(     data,     column='POP_EST',     scheme='EqualInterval',     cmap='Blues',     legend_title='Population', ) m In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_data(\n    data,\n    column='POP_EST',\n    scheme='FisherJenks',\n    cmap='Blues',\n    legend_title='Population',\n)\nm\n</pre> m = geemap.Map() m.add_data(     data,     column='POP_EST',     scheme='FisherJenks',     cmap='Blues',     legend_title='Population', ) m In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_data(\n    data,\n    column='POP_EST',\n    scheme='JenksCaspall',\n    cmap='Blues',\n    legend_title='Population',\n)\nm\n</pre> m = geemap.Map() m.add_data(     data,     column='POP_EST',     scheme='JenksCaspall',     cmap='Blues',     legend_title='Population', ) m"},{"location":"notebooks/111_image_count/","title":"111 image count","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport geemap.colormaps as cm\n</pre> import ee import geemap import geemap.colormaps as cm <p>If run into errors, uncomment the following line to update the package and restart the kernel to take effect.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map <p>Draw a rectangle/polygon on the map to be used as an Area of Interest (AOI). If no AOI is specified, the entire image collection will be used.</p> In\u00a0[\u00a0]: Copied! <pre>region = Map.user_roi\n</pre> region = Map.user_roi <p>Use any Earth Engine collection to filter data, for example, using Landsat 8 Collection 2.</p> In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")\n</pre> collection = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\") <p>You can filter the image collection by region and date range. Set <code>clip=True</code> if you want to clip the resulting image to the region boundary.</p> In\u00a0[\u00a0]: Copied! <pre>image = geemap.image_count(\n    collection, region, start_date='2021-01-01', end_date='2022-01-01', clip=False\n)\n</pre> image = geemap.image_count(     collection, region, start_date='2021-01-01', end_date='2022-01-01', clip=False ) <p>Set visualization parameters.</p> In\u00a0[\u00a0]: Copied! <pre>vis = {'min': 0, 'max': 60, 'palette': cm.palettes.coolwarm}\n</pre> vis = {'min': 0, 'max': 60, 'palette': cm.palettes.coolwarm} In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(image, vis, 'Landsat 8 Image Count')\n</pre> Map.addLayer(image, vis, 'Landsat 8 Image Count') <p>Add country boundaries to the map</p> In\u00a0[\u00a0]: Copied! <pre>countries = ee.FeatureCollection('users/giswqs/public/countries')\nstyle = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"}\nMap.addLayer(countries.style(**style), {}, \"Countries\")\nMap.add_colorbar(vis, label='Landsat 8 Image Count')\nMap\n</pre> countries = ee.FeatureCollection('users/giswqs/public/countries') style = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"} Map.addLayer(countries.style(**style), {}, \"Countries\") Map.add_colorbar(vis, label='Landsat 8 Image Count') Map"},{"location":"notebooks/112_cartoee_basemap/","title":"112 cartoee basemap","text":"<p>Uncomment the following line to install geemap and cartopy if needed. Keep in mind that cartopy can be challenging to install. If you are unable to install cartopy on your computer, you can try Google Colab with this the notebook example.</p> <p>See below the commands to install cartopy and geemap using conda/mamba:</p> <pre><code>conda create -n gee python=3.9\nconda activate gee\nconda install mamba -c conda-forge\nmamba install cartopy scipy -c conda-forge\nmamba install geemap -c conda-forge\n</code></pre> In\u00a0[\u00a0]: Copied! <pre>%pylab inline\n\nimport ee\nimport geemap\n\n# import the cartoee functionality from geemap\nfrom geemap import cartoee\nimport cartopy.io.img_tiles as cimgt\n</pre> %pylab inline  import ee import geemap  # import the cartoee functionality from geemap from geemap import cartoee import cartopy.io.img_tiles as cimgt In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre># get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n\n# define the visualization parameters to view\nvis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3}\n</pre> # get a landsat image to visualize image = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')  # define the visualization parameters to view vis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3} In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap='ROADMAP', zoom_level=8)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"yellow\")\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis, basemap='ROADMAP', zoom_level=8)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")  # add the coastline ax.coastlines(color=\"yellow\")  plt.show() In\u00a0[\u00a0]: Copied! <pre>basemap = cimgt.Stamen('terrain-background')\n</pre> basemap = cimgt.Stamen('terrain-background') In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap=basemap, zoom_level=8)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"yellow\")\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis, basemap=basemap, zoom_level=8)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")  # add the coastline ax.coastlines(color=\"yellow\")  plt.show() In\u00a0[\u00a0]: Copied! <pre>basemap = cimgt.OSM()\n</pre> basemap = cimgt.OSM() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap=basemap, zoom_level=8)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"yellow\")\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis, basemap=basemap, zoom_level=8)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")  # add the coastline ax.coastlines(color=\"yellow\")  plt.show() In\u00a0[\u00a0]: Copied! <pre>from matplotlib.transforms import offset_copy\nimport cartopy.crs as ccrs\n</pre> from matplotlib.transforms import offset_copy import cartopy.crs as ccrs In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap='SATELLITE', zoom_level=8)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"yellow\")\n\nplt.plot(\n    -122.4457,\n    37.7574,\n    marker='o',\n    color='blue',\n    markersize=10,\n    alpha=0.7,\n    transform=ccrs.Geodetic(),\n)\n\n# Use the cartopy interface to create a matplotlib transform object\n# for the Geodetic coordinate system. We will use this along with\n# matplotlib's offset_copy function to define a coordinate system which\n# translates the text by 25 pixels to the left.\ngeodetic_transform = ccrs.Geodetic()._as_mpl_transform(ax)\ntext_transform = offset_copy(geodetic_transform, units='dots', x=-25)\n\nplt.text(\n    -122.4457,\n    37.7574,\n    u'San Francisco',\n    verticalalignment='center',\n    horizontalalignment='right',\n    transform=text_transform,\n    fontsize='large',\n    fontweight='bold',\n    color='white',\n    bbox=dict(facecolor='sandybrown', alpha=0.5, boxstyle='round'),\n)\n\n# Save the plot by calling plt.savefig() BEFORE plt.show()\nplt.savefig('sfo.pdf')\nplt.savefig('sfo.jpg', dpi=300)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis, basemap='SATELLITE', zoom_level=8)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")  # add the coastline ax.coastlines(color=\"yellow\")  plt.plot(     -122.4457,     37.7574,     marker='o',     color='blue',     markersize=10,     alpha=0.7,     transform=ccrs.Geodetic(), )  # Use the cartopy interface to create a matplotlib transform object # for the Geodetic coordinate system. We will use this along with # matplotlib's offset_copy function to define a coordinate system which # translates the text by 25 pixels to the left. geodetic_transform = ccrs.Geodetic()._as_mpl_transform(ax) text_transform = offset_copy(geodetic_transform, units='dots', x=-25)  plt.text(     -122.4457,     37.7574,     u'San Francisco',     verticalalignment='center',     horizontalalignment='right',     transform=text_transform,     fontsize='large',     fontweight='bold',     color='white',     bbox=dict(facecolor='sandybrown', alpha=0.5, boxstyle='round'), )  # Save the plot by calling plt.savefig() BEFORE plt.show() plt.savefig('sfo.pdf') plt.savefig('sfo.jpg', dpi=300)  plt.show() <p></p> In\u00a0[\u00a0]: Copied! <pre># get an earth engine image of ocean data for Jan-Mar 2018\nocean = (\n    ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')\n    .filter(ee.Filter.date('2018-01-01', '2018-03-01'))\n    .median()\n    .select([\"sst\"], [\"SST\"])\n)\n</pre> # get an earth engine image of ocean data for Jan-Mar 2018 ocean = (     ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')     .filter(ee.Filter.date('2018-01-01', '2018-03-01'))     .median()     .select([\"sst\"], [\"SST\"]) ) In\u00a0[\u00a0]: Copied! <pre># set parameters for plotting\n# will plot the Sea Surface Temp with specific range and colormap\nvisualization = {'bands': \"SST\", 'min': -2, 'max': 30}\n# specify region to focus on\nbbox = [180, -88, -180, 88]\n</pre> # set parameters for plotting # will plot the Sea Surface Temp with specific range and colormap visualization = {'bands': \"SST\", 'min': -2, 'max': 30} # specify region to focus on bbox = [180, -88, -180, 88] In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(\n    ocean,\n    cmap='plasma',\n    vis_params=visualization,\n    region=bbox,\n    basemap=cimgt.Stamen('terrain'),\n    zoom_level=2,\n)\ncb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')\n\nax.set_title(label='Sea Surface Temperature', fontsize=15)\n\nax.coastlines()\n\n# Save the plot by calling plt.savefig() BEFORE plt.show()\nplt.savefig('sst.pdf')\nplt.savefig('sst.jpg', dpi=300)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(     ocean,     cmap='plasma',     vis_params=visualization,     region=bbox,     basemap=cimgt.Stamen('terrain'),     zoom_level=2, ) cb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')  ax.set_title(label='Sea Surface Temperature', fontsize=15)  ax.coastlines()  # Save the plot by calling plt.savefig() BEFORE plt.show() plt.savefig('sst.pdf') plt.savefig('sst.jpg', dpi=300)  plt.show() <p></p>"},{"location":"notebooks/112_cartoee_basemap/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap/#initialize-earth-engine","title":"Initialize Earth Engine\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap/#add-earth-engine-dataset","title":"Add Earth Engine dataset\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap/#use-google-basemap","title":"Use Google basemap\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap/#use-stamen-terrain-basemap","title":"Use Stamen Terrain basemap\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap/#use-openstreetmap-basemap","title":"Use OpenStreetMap basemap\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap/#use-other-basemaps","title":"Use other basemaps\u00b6","text":"<p>For more basemaps, see https://scitools.org.uk/cartopy/docs/v0.19/cartopy/io/img_tiles.html</p>"},{"location":"notebooks/112_cartoee_basemap/#add-text","title":"Add text\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap/#global-scale-maps","title":"Global-scale maps\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap_X/","title":"112 cartoee basemap X","text":"<p>Uncomment the following line to install geemap and cartopy if needed. Keep in mind that cartopy can be challenging to install. If you are unable to install cartopy on your computer, you can try Google Colab with this the notebook example.</p> <p>See below the commands to install cartopy and geemap using conda/mamba:</p> <pre><code>conda create -n gee python=3.9\nconda activate gee\nconda install mamba -c conda-forge\nmamba install cartopy scipy -c conda-forge\nmamba install geemap -c conda-forge\n</code></pre> In\u00a0[\u00a0]: Copied! <pre>%pylab inline\n\nimport ee\nimport geemap\n\n# import the cartoee functionality from geemap\nfrom geemap import cartoee\nimport cartopy.io.img_tiles as cimgt\n</pre> %pylab inline  import ee import geemap  # import the cartoee functionality from geemap from geemap import cartoee import cartopy.io.img_tiles as cimgt In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre># get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n\n# define the visualization parameters to view\nvis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3}\n</pre> # get a landsat image to visualize image = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')  # define the visualization parameters to view vis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3} In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap='ROADMAP', zoom_level=8)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"yellow\")\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis, basemap='ROADMAP', zoom_level=8)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")  # add the coastline ax.coastlines(color=\"yellow\")  plt.show() In\u00a0[\u00a0]: Copied! <pre>basemap = cimgt.Stamen('terrain-background')\n</pre> basemap = cimgt.Stamen('terrain-background') In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap=basemap, zoom_level=8)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"yellow\")\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis, basemap=basemap, zoom_level=8)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")  # add the coastline ax.coastlines(color=\"yellow\")  plt.show() In\u00a0[\u00a0]: Copied! <pre>basemap = cimgt.OSM()\n</pre> basemap = cimgt.OSM() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap=basemap, zoom_level=8)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"yellow\")\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis, basemap=basemap, zoom_level=8)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")  # add the coastline ax.coastlines(color=\"yellow\")  plt.show() In\u00a0[\u00a0]: Copied! <pre>from matplotlib.transforms import offset_copy\nimport cartopy.crs as ccrs\n</pre> from matplotlib.transforms import offset_copy import cartopy.crs as ccrs In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis, basemap='SATELLITE', zoom_level=8)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"yellow\")\n\nplt.plot(\n    -122.4457,\n    37.7574,\n    marker='o',\n    color='blue',\n    markersize=10,\n    alpha=0.7,\n    transform=ccrs.Geodetic(),\n)\n\n# Use the cartopy interface to create a matplotlib transform object\n# for the Geodetic coordinate system. We will use this along with\n# matplotlib's offset_copy function to define a coordinate system which\n# translates the text by 25 pixels to the left.\ngeodetic_transform = ccrs.Geodetic()._as_mpl_transform(ax)\ntext_transform = offset_copy(geodetic_transform, units='dots', x=-25)\n\nplt.text(\n    -122.4457,\n    37.7574,\n    u'San Francisco',\n    verticalalignment='center',\n    horizontalalignment='right',\n    transform=text_transform,\n    fontsize='large',\n    fontweight='bold',\n    color='white',\n    bbox=dict(facecolor='sandybrown', alpha=0.5, boxstyle='round'),\n)\n\n# Save the plot by calling plt.savefig() BEFORE plt.show()\nplt.savefig('sfo.pdf')\nplt.savefig('sfo.jpg', dpi=300)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis, basemap='SATELLITE', zoom_level=8)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")  # add the coastline ax.coastlines(color=\"yellow\")  plt.plot(     -122.4457,     37.7574,     marker='o',     color='blue',     markersize=10,     alpha=0.7,     transform=ccrs.Geodetic(), )  # Use the cartopy interface to create a matplotlib transform object # for the Geodetic coordinate system. We will use this along with # matplotlib's offset_copy function to define a coordinate system which # translates the text by 25 pixels to the left. geodetic_transform = ccrs.Geodetic()._as_mpl_transform(ax) text_transform = offset_copy(geodetic_transform, units='dots', x=-25)  plt.text(     -122.4457,     37.7574,     u'San Francisco',     verticalalignment='center',     horizontalalignment='right',     transform=text_transform,     fontsize='large',     fontweight='bold',     color='white',     bbox=dict(facecolor='sandybrown', alpha=0.5, boxstyle='round'), )  # Save the plot by calling plt.savefig() BEFORE plt.show() plt.savefig('sfo.pdf') plt.savefig('sfo.jpg', dpi=300)  plt.show() <p></p> In\u00a0[\u00a0]: Copied! <pre># get an earth engine image of ocean data for Jan-Mar 2018\nocean = (\n    ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')\n    .filter(ee.Filter.date('2018-01-01', '2018-03-01'))\n    .median()\n    .select([\"sst\"], [\"SST\"])\n)\n</pre> # get an earth engine image of ocean data for Jan-Mar 2018 ocean = (     ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')     .filter(ee.Filter.date('2018-01-01', '2018-03-01'))     .median()     .select([\"sst\"], [\"SST\"]) ) In\u00a0[\u00a0]: Copied! <pre># set parameters for plotting\n# will plot the Sea Surface Temp with specific range and colormap\nvisualization = {'bands': \"SST\", 'min': -2, 'max': 30}\n# specify region to focus on\nbbox = [180, -88, -180, 88]\n</pre> # set parameters for plotting # will plot the Sea Surface Temp with specific range and colormap visualization = {'bands': \"SST\", 'min': -2, 'max': 30} # specify region to focus on bbox = [180, -88, -180, 88] In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(\n    ocean,\n    cmap='plasma',\n    vis_params=visualization,\n    region=bbox,\n    basemap=cimgt.Stamen('terrain'),\n    zoom_level=2,\n)\ncb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')\n\nax.set_title(label='Sea Surface Temperature', fontsize=15)\n\nax.coastlines()\n\n# Save the plot by calling plt.savefig() BEFORE plt.show()\nplt.savefig('sst.pdf')\nplt.savefig('sst.jpg', dpi=300)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(     ocean,     cmap='plasma',     vis_params=visualization,     region=bbox,     basemap=cimgt.Stamen('terrain'),     zoom_level=2, ) cb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')  ax.set_title(label='Sea Surface Temperature', fontsize=15)  ax.coastlines()  # Save the plot by calling plt.savefig() BEFORE plt.show() plt.savefig('sst.pdf') plt.savefig('sst.jpg', dpi=300)  plt.show() <p></p>"},{"location":"notebooks/112_cartoee_basemap_X/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap_X/#initialize-earth-engine","title":"Initialize Earth Engine\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap_X/#add-earth-engine-dataset","title":"Add Earth Engine dataset\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap_X/#use-google-basemap","title":"Use Google basemap\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap_X/#use-stamen-terrain-basemap","title":"Use Stamen Terrain basemap\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap_X/#use-openstreetmap-basemap","title":"Use OpenStreetMap basemap\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap_X/#use-other-basemaps","title":"Use other basemaps\u00b6","text":"<p>For more basemaps, see https://scitools.org.uk/cartopy/docs/v0.19/cartopy/io/img_tiles.html</p>"},{"location":"notebooks/112_cartoee_basemap_X/#add-text","title":"Add text\u00b6","text":""},{"location":"notebooks/112_cartoee_basemap_X/#global-scale-maps","title":"Global-scale maps\u00b6","text":""},{"location":"notebooks/113_image_area/","title":"113 image area","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap <p>Add ESA Land Cover data.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ndataset = ee.ImageCollection(\"ESA/WorldCover/v100\").first()\nMap.addLayer(dataset, {'bands': ['Map']}, 'ESA Land Cover')\nMap.add_legend(builtin_legend='ESA_WorldCover')\nMap\n</pre> Map = geemap.Map() dataset = ee.ImageCollection(\"ESA/WorldCover/v100\").first() Map.addLayer(dataset, {'bands': ['Map']}, 'ESA Land Cover') Map.add_legend(builtin_legend='ESA_WorldCover') Map <p>Calculate the area of each land cover type.</p> In\u00a0[\u00a0]: Copied! <pre>df = geemap.image_area_by_group(\n    dataset, scale=1000, denominator=1e6, decimal_places=4, verbose=True\n)\ndf\n</pre> df = geemap.image_area_by_group(     dataset, scale=1000, denominator=1e6, decimal_places=4, verbose=True ) df <p>Save the results to a CSV.</p> In\u00a0[\u00a0]: Copied! <pre>df.to_csv('esa_area.csv')\n</pre> df.to_csv('esa_area.csv') <p>Add NLCD land cover data.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap.add_basemap('HYBRID')\n\nnlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')\nlandcover = nlcd.select('landcover')\n\nMap.addLayer(landcover, {}, 'NLCD Land Cover 2019')\nMap.add_legend(\n    title=\"NLCD Land Cover Classification\", builtin_legend='NLCD', height='465px'\n)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map.add_basemap('HYBRID')  nlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019') landcover = nlcd.select('landcover')  Map.addLayer(landcover, {}, 'NLCD Land Cover 2019') Map.add_legend(     title=\"NLCD Land Cover Classification\", builtin_legend='NLCD', height='465px' ) Map <p>Calculate the area of each land cover type.</p> In\u00a0[\u00a0]: Copied! <pre>df = geemap.image_area_by_group(\n    landcover, scale=1000, denominator=1e6, decimal_places=4, verbose=True\n)\ndf\n</pre> df = geemap.image_area_by_group(     landcover, scale=1000, denominator=1e6, decimal_places=4, verbose=True ) df <p>Save the results to a CSV.</p> In\u00a0[\u00a0]: Copied! <pre>df.to_csv('nlcd_area.csv')\n</pre> df.to_csv('nlcd_area.csv')"},{"location":"notebooks/114_dynamic_world/","title":"114 dynamic world","text":"<p>Creating near real-time global 10-m land cover maps with geemap and Dynamic World</p> <ul> <li>App: https://www.dynamicworld.app</li> <li>App2: https://earthoutreach.users.earthengine.app/view/dynamicworld</li> <li>Paper: https://doi.org/10.1038/s41597-022-01307-4</li> <li>Model: https://github.com/google/dynamicworld</li> <li>Training data: https://doi.pangaea.de/10.1594/PANGAEA.933475</li> <li>Data: https://developers.google.com/earth-engine/datasets/catalog/GOOGLE_DYNAMICWORLD_V1</li> <li>JavaScript tutorial: https://developers.google.com/earth-engine/tutorials/community/introduction-to-dynamic-world-pt-1</li> </ul> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map In\u00a0[\u00a0]: Copied! <pre># Set the region of interest by simply drawing a polygon on the map\nregion = Map.user_roi\nif region is None:\n    region = ee.Geometry.BBox(-89.7088, 42.9006, -89.0647, 43.2167)\n\nMap.centerObject(region)\n</pre> # Set the region of interest by simply drawing a polygon on the map region = Map.user_roi if region is None:     region = ee.Geometry.BBox(-89.7088, 42.9006, -89.0647, 43.2167)  Map.centerObject(region) In\u00a0[\u00a0]: Copied! <pre># Set the date range\nstart_date = '2021-01-01'\nend_date = '2022-01-01'\n</pre> # Set the date range start_date = '2021-01-01' end_date = '2022-01-01' In\u00a0[\u00a0]: Copied! <pre># Create a Sentinel-2 image composite\nimage = geemap.dynamic_world_s2(region, start_date, end_date)\nvis_params = {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 3000}\nMap.addLayer(image, vis_params, 'Sentinel-2 image')\n</pre> # Create a Sentinel-2 image composite image = geemap.dynamic_world_s2(region, start_date, end_date) vis_params = {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 3000} Map.addLayer(image, vis_params, 'Sentinel-2 image') In\u00a0[\u00a0]: Copied! <pre># Create Dynamic World land cover composite\nlandcover = geemap.dynamic_world(region, start_date, end_date, return_type='hillshade')\nMap.addLayer(landcover, {}, 'Land Cover')\n</pre> # Create Dynamic World land cover composite landcover = geemap.dynamic_world(region, start_date, end_date, return_type='hillshade') Map.addLayer(landcover, {}, 'Land Cover') In\u00a0[\u00a0]: Copied! <pre># Add legend to the map\nMap.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')\nMap\n</pre> # Add legend to the map Map.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World') Map <p></p>"},{"location":"notebooks/115_land_cover/","title":"115 land cover","text":"<p>Comparing Dynamic World with ESA and ESRI global land cover data</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap <p>Visualizing ESA Global Land Cover.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nesa = ee.ImageCollection(\"ESA/WorldCover/v100\").first()\nesa_vis = {'bands': ['Map']}\n\nMap.addLayer(esa, esa_vis, \"ESA Land Cover\")\nMap.add_legend(title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover')\n\nMap\n</pre> Map = geemap.Map()  esa = ee.ImageCollection(\"ESA/WorldCover/v100\").first() esa_vis = {'bands': ['Map']}  Map.addLayer(esa, esa_vis, \"ESA Land Cover\") Map.add_legend(title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover')  Map <p>Visualizing ESRI Global Land Cover.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nesri = ee.ImageCollection(\n    \"projects/sat-io/open-datasets/landcover/ESRI_Global-LULC_10m\"\n).mosaic()\nesri_vis = {\n    'min': 1,\n    'max': 10,\n    'palette': [\n        \"#1A5BAB\",\n        \"#358221\",\n        \"#A7D282\",\n        \"#87D19E\",\n        \"#FFDB5C\",\n        \"#EECFA8\",\n        \"#ED022A\",\n        \"#EDE9E4\",\n        \"#F2FAFF\",\n        \"#C8C8C8\",\n    ],\n}\n\nMap.addLayer(esri, esri_vis, \"ESRI Land Cover\")\nMap.add_legend(title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover')\n\nMap\n</pre> Map = geemap.Map()  esri = ee.ImageCollection(     \"projects/sat-io/open-datasets/landcover/ESRI_Global-LULC_10m\" ).mosaic() esri_vis = {     'min': 1,     'max': 10,     'palette': [         \"#1A5BAB\",         \"#358221\",         \"#A7D282\",         \"#87D19E\",         \"#FFDB5C\",         \"#EECFA8\",         \"#ED022A\",         \"#EDE9E4\",         \"#F2FAFF\",         \"#C8C8C8\",     ], }  Map.addLayer(esri, esri_vis, \"ESRI Land Cover\") Map.add_legend(title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover')  Map <p>Visualizing Dynamic World Land Cover.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nregion = ee.Geometry.BBox(-179, -89, 179, 89)\nstart_date = '2021-01-01'\nend_date = '2022-01-01'\n\ndw_class = geemap.dynamic_world(region, start_date, end_date, return_type='class')\ndw = geemap.dynamic_world(region, start_date, end_date, return_type='hillshade')\n\ndw_vis = {\n    \"min\": 0,\n    \"max\": 8,\n    \"palette\": [\n        \"#419BDF\",\n        \"#397D49\",\n        \"#88B053\",\n        \"#7A87C6\",\n        \"#E49635\",\n        \"#DFC35A\",\n        \"#C4281B\",\n        \"#A59B8F\",\n        \"#B39FE1\",\n    ],\n}\n\nMap.addLayer(dw_class, dw_vis, 'DW Land Cover', False)\nMap.addLayer(dw, {}, 'DW Land Cover Hillshade')\n\nMap.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')\nMap.setCenter(-88.9088, 43.0006, 12)\nMap\n</pre> Map = geemap.Map()  region = ee.Geometry.BBox(-179, -89, 179, 89) start_date = '2021-01-01' end_date = '2022-01-01'  dw_class = geemap.dynamic_world(region, start_date, end_date, return_type='class') dw = geemap.dynamic_world(region, start_date, end_date, return_type='hillshade')  dw_vis = {     \"min\": 0,     \"max\": 8,     \"palette\": [         \"#419BDF\",         \"#397D49\",         \"#88B053\",         \"#7A87C6\",         \"#E49635\",         \"#DFC35A\",         \"#C4281B\",         \"#A59B8F\",         \"#B39FE1\",     ], }  Map.addLayer(dw_class, dw_vis, 'DW Land Cover', False) Map.addLayer(dw, {}, 'DW Land Cover Hillshade')  Map.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World') Map.setCenter(-88.9088, 43.0006, 12) Map <p>Comparing Dynamic World with ESA Land Cover.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[39.3322, -106.7349], zoom=10)\n\nleft_layer = geemap.ee_tile_layer(esa, esa_vis, \"ESA Land Cover\")\nright_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World Land Cover\")\n\nMap.split_map(left_layer, right_layer)\nMap.add_legend(\n    title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover', position='bottomleft'\n)\nMap.add_legend(\n    title=\"Dynamic World Land Cover\",\n    builtin_legend='Dynamic_World',\n    position='bottomright',\n)\nMap.setCenter(-88.9088, 43.0006, 12)\n\nMap\n</pre> Map = geemap.Map(center=[39.3322, -106.7349], zoom=10)  left_layer = geemap.ee_tile_layer(esa, esa_vis, \"ESA Land Cover\") right_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World Land Cover\")  Map.split_map(left_layer, right_layer) Map.add_legend(     title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover', position='bottomleft' ) Map.add_legend(     title=\"Dynamic World Land Cover\",     builtin_legend='Dynamic_World',     position='bottomright', ) Map.setCenter(-88.9088, 43.0006, 12)  Map <p>Comparing Dynamic World with ESRI Land Cover.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[-89.3998, 43.0886], zoom=10)\n\nleft_layer = geemap.ee_tile_layer(esri, esri_vis, \"ESRI Land Cover\")\nright_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World Land Cover\")\n\nMap.split_map(left_layer, right_layer)\nMap.add_legend(\n    title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover', position='bottomleft'\n)\nMap.add_legend(\n    title=\"Dynamic World Land Cover\",\n    builtin_legend='Dynamic_World',\n    position='bottomright',\n)\nMap.setCenter(-88.9088, 43.0006, 12)\n\nMap\n</pre> Map = geemap.Map(center=[-89.3998, 43.0886], zoom=10)  left_layer = geemap.ee_tile_layer(esri, esri_vis, \"ESRI Land Cover\") right_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World Land Cover\")  Map.split_map(left_layer, right_layer) Map.add_legend(     title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover', position='bottomleft' ) Map.add_legend(     title=\"Dynamic World Land Cover\",     builtin_legend='Dynamic_World',     position='bottomright', ) Map.setCenter(-88.9088, 43.0006, 12)  Map"},{"location":"notebooks/116_land_cover_timeseries/","title":"116 land cover timeseries","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map In\u00a0[\u00a0]: Copied! <pre># Set the region of interest by simply drawing a polygon on the map\nregion = Map.user_roi\nif region is None:\n    region = ee.Geometry.BBox(-89.7088, 42.9006, -89.0647, 43.2167)\n\nMap.centerObject(region)\n</pre> # Set the region of interest by simply drawing a polygon on the map region = Map.user_roi if region is None:     region = ee.Geometry.BBox(-89.7088, 42.9006, -89.0647, 43.2167)  Map.centerObject(region) In\u00a0[\u00a0]: Copied! <pre># Set the date range\nstart_date = '2017-01-01'\nend_date = '2021-12-31'\n</pre> # Set the date range start_date = '2017-01-01' end_date = '2021-12-31' <p>The <code>return_type</code> can be <code>hillshade</code>, <code>visualize</code>, <code>class</code>, or <code>probability</code>. If you want to use the resulting images for further analysis, you should use <code>class</code>.</p> In\u00a0[\u00a0]: Copied! <pre>images = geemap.dynamic_world_timeseries(\n    region, start_date, end_date, return_type=\"class\"\n)\n</pre> images = geemap.dynamic_world_timeseries(     region, start_date, end_date, return_type=\"class\" ) In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    \"min\": 0,\n    \"max\": 8,\n    \"palette\": [\n        \"#419BDF\",\n        \"#397D49\",\n        \"#88B053\",\n        \"#7A87C6\",\n        \"#E49635\",\n        \"#DFC35A\",\n        \"#C4281B\",\n        \"#A59B8F\",\n        \"#B39FE1\",\n    ],\n}\nMap.addLayer(images.first(), vis_params, 'First image')\nMap.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')\nMap\n</pre> vis_params = {     \"min\": 0,     \"max\": 8,     \"palette\": [         \"#419BDF\",         \"#397D49\",         \"#88B053\",         \"#7A87C6\",         \"#E49635\",         \"#DFC35A\",         \"#C4281B\",         \"#A59B8F\",         \"#B39FE1\",     ], } Map.addLayer(images.first(), vis_params, 'First image') Map.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World') Map In\u00a0[\u00a0]: Copied! <pre>Map.ts_inspector(images, left_vis=vis_params, date_format='YYYY')\n</pre> Map.ts_inspector(images, left_vis=vis_params, date_format='YYYY') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap.centerObject(region)\n\nimages = geemap.dynamic_world_timeseries(\n    region, start_date, end_date, return_type=\"hillshade\"\n)\nMap.ts_inspector(images, date_format='YYYY')\nMap.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')\n\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map.centerObject(region)  images = geemap.dynamic_world_timeseries(     region, start_date, end_date, return_type=\"hillshade\" ) Map.ts_inspector(images, date_format='YYYY') Map.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')  Map <p></p>"},{"location":"notebooks/117_fishnet/","title":"117 fishnet","text":"<p>Creating a fishnet based on an input vector dataset</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map <p>Simply draw a rectangle or polyon on the map use to used as an ROI.</p> In\u00a0[\u00a0]: Copied! <pre>data = Map.user_roi\n\nif data is None:\n    data = ee.Geometry.BBox(-112.8089, 33.7306, -88.5951, 46.6244)\n    Map.addLayer(data, {}, 'ROI')\n    Map.user_roi = None\n\nMap.centerObject(data)\n</pre> data = Map.user_roi  if data is None:     data = ee.Geometry.BBox(-112.8089, 33.7306, -88.5951, 46.6244)     Map.addLayer(data, {}, 'ROI')     Map.user_roi = None  Map.centerObject(data) <p>The input data can also be a file path or HTTP URL to a vector dataset. There are two ways to create a fishnet: specifying horizontal and vertical intervals or the number of rows and columns.</p> <p>Let's create a fishnet by specifying horizontal and vertical intervals in degrees.</p> In\u00a0[\u00a0]: Copied! <pre>fishnet = geemap.fishnet(data, h_interval=2.0, v_interval=2.0, delta=1)\n</pre> fishnet = geemap.fishnet(data, h_interval=2.0, v_interval=2.0, delta=1) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(fishnet, {}, 'Fishnet 1')\n</pre> Map.addLayer(fishnet, {}, 'Fishnet 1') <p>Draw another polygon on the map.</p> In\u00a0[\u00a0]: Copied! <pre>data = Map.user_roi\n\nif data is None:\n    data = ee.Geometry.Polygon(\n        [\n            [\n                [-64.602356, -1.127399],\n                [-68.821106, -12.625598],\n                [-60.647278, -22.498601],\n                [-47.815247, -21.111406],\n                [-43.860168, -8.913564],\n                [-54.582825, -0.775886],\n                [-60.823059, 0.454555],\n                [-64.602356, -1.127399],\n            ]\n        ]\n    )\n    Map.addLayer(data, {}, 'ROI2')\n\nMap.centerObject(data)\nMap\n</pre> data = Map.user_roi  if data is None:     data = ee.Geometry.Polygon(         [             [                 [-64.602356, -1.127399],                 [-68.821106, -12.625598],                 [-60.647278, -22.498601],                 [-47.815247, -21.111406],                 [-43.860168, -8.913564],                 [-54.582825, -0.775886],                 [-60.823059, 0.454555],                 [-64.602356, -1.127399],             ]         ]     )     Map.addLayer(data, {}, 'ROI2')  Map.centerObject(data) Map <p>Let's create another fishnet by specifying the number of rows and columns.</p> In\u00a0[\u00a0]: Copied! <pre>fishnet = geemap.fishnet(data, rows=6, cols=8, delta=1)\n</pre> fishnet = geemap.fishnet(data, rows=6, cols=8, delta=1) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(fishnet, {}, 'Fishnet 2')\n</pre> Map.addLayer(fishnet, {}, 'Fishnet 2')"},{"location":"notebooks/118_download_image/","title":"118 download image","text":"<p>Download images directly to a local computer</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>image = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_TOA\").first()\nMap.addLayer(image, {}, 'Landsat')\nMap.centerObject(image)\n</pre> image = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_TOA\").first() Map.addLayer(image, {}, 'Landsat') Map.centerObject(image) In\u00a0[\u00a0]: Copied! <pre>geemap.download_ee_image(image, \"landsat.tif\", scale=100)\n</pre> geemap.download_ee_image(image, \"landsat.tif\", scale=100) In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\n</pre> out_dir = os.path.expanduser('~/Downloads') In\u00a0[\u00a0]: Copied! <pre>loc = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(loc)\n    .filterDate('2008-01-01', '2020-01-01')\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n</pre> loc = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(loc)     .filterDate('2008-01-01', '2020-01-01')     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) In\u00a0[\u00a0]: Copied! <pre>geemap.download_ee_image_collection(collection, out_dir, scale=10)\n</pre> geemap.download_ee_image_collection(collection, out_dir, scale=10) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 2}\nMap.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 1)\nMap\n</pre> Map = geemap.Map()  image = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 2} Map.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 1) Map In\u00a0[\u00a0]: Copied! <pre>region = ee.Geometry.BBox(-115.6339, 35.7529, -113.9338, 36.7012)\nMap.centerObject(region)\n</pre> region = ee.Geometry.BBox(-115.6339, 35.7529, -113.9338, 36.7012) Map.centerObject(region) In\u00a0[\u00a0]: Copied! <pre>features = geemap.fishnet(region, rows=2, cols=2)\nMap.addLayer(features, {}, 'Grids')\n</pre> features = geemap.fishnet(region, rows=2, cols=2) Map.addLayer(features, {}, 'Grids') In\u00a0[\u00a0]: Copied! <pre>geemap.download_ee_image_tiles(\n    image, features, out_dir, prefix=\"landsat_\", crs=\"EPSG:3857\", scale=30\n)\n</pre> geemap.download_ee_image_tiles(     image, features, out_dir, prefix=\"landsat_\", crs=\"EPSG:3857\", scale=30 )"},{"location":"notebooks/118_download_image/#download-a-single-image","title":"Download a single image\u00b6","text":""},{"location":"notebooks/118_download_image/#download-an-image-collection","title":"Download an image collection\u00b6","text":""},{"location":"notebooks/118_download_image/#download-image-by-tile","title":"Download image by tile\u00b6","text":""},{"location":"notebooks/119_plot_raster/","title":"119 plot raster","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap\n</pre> import os import geemap <p>Download a sample dataset.</p> In\u00a0[\u00a0]: Copied! <pre>url = 'https://github.com/giswqs/data/raw/main/raster/srtm90.tif'\n</pre> url = 'https://github.com/giswqs/data/raw/main/raster/srtm90.tif' In\u00a0[\u00a0]: Copied! <pre>image = 'srtm90.tif'\nif not os.path.exists(image):\n    geemap.download_file(url, image)\n</pre> image = 'srtm90.tif' if not os.path.exists(image):     geemap.download_file(url, image) <p>Plot the raster image in 2D.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.plot_raster(image, cmap='terrain', figsize=(15, 10))\n</pre> geemap.plot_raster(image, cmap='terrain', figsize=(15, 10)) <p></p> <p>Plot the raster image in 3D.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.plot_raster_3d('srtm90.tif', factor=2, cmap='terrain', background='gray')\n</pre> geemap.plot_raster_3d('srtm90.tif', factor=2, cmap='terrain', background='gray') <p></p>"},{"location":"notebooks/11_export_image/","title":"11 export image","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport os\n</pre> import ee import geemap import os In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('_6JOA-iiEGU')\n</pre> geemap.show_youtube('_6JOA-iiEGU') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 0.7)\n</pre> image = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 0.7) In\u00a0[\u00a0]: Copied! <pre># Draw any shapes on the map using the Drawing tools before executing this code block\nfeature = Map.draw_last_feature\n\nif feature is None:\n    geom = ee.Geometry.Polygon(\n        [\n            [\n                [-115.413031, 35.889467],\n                [-115.413031, 36.543157],\n                [-114.034328, 36.543157],\n                [-114.034328, 35.889467],\n                [-115.413031, 35.889467],\n            ]\n        ]\n    )\n    feature = ee.Feature(geom, {})\n\nroi = feature.geometry()\n</pre> # Draw any shapes on the map using the Drawing tools before executing this code block feature = Map.draw_last_feature  if feature is None:     geom = ee.Geometry.Polygon(         [             [                 [-115.413031, 35.889467],                 [-115.413031, 36.543157],                 [-114.034328, 36.543157],                 [-114.034328, 35.889467],                 [-115.413031, 35.889467],             ]         ]     )     feature = ee.Feature(geom, {})  roi = feature.geometry() In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nfilename = os.path.join(out_dir, 'landsat.tif')\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') filename = os.path.join(out_dir, 'landsat.tif') In\u00a0[\u00a0]: Copied! <pre>image = image.clip(roi).unmask()\ngeemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=False\n)\n</pre> image = image.clip(roi).unmask() geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=False ) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=True\n)\n</pre> geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=True ) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_to_drive(\n    image, description='landsat', folder='export', region=roi, scale=30\n)\n</pre> geemap.ee_export_image_to_drive(     image, description='landsat', folder='export', region=roi, scale=30 ) In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport os\n</pre> import ee import geemap import os In\u00a0[\u00a0]: Copied! <pre>loc = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(loc)\n    .filterDate('2008-01-01', '2020-01-01')\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n</pre> loc = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(loc)     .filterDate('2008-01-01', '2020-01-01')     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') In\u00a0[\u00a0]: Copied! <pre>print(collection.aggregate_array('system:index').getInfo())\n</pre> print(collection.aggregate_array('system:index').getInfo()) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection(collection, out_dir=out_dir)\n</pre> geemap.ee_export_image_collection(collection, out_dir=out_dir) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10)\n</pre> geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10) In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimg = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810').select(['B4', 'B5', 'B6'])\n\naoi = ee.Geometry.Polygon(\n    [[[-110.8, 44.7], [-110.8, 44.6], [-110.6, 44.6], [-110.6, 44.7]]], None, False\n)\n\nrgb_img = geemap.ee_to_numpy(img, region=aoi)\nprint(rgb_img.shape)\n</pre> import ee import geemap import numpy as np import matplotlib.pyplot as plt  img = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810').select(['B4', 'B5', 'B6'])  aoi = ee.Geometry.Polygon(     [[[-110.8, 44.7], [-110.8, 44.6], [-110.6, 44.6], [-110.6, 44.7]]], None, False )  rgb_img = geemap.ee_to_numpy(img, region=aoi) print(rgb_img.shape) In\u00a0[\u00a0]: Copied! <pre># Scale the data to [0, 255] to show as an RGB image.\n# Adapted from https://bit.ly/2XlmQY8. Credits to Justin Braaten\nrgb_img_test = (255 * ((rgb_img[:, :, 0:3] - 100) / 3500)).astype('uint8')\nplt.imshow(rgb_img_test)\nplt.show()\n</pre> # Scale the data to [0, 255] to show as an RGB image. # Adapted from https://bit.ly/2XlmQY8. Credits to Justin Braaten rgb_img_test = (255 * ((rgb_img[:, :, 0:3] - 100) / 3500)).astype('uint8') plt.imshow(rgb_img_test) plt.show()"},{"location":"notebooks/11_export_image/#download-an-eeimage","title":"Download an ee.Image\u00b6","text":""},{"location":"notebooks/11_export_image/#exporting-all-bands-as-one-single-image","title":"Exporting all bands as one single image\u00b6","text":""},{"location":"notebooks/11_export_image/#exporting-each-band-as-one-image","title":"Exporting each band as one image\u00b6","text":""},{"location":"notebooks/11_export_image/#export-an-image-to-google-drive","title":"Export an image to Google Drive\u00b6","text":""},{"location":"notebooks/11_export_image/#download-an-eeimagecollection","title":"Download an ee.ImageCollection\u00b6","text":""},{"location":"notebooks/11_export_image/#extract-pixels-as-a-numpy-array","title":"Extract pixels as a Numpy array\u00b6","text":""},{"location":"notebooks/120_javascript/","title":"120 javascript","text":"<p>Calling functions in Earth Engine JavaScript libraries from Python</p> <p>Run the following line to enable tab-completion for JavaScript libraries.</p> In\u00a0[\u00a0]: Copied! <pre>%config IPCompleter.use_jedi = False\n</pre> %config IPCompleter.use_jedi = False <p>Import libraries</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() <p>Use the Open Earth Engine Library (OEEL)</p> In\u00a0[\u00a0]: Copied! <pre>oeel = geemap.requireJS()\n</pre> oeel = geemap.requireJS() In\u00a0[\u00a0]: Copied! <pre>ic = ee.ImageCollection(\"COPERNICUS/S2_SR\")\n\nicSize = (\n    oeel.Algorithms.Sentinel2.cloudfree(maxCloud=20, S2Collection=ic)\n    .filterDate('2020-01-01', '2020-01-02')\n    .size()\n)\nprint('Cloud free imagery: ', icSize.getInfo())\n</pre> ic = ee.ImageCollection(\"COPERNICUS/S2_SR\")  icSize = (     oeel.Algorithms.Sentinel2.cloudfree(maxCloud=20, S2Collection=ic)     .filterDate('2020-01-01', '2020-01-02')     .size() ) print('Cloud free imagery: ', icSize.getInfo()) <p>Use an Earth Engine JavaScript library from a HTTP URL.</p> In\u00a0[\u00a0]: Copied! <pre>url = 'https://github.com/gee-community/geemap/blob/master/examples/javascripts/grid.js'\n</pre> url = 'https://github.com/gee-community/geemap/blob/master/examples/javascripts/grid.js' In\u00a0[\u00a0]: Copied! <pre>lib = geemap.requireJS(url)\n</pre> lib = geemap.requireJS(url) In\u00a0[\u00a0]: Copied! <pre>lib.availability\n</pre> lib.availability In\u00a0[\u00a0]: Copied! <pre>grid = lib.generateGrid(-180, -50, 180, 50, 10, 10, 0, 0)\n</pre> grid = lib.generateGrid(-180, -50, 180, 50, 10, 10, 0, 0) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(grid, {}, 'Grid')\nMap\n</pre> Map = geemap.Map() Map.addLayer(grid, {}, 'Grid') Map <p>Use a local Earth Engine JavaScript library.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>lib = geemap.requireJS('grid.js', Map)\n</pre> lib = geemap.requireJS('grid.js', Map) In\u00a0[\u00a0]: Copied! <pre>lib.availability\n</pre> lib.availability In\u00a0[\u00a0]: Copied! <pre>lib.grid_test()\n</pre> lib.grid_test() <p>Use an Earth Engine JavaScript from an Earth Engine repo.</p> In\u00a0[\u00a0]: Copied! <pre>lib = geemap.requireJS('users/gena/packages:grid')\n</pre> lib = geemap.requireJS('users/gena/packages:grid') In\u00a0[\u00a0]: Copied! <pre>lib.availability\n</pre> lib.availability In\u00a0[\u00a0]: Copied! <pre>grid = lib.generateGrid(-180, -50, 180, 50, 10, 10, 0, 0)\n</pre> grid = lib.generateGrid(-180, -50, 180, 50, 10, 10, 0, 0) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(grid, {}, 'Grid')\nMap\n</pre> Map = geemap.Map() Map.addLayer(grid, {}, 'Grid') Map"},{"location":"notebooks/121_vector_style/","title":"121 vector style","text":"<p>Styling Earth Engine vector data based on attributes</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap <p>Styling polygons</p> <p>The US National Wetland Inventory.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[28.00142, -81.7424], zoom=13)\nMap.add_basemap('HYBRID')\n</pre> Map = geemap.Map(center=[28.00142, -81.7424], zoom=13) Map.add_basemap('HYBRID') In\u00a0[\u00a0]: Copied! <pre>fc = ee.FeatureCollection(\"projects/sat-io/open-datasets/NWI/wetlands/FL_Wetlands\")\n</pre> fc = ee.FeatureCollection(\"projects/sat-io/open-datasets/NWI/wetlands/FL_Wetlands\") In\u00a0[\u00a0]: Copied! <pre>types = [\n    \"Freshwater Forested/Shrub Wetland\",\n    \"Freshwater Emergent Wetland\",\n    \"Freshwater Pond\",\n    \"Estuarine and Marine Wetland\",\n    \"Riverine\",\n    \"Lake\",\n    \"Estuarine and Marine Deepwater\",\n    \"Other\",\n]\n\ncolors = [\n    \"#008837\",\n    \"#7FC31C\",\n    \"#688CC0\",\n    \"#66C2A5\",\n    \"#0190BF\",\n    \"#13007C\",\n    \"#007C88\",\n    \"#B28653\",\n]\n\nfillColor = [c + \"A8\" for c in colors]\n</pre> types = [     \"Freshwater Forested/Shrub Wetland\",     \"Freshwater Emergent Wetland\",     \"Freshwater Pond\",     \"Estuarine and Marine Wetland\",     \"Riverine\",     \"Lake\",     \"Estuarine and Marine Deepwater\",     \"Other\", ]  colors = [     \"#008837\",     \"#7FC31C\",     \"#688CC0\",     \"#66C2A5\",     \"#0190BF\",     \"#13007C\",     \"#007C88\",     \"#B28653\", ]  fillColor = [c + \"A8\" for c in colors] In\u00a0[\u00a0]: Copied! <pre>styled_fc = geemap.ee_vector_style(\n    fc, column='WETLAND_TY', labels=types, fillColor=fillColor, color='00000000'\n)\n</pre> styled_fc = geemap.ee_vector_style(     fc, column='WETLAND_TY', labels=types, fillColor=fillColor, color='00000000' ) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(styled_fc, {}, 'NWI')\nMap.add_legend(title='Wetland Type', labels=types, colors=colors)\nMap\n</pre> Map.addLayer(styled_fc, {}, 'NWI') Map.add_legend(title='Wetland Type', labels=types, colors=colors) Map <p></p> <p>Styling points</p> <p>The Global Power Plant Database .</p> In\u00a0[\u00a0]: Copied! <pre>fuels = [\n    'Coal',\n    'Oil',\n    'Gas',\n    'Hydro',\n    'Nuclear',\n    'Solar',\n    'Waste',\n    'Wind',\n    'Geothermal',\n    'Biomass',\n]\n</pre> fuels = [     'Coal',     'Oil',     'Gas',     'Hydro',     'Nuclear',     'Solar',     'Waste',     'Wind',     'Geothermal',     'Biomass', ] In\u00a0[\u00a0]: Copied! <pre>fc = ee.FeatureCollection(\"WRI/GPPD/power_plants\").filter(\n    ee.Filter.inList('fuel1', fuels)\n)\n</pre> fc = ee.FeatureCollection(\"WRI/GPPD/power_plants\").filter(     ee.Filter.inList('fuel1', fuels) ) In\u00a0[\u00a0]: Copied! <pre>colors = [\n    '000000',\n    '593704',\n    'BC80BD',\n    '0565A6',\n    'E31A1C',\n    'FF7F00',\n    '6A3D9A',\n    '5CA2D1',\n    'FDBF6F',\n    '229A00',\n]\n</pre> colors = [     '000000',     '593704',     'BC80BD',     '0565A6',     'E31A1C',     'FF7F00',     '6A3D9A',     '5CA2D1',     'FDBF6F',     '229A00', ] In\u00a0[\u00a0]: Copied! <pre>styled_fc = geemap.ee_vector_style(fc, column=\"fuel1\", labels=fuels, color=colors)\n</pre> styled_fc = geemap.ee_vector_style(fc, column=\"fuel1\", labels=fuels, color=colors) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(styled_fc, {}, 'Power Plants')\nMap.add_legend(title=\"Power Plant Fuel Type\", labels=fuels, colors=colors)\nMap\n</pre> Map = geemap.Map() Map.addLayer(styled_fc, {}, 'Power Plants') Map.add_legend(title=\"Power Plant Fuel Type\", labels=fuels, colors=colors) Map <p></p> <p>Styling polylines</p> <p>The TIGER: US Census Roads. See the route type codes.</p> In\u00a0[\u00a0]: Copied! <pre>fc = ee.FeatureCollection('TIGER/2016/Roads')\n</pre> fc = ee.FeatureCollection('TIGER/2016/Roads') In\u00a0[\u00a0]: Copied! <pre>types = ['I', 'U', 'S', 'M', 'C', 'O']\n</pre> types = ['I', 'U', 'S', 'M', 'C', 'O'] In\u00a0[\u00a0]: Copied! <pre>labels = ['Interstate', 'U.S.', 'State recognized', 'Common Name', 'County', 'Other']\n</pre> labels = ['Interstate', 'U.S.', 'State recognized', 'Common Name', 'County', 'Other'] In\u00a0[\u00a0]: Copied! <pre>colors = ['E31A1C', 'FF7F00', '6A3D9A', '000000', 'FDBF6F', '229A00']\n</pre> colors = ['E31A1C', 'FF7F00', '6A3D9A', '000000', 'FDBF6F', '229A00'] In\u00a0[\u00a0]: Copied! <pre>width = [8, 5, 4, 2, 1, 1]\n</pre> width = [8, 5, 4, 2, 1, 1] In\u00a0[\u00a0]: Copied! <pre>styled_fc = geemap.ee_vector_style(\n    fc, column='rttyp', labels=types, color=colors, width=width\n)\n</pre> styled_fc = geemap.ee_vector_style(     fc, column='rttyp', labels=types, color=colors, width=width ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40.7792, -73.9613], zoom=12)\nMap.addLayer(styled_fc, {}, 'Census Roads')\nMap.add_legend(title='Route Type', labels=labels, colors=colors)\nMap\n</pre> Map = geemap.Map(center=[40.7792, -73.9613], zoom=12) Map.addLayer(styled_fc, {}, 'Census Roads') Map.add_legend(title='Route Type', labels=labels, colors=colors) Map <p></p>"},{"location":"notebooks/122_lidar/","title":"122 lidar","text":"<p>LiDAR data analysis and visualization with whitebox and geemap</p> <p>Create a new conda env to install required packages:</p> <pre>conda create -n geo python\nconda activate geo\nconda install -c conda-forge mamba\nmamba install -c conda-forge pygis\npip install laspy[lazrs]\n</pre> <p>Uncomment the following line to install packages in Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap[lidar]\n</pre> # !pip install geemap[lidar] In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap\nimport whitebox\n</pre> import os import geemap import whitebox In\u00a0[\u00a0]: Copied! <pre>wbt = whitebox.WhiteboxTools()\nwbt.set_working_dir(os.getcwd())\nwbt.set_verbose_mode(False)\n</pre> wbt = whitebox.WhiteboxTools() wbt.set_working_dir(os.getcwd()) wbt.set_verbose_mode(False) In\u00a0[\u00a0]: Copied! <pre>url = 'https://github.com/giswqs/data/raw/main/lidar/madison.laz'\nif not os.path.exists('madison.laz'):\n    geemap.download_file(url)\n</pre> url = 'https://github.com/giswqs/data/raw/main/lidar/madison.laz' if not os.path.exists('madison.laz'):     geemap.download_file(url) In\u00a0[\u00a0]: Copied! <pre>laz = geemap.read_lidar('madison.laz')\n</pre> laz = geemap.read_lidar('madison.laz') In\u00a0[\u00a0]: Copied! <pre>laz\n</pre> laz In\u00a0[\u00a0]: Copied! <pre>str(laz.header.version)\n</pre> str(laz.header.version) In\u00a0[\u00a0]: Copied! <pre>las = geemap.convert_lidar(laz, file_version='1.4')\n</pre> las = geemap.convert_lidar(laz, file_version='1.4') In\u00a0[\u00a0]: Copied! <pre>str(las.header.version)\n</pre> str(las.header.version) In\u00a0[\u00a0]: Copied! <pre>geemap.write_lidar(las, 'madison.las')\n</pre> geemap.write_lidar(las, 'madison.las') In\u00a0[\u00a0]: Copied! <pre>wbt.lidar_histogram('madison.las', 'histogram.html')\n</pre> wbt.lidar_histogram('madison.las', 'histogram.html') In\u00a0[\u00a0]: Copied! <pre>geemap.view_lidar('madison.las')\n</pre> geemap.view_lidar('madison.las') In\u00a0[\u00a0]: Copied! <pre>wbt.lidar_elevation_slice(\"madison.las\", \"madison_rm.las\", minz=0, maxz=450)\n</pre> wbt.lidar_elevation_slice(\"madison.las\", \"madison_rm.las\", minz=0, maxz=450) In\u00a0[\u00a0]: Copied! <pre>geemap.view_lidar('madison_rm.las', cmap='terrain')\n</pre> geemap.view_lidar('madison_rm.las', cmap='terrain') In\u00a0[\u00a0]: Copied! <pre>wbt.lidar_digital_surface_model(\n    'madison_rm.las', 'dsm.tif', resolution=1.0, minz=0, maxz=450\n)\n</pre> wbt.lidar_digital_surface_model(     'madison_rm.las', 'dsm.tif', resolution=1.0, minz=0, maxz=450 ) In\u00a0[\u00a0]: Copied! <pre>geemap.add_crs(\"dsm.tif\", epsg=2255)\n</pre> geemap.add_crs(\"dsm.tif\", epsg=2255) In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_raster('dsm.tif', palette='terrain', layer_name='DSM')\nm\n</pre> m = geemap.Map() m.add_raster('dsm.tif', palette='terrain', layer_name='DSM') m In\u00a0[\u00a0]: Copied! <pre>wbt.remove_off_terrain_objects('dsm.tif', 'dem.tif', filter=25, slope=15.0)\n</pre> wbt.remove_off_terrain_objects('dsm.tif', 'dem.tif', filter=25, slope=15.0) In\u00a0[\u00a0]: Copied! <pre>m.add_raster('dem.tif', palette='terrain', layer_name='DEM')\nm\n</pre> m.add_raster('dem.tif', palette='terrain', layer_name='DEM') m In\u00a0[\u00a0]: Copied! <pre>chm = wbt.subtract('dsm.tif', 'dem.tif', 'chm.tif')\n</pre> chm = wbt.subtract('dsm.tif', 'dem.tif', 'chm.tif') In\u00a0[\u00a0]: Copied! <pre>m.add_raster('chm.tif', palette='gist_earth', layer_name='CHM')\nm\n</pre> m.add_raster('chm.tif', palette='gist_earth', layer_name='CHM') m"},{"location":"notebooks/122_lidar/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/122_lidar/#set-up-whitebox","title":"Set up whitebox\u00b6","text":""},{"location":"notebooks/122_lidar/#download-sample-data","title":"Download sample data\u00b6","text":""},{"location":"notebooks/122_lidar/#read-laslaz-data","title":"Read LAS/LAZ data\u00b6","text":""},{"location":"notebooks/122_lidar/#upgrade-file-version","title":"Upgrade file version\u00b6","text":""},{"location":"notebooks/122_lidar/#write-las-data","title":"Write LAS data\u00b6","text":""},{"location":"notebooks/122_lidar/#histogram-analysis","title":"Histogram analysis\u00b6","text":""},{"location":"notebooks/122_lidar/#visualize-lidar-data","title":"Visualize LiDAR data\u00b6","text":""},{"location":"notebooks/122_lidar/#remove-outliers","title":"Remove outliers\u00b6","text":""},{"location":"notebooks/122_lidar/#visualize-lidar-data-after-removing-outliers","title":"Visualize LiDAR data after removing outliers\u00b6","text":""},{"location":"notebooks/122_lidar/#create-dsm","title":"Create DSM\u00b6","text":""},{"location":"notebooks/122_lidar/#visualize-dsm","title":"Visualize DSM\u00b6","text":""},{"location":"notebooks/122_lidar/#create-dem","title":"Create DEM\u00b6","text":""},{"location":"notebooks/122_lidar/#visualize-dem","title":"Visualize DEM\u00b6","text":""},{"location":"notebooks/122_lidar/#create-chm","title":"Create CHM\u00b6","text":""},{"location":"notebooks/123_sentinel1_timelapse/","title":"123 sentinel1 timelapse","text":"<p>Creating Sentinel-1 SAR imagery timelapse</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map <p>Pan and zoom to an area of interest and draw a rectangle on the map.</p> In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(117.1132, 3.5227, 117.2214, 3.5843)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(117.1132, 3.5227, 117.2214, 3.5843)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.sentinel1_timelapse(\n    roi,\n    out_gif='sentinel1.gif',\n    start_year=2019,\n    end_year=2019,\n    start_date='04-01',\n    end_date='08-01',\n    frequency='day',\n    vis_params={\"min\": -30, \"max\": 0},\n    palette=\"Greys\",\n    frames_per_second=3,\n    title='Sentinel-1 Timelapse',\n    add_colorbar=True,\n    colorbar_bg_color='gray',\n)\n</pre> timelapse = geemap.sentinel1_timelapse(     roi,     out_gif='sentinel1.gif',     start_year=2019,     end_year=2019,     start_date='04-01',     end_date='08-01',     frequency='day',     vis_params={\"min\": -30, \"max\": 0},     palette=\"Greys\",     frames_per_second=3,     title='Sentinel-1 Timelapse',     add_colorbar=True,     colorbar_bg_color='gray', ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(timelapse)\n</pre> geemap.show_image(timelapse) <p></p>"},{"location":"notebooks/124_more_datasets/","title":"124 more datasets","text":"<p>Finding useful datasets</p> <ul> <li>added community datasets based on regularly updated repository.</li> <li>changed layout</li> <li>added links to ee code examples</li> </ul> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nfrom geemap import common as cm\nfrom geemap import datasets as ds\n</pre> import ee from geemap import common as cm from geemap import datasets as ds In\u00a0[\u00a0]: Copied! <pre>ds.get_metadata('AAFC/ACI')\n</pre> ds.get_metadata('AAFC/ACI') In\u00a0[\u00a0]: Copied! <pre>cm.search_ee_data('CAMS Copernicus', source='ee')\n</pre> cm.search_ee_data('CAMS Copernicus', source='ee') In\u00a0[\u00a0]: Copied! <pre>ds.get_community_data_list()[0]\n</pre> ds.get_community_data_list()[0] In\u00a0[\u00a0]: Copied! <pre>ds.get_metadata(\n    'projects/sat-io/open-datasets/landcover/ESRI_Global-LULC_10m', source='community'\n)\n</pre> ds.get_metadata(     'projects/sat-io/open-datasets/landcover/ESRI_Global-LULC_10m', source='community' ) In\u00a0[\u00a0]: Copied! <pre>len(cm.search_ee_data('DEM', source='community'))\n</pre> len(cm.search_ee_data('DEM', source='community')) In\u00a0[\u00a0]: Copied! <pre>len(cm.search_ee_data('DEM', source='all'))\n</pre> len(cm.search_ee_data('DEM', source='all')) In\u00a0[\u00a0]: Copied! <pre>len(cm.search_ee_data('ECM.*F', regex=True, source='ee'))\n</pre> len(cm.search_ee_data('ECM.*F', regex=True, source='ee')) In\u00a0[\u00a0]: Copied! <pre>import geemap\n\nMap = geemap.Map()\nMap\n</pre> import geemap  Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/124_more_datasets/#changed-layout","title":"Changed layout\u00b6","text":""},{"location":"notebooks/124_more_datasets/#search-supports-multiple-keywords-list-or-space-separated","title":"Search supports multiple keywords (list or space separated).\u00b6","text":""},{"location":"notebooks/124_more_datasets/#find-community-datasets","title":"Find community datasets\u00b6","text":""},{"location":"notebooks/124_more_datasets/#search-supports-regular-expressions","title":"Search supports regular expressions.\u00b6","text":""},{"location":"notebooks/124_more_datasets/#search-data-looks-in-both-ee-and-community","title":"Search data looks in both ee and community\u00b6","text":""},{"location":"notebooks/125_example_code/","title":"125 example code","text":"<p>Using Earth engine examples</p> <ul> <li>ee datasets seem to come from https://code.earthengine.google.com/scripts/load</li> <li>When logged into gee, this link returns a f.json. It contains all code examples from the docs, including the datasets.</li> <li>community datasets can be accessed using git from https://earthengine.googlesource.com</li> <li>which in many cases can be translated into python code</li> <li>this should make it feasible to use the code examples directly into geemap</li> </ul> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport json\n</pre> import ee import geemap import json In\u00a0[\u00a0]: Copied! <pre>url = 'https://github.com/gee-community/geemap/blob/master/geemap/data/gee_f.json'\ngeemap.download_file(url)\n</pre> url = 'https://github.com/gee-community/geemap/blob/master/geemap/data/gee_f.json' geemap.download_file(url) In\u00a0[\u00a0]: Copied! <pre>with open('gee_f.json', encoding=\"utf-8\") as f:\n    functions = json.load(f)\n\nfunctions.keys()\n</pre> with open('gee_f.json', encoding=\"utf-8\") as f:     functions = json.load(f)  functions.keys() In\u00a0[\u00a0]: Copied! <pre>[(x['name'], len(x['contents'])) for x in functions['examples']]\n</pre> [(x['name'], len(x['contents'])) for x in functions['examples']] In\u00a0[\u00a0]: Copied! <pre>details = [\n    (dataset['name'], dataset['code'])\n    for x in functions['examples']\n    for dataset in x['contents']\n    if x['name'] == 'Datasets'\n]\ndetails[0]\n</pre> details = [     (dataset['name'], dataset['code'])     for x in functions['examples']     for dataset in x['contents']     if x['name'] == 'Datasets' ] details[0] In\u00a0[\u00a0]: Copied! <pre>def get_py(js):\n    try:\n        return geemap.js_snippet_to_py(\n            js, add_new_cell=False, import_ee=False, import_geemap=False, show_map=False\n        )\n    except:\n        return None\n\n\nresults_convert = [get_py(js) for _, js in details]\n</pre> def get_py(js):     try:         return geemap.js_snippet_to_py(             js, add_new_cell=False, import_ee=False, import_geemap=False, show_map=False         )     except:         return None   results_convert = [get_py(js) for _, js in details] In\u00a0[\u00a0]: Copied! <pre>len(details), len(results_convert)\n</pre> len(details), len(results_convert) <p>Except for 2 cases, converts ran without error.</p> In\u00a0[\u00a0]: Copied! <pre>len([x for x in results_convert if x])\n</pre> len([x for x in results_convert if x]) In\u00a0[\u00a0]: Copied! <pre>from geemap import datasets\n\nlen(datasets.get_ee_stac_list())\n</pre> from geemap import datasets  len(datasets.get_ee_stac_list()) In\u00a0[\u00a0]: Copied! <pre>known_datasets = set(name.replace('/', '_') for name in datasets.get_ee_stac_list())\nknown_code = set(name for name, _ in details)\n</pre> known_datasets = set(name.replace('/', '_') for name in datasets.get_ee_stac_list()) known_code = set(name for name, _ in details) In\u00a0[\u00a0]: Copied! <pre>len(known_code &amp; known_datasets)\n</pre> len(known_code &amp; known_datasets) <p>Sometimes there is a 2 example available for a dataset, mostly FeatureViews.</p> In\u00a0[\u00a0]: Copied! <pre>excess = known_code - known_datasets\n</pre> excess = known_code - known_datasets In\u00a0[\u00a0]: Copied! <pre>len(excess)\n</pre> len(excess) In\u00a0[\u00a0]: Copied! <pre>excess_no_featureview = set(x.replace('_FeatureView', '') for x in known_code)\nlen(excess_no_featureview - known_datasets)\n</pre> excess_no_featureview = set(x.replace('_FeatureView', '') for x in known_code) len(excess_no_featureview - known_datasets) <p>Leftovers</p> In\u00a0[\u00a0]: Copied! <pre>(excess_no_featureview - known_datasets)\n</pre> (excess_no_featureview - known_datasets) In\u00a0[\u00a0]: Copied! <pre>missing_code = known_datasets - known_code\nlen(missing_code)\n</pre> missing_code = known_datasets - known_code len(missing_code) <p>These are also missing in gee itself (logically as these load from f.json).</p> <ul> <li>https://code.earthengine.google.com/?scriptPath=Examples%3ADatasets%2FLANDSAT_LC8</li> </ul> <p>Deprecated stuff afaik, s.a. Landsat LT1</p> In\u00a0[\u00a0]: Copied! <pre>missing_code\n</pre> missing_code In\u00a0[\u00a0]: Copied! <pre>from geemap import common\n\n[x['title'] for x in common.search_ee_data('LANDSAT L1T')][:5]\n</pre> from geemap import common  [x['title'] for x in common.search_ee_data('LANDSAT L1T')][:5] In\u00a0[\u00a0]: Copied! <pre>[(x['uid'], x['title']) for x in common.search_ee_data('MODIS MYD')][:5]\n</pre> [(x['uid'], x['title']) for x in common.search_ee_data('MODIS MYD')][:5]"},{"location":"notebooks/125_example_code/#manually-download-fjson","title":"Manually download f.json\u00b6","text":"<p>https://code.earthengine.google.com/scripts/load</p>"},{"location":"notebooks/125_example_code/#explore-json-contents","title":"Explore json contents\u00b6","text":"<p>Change file download location. Also added f.json to repo.</p>"},{"location":"notebooks/125_example_code/#details","title":"Details\u00b6","text":""},{"location":"notebooks/125_example_code/#convert-js-to-py","title":"Convert js to py\u00b6","text":""},{"location":"notebooks/125_example_code/#verify-availability","title":"Verify availability\u00b6","text":""},{"location":"notebooks/125_example_code/#only-some-have-exact-matches","title":"Only some have exact matches\u00b6","text":""},{"location":"notebooks/125_example_code/#datasets-without-examples","title":"Datasets without examples\u00b6","text":""},{"location":"notebooks/126_inspector/","title":"126 inspector","text":"<p>Using the improved Inspector GUI</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select('B[1-7]')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': 'terrain',\n}\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select('B[1-7]') states = ee.FeatureCollection(\"TIGER/2018/States\")  vis_params = {     'min': 0,     'max': 4000,     'palette': 'terrain', } Map.addLayer(dem, vis_params, 'SRTM DEM') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_023031_20220617')\ngeemap.get_info(image)\n</pre> image = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_023031_20220617') geemap.get_info(image) In\u00a0[\u00a0]: Copied! <pre>geemap.get_info(states.first(), opened=True)\n</pre> geemap.get_info(states.first(), opened=True) <p></p>"},{"location":"notebooks/127_create_legend/","title":"127 create legend","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap <p>Create a built-in draggable legend. Specify the <code>output</code> parameter to save the legend as an HTML file.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.create_legend(\n    title='NLCD Land Cover Type',\n    builtin_legend='NLCD',\n    draggable=True,\n    output='NLCD_legend.html',\n)\n</pre> geemap.create_legend(     title='NLCD Land Cover Type',     builtin_legend='NLCD',     draggable=True,     output='NLCD_legend.html', ) <p>Create a built-in non-draggable legend. If the <code>output</code> parameter is not specified, the legend will be returned as an HTML string.</p> In\u00a0[\u00a0]: Copied! <pre>html = geemap.create_legend(\n    title='NLCD Land Cover Type',\n    builtin_legend='NLCD',\n    draggable=False,\n    position='bottomright',\n)\n</pre> html = geemap.create_legend(     title='NLCD Land Cover Type',     builtin_legend='NLCD',     draggable=False,     position='bottomright', ) In\u00a0[\u00a0]: Copied! <pre>widget = geemap.show_html(html)\nwidget\n</pre> widget = geemap.show_html(html) widget In\u00a0[\u00a0]: Copied! <pre>widget.close()\n</pre> widget.close() <p>Create a custom legend.</p> In\u00a0[\u00a0]: Copied! <pre>legend_dict = {\n    \"10 Trees\": \"006400\",\n    \"20 Shrubland\": \"ffbb22\",\n    \"30 Grassland\": \"ffff4c\",\n    \"40 Cropland\": \"f096ff\",\n    \"50 Built-up\": \"fa0000\",\n    \"60 Barren / sparse vegetation\": \"b4b4b4\",\n    \"70 Snow and ice\": \"f0f0f0\",\n    \"80 Open water\": \"0064c8\",\n    \"90 Herbaceous wetland\": \"0096a0\",\n    \"95 Mangroves\": \"00cf75\",\n    \"100 Moss and lichen\": \"fae6a0\",\n}\n</pre> legend_dict = {     \"10 Trees\": \"006400\",     \"20 Shrubland\": \"ffbb22\",     \"30 Grassland\": \"ffff4c\",     \"40 Cropland\": \"f096ff\",     \"50 Built-up\": \"fa0000\",     \"60 Barren / sparse vegetation\": \"b4b4b4\",     \"70 Snow and ice\": \"f0f0f0\",     \"80 Open water\": \"0064c8\",     \"90 Herbaceous wetland\": \"0096a0\",     \"95 Mangroves\": \"00cf75\",     \"100 Moss and lichen\": \"fae6a0\", } In\u00a0[\u00a0]: Copied! <pre>geemap.create_legend(\n    title='ESA Land Cover Type',\n    legend_dict=legend_dict,\n    draggable=False,\n    output='ESA_legend.html',\n)\n</pre> geemap.create_legend(     title='ESA Land Cover Type',     legend_dict=legend_dict,     draggable=False,     output='ESA_legend.html', ) <p>Customize the legend by specifying the <code>style</code> parameter.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_basemap('ESA WorldCover 2021')\n\nstyle = {\n    'position': 'fixed',\n    'z-index': '9999',\n    'border': '2px solid grey',\n    'background-color': 'rgba(255, 255, 255, 0.8)',\n    'border-radius': '10px',\n    'padding': '5px',\n    'font-size': '14px',\n    'bottom': '20px',\n    'right': '5px',\n}\n\nm.add_legend(\n    title='ESA Land Cover Type', legend_dict=legend_dict, draggable=False, style=style\n)\nm\n</pre> m = geemap.Map() m.add_basemap('ESA WorldCover 2021')  style = {     'position': 'fixed',     'z-index': '9999',     'border': '2px solid grey',     'background-color': 'rgba(255, 255, 255, 0.8)',     'border-radius': '10px',     'padding': '5px',     'font-size': '14px',     'bottom': '20px',     'right': '5px', }  m.add_legend(     title='ESA Land Cover Type', legend_dict=legend_dict, draggable=False, style=style ) m <p>Add a legend to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_basemap('ESA WorldCover 2021')\nm.add_legend(title='ESA Land Cover Type', builtin_legend='ESA_WorldCover')\nm\n</pre> m = geemap.Map() m.add_basemap('ESA WorldCover 2021') m.add_legend(title='ESA Land Cover Type', builtin_legend='ESA_WorldCover') m <p>Add legends to a split-view map. Make sure the <code>draggable</code> parameter is set to <code>False</code>.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(\n    center=[40, -100],\n    zoom=4,\n    draw_control=False,\n    measure_control=False,\n    scale_control=False,\n)\nm.split_map(left_layer='ESA WorldCover 2021', right_layer='NLCD 2019 CONUS Land Cover')\nm.add_legend(\n    title='ESA Land Cover Type',\n    builtin_legend='ESA_WorldCover',\n    draggable=False,\n    position='bottomleft',\n    style={'bottom': '5px'},\n)\nm.add_legend(\n    title='NLCD Land Cover Type',\n    builtin_legend='NLCD',\n    draggable=False,\n    position='bottomright',\n)\nm\n</pre> m = geemap.Map(     center=[40, -100],     zoom=4,     draw_control=False,     measure_control=False,     scale_control=False, ) m.split_map(left_layer='ESA WorldCover 2021', right_layer='NLCD 2019 CONUS Land Cover') m.add_legend(     title='ESA Land Cover Type',     builtin_legend='ESA_WorldCover',     draggable=False,     position='bottomleft',     style={'bottom': '5px'}, ) m.add_legend(     title='NLCD Land Cover Type',     builtin_legend='NLCD',     draggable=False,     position='bottomright', ) m"},{"location":"notebooks/128_add_widget/","title":"128 add widget","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap <p>Add text.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\ntext = 'Hello World'\nm.add_text(text, position='bottomright')\nm\n</pre> m = geemap.Map() text = 'Hello World' m.add_text(text, position='bottomright') m <p>Customize text style.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\ntext = 'Hello World'\n\nparams = {\n    'fontsize': 30,\n    'fontcolor': 'blue',\n    'bold': True,\n    'padding': '10px',\n    'background': True,\n    'bg_color': 'white',\n    'border_radius': '5px',\n    'position': 'bottomright',\n}\n\nm.add_text(text, **params)\nm\n</pre> m = geemap.Map() text = 'Hello World'  params = {     'fontsize': 30,     'fontcolor': 'blue',     'bold': True,     'padding': '10px',     'background': True,     'bg_color': 'white',     'border_radius': '5px',     'position': 'bottomright', }  m.add_text(text, **params) m <p>Add image.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nimage = 'https://i.imgur.com/LmTETPX.png'\nm.add_image(image, position='bottomright')\nm\n</pre> m = geemap.Map() image = 'https://i.imgur.com/LmTETPX.png' m.add_image(image, position='bottomright') m <p>Add HTML.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nhtml = \"\"\"\n&lt;h2&gt;Jupyter Logo&lt;/h2&gt;\n&lt;img src=\"https://i.imgur.com/LmTETPX.png\"&gt;\n\"\"\"\nm.add_html(html, position='bottomright')\nm\n</pre> m = geemap.Map() html = \"\"\" Jupyter Logo  \"\"\" m.add_html(html, position='bottomright') m <p>Add widget.</p> In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n</pre> import numpy as np import matplotlib.pyplot as plt In\u00a0[\u00a0]: Copied! <pre># Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots(figsize=(4, 3))\nax.plot(t, s)\n\nax.set(\n    xlabel='time (s)', ylabel='voltage (mV)', title='About as simple as it gets, folks'\n)\nax.grid()\n</pre> # Data for plotting t = np.arange(0.0, 2.0, 0.01) s = 1 + np.sin(2 * np.pi * t)  fig, ax = plt.subplots(figsize=(4, 3)) ax.plot(t, s)  ax.set(     xlabel='time (s)', ylabel='voltage (mV)', title='About as simple as it gets, folks' ) ax.grid() In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_widget(fig, position='bottomright')\nm\n</pre> m = geemap.Map() m.add_widget(fig, position='bottomright') m"},{"location":"notebooks/129_vector_to_gif/","title":"129 vector to gif","text":"<p>Creating animated GIF from vector data</p> <p>Inspired by Johannes Uhl's shapefile2gif, I created a <code>vector_to_gif()</code> function in geemap that makes it much easier to create animated GIF from vector data with only one line of code. The sample dataset used in this notebook is a subset of the dataset retrieved from the shapefile2gif repo. Credits to Johannes Uhl. For more information about the datasets, check out the references below:</p> <ul> <li>Uhl, Johannes H; Leyk, Stefan (2022), \"MTBF-33: A multi-temporal building footprint dataset for</li> </ul> <p>33 counties in the United States (1900\u20132015)\", Data in Brief, 43, 108369. DOI: 10.1016/j.dib.2022.108369</p> <ul> <li>Uhl, Johannes H; Leyk, Stefan (2022), \u201cMTBF-33: A multi-temporal building footprint dataset for 33 U.S. counties</li> </ul> <p>at annual resolution (1900-2015)\u201d, Mendeley Data, V2. DOI: 10.17632/w33vbvjtdy.2</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre># A subset of the dataset retrieved from https://github.com/johannesuhl/shapefile2gif\ndata = 'https://github.com/giswqs/data/raw/main/us/boulder_buildings.zip'\n</pre> # A subset of the dataset retrieved from https://github.com/johannesuhl/shapefile2gif data = 'https://github.com/giswqs/data/raw/main/us/boulder_buildings.zip' In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[39.9898, -105.2532], zoom=14)\nm.add_vector(data, layer_name='Buildings')\nm\n</pre> m = geemap.Map(center=[39.9898, -105.2532], zoom=14) m.add_vector(data, layer_name='Buildings') m In\u00a0[\u00a0]: Copied! <pre>out_gif = 'buildings.gif'\ncolname = 'year_built'\ntitle = 'Building Evolution in Boulder, Colorado, USA (1950-2015)'\n</pre> out_gif = 'buildings.gif' colname = 'year_built' title = 'Building Evolution in Boulder, Colorado, USA (1950-2015)' In\u00a0[\u00a0]: Copied! <pre>geemap.vector_to_gif(\n    data,\n    out_gif,\n    colname,\n    vmin=1950,\n    vmax=2015,\n    step=10,\n    facecolor='black',\n    figsize=(10, 8),\n    title=title,\n    xy=('1%', '1%'),\n    fontsize=20,\n    progress_bar_color='blue',\n    progress_bar_height=10,\n    dpi=300,\n    fps=10,\n    mp4=False,\n    verbose=True,\n)\n</pre> geemap.vector_to_gif(     data,     out_gif,     colname,     vmin=1950,     vmax=2015,     step=10,     facecolor='black',     figsize=(10, 8),     title=title,     xy=('1%', '1%'),     fontsize=20,     progress_bar_color='blue',     progress_bar_height=10,     dpi=300,     fps=10,     mp4=False,     verbose=True, )"},{"location":"notebooks/12_zonal_statistics/","title":"12 zonal statistics","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport os\n</pre> import ee import geemap import os In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('ou-Xm3CLitM')\n</pre> geemap.show_youtube('ou-Xm3CLitM') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\n\n# Set visualization parameters.\ndem_vis = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine DEM to map\nMap.addLayer(dem, dem_vis, 'SRTM DEM')\n\n# Add Landsat data to map\nlandsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\n</pre> # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003')  # Set visualization parameters. dem_vis = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine DEM to map Map.addLayer(dem, dem_vis, 'SRTM DEM')  # Add Landsat data to map landsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nout_dem_stats = os.path.join(out_dir, 'dem_stats.csv')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\n# Allowed output formats: csv, shp, json, kml, kmz\n# Allowed statistics type: MEAN, MAXIMUM, MINIMUM, MEDIAN, STD, MIN_MAX, VARIANCE, SUM\ngeemap.zonal_statistics(dem, states, out_dem_stats, statistics_type='MEAN', scale=1000)\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') out_dem_stats = os.path.join(out_dir, 'dem_stats.csv')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  # Allowed output formats: csv, shp, json, kml, kmz # Allowed statistics type: MEAN, MAXIMUM, MINIMUM, MEDIAN, STD, MIN_MAX, VARIANCE, SUM geemap.zonal_statistics(dem, states, out_dem_stats, statistics_type='MEAN', scale=1000) In\u00a0[\u00a0]: Copied! <pre>out_landsat_stats = os.path.join(out_dir, 'landsat_stats.csv')\ngeemap.zonal_statistics(\n    landsat, states, out_landsat_stats, statistics_type='SUM', scale=1000\n)\n</pre> out_landsat_stats = os.path.join(out_dir, 'landsat_stats.csv') geemap.zonal_statistics(     landsat, states, out_landsat_stats, statistics_type='SUM', scale=1000 ) In\u00a0[\u00a0]: Copied! <pre>geemap.create_download_link(out_dem_stats)\n</pre> geemap.create_download_link(out_dem_stats) In\u00a0[\u00a0]: Copied! <pre>geemap.create_download_link(out_landsat_stats)\n</pre> geemap.create_download_link(out_landsat_stats)"},{"location":"notebooks/130_print_objects/","title":"130 print objects","text":"<p>Printing Earth Engine objects in a collapsible tree structure using eerepr</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap <p>By default, geemap now uses eerepr to print Earth Engine objects. You no longer need to used the <code>.getInfo()</code> function. Uncomment the following code block and execute it if you don't want to use eerepr for printing objects.</p> In\u00a0[\u00a0]: Copied! <pre># import os\n# os.environ['USE_EEREPR'] = 'False'\n</pre> # import os # os.environ['USE_EEREPR'] = 'False' In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() <p>Print <code>ee.Image</code></p> In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('USGS/SRTMGL1_003')\nimage\n</pre> image = ee.Image('USGS/SRTMGL1_003') image <p>Print <code>ee.ImageCollection</code></p> In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection(\"LANDSAT/LC09/C02/T1_L2\").limit(10)\ncollection\n</pre> collection = ee.ImageCollection(\"LANDSAT/LC09/C02/T1_L2\").limit(10) collection <p>Print <code>ee.Feature</code></p> In\u00a0[\u00a0]: Copied! <pre>feature = ee.FeatureCollection(\"TIGER/2018/States\").first()\nfeature\n</pre> feature = ee.FeatureCollection(\"TIGER/2018/States\").first() feature <p>Print <code>ee.FeatureCollection</code></p> In\u00a0[\u00a0]: Copied! <pre>fc = ee.FeatureCollection(\"TIGER/2018/States\").limit(10)\nfc\n</pre> fc = ee.FeatureCollection(\"TIGER/2018/States\").limit(10) fc"},{"location":"notebooks/131_arcgis/","title":"131 arcgis","text":"<p>Using Earth Engine with ArcGIS Pro</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap <p>Add Earth Engine layers.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': 'terrain',\n}\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map() dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': 'terrain', } Map.addLayer(dem, vis_params, 'SRTM DEM') Map <p>Center an Earth Engine object on the map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nimage = (\n    ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503')\n    .select('SR_B.')\n    .multiply(0.0000275)\n    .add(-0.2)\n)\n\nvis_params = {'bands': ['SR_B5', 'SR_B4', 'SR_B3'], 'min': 0, 'max': 0.3}\n\nMap.addLayer(image, vis_params, 'Landsat 9')\nMap.centerObject(image)\nMap\n</pre> Map = geemap.Map() image = (     ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503')     .select('SR_B.')     .multiply(0.0000275)     .add(-0.2) )  vis_params = {'bands': ['SR_B5', 'SR_B4', 'SR_B3'], 'min': 0, 'max': 0.3}  Map.addLayer(image, vis_params, 'Landsat 9') Map.centerObject(image) Map"},{"location":"notebooks/131_arcgis/#step-1-clone-conda-env","title":"Step 1 - Clone conda env\u00b6","text":"<p>Clone the <code>arcgispro-py3</code> conda environment and name it as <code>gee</code> (or whatever name you prefer)</p> <p></p>"},{"location":"notebooks/131_arcgis/#step-2-install-geemap","title":"Step 2 - Install geemap\u00b6","text":"<p>Open Command Prompt or PowerShell to install geemap.</p> <p><code>AppData\\Local\\ESRI\\conda\\envs\\gee\\Scripts\\pip.exe install geemap</code></p> <p></p>"},{"location":"notebooks/131_arcgis/#step-3-create-a-new-notebook","title":"Step 3 - Create a New Notebook\u00b6","text":"<p>To create a notebook, click the Insert tab on the ArcGIS Pro ribbon, and click the New Notebook button. Alternatively, open the Catalog pane, browse to your project directory, right-click a folder, and select New &gt; Notebook.</p>"},{"location":"notebooks/131_arcgis/#step-4-run-gee-script","title":"Step 4 - Run GEE script\u00b6","text":"<p>Run any geemap code as usual. The <code>Map.addLayer()</code> function will automatically add Earth Engine layers to the active map. Use <code>Map.centerObject()</code> to center an Earth Engine object on the map.</p>"},{"location":"notebooks/132_folium_colorbar/","title":"132 folium colorbar","text":"<p>Adding colorbars to a folium map</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\n</pre> import ee import geemap.foliumap as geemap <p>Unlike the ipyleaflet plotting backend, folium does not support adding matplotlib colormap directly. One workaround is to save the maplotlib colormap as an image, then add the image to the map. Let's first create a colormap.</p> <p>Create a colormap using specified parameters.</p> In\u00a0[\u00a0]: Copied! <pre>params = {\n    'width': 4.0,\n    'height': 0.3,\n    'vmin': 0,\n    'vmax': 6000,\n    'cmap': 'terrain',\n    'label': 'Elevation (m)',\n    'orientation': 'horizontal',\n    'transparent': False,\n}\n</pre> params = {     'width': 4.0,     'height': 0.3,     'vmin': 0,     'vmax': 6000,     'cmap': 'terrain',     'label': 'Elevation (m)',     'orientation': 'horizontal',     'transparent': False, } <p>Save the colormap as an image.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.save_colorbar('colorbar.png', **params)\n</pre> geemap.save_colorbar('colorbar.png', **params) <p>You can also create use the <code>m.add_colormap()</code> method to add a colormap. Under the hood, it generate a colormap as an image, then add it to the map. You need to specified the position of the colormap using a tuple (x, y), which represents the percentage [0-100] from the lower-left corner. If the map size changes, you might need to change the colormap position as well.</p> <p>Add a horizontal colormap to the map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 6000,\n    'palette': 'terrain',\n}\nMap.addLayer(image, vis_params, 'SRTM')\n\nMap.add_colormap(position=(55, 5), **params)\nMap\n</pre> Map = geemap.Map()  image = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 6000,     'palette': 'terrain', } Map.addLayer(image, vis_params, 'SRTM')  Map.add_colormap(position=(55, 5), **params) Map <p>Make the colormap background transparent.</p> In\u00a0[\u00a0]: Copied! <pre>params['transparent'] = True\n</pre> params['transparent'] = True In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(image, vis_params, 'SRTM')\nMap.add_colormap(position=(55, 5), **params)\nMap\n</pre> Map = geemap.Map() Map.addLayer(image, vis_params, 'SRTM') Map.add_colormap(position=(55, 5), **params) Map <p>Change the orientation to vertical.</p> In\u00a0[\u00a0]: Copied! <pre>params = {\n    'width': 0.3,\n    'height': 4,\n    'vmin': 0,\n    'vmax': 6000,\n    'cmap': 'terrain',\n    'label': 'Elevation (m)',\n    'orientation': 'vertical',\n    'transparent': False,\n}\n</pre> params = {     'width': 0.3,     'height': 4,     'vmin': 0,     'vmax': 6000,     'cmap': 'terrain',     'label': 'Elevation (m)',     'orientation': 'vertical',     'transparent': False, } In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(image, vis_params, 'SRTM')\nMap.add_colormap(position=(85, 5), **params)\nMap\n</pre> Map = geemap.Map() Map.addLayer(image, vis_params, 'SRTM') Map.add_colormap(position=(85, 5), **params) Map <p>To make the colormap position fixed at four corners (i.e., <code>bottomright</code>, <code>bottomleft</code>, <code>topright</code>, <code>topleft</code>), you need to make the image available through an HTTP URL (e.g., imgur). Local file paths are not supported. Use <code>m.add_image()</code> to add the colormap image to the map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(image, vis_params, 'SRTM')\nimage = 'https://i.imgur.com/SpmE7Cs.png'\nMap.add_image(image, position='bottomright')\nMap\n</pre> Map = geemap.Map() Map.addLayer(image, vis_params, 'SRTM') image = 'https://i.imgur.com/SpmE7Cs.png' Map.add_image(image, position='bottomright') Map <p></p>"},{"location":"notebooks/133_gradio/","title":"133 gradio","text":"<p>Developing interactive web apps with gradio and leafmap</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap gradio\n</pre> # !pip install -U geemap gradio In\u00a0[\u00a0]: Copied! <pre>import ee\nimport gradio as gr\nimport geemap.foliumap as geemap\n</pre> import ee import gradio as gr import geemap.foliumap as geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[21.79, 70.87], zoom=3)\nimage = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 6000,\n    'palette': 'terrain',\n}\nMap.addLayer(image, vis_params, 'SRTM')\nMap\n</pre> Map = geemap.Map(center=[21.79, 70.87], zoom=3) image = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 6000,     'palette': 'terrain', } Map.addLayer(image, vis_params, 'SRTM') Map <p>Visualize an Earth Engine layer.</p> In\u00a0[\u00a0]: Copied! <pre>def viz_dem(vmin, vmax, palette):\n    Map = geemap.Map()\n    image = ee.Image('USGS/SRTMGL1_003')\n    vis_params = {\n        'min': vmin,\n        'max': vmax,\n        'palette': palette,\n    }\n    Map.addLayer(image, vis_params, 'SRTM')\n    return Map.to_gradio()\n\n\nvmin = gr.Number(value=0, label=\"Min value\")\nvmax = gr.Number(value=6000, label=\"Max value\")\npalette = gr.Textbox(value=\"terrain\", label=\"Palette\")\ntitle = 'Visualize Earth Engine Data'\ndemo = gr.Interface(viz_dem, [vmin, vmax, palette], \"html\", title=title)\ndemo.launch()\n</pre> def viz_dem(vmin, vmax, palette):     Map = geemap.Map()     image = ee.Image('USGS/SRTMGL1_003')     vis_params = {         'min': vmin,         'max': vmax,         'palette': palette,     }     Map.addLayer(image, vis_params, 'SRTM')     return Map.to_gradio()   vmin = gr.Number(value=0, label=\"Min value\") vmax = gr.Number(value=6000, label=\"Max value\") palette = gr.Textbox(value=\"terrain\", label=\"Palette\") title = 'Visualize Earth Engine Data' demo = gr.Interface(viz_dem, [vmin, vmax, palette], \"html\", title=title) demo.launch() <p>Visualize Earth Engine layers side by side.</p> In\u00a0[\u00a0]: Copied! <pre>def split(left, right):\n    Map = geemap.Map(center=(40, -100), zoom=4, height=600)\n\n    nlcd_left = ee.Image(f'USGS/NLCD_RELEASES/2019_REL/NLCD/{left}').select('landcover')\n    nlcd_right = ee.Image(f'USGS/NLCD_RELEASES/2019_REL/NLCD/{right}').select(\n        'landcover'\n    )\n\n    left_layer = geemap.ee_tile_layer(nlcd_left, {}, f'NLCD {left}')\n    right_layer = geemap.ee_tile_layer(nlcd_right, {}, f'NLCD {right}')\n\n    Map.split_map(\n        left_layer,\n        right_layer,\n    )\n    return Map.to_gradio()\n\n\nleft_input = gr.Textbox(value='2001', label=\"Left Layer URL\")\nright_input = gr.Textbox(value='2019', label=\"Right Layer URL\")\n\ntitle = 'Visualizing National Land Cover Database (NLCD)'\ndemo = gr.Interface(split, [left_input, right_input], \"html\", title=title)\ndemo.launch()\n</pre> def split(left, right):     Map = geemap.Map(center=(40, -100), zoom=4, height=600)      nlcd_left = ee.Image(f'USGS/NLCD_RELEASES/2019_REL/NLCD/{left}').select('landcover')     nlcd_right = ee.Image(f'USGS/NLCD_RELEASES/2019_REL/NLCD/{right}').select(         'landcover'     )      left_layer = geemap.ee_tile_layer(nlcd_left, {}, f'NLCD {left}')     right_layer = geemap.ee_tile_layer(nlcd_right, {}, f'NLCD {right}')      Map.split_map(         left_layer,         right_layer,     )     return Map.to_gradio()   left_input = gr.Textbox(value='2001', label=\"Left Layer URL\") right_input = gr.Textbox(value='2019', label=\"Right Layer URL\")  title = 'Visualizing National Land Cover Database (NLCD)' demo = gr.Interface(split, [left_input, right_input], \"html\", title=title) demo.launch() <p>Visualize Cloud Optimized GeoTIFF (COG).</p> In\u00a0[\u00a0]: Copied! <pre>def split(left, right):\n    Map = geemap.Map(center=[21.79, 70.87], zoom=3)\n    Map.split_map(left, right)\n    print(Map.options[\"layersControl\"])\n    return Map.to_gradio()\n\n\nleft_url = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\nright_url = 'https://opendata.digitalglobe.com/events/california-fire-2020/post-event/2020-08-14/pine-gulch-fire20/10300100AAC8DD00.tif'\nleft_input = gr.Textbox(value=left_url, label=\"Left Layer URL\")\nright_input = gr.Textbox(value=right_url, label=\"Right Layer URL\")\ntitle = 'Visualze Cloud Optimized GeoTIFF (COG)'\ndemo = gr.Interface(split, [left_input, right_input], \"html\", title=title)\ndemo.launch()\n</pre> def split(left, right):     Map = geemap.Map(center=[21.79, 70.87], zoom=3)     Map.split_map(left, right)     print(Map.options[\"layersControl\"])     return Map.to_gradio()   left_url = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif' right_url = 'https://opendata.digitalglobe.com/events/california-fire-2020/post-event/2020-08-14/pine-gulch-fire20/10300100AAC8DD00.tif' left_input = gr.Textbox(value=left_url, label=\"Left Layer URL\") right_input = gr.Textbox(value=right_url, label=\"Right Layer URL\") title = 'Visualze Cloud Optimized GeoTIFF (COG)' demo = gr.Interface(split, [left_input, right_input], \"html\", title=title) demo.launch()"},{"location":"notebooks/134_ee_to_geotiff/","title":"134 ee to geotiff","text":"<p>Download Earth Engine map tiles as a GeoTIFF</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geemap\n</pre> # !pip install -U geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\npoint = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(point)\n    .filterDate('2008-01-01', '2018-01-01')\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\nimage = collection.first()\nMap.addLayer(image, {}, 'NAIP')\nMap.centerObject(image)\nMap\n</pre> Map = geemap.Map() point = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(point)     .filterDate('2008-01-01', '2018-01-01')     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) image = collection.first() Map.addLayer(image, {}, 'NAIP') Map.centerObject(image) Map In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_geotiff(\n    image, 'naip.tif', resolution=5, vis_params={'bands': ['N', 'R', 'G']}\n)\n</pre> geemap.ee_to_geotiff(     image, 'naip.tif', resolution=5, vis_params={'bands': ['N', 'R', 'G']} ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(\n    ['B5', 'B4', 'B3']\n)\n\nvis_params = {'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n\nMap.centerObject(image)\nMap.addLayer(image, vis_params, 'Landsat')\nMap\n</pre> Map = geemap.Map()  image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(     ['B5', 'B4', 'B3'] )  vis_params = {'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}  Map.centerObject(image) Map.addLayer(image, vis_params, 'Landsat') Map In\u00a0[\u00a0]: Copied! <pre>bbox = Map.user_roi_coords()\nif bbox is None:\n    bbox = [-122.5955, 37.5339, -122.0982, 37.8252]\n</pre> bbox = Map.user_roi_coords() if bbox is None:     bbox = [-122.5955, 37.5339, -122.0982, 37.8252] In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_geotiff(image, 'landsat.tif', bbox, vis_params, resolution=30)\n</pre> geemap.ee_to_geotiff(image, 'landsat.tif', bbox, vis_params, resolution=30)"},{"location":"notebooks/13_zonal_statistics_by_group/","title":"13 zonal statistics by group","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport os\n</pre> import ee import geemap import os In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>dataset = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')\nlandcover = ee.Image(dataset.select('landcover'))\nMap.addLayer(landcover, {}, 'NLCD 2016')\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\n</pre> dataset = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019') landcover = ee.Image(dataset.select('landcover')) Map.addLayer(landcover, {}, 'NLCD 2016')  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') In\u00a0[\u00a0]: Copied! <pre>Map.add_legend(builtin_legend='NLCD')\n</pre> Map.add_legend(builtin_legend='NLCD') In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nnlcd_stats = os.path.join(out_dir, 'nlcd_stats.csv')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\n# statistics_type can be either 'SUM' or 'PERCENTAGE'\n# denominator can be used to convert square meters to other areal units, such as square kilometers\ngeemap.zonal_statistics_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    statistics_type='SUM',\n    denominator=1000000,\n    decimal_places=2,\n)\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') nlcd_stats = os.path.join(out_dir, 'nlcd_stats.csv')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  # statistics_type can be either 'SUM' or 'PERCENTAGE' # denominator can be used to convert square meters to other areal units, such as square kilometers geemap.zonal_statistics_by_group(     landcover,     states,     nlcd_stats,     statistics_type='SUM',     denominator=1000000,     decimal_places=2, ) In\u00a0[\u00a0]: Copied! <pre>geemap.create_download_link(nlcd_stats)\n</pre> geemap.create_download_link(nlcd_stats) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>landcover = ee.Image('MODIS/006/MCD12Q1/2013_01_01').select('LC_Type1')\n\nvis = {\n    'min': 1.0,\n    'max': 17.0,\n    'palette': [\n        '05450a',\n        '086a10',\n        '54a708',\n        '78d203',\n        '009900',\n        'c6b044',\n        'dcd159',\n        'dade48',\n        'fbff13',\n        'b6ff05',\n        '27ff87',\n        'c24f44',\n        'a5a5a5',\n        'ff6d4c',\n        '69fff8',\n        'f9ffa4',\n        '1c0dff',\n    ],\n}\n\nMap.setCenter(6.746, 46.529, 2)\nMap.addLayer(landcover, vis, 'MODIS Land Cover')\n</pre> landcover = ee.Image('MODIS/006/MCD12Q1/2013_01_01').select('LC_Type1')  vis = {     'min': 1.0,     'max': 17.0,     'palette': [         '05450a',         '086a10',         '54a708',         '78d203',         '009900',         'c6b044',         'dcd159',         'dade48',         'fbff13',         'b6ff05',         '27ff87',         'c24f44',         'a5a5a5',         'ff6d4c',         '69fff8',         'f9ffa4',         '1c0dff',     ], }  Map.setCenter(6.746, 46.529, 2) Map.addLayer(landcover, vis, 'MODIS Land Cover') In\u00a0[\u00a0]: Copied! <pre>Map.add_legend(builtin_legend='MODIS/006/MCD12Q1')\n</pre> Map.add_legend(builtin_legend='MODIS/006/MCD12Q1') In\u00a0[\u00a0]: Copied! <pre>countries_shp = '../data/countries.shp'\ncountries = geemap.shp_to_ee(countries_shp)\nMap.addLayer(countries, {}, 'Countries')\n</pre> countries_shp = '../data/countries.shp' countries = geemap.shp_to_ee(countries_shp) Map.addLayer(countries, {}, 'Countries') In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nglobal_stats = os.path.join(out_dir, 'global_stats.csv')\n\n# statistics_type can be either 'SUM' or 'PERCENTAGE'\n# denominator can be used to convert square meters to other areal units, such as square kilimeters\ngeemap.zonal_statistics_by_group(\n    landcover,\n    countries,\n    global_stats,\n    statistics_type='PERCENTAGE',\n    denominator=1000000,\n    decimal_places=2,\n)\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') global_stats = os.path.join(out_dir, 'global_stats.csv')  # statistics_type can be either 'SUM' or 'PERCENTAGE' # denominator can be used to convert square meters to other areal units, such as square kilimeters geemap.zonal_statistics_by_group(     landcover,     countries,     global_stats,     statistics_type='PERCENTAGE',     denominator=1000000,     decimal_places=2, ) In\u00a0[\u00a0]: Copied! <pre>geemap.create_download_link(global_stats)\n</pre> geemap.create_download_link(global_stats)"},{"location":"notebooks/13_zonal_statistics_by_group/#analyzing-national-land-cover-database-nlcd","title":"Analyzing National Land Cover Database (NLCD)\u00b6","text":""},{"location":"notebooks/13_zonal_statistics_by_group/#add-nlcd-data","title":"Add NLCD data\u00b6","text":""},{"location":"notebooks/13_zonal_statistics_by_group/#calculate-land-cover-compostion-of-each-us-state","title":"Calculate land cover compostion of each US state\u00b6","text":""},{"location":"notebooks/13_zonal_statistics_by_group/#analyzing-global-land-cover","title":"Analyzing Global Land Cover\u00b6","text":""},{"location":"notebooks/13_zonal_statistics_by_group/#add-modis-global-land-cover-data","title":"Add MODIS global land cover data\u00b6","text":"<p>MODIS MCD12Q1.006 Land Cover Type Yearly Global 500m</p> <p>https://developers.google.com/earth-engine/datasets/catalog/MODIS_006_MCD12Q1</p>"},{"location":"notebooks/14_legends/","title":"14 legends","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('NwnW_qOkNRw')\n</pre> geemap.show_youtube('NwnW_qOkNRw') In\u00a0[\u00a0]: Copied! <pre>legends = geemap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = geemap.builtin_legends for legend in legends:     print(legend) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nlandcover = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') landcover = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover') Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap.add_basemap('FWS NWI Wetlands')\nMap.add_legend(builtin_legend='NWI')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map.add_basemap('FWS NWI Wetlands') Map.add_legend(builtin_legend='NWI') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\n\nlandcover = ee.Image('MODIS/051/MCD12Q1/2013_01_01').select('Land_Cover_Type_1')\n\nMap.setCenter(6.746, 46.529, 2)\nMap.addLayer(landcover, {}, 'MODIS Land Cover')\nMap.add_legend(builtin_legend='MODIS/051/MCD12Q1')\n\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID')  landcover = ee.Image('MODIS/051/MCD12Q1/2013_01_01').select('Land_Cover_Type_1')  Map.setCenter(6.746, 46.529, 2) Map.addLayer(landcover, {}, 'MODIS Land Cover') Map.add_legend(builtin_legend='MODIS/051/MCD12Q1')  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlegend_keys = ['One', 'Two', 'Three', 'Four', 'ect']\n# colorS can be defined using either hex code or RGB (0-255, 0-255, 0-255)\nlegend_colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']\n# legend_colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68 123)]\n\nMap.add_legend(\n    legend_keys=legend_keys, legend_colors=legend_colors, position='bottomleft'\n)\nMap\n</pre> Map = geemap.Map()  legend_keys = ['One', 'Two', 'Three', 'Four', 'ect'] # colorS can be defined using either hex code or RGB (0-255, 0-255, 0-255) legend_colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3'] # legend_colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68 123)]  Map.add_legend(     legend_keys=legend_keys, legend_colors=legend_colors, position='bottomleft' ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlegend_dict = {\n    '11 Open Water': '466b9f',\n    '12 Perennial Ice/Snow': 'd1def8',\n    '21 Developed, Open Space': 'dec5c5',\n    '22 Developed, Low Intensity': 'd99282',\n    '23 Developed, Medium Intensity': 'eb0000',\n    '24 Developed High Intensity': 'ab0000',\n    '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',\n    '41 Deciduous Forest': '68ab5f',\n    '42 Evergreen Forest': '1c5f2c',\n    '43 Mixed Forest': 'b5c58f',\n    '51 Dwarf Scrub': 'af963c',\n    '52 Shrub/Scrub': 'ccb879',\n    '71 Grassland/Herbaceous': 'dfdfc2',\n    '72 Sedge/Herbaceous': 'd1d182',\n    '73 Lichens': 'a3cc51',\n    '74 Moss': '82ba9e',\n    '81 Pasture/Hay': 'dcd939',\n    '82 Cultivated Crops': 'ab6c28',\n    '90 Woody Wetlands': 'b8d9eb',\n    '95 Emergent Herbaceous Wetlands': '6c9fb8',\n}\n\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\n\nMap.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n</pre> Map = geemap.Map()  legend_dict = {     '11 Open Water': '466b9f',     '12 Perennial Ice/Snow': 'd1def8',     '21 Developed, Open Space': 'dec5c5',     '22 Developed, Low Intensity': 'd99282',     '23 Developed, Medium Intensity': 'eb0000',     '24 Developed High Intensity': 'ab0000',     '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',     '41 Deciduous Forest': '68ab5f',     '42 Evergreen Forest': '1c5f2c',     '43 Mixed Forest': 'b5c58f',     '51 Dwarf Scrub': 'af963c',     '52 Shrub/Scrub': 'ccb879',     '71 Grassland/Herbaceous': 'dfdfc2',     '72 Sedge/Herbaceous': 'd1d182',     '73 Lichens': 'a3cc51',     '74 Moss': '82ba9e',     '81 Pasture/Hay': 'dcd939',     '82 Cultivated Crops': 'ab6c28',     '90 Woody Wetlands': 'b8d9eb',     '95 Emergent Herbaceous Wetlands': '6c9fb8', }  landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover')  Map.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nee_class_table = \"\"\"\n\nValue\tColor\tDescription\n0\t1c0dff\tWater\n1\t05450a\tEvergreen needleleaf forest\n2\t086a10\tEvergreen broadleaf forest\n3\t54a708\tDeciduous needleleaf forest\n4\t78d203\tDeciduous broadleaf forest\n5\t009900\tMixed forest\n6\tc6b044\tClosed shrublands\n7\tdcd159\tOpen shrublands\n8\tdade48\tWoody savannas\n9\tfbff13\tSavannas\n10\tb6ff05\tGrasslands\n11\t27ff87\tPermanent wetlands\n12\tc24f44\tCroplands\n13\ta5a5a5\tUrban and built-up\n14\tff6d4c\tCropland/natural vegetation mosaic\n15\t69fff8\tSnow and ice\n16\tf9ffa4\tBarren or sparsely vegetated\n254\tffffff\tUnclassified\n\n\"\"\"\n\nlandcover = ee.Image('MODIS/051/MCD12Q1/2013_01_01').select('Land_Cover_Type_1')\nMap.setCenter(6.746, 46.529, 2)\nMap.addLayer(landcover, {}, 'MODIS Land Cover')\n\nlegend_dict = geemap.legend_from_ee(ee_class_table)\nMap.add_legend(legend_title=\"MODIS Global Land Cover\", legend_dict=legend_dict)\n\nMap\n</pre> Map = geemap.Map()  ee_class_table = \"\"\"  Value\tColor\tDescription 0\t1c0dff\tWater 1\t05450a\tEvergreen needleleaf forest 2\t086a10\tEvergreen broadleaf forest 3\t54a708\tDeciduous needleleaf forest 4\t78d203\tDeciduous broadleaf forest 5\t009900\tMixed forest 6\tc6b044\tClosed shrublands 7\tdcd159\tOpen shrublands 8\tdade48\tWoody savannas 9\tfbff13\tSavannas 10\tb6ff05\tGrasslands 11\t27ff87\tPermanent wetlands 12\tc24f44\tCroplands 13\ta5a5a5\tUrban and built-up 14\tff6d4c\tCropland/natural vegetation mosaic 15\t69fff8\tSnow and ice 16\tf9ffa4\tBarren or sparsely vegetated 254\tffffff\tUnclassified  \"\"\"  landcover = ee.Image('MODIS/051/MCD12Q1/2013_01_01').select('Land_Cover_Type_1') Map.setCenter(6.746, 46.529, 2) Map.addLayer(landcover, {}, 'MODIS Land Cover')  legend_dict = geemap.legend_from_ee(ee_class_table) Map.add_legend(legend_title=\"MODIS Global Land Cover\", legend_dict=legend_dict)  Map"},{"location":"notebooks/14_legends/#add-builtin-legends-from-geemap-python-package","title":"Add builtin legends from geemap Python package\u00b6","text":"<p>https://github.com/gee-community/geemap/blob/master/geemap/legends.py</p>"},{"location":"notebooks/14_legends/#available-builtin-legends","title":"Available builtin legends:\u00b6","text":""},{"location":"notebooks/14_legends/#available-land-cover-datasets-in-earth-engine","title":"Available Land Cover Datasets in Earth Engine\u00b6","text":"<p>https://developers.google.com/earth-engine/datasets/tags/landcover</p>"},{"location":"notebooks/14_legends/#national-land-cover-database-nlcd","title":"National Land Cover Database (NLCD)\u00b6","text":"<p>https://developers.google.com/earth-engine/datasets/catalog/USGS_NLCD_RELEASES_2019_REL_NLCD</p>"},{"location":"notebooks/14_legends/#national-wetlands-inventory-nwi","title":"National Wetlands Inventory (NWI)\u00b6","text":"<p>https://www.fws.gov/program/national-wetlands-inventory/wetlands-mapper</p>"},{"location":"notebooks/14_legends/#modis-land-cover-type-yearly-global-500m","title":"MODIS Land Cover Type Yearly Global 500m\u00b6","text":"<p>https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1</p>"},{"location":"notebooks/14_legends/#add-customized-legends-for-earth-engine-data","title":"Add customized legends for Earth Engine data\u00b6","text":"<p>There are three ways you can add customized legends for Earth Engine data</p> <ol> <li>Define legend keys and colors</li> <li>Define legend dictionary</li> <li>Convert Earth Engine class table to legend dictionary</li> </ol>"},{"location":"notebooks/14_legends/#define-legend-keys-and-colors","title":"Define legend keys and colors\u00b6","text":""},{"location":"notebooks/14_legends/#define-a-legend-dictionary","title":"Define a legend dictionary\u00b6","text":""},{"location":"notebooks/14_legends/#convert-an-earth-engine-class-table-to-legend","title":"Convert an Earth Engine class table to legend\u00b6","text":"<p>For example: MCD12Q1.051 Land Cover Type Yearly Global 500m</p> <p>https://developers.google.com/earth-engine/datasets/catalog/MODIS_051_MCD12Q1</p>"},{"location":"notebooks/15_convert_js_to_py/","title":"15 convert js to py","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('nAzZjKKd4w0')\n</pre> geemap.show_youtube('nAzZjKKd4w0') <p>You can simply copy and paste your GEE JavaScripts into a code block wrapped with trip quotes and pass it to a variable.</p> <p>For example, you can grap GEE JavaScripts from GEE Documentation.</p> In\u00a0[\u00a0]: Copied! <pre>js_snippet = \"\"\"\n// Load an image.\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\n\n// Define the visualization parameters.\nvar vizParams = {\n  bands: ['B5', 'B4', 'B3'],\n  min: 0,\n  max: 0.5,\n  gamma: [0.95, 1.1, 1]\n};\n\n// Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay\nMap.addLayer(image, vizParams, 'false color composite');\n\n\"\"\"\n</pre> js_snippet = \"\"\" // Load an image. var image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');  // Define the visualization parameters. var vizParams = {   bands: ['B5', 'B4', 'B3'],   min: 0,   max: 0.5,   gamma: [0.95, 1.1, 1] };  // Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay Map.addLayer(image, vizParams, 'false color composite');  \"\"\" In\u00a0[\u00a0]: Copied! <pre>geemap.js_snippet_to_py(\n    js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True\n)\n</pre> geemap.js_snippet_to_py(     js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True ) In\u00a0[\u00a0]: Copied! <pre>js_snippet = \"\"\"\n\n// Load an image.\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\n\n// Create an NDWI image, define visualization parameters and display.\nvar ndwi = image.normalizedDifference(['B3', 'B5']);\nvar ndwiViz = {min: 0.5, max: 1, palette: ['00FFFF', '0000FF']};\nMap.addLayer(ndwi, ndwiViz, 'NDWI', false);\n\n\"\"\"\n</pre> js_snippet = \"\"\"  // Load an image. var image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');  // Create an NDWI image, define visualization parameters and display. var ndwi = image.normalizedDifference(['B3', 'B5']); var ndwiViz = {min: 0.5, max: 1, palette: ['00FFFF', '0000FF']}; Map.addLayer(ndwi, ndwiViz, 'NDWI', false);  \"\"\" In\u00a0[\u00a0]: Copied! <pre>geemap.js_snippet_to_py(js_snippet)\n</pre> geemap.js_snippet_to_py(js_snippet) In\u00a0[\u00a0]: Copied! <pre>js_snippet = \"\"\"\n\n// Load 2012 MODIS land cover and select the IGBP classification.\nvar cover = ee.Image('MODIS/051/MCD12Q1/2012_01_01')\n  .select('Land_Cover_Type_1');\n\n// Define a palette for the 18 distinct land cover classes.\nvar igbpPalette = [\n  'aec3d4', // water\n  '152106', '225129', '369b47', '30eb5b', '387242', // forest\n  '6a2325', 'c3aa69', 'b76031', 'd9903d', '91af40',  // shrub, grass\n  '111149', // wetlands\n  'cdb33b', // croplands\n  'cc0013', // urban\n  '33280d', // crop mosaic\n  'd7cdcc', // snow and ice\n  'f7e084', // barren\n  '6f6f6f'  // tundra\n];\n\n// Specify the min and max labels and the color palette matching the labels.\nMap.setCenter(-99.229, 40.413, 5);\nMap.addLayer(cover,\n             {min: 0, max: 17, palette: igbpPalette},\n             'IGBP classification');\n\n\"\"\"\n</pre> js_snippet = \"\"\"  // Load 2012 MODIS land cover and select the IGBP classification. var cover = ee.Image('MODIS/051/MCD12Q1/2012_01_01')   .select('Land_Cover_Type_1');  // Define a palette for the 18 distinct land cover classes. var igbpPalette = [   'aec3d4', // water   '152106', '225129', '369b47', '30eb5b', '387242', // forest   '6a2325', 'c3aa69', 'b76031', 'd9903d', '91af40',  // shrub, grass   '111149', // wetlands   'cdb33b', // croplands   'cc0013', // urban   '33280d', // crop mosaic   'd7cdcc', // snow and ice   'f7e084', // barren   '6f6f6f'  // tundra ];  // Specify the min and max labels and the color palette matching the labels. Map.setCenter(-99.229, 40.413, 5); Map.addLayer(cover,              {min: 0, max: 17, palette: igbpPalette},              'IGBP classification');  \"\"\" In\u00a0[\u00a0]: Copied! <pre>geemap.js_snippet_to_py(js_snippet)\n</pre> geemap.js_snippet_to_py(js_snippet)"},{"location":"notebooks/16_add_animated_text/","title":"16 add animated text","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\nimport os\n</pre> import geemap import os In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('fDnDVuM_Ke4')\n</pre> geemap.show_youtube('fDnDVuM_Ke4') In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>in_gif = os.path.abspath('../data/animation.gif')\nout_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nout_gif = os.path.join(out_dir, 'output.gif')\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n</pre> in_gif = os.path.abspath('../data/animation.gif') out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') out_gif = os.path.join(out_dir, 'output.gif') if not os.path.exists(out_dir):     os.makedirs(out_dir) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(in_gif)\n</pre> geemap.show_image(in_gif) In\u00a0[\u00a0]: Copied! <pre>geemap.add_text_to_gif(\n    in_gif,\n    out_gif,\n    xy=('5%', '5%'),\n    text_sequence=1984,\n    font_size=30,\n    font_color='#0000ff',\n    duration=100,\n)\n</pre> geemap.add_text_to_gif(     in_gif,     out_gif,     xy=('5%', '5%'),     text_sequence=1984,     font_size=30,     font_color='#0000ff',     duration=100, ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>geemap.add_text_to_gif(\n    out_gif, out_gif, xy=('30%', '85%'), text_sequence=\"Las Vegas\", font_color='black'\n)\n</pre> geemap.add_text_to_gif(     out_gif, out_gif, xy=('30%', '85%'), text_sequence=\"Las Vegas\", font_color='black' ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>geemap.system_fonts()\n</pre> geemap.system_fonts() In\u00a0[\u00a0]: Copied! <pre>geemap.add_text_to_gif(\n    in_gif,\n    out_gif,\n    xy=('5%', '5%'),\n    text_sequence=1984,\n    font_size=30,\n    font_color='#0000ff',\n    duration=100,\n)\ngeemap.add_text_to_gif(\n    out_gif,\n    out_gif,\n    xy=('30%', '85%'),\n    text_sequence=\"Las Vegas\",\n    font_type=\"timesbd.ttf\",\n    font_size=30,\n    font_color='black',\n)\ngeemap.show_image(out_gif)\n</pre> geemap.add_text_to_gif(     in_gif,     out_gif,     xy=('5%', '5%'),     text_sequence=1984,     font_size=30,     font_color='#0000ff',     duration=100, ) geemap.add_text_to_gif(     out_gif,     out_gif,     xy=('30%', '85%'),     text_sequence=\"Las Vegas\",     font_type=\"timesbd.ttf\",     font_size=30,     font_color='black', ) geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nee.Initialize()\n\n# Define an area of interest geometry with a global non-polar extent.\naoi = ee.Geometry.Polygon(\n    [[[-179.0, 78.0], [-179.0, -58.0], [179.0, -58.0], [179.0, 78.0]]], None, False\n)\n\n# Import hourly predicted temperature image collection for northern winter\n# solstice. Note that predictions extend for 384 hours; limit the collection\n# to the first 24 hours.\ntempCol = (\n    ee.ImageCollection('NOAA/GFS0P25')\n    .filterDate('2018-12-22', '2018-12-23')\n    .limit(24)\n    .select('temperature_2m_above_ground')\n)\n\n# Define arguments for animation function parameters.\nvideoArgs = {\n    'dimensions': 768,\n    'region': aoi,\n    'framesPerSecond': 10,\n    'crs': 'EPSG:3857',\n    'min': -40.0,\n    'max': 35.0,\n    'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'],\n}\n</pre> import ee import geemap  ee.Initialize()  # Define an area of interest geometry with a global non-polar extent. aoi = ee.Geometry.Polygon(     [[[-179.0, 78.0], [-179.0, -58.0], [179.0, -58.0], [179.0, 78.0]]], None, False )  # Import hourly predicted temperature image collection for northern winter # solstice. Note that predictions extend for 384 hours; limit the collection # to the first 24 hours. tempCol = (     ee.ImageCollection('NOAA/GFS0P25')     .filterDate('2018-12-22', '2018-12-23')     .limit(24)     .select('temperature_2m_above_ground') )  # Define arguments for animation function parameters. videoArgs = {     'dimensions': 768,     'region': aoi,     'framesPerSecond': 10,     'crs': 'EPSG:3857',     'min': -40.0,     'max': 35.0,     'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'], } In\u00a0[\u00a0]: Copied! <pre>saved_gif = os.path.join(os.path.expanduser('~'), 'Downloads/temperature.gif')\ngeemap.download_ee_video(tempCol, videoArgs, saved_gif)\n</pre> saved_gif = os.path.join(os.path.expanduser('~'), 'Downloads/temperature.gif') geemap.download_ee_video(tempCol, videoArgs, saved_gif) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(saved_gif)\n</pre> geemap.show_image(saved_gif) In\u00a0[\u00a0]: Copied! <pre>text = [str(n).zfill(2) + \":00\" for n in range(0, 24)]\nprint(text)\n</pre> text = [str(n).zfill(2) + \":00\" for n in range(0, 24)] print(text) In\u00a0[\u00a0]: Copied! <pre>out_gif = os.path.join(os.path.expanduser('~'), 'Downloads/output2.gif')\n</pre> out_gif = os.path.join(os.path.expanduser('~'), 'Downloads/output2.gif') In\u00a0[\u00a0]: Copied! <pre>geemap.add_text_to_gif(\n    saved_gif,\n    out_gif,\n    xy=('3%', '5%'),\n    text_sequence=text,\n    font_size=30,\n    font_color='#ffffff',\n)\n</pre> geemap.add_text_to_gif(     saved_gif,     out_gif,     xy=('3%', '5%'),     text_sequence=text,     font_size=30,     font_color='#ffffff', ) In\u00a0[\u00a0]: Copied! <pre>geemap.add_text_to_gif(\n    out_gif,\n    out_gif,\n    xy=('32%', '92%'),\n    text_sequence='NOAA GFS Hourly Temperature',\n    font_color='white',\n)\n</pre> geemap.add_text_to_gif(     out_gif,     out_gif,     xy=('32%', '92%'),     text_sequence='NOAA GFS Hourly Temperature',     font_color='white', ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif)"},{"location":"notebooks/16_add_animated_text/#update-the-geemap-package","title":"Update the geemap package\u00b6","text":"<p>If you run into errors with this notebook, please uncomment the line below to update the geemap package to the latest version from GitHub.  Restart the Kernel (Menu -&gt; Kernel -&gt; Restart) to take effect.</p>"},{"location":"notebooks/16_add_animated_text/#add-animated-text-to-an-existing-gif","title":"Add animated text to an existing GIF\u00b6","text":"<p>You can download this GIF example from here. You can also create GIF images from Earth Engine data using this amazing LT-GEE Time Series Animator, which was created by Justin Braaten.</p>"},{"location":"notebooks/16_add_animated_text/#add-animated-text-to-gif","title":"Add animated text to GIF\u00b6","text":""},{"location":"notebooks/16_add_animated_text/#add-place-name","title":"Add place name\u00b6","text":""},{"location":"notebooks/16_add_animated_text/#change-font-type","title":"Change font type\u00b6","text":""},{"location":"notebooks/16_add_animated_text/#create-gif-from-earth-engine-data","title":"Create GIF from Earth Engine data\u00b6","text":"<p>This example was adapted from the Earth Engine JavaScript API Documentation here.</p>"},{"location":"notebooks/16_add_animated_text/#prepare-for-an-imagecollection","title":"Prepare for an ImageCollection\u00b6","text":""},{"location":"notebooks/16_add_animated_text/#save-the-gif-to-local-drive","title":"Save the GIF to local drive\u00b6","text":""},{"location":"notebooks/16_add_animated_text/#generate-an-hourly-text-sequence","title":"Generate an hourly text sequence\u00b6","text":""},{"location":"notebooks/16_add_animated_text/#add-text-to-gif","title":"Add text to GIF\u00b6","text":""},{"location":"notebooks/17_add_colorbar_to_gif/","title":"17 add colorbar to gif","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\nimport os\n</pre> import geemap import os In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>from geemap import *\n</pre> from geemap import * In\u00a0[\u00a0]: Copied! <pre>url = 'https://i.imgur.com/MSde1om.gif'\nout_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\ndownload_from_url(url, out_file_name='temp.gif', out_dir=out_dir)\n</pre> url = 'https://i.imgur.com/MSde1om.gif' out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') if not os.path.exists(out_dir):     os.makedirs(out_dir) download_from_url(url, out_file_name='temp.gif', out_dir=out_dir) In\u00a0[\u00a0]: Copied! <pre>in_gif = os.path.join(out_dir, 'temp.gif')\nshow_image(in_gif)\n</pre> in_gif = os.path.join(out_dir, 'temp.gif') show_image(in_gif) In\u00a0[\u00a0]: Copied! <pre>noaa_logo = 'https://bit.ly/3ahJoMq'\nee_logo = 'https://i.imgur.com/Qbvacvm.png'\n</pre> noaa_logo = 'https://bit.ly/3ahJoMq' ee_logo = 'https://i.imgur.com/Qbvacvm.png' In\u00a0[\u00a0]: Copied! <pre>out_gif = os.path.join(out_dir, 'output.gif')\n</pre> out_gif = os.path.join(out_dir, 'output.gif') In\u00a0[\u00a0]: Copied! <pre>add_image_to_gif(\n    in_gif, out_gif, in_image=noaa_logo, xy=('2%', '80%'), image_size=(80, 80)\n)\n</pre> add_image_to_gif(     in_gif, out_gif, in_image=noaa_logo, xy=('2%', '80%'), image_size=(80, 80) ) In\u00a0[\u00a0]: Copied! <pre>add_image_to_gif(\n    out_gif, out_gif, in_image=ee_logo, xy=('13%', '79%'), image_size=(85, 85)\n)\n</pre> add_image_to_gif(     out_gif, out_gif, in_image=ee_logo, xy=('13%', '79%'), image_size=(85, 85) ) In\u00a0[\u00a0]: Copied! <pre>show_image(out_gif)\n</pre> show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>width = 250\nheight = 30\npalette = ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']\nlabels = [-40, 35]\ncolorbar = create_colorbar(\n    width=width,\n    height=height,\n    palette=palette,\n    vertical=False,\n    add_labels=True,\n    font_size=20,\n    labels=labels,\n)\n</pre> width = 250 height = 30 palette = ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'] labels = [-40, 35] colorbar = create_colorbar(     width=width,     height=height,     palette=palette,     vertical=False,     add_labels=True,     font_size=20,     labels=labels, ) In\u00a0[\u00a0]: Copied! <pre>show_image(colorbar)\n</pre> show_image(colorbar) In\u00a0[\u00a0]: Copied! <pre>add_image_to_gif(\n    out_gif, out_gif, in_image=colorbar, xy=('69%', '89%'), image_size=(250, 250)\n)\n</pre> add_image_to_gif(     out_gif, out_gif, in_image=colorbar, xy=('69%', '89%'), image_size=(250, 250) ) In\u00a0[\u00a0]: Copied! <pre>show_image(out_gif)\n</pre> show_image(out_gif)"},{"location":"notebooks/17_add_colorbar_to_gif/#update-the-geemap-package","title":"Update the geemap package\u00b6","text":"<p>If you run into errors with this notebook, please uncomment the line below to update the geemap package to the latest version from GitHub.  Restart the Kernel (Menu -&gt; Kernel -&gt; Restart) to take effect.</p>"},{"location":"notebooks/17_add_colorbar_to_gif/#download-a-gif","title":"Download a GIF\u00b6","text":""},{"location":"notebooks/17_add_colorbar_to_gif/#get-image-urls","title":"Get image URLs\u00b6","text":""},{"location":"notebooks/17_add_colorbar_to_gif/#set-output-gif-path","title":"Set output GIF path\u00b6","text":""},{"location":"notebooks/17_add_colorbar_to_gif/#add-images-to-gif","title":"Add images to GIF\u00b6","text":""},{"location":"notebooks/17_add_colorbar_to_gif/#display-output-gif","title":"Display output GIF\u00b6","text":""},{"location":"notebooks/17_add_colorbar_to_gif/#create-a-colorbar","title":"Create a colorbar\u00b6","text":""},{"location":"notebooks/17_add_colorbar_to_gif/#add-colorbar-to-gif","title":"Add colorbar to GIF\u00b6","text":""},{"location":"notebooks/18_create_landsat_timelapse/","title":"18 create landsat timelapse","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('OwjSJnGWKJs')\n</pre> geemap.show_youtube('OwjSJnGWKJs') In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>import os\n\nout_dir = os.path.join(os.path.expanduser(\"~\"), 'Downloads')\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n</pre> import os  out_dir = os.path.join(os.path.expanduser(\"~\"), 'Downloads') if not os.path.exists(out_dir):     os.makedirs(out_dir) In\u00a0[\u00a0]: Copied! <pre>label = 'Urban Growth in Las Vegas'\nMap.add_landsat_ts_gif(\n    label=label,\n    start_year=1985,\n    bands=['Red', 'Green', 'Blue'],\n    font_color='white',\n    frames_per_second=10,\n    progress_bar_color='blue',\n)\n</pre> label = 'Urban Growth in Las Vegas' Map.add_landsat_ts_gif(     label=label,     start_year=1985,     bands=['Red', 'Green', 'Blue'],     font_color='white',     frames_per_second=10,     progress_bar_color='blue', ) In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map <p>You and define an roi or draw a rectangle on the map</p> In\u00a0[\u00a0]: Copied! <pre>roi = ee.Geometry.Polygon(\n    [\n        [\n            [-115.471773, 35.892718],\n            [-115.471773, 36.409454],\n            [-114.271283, 36.409454],\n            [-114.271283, 35.892718],\n            [-115.471773, 35.892718],\n        ]\n    ],\n    None,\n    False,\n)\n</pre> roi = ee.Geometry.Polygon(     [         [             [-115.471773, 35.892718],             [-115.471773, 36.409454],             [-114.271283, 36.409454],             [-114.271283, 35.892718],             [-115.471773, 35.892718],         ]     ],     None,     False, ) In\u00a0[\u00a0]: Copied! <pre># roi = Map.draw_last_feature\n</pre> # roi = Map.draw_last_feature In\u00a0[\u00a0]: Copied! <pre>collection = geemap.landsat_timeseries(\n    roi=roi, start_year=1985, end_year=2019, start_date='06-10', end_date='09-20'\n)\n</pre> collection = geemap.landsat_timeseries(     roi=roi, start_year=1985, end_year=2019, start_date='06-10', end_date='09-20' ) In\u00a0[\u00a0]: Copied! <pre>print(collection.size().getInfo())\n</pre> print(collection.size().getInfo()) In\u00a0[\u00a0]: Copied! <pre>first_image = collection.first()\n\nvis = {'bands': ['NIR', 'Red', 'Green'], 'min': 0, 'max': 4000, 'gamma': [1, 1, 1]}\n\nMap.addLayer(first_image, vis, 'First image')\n</pre> first_image = collection.first()  vis = {'bands': ['NIR', 'Red', 'Green'], 'min': 0, 'max': 4000, 'gamma': [1, 1, 1]}  Map.addLayer(first_image, vis, 'First image') In\u00a0[\u00a0]: Copied! <pre># Define arguments for animation function parameters.\nvideo_args = {\n    'dimensions': 768,\n    'region': roi,\n    'framesPerSecond': 10,\n    'bands': ['NIR', 'Red', 'Green'],\n    'min': 0,\n    'max': 4000,\n    'gamma': [1, 1, 1],\n}\n</pre> # Define arguments for animation function parameters. video_args = {     'dimensions': 768,     'region': roi,     'framesPerSecond': 10,     'bands': ['NIR', 'Red', 'Green'],     'min': 0,     'max': 4000,     'gamma': [1, 1, 1], } In\u00a0[\u00a0]: Copied! <pre>work_dir = os.path.join(os.path.expanduser(\"~\"), 'Downloads')\nif not os.path.exists(work_dir):\n    os.makedirs(work_dir)\nout_gif = os.path.join(work_dir, \"landsat_ts.gif\")\n</pre> work_dir = os.path.join(os.path.expanduser(\"~\"), 'Downloads') if not os.path.exists(work_dir):     os.makedirs(work_dir) out_gif = os.path.join(work_dir, \"landsat_ts.gif\") In\u00a0[\u00a0]: Copied! <pre>geemap.download_ee_video(collection, video_args, out_gif)\n</pre> geemap.download_ee_video(collection, video_args, out_gif) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>texted_gif = os.path.join(work_dir, \"landsat_ts_text.gif\")\ngeemap.add_text_to_gif(\n    out_gif,\n    texted_gif,\n    xy=('3%', '5%'),\n    text_sequence=1985,\n    font_size=30,\n    font_color='#ffffff',\n    add_progress_bar=False,\n)\n</pre> texted_gif = os.path.join(work_dir, \"landsat_ts_text.gif\") geemap.add_text_to_gif(     out_gif,     texted_gif,     xy=('3%', '5%'),     text_sequence=1985,     font_size=30,     font_color='#ffffff',     add_progress_bar=False, ) In\u00a0[\u00a0]: Copied! <pre>label = 'Urban Growth in Las Vegas'\ngeemap.add_text_to_gif(\n    texted_gif,\n    texted_gif,\n    xy=('2%', '88%'),\n    text_sequence=label,\n    font_size=30,\n    font_color='#ffffff',\n    progress_bar_color='cyan',\n)\n</pre> label = 'Urban Growth in Las Vegas' geemap.add_text_to_gif(     texted_gif,     texted_gif,     xy=('2%', '88%'),     text_sequence=label,     font_size=30,     font_color='#ffffff',     progress_bar_color='cyan', ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(texted_gif)\n</pre> geemap.show_image(texted_gif)"},{"location":"notebooks/18_create_landsat_timelapse/#update-the-geemap-package","title":"Update the geemap package\u00b6","text":"<p>If you run into errors with this notebook, please uncomment the line below to update the geemap package to the latest version from GitHub.  Restart the Kernel (Menu -&gt; Kernel -&gt; Restart) to take effect.</p>"},{"location":"notebooks/18_create_landsat_timelapse/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/18_create_landsat_timelapse/#use-the-drawing-tool-to-draw-a-rectangle-on-the-map","title":"Use the Drawing tool to draw a rectangle on the map\u00b6","text":""},{"location":"notebooks/18_create_landsat_timelapse/#generate-a-landsat-timelapse-animation","title":"Generate a Landsat timelapse animation\u00b6","text":""},{"location":"notebooks/18_create_landsat_timelapse/#create-landsat-timeseries","title":"Create Landsat timeseries\u00b6","text":""},{"location":"notebooks/18_create_landsat_timelapse/#download-imagecollection-as-a-gif","title":"Download ImageCollection as a GIF\u00b6","text":""},{"location":"notebooks/18_create_landsat_timelapse/#add-animated-text-to-gif","title":"Add animated text to GIF\u00b6","text":""},{"location":"notebooks/19_search_places_and_datasets/","title":"19 search places and datasets","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('lwtgzrHrXj8')\n</pre> geemap.show_youtube('lwtgzrHrXj8') In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map.search_locations\n</pre> Map.search_locations In\u00a0[\u00a0]: Copied! <pre>Map.search_loc_geom\n</pre> Map.search_loc_geom In\u00a0[\u00a0]: Copied! <pre>location = Map.search_loc_geom\n# print(location.getInfo())\n</pre> location = Map.search_loc_geom # print(location.getInfo())"},{"location":"notebooks/19_search_places_and_datasets/#update-the-geemap-package","title":"Update the geemap package\u00b6","text":"<p>If you run into errors with this notebook, please uncomment the line below to update the geemap package to the latest version from GitHub.  Restart the Kernel (Menu -&gt; Kernel -&gt; Restart) to take effect.</p>"},{"location":"notebooks/19_search_places_and_datasets/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/19_search_places_and_datasets/#convert-marker-to-eegeometry","title":"Convert marker to ee.Geometry\u00b6","text":""},{"location":"notebooks/20_timeseries_inspector/","title":"20 timeseries inspector","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('0CZ7Aj8hCyo')\n</pre> geemap.show_youtube('0CZ7Aj8hCyo') In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() In\u00a0[\u00a0]: Copied! <pre>naip_ts = geemap.naip_timeseries(start_year=2009, end_year=2018)\n</pre> naip_ts = geemap.naip_timeseries(start_year=2009, end_year=2018) <p>Create a list of layer names to be shown under the dropdown list.</p> In\u00a0[\u00a0]: Copied! <pre>layer_names = ['NAIP ' + str(year) for year in range(2009, 2019)]\nprint(layer_names)\n</pre> layer_names = ['NAIP ' + str(year) for year in range(2009, 2019)] print(layer_names) <p>Set visualization parameters.</p> In\u00a0[\u00a0]: Copied! <pre>naip_vis = {'bands': ['N', 'R', 'G']}\n</pre> naip_vis = {'bands': ['N', 'R', 'G']} <p>Create a split-panel map for visualizing NAIP imagery</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.ts_inspector(\n    left_ts=naip_ts,\n    right_ts=naip_ts,\n    left_names=layer_names,\n    right_names=layer_names,\n    left_vis=naip_vis,\n    right_vis=naip_vis,\n)\nMap\n</pre> Map = geemap.Map() Map.ts_inspector(     left_ts=naip_ts,     right_ts=naip_ts,     left_names=layer_names,     right_names=layer_names,     left_vis=naip_vis,     right_vis=naip_vis, ) Map In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>region = Map.draw_last_feature\n</pre> region = Map.draw_last_feature In\u00a0[\u00a0]: Copied! <pre>if region is not None:\n    roi = region.geometry()\nelse:\n    roi = ee.Geometry.Polygon(\n        [\n            [\n                [-115.897448, 35.640766],\n                [-115.897448, 36.603608],\n                [-113.784915, 36.603608],\n                [-113.784915, 35.640766],\n                [-115.897448, 35.640766],\n            ]\n        ],\n        None,\n        False,\n    )\n</pre> if region is not None:     roi = region.geometry() else:     roi = ee.Geometry.Polygon(         [             [                 [-115.897448, 35.640766],                 [-115.897448, 36.603608],                 [-113.784915, 36.603608],                 [-113.784915, 35.640766],                 [-115.897448, 35.640766],             ]         ],         None,         False,     ) In\u00a0[\u00a0]: Copied! <pre>print(roi.getInfo())\n</pre> print(roi.getInfo()) In\u00a0[\u00a0]: Copied! <pre>landsat_ts = geemap.landsat_timeseries(\n    roi=roi, start_year=1984, end_year=2019, start_date='01-01', end_date='12-31'\n)\n</pre> landsat_ts = geemap.landsat_timeseries(     roi=roi, start_year=1984, end_year=2019, start_date='01-01', end_date='12-31' ) In\u00a0[\u00a0]: Copied! <pre>layer_names = ['Landsat ' + str(year) for year in range(1984, 2020)]\nprint(layer_names)\n</pre> layer_names = ['Landsat ' + str(year) for year in range(1984, 2020)] print(layer_names) In\u00a0[\u00a0]: Copied! <pre>landsat_vis = {\n    'min': 0,\n    'max': 0.3,\n    'gamma': [1, 1, 1],\n    'bands': ['NIR', 'Red', 'Green'],\n}\n</pre> landsat_vis = {     'min': 0,     'max': 0.3,     'gamma': [1, 1, 1],     'bands': ['NIR', 'Red', 'Green'], } In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.ts_inspector(\n    left_ts=landsat_ts,\n    right_ts=landsat_ts,\n    left_names=layer_names,\n    right_names=layer_names,\n    left_vis=landsat_vis,\n    right_vis=landsat_vis,\n)\nMap.centerObject(roi, zoom=8)\nMap\n</pre> Map = geemap.Map() Map.ts_inspector(     left_ts=landsat_ts,     right_ts=landsat_ts,     left_names=layer_names,     right_names=layer_names,     left_vis=landsat_vis,     right_vis=landsat_vis, ) Map.centerObject(roi, zoom=8) Map In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>NLCD = ee.ImageCollection('USGS/NLCD')\n</pre> NLCD = ee.ImageCollection('USGS/NLCD') In\u00a0[\u00a0]: Copied! <pre>NLCD_layers = NLCD.aggregate_array('system:id').getInfo()\nprint(NLCD_layers)\n</pre> NLCD_layers = NLCD.aggregate_array('system:id').getInfo() print(NLCD_layers) In\u00a0[\u00a0]: Copied! <pre>NLCD2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover')\nNLCD2006 = ee.Image('USGS/NLCD/NLCD2006').select('landcover')\nNLCD2011 = ee.Image('USGS/NLCD/NLCD2011').select('landcover')\nNLCD2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\n</pre> NLCD2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover') NLCD2006 = ee.Image('USGS/NLCD/NLCD2006').select('landcover') NLCD2011 = ee.Image('USGS/NLCD/NLCD2011').select('landcover') NLCD2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover') In\u00a0[\u00a0]: Copied! <pre>NLCD = ee.ImageCollection([NLCD2001, NLCD2006, NLCD2011, NLCD2016])\n</pre> NLCD = ee.ImageCollection([NLCD2001, NLCD2006, NLCD2011, NLCD2016]) In\u00a0[\u00a0]: Copied! <pre>NLCD_layer_names = ['NLCD ' + str(year) for year in range(2001, 2017, 5)]\nprint(NLCD_layer_names)\n</pre> NLCD_layer_names = ['NLCD ' + str(year) for year in range(2001, 2017, 5)] print(NLCD_layer_names) In\u00a0[\u00a0]: Copied! <pre>roi = ee.Geometry.Polygon(\n    [\n        [\n            [-115.897448, 35.640766],\n            [-115.897448, 36.603608],\n            [-113.784915, 36.603608],\n            [-113.784915, 35.640766],\n            [-115.897448, 35.640766],\n        ]\n    ],\n    None,\n    False,\n)\n</pre> roi = ee.Geometry.Polygon(     [         [             [-115.897448, 35.640766],             [-115.897448, 36.603608],             [-113.784915, 36.603608],             [-113.784915, 35.640766],             [-115.897448, 35.640766],         ]     ],     None,     False, ) In\u00a0[\u00a0]: Copied! <pre>landsat_ts = geemap.landsat_timeseries(\n    roi=roi, start_year=2001, end_year=2016, start_date='01-01', end_date='12-31'\n)\n</pre> landsat_ts = geemap.landsat_timeseries(     roi=roi, start_year=2001, end_year=2016, start_date='01-01', end_date='12-31' ) In\u00a0[\u00a0]: Copied! <pre>landsat_layer_names = ['Landsat ' + str(year) for year in range(2001, 2017)]\n</pre> landsat_layer_names = ['Landsat ' + str(year) for year in range(2001, 2017)] In\u00a0[\u00a0]: Copied! <pre>landsat_vis = {\n    'min': 0,\n    'max': 0.3,\n    'gamma': [1, 1, 1],\n    'bands': ['NIR', 'Red', 'Green'],\n}\n\nnlcd_vis = {'bands': ['landcover']}\n</pre> landsat_vis = {     'min': 0,     'max': 0.3,     'gamma': [1, 1, 1],     'bands': ['NIR', 'Red', 'Green'], }  nlcd_vis = {'bands': ['landcover']} In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.ts_inspector(\n    left_ts=landsat_ts,\n    right_ts=NLCD,\n    left_names=landsat_layer_names,\n    right_names=NLCD_layer_names,\n    left_vis=landsat_vis,\n    right_vis=nlcd_vis,\n)\nMap.centerObject(roi, zoom=8)\nMap\n</pre> Map = geemap.Map() Map.ts_inspector(     left_ts=landsat_ts,     right_ts=NLCD,     left_names=landsat_layer_names,     right_names=NLCD_layer_names,     left_vis=landsat_vis,     right_vis=nlcd_vis, ) Map.centerObject(roi, zoom=8) Map"},{"location":"notebooks/20_timeseries_inspector/#update-the-geemap-package","title":"Update the geemap package\u00b6","text":"<p>If you run into errors with this notebook, please uncomment the line below to update the geemap package to the latest version from GitHub.  Restart the Kernel (Menu -&gt; Kernel -&gt; Restart) to take effect.</p>"},{"location":"notebooks/20_timeseries_inspector/#naip-national-agriculture-imagery-program","title":"NAIP: National Agriculture Imagery Program\u00b6","text":"<p>The National Agriculture Imagery Program (NAIP) acquires aerial imagery during the agricultural growing seasons in the continental U.S.</p> <p>NAIP projects are contracted each year based upon available funding and the FSA imagery acquisition cycle. Beginning in 2003, NAIP was acquired on a 5-year cycle. 2008 was a transition year, and a three-year cycle began in 2009.</p> <p>NAIP imagery is acquired at a one-meter ground sample distance (GSD) with a horizontal accuracy that matches within six meters of photo-identifiable ground control points, which are used during image inspection.</p> <p>Older images were collected using 3 bands (Red, Green, and Blue: RGB), but newer imagery is usually collected with an additional near-infrared band (RGBN).</p> <p>More information about NAIP imagery can be found on Earth Engine Data Catalog.</p>"},{"location":"notebooks/20_timeseries_inspector/#create-annual-composite-of-naip-imagery","title":"Create annual composite of NAIP imagery\u00b6","text":"<p>Select 4-band (RGBN) NAIP imagery.</p>"},{"location":"notebooks/20_timeseries_inspector/#create-annual-composite-of-landsat-imagery","title":"Create annual composite of Landsat imagery\u00b6","text":"<p>Use the drawing tools to create an ROI</p>"},{"location":"notebooks/20_timeseries_inspector/#compare-landsat-imagery-and-national-land-cover-database-nlcd","title":"Compare Landsat imagery and National Land Cover Database (NLCD)\u00b6","text":"<p>More information about NLCD can be found at the Earth Engine Data Catalog.</p>"},{"location":"notebooks/21_export_map_to_html_png/","title":"21 export map to html png","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('h0pz3S6Tvx0')\n</pre> geemap.show_youtube('h0pz3S6Tvx0') In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(toolbar_ctrl=True, layer_ctrl=True)\nMap\n</pre> Map = geemap.Map(toolbar_ctrl=True, layer_ctrl=True) Map In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\n</pre> # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\") In\u00a0[\u00a0]: Copied! <pre>import os\n</pre> import os In\u00a0[\u00a0]: Copied! <pre>download_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nif not os.path.exists(download_dir):\n    os.makedirs(download_dir)\nhtml_file = os.path.join(download_dir, 'my_map.html')\n</pre> download_dir = os.path.join(os.path.expanduser('~'), 'Downloads') if not os.path.exists(download_dir):     os.makedirs(download_dir) html_file = os.path.join(download_dir, 'my_map.html') In\u00a0[\u00a0]: Copied! <pre>Map.to_html(filename=html_file, title='My Map', width='100%', height='880px')\n</pre> Map.to_html(filename=html_file, title='My Map', width='100%', height='880px') In\u00a0[\u00a0]: Copied! <pre>png_file = os.path.join(download_dir, 'my_map.png')\n</pre> png_file = os.path.join(download_dir, 'my_map.png') In\u00a0[\u00a0]: Copied! <pre>Map.to_image(filename=png_file, monitor=1)\n</pre> Map.to_image(filename=png_file, monitor=1) In\u00a0[\u00a0]: Copied! <pre>jpg_file = os.path.join(download_dir, 'my_map.jpg')\n</pre> jpg_file = os.path.join(download_dir, 'my_map.jpg') In\u00a0[\u00a0]: Copied! <pre>Map.to_image(filename=jpg_file, monitor=1)\n</pre> Map.to_image(filename=jpg_file, monitor=1)"},{"location":"notebooks/21_export_map_to_html_png/#google-earth-engine-python-tutorials","title":"Google Earth Engine Python Tutorials\u00b6","text":"<ul> <li>GitHub: https://github.com/gee-community/geemap</li> <li>Notebook examples: https://github.com/gee-community/geemap/blob/master/examples/README.md#tutorials</li> <li>Video tutorials: https://www.youtube.com/playlist?list=PLAxJ4-o7ZoPccOFv1dCwvGI6TYnirRTg3</li> </ul> <p>Tutorial 21  - How to export Earth Engine maps as HTML and images</p>"},{"location":"notebooks/21_export_map_to_html_png/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/21_export_map_to_html_png/#video-tutorial-on-youtube","title":"Video tutorial on YouTube\u00b6","text":""},{"location":"notebooks/21_export_map_to_html_png/#update-the-geemap-package","title":"Update the geemap package\u00b6","text":"<p>If you run into errors with this notebook, please uncomment the line below to update the geemap package to the latest version from GitHub.  Restart the Kernel (Menu -&gt; Kernel -&gt; Restart) to take effect.</p>"},{"location":"notebooks/21_export_map_to_html_png/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/21_export_map_to_html_png/#exporting-maps-as-html","title":"Exporting maps as HTML\u00b6","text":"<p>You can either click the camera icon on toolbar to export maps or use the following script.</p>"},{"location":"notebooks/21_export_map_to_html_png/#exporting-maps-as-pngjpg","title":"Exporting maps as PNG/JPG\u00b6","text":"<p>Make sure you click the fullscreen button on the map to maximum the map.</p>"},{"location":"notebooks/22_import_scripts/","title":"22 import scripts","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>geemap.ee_search()\n</pre> geemap.ee_search()"},{"location":"notebooks/23_import_assets/","title":"23 import assets","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') if not os.path.exists(out_dir):     os.makedirs(out_dir) In\u00a0[\u00a0]: Copied! <pre>out_csv = os.path.join(out_dir, 'ee_api.csv')\ngeemap.ee_api_to_csv(out_csv)\n</pre> out_csv = os.path.join(out_dir, 'ee_api.csv') geemap.ee_api_to_csv(out_csv) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_search()\n</pre> geemap.ee_search()"},{"location":"notebooks/24_publish_maps/","title":"24 publish maps","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p>To follow this tutorial, you will need to sign up for an account with https://datapane.com, then install and authenticate the <code>datapane</code> Python package. More information can be found here.</p> <ul> <li><code>pip install datapane</code></li> <li><code>datapane login</code></li> <li><code>datapane ping</code></li> </ul> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\n</pre> import ee import geemap.foliumap as geemap In\u00a0[\u00a0]: Copied! <pre># Create a map centered at (lat, lon).\nMap = geemap.Map(center=[40, -100], zoom=4)\n\n# Use an elevation dataset and terrain functions to create\n# a custom visualization of topography.\n\n# Load a global elevation image.\nelev = ee.Image('USGS/GMTED2010')\n\n# Zoom to an area of interest.\nMap.setCenter(-121.069, 50.709, 6)\n\n# Add the elevation to the map.\nMap.addLayer(elev, {}, 'elev')\n\n# Use the terrain algorithms to compute a hillshade with 8-bit values.\nshade = ee.Terrain.hillshade(elev)\nMap.addLayer(shade, {}, 'hillshade', False)\n\n# Create a \"sea\" variable to be used for cartographic purposes\nsea = elev.lte(0)\nMap.addLayer(sea.mask(sea), {'palette': '000022'}, 'sea', False)\n\n# Create a custom elevation palette from hex strings.\nelevationPalette = ['006600', '002200', 'fff700', 'ab7634', 'c4d0ff', 'ffffff']\n# Use these visualization parameters, customized by location.\nvisParams = {'min': 1, 'max': 3000, 'palette': elevationPalette}\n\n# Create a mosaic of the sea and the elevation data\nvisualized = ee.ImageCollection(\n    [\n        # Mask the elevation to get only land\n        elev.mask(sea.Not()).visualize(**visParams),\n        # Use the sea mask directly to display sea.\n        sea.mask(sea).visualize(**{'palette': '000022'}),\n    ]\n).mosaic()\n\n# Note that the visualization image doesn't require visualization parameters.\nMap.addLayer(visualized, {}, 'elev palette', False)\n\n# Convert the visualized elevation to HSV, first converting to [0, 1] data.\nhsv = visualized.divide(255).rgbToHsv()\n# Select only the hue and saturation bands.\nhs = hsv.select(0, 1)\n# Convert the hillshade to [0, 1] data, as expected by the HSV algorithm.\nv = shade.divide(255)\n# Create a visualization image by converting back to RGB from HSV.\n# Note the cast to byte in order to export the image correctly.\nrgb = hs.addBands(v).hsvToRgb().multiply(255).byte()\nMap.addLayer(rgb, {}, 'styled')\n\nstates = ee.FeatureCollection('TIGER/2018/States')\nMap.addLayer(ee.Image().paint(states, 0, 2), {}, \"US States\")\n</pre> # Create a map centered at (lat, lon). Map = geemap.Map(center=[40, -100], zoom=4)  # Use an elevation dataset and terrain functions to create # a custom visualization of topography.  # Load a global elevation image. elev = ee.Image('USGS/GMTED2010')  # Zoom to an area of interest. Map.setCenter(-121.069, 50.709, 6)  # Add the elevation to the map. Map.addLayer(elev, {}, 'elev')  # Use the terrain algorithms to compute a hillshade with 8-bit values. shade = ee.Terrain.hillshade(elev) Map.addLayer(shade, {}, 'hillshade', False)  # Create a \"sea\" variable to be used for cartographic purposes sea = elev.lte(0) Map.addLayer(sea.mask(sea), {'palette': '000022'}, 'sea', False)  # Create a custom elevation palette from hex strings. elevationPalette = ['006600', '002200', 'fff700', 'ab7634', 'c4d0ff', 'ffffff'] # Use these visualization parameters, customized by location. visParams = {'min': 1, 'max': 3000, 'palette': elevationPalette}  # Create a mosaic of the sea and the elevation data visualized = ee.ImageCollection(     [         # Mask the elevation to get only land         elev.mask(sea.Not()).visualize(**visParams),         # Use the sea mask directly to display sea.         sea.mask(sea).visualize(**{'palette': '000022'}),     ] ).mosaic()  # Note that the visualization image doesn't require visualization parameters. Map.addLayer(visualized, {}, 'elev palette', False)  # Convert the visualized elevation to HSV, first converting to [0, 1] data. hsv = visualized.divide(255).rgbToHsv() # Select only the hue and saturation bands. hs = hsv.select(0, 1) # Convert the hillshade to [0, 1] data, as expected by the HSV algorithm. v = shade.divide(255) # Create a visualization image by converting back to RGB from HSV. # Note the cast to byte in order to export the image correctly. rgb = hs.addBands(v).hsvToRgb().multiply(255).byte() Map.addLayer(rgb, {}, 'styled')  states = ee.FeatureCollection('TIGER/2018/States') Map.addLayer(ee.Image().paint(states, 0, 2), {}, \"US States\") In\u00a0[\u00a0]: Copied! <pre># Display the map.\nMap\n</pre> # Display the map. Map In\u00a0[\u00a0]: Copied! <pre>Map.publish(\n    name='Terrain Visualization',\n    description='A folium map with Earth Engine data layers',\n)\n</pre> Map.publish(     name='Terrain Visualization',     description='A folium map with Earth Engine data layers', )"},{"location":"notebooks/25_load_rasters/","title":"25 load rasters","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p>To follow this tutorial, you need to install the [geemap] and xarray_leaflet Python packages. Use the following conda commands to create a conda env and install packages:</p> <ul> <li><code>conda create -n gee python</code></li> <li><code>conda activate gee</code></li> <li><code>conda install mamba -c conda-forge</code></li> <li><code>mamba install geemap xarray_leaflet -c conda-forge</code></li> </ul> <p>Import libraries</p> In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap\n</pre> import os import geemap <p>Specify input raster datasets</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\nlandsat = os.path.join(out_dir, 'landsat.tif')\ndem = os.path.join(out_dir, 'dem.tif')\n</pre> out_dir = os.path.expanduser('~/Downloads')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  landsat = os.path.join(out_dir, 'landsat.tif') dem = os.path.join(out_dir, 'dem.tif') <p>Download samples raster datasets</p> <p>More datasets can be downloaded from https://viewer.nationalmap.gov/basic/</p> In\u00a0[\u00a0]: Copied! <pre>if not os.path.exists(landsat):\n    landsat_url = 'https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing'\n    geemap.download_from_gdrive(landsat_url, 'landsat.tif', out_dir, unzip=False)\n</pre> if not os.path.exists(landsat):     landsat_url = 'https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing'     geemap.download_from_gdrive(landsat_url, 'landsat.tif', out_dir, unzip=False) In\u00a0[\u00a0]: Copied! <pre>if not os.path.exists(dem):\n    dem_url = 'https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing'\n    geemap.download_from_gdrive(dem_url, 'dem.tif', out_dir, unzip=False)\n</pre> if not os.path.exists(dem):     dem_url = 'https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing'     geemap.download_from_gdrive(dem_url, 'dem.tif', out_dir, unzip=False) <p>Create an interactive map</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() <p>Add local raster datasets to the map</p> <p>More colormap can be found at https://matplotlib.org/stable/tutorials/colors/colormaps.html</p> In\u00a0[\u00a0]: Copied! <pre>Map.add_raster(dem, colormap='terrain', layer_name='DEM')\n</pre> Map.add_raster(dem, colormap='terrain', layer_name='DEM') In\u00a0[\u00a0]: Copied! <pre>Map.add_raster(landsat, bands=[5, 4, 3], layer_name='Landsat')\n</pre> Map.add_raster(landsat, bands=[5, 4, 3], layer_name='Landsat') <p>Display the map</p> In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map"},{"location":"notebooks/26_heroku/","title":"26 heroku","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n</pre> Map = geemap.Map(center=(40, -100), zoom=4) In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(\n    landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7'\n)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap.addLayer(states, {}, \"US States\")\n\nMap\n</pre> # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(     landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7' ) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map.addLayer(states, {}, \"US States\")  Map In\u00a0[\u00a0]: Copied! <pre>print('Change layer opacity:')\ndem_layer = Map.layers[-2]\ndem_layer.interact(opacity=(0, 1, 0.1))\n</pre> print('Change layer opacity:') dem_layer = Map.layers[-2] dem_layer.interact(opacity=(0, 1, 0.1))"},{"location":"notebooks/26_heroku/#earth-engine-app","title":"Earth Engine App\u00b6","text":""},{"location":"notebooks/27_timelapse_app/","title":"27 timelapse app","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\nimport ipywidgets as widgets\n</pre> import os import ee import geemap import ipywidgets as widgets In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') if not os.path.exists(out_dir):     os.makedirs(out_dir) In\u00a0[\u00a0]: Copied! <pre>style = {'description_width': 'initial'}\ntitle = widgets.Text(\n    description='Title:', value='Landsat Timelapse', width=200, style=style\n)\n</pre> style = {'description_width': 'initial'} title = widgets.Text(     description='Title:', value='Landsat Timelapse', width=200, style=style ) In\u00a0[\u00a0]: Copied! <pre>bands = widgets.Dropdown(\n    description='Select RGB Combo:',\n    options=[\n        'Red/Green/Blue',\n        'NIR/Red/Green',\n        'SWIR2/SWIR1/NIR',\n        'NIR/SWIR1/Red',\n        'SWIR2/NIR/Red',\n        'SWIR2/SWIR1/Red',\n        'SWIR1/NIR/Blue',\n        'NIR/SWIR1/Blue',\n        'SWIR2/NIR/Green',\n        'SWIR1/NIR/Red',\n    ],\n    value='NIR/Red/Green',\n    style=style,\n)\n</pre> bands = widgets.Dropdown(     description='Select RGB Combo:',     options=[         'Red/Green/Blue',         'NIR/Red/Green',         'SWIR2/SWIR1/NIR',         'NIR/SWIR1/Red',         'SWIR2/NIR/Red',         'SWIR2/SWIR1/Red',         'SWIR1/NIR/Blue',         'NIR/SWIR1/Blue',         'SWIR2/NIR/Green',         'SWIR1/NIR/Red',     ],     value='NIR/Red/Green',     style=style, ) In\u00a0[\u00a0]: Copied! <pre>hbox1 = widgets.HBox([title, bands])\nhbox1\n</pre> hbox1 = widgets.HBox([title, bands]) hbox1 In\u00a0[\u00a0]: Copied! <pre>start_year = widgets.IntSlider(\n    description='Start Year:', value=1984, min=1984, max=2021, style=style\n)\n</pre> start_year = widgets.IntSlider(     description='Start Year:', value=1984, min=1984, max=2021, style=style ) In\u00a0[\u00a0]: Copied! <pre>end_year = widgets.IntSlider(\n    description='End Year:', value=2021, min=1984, max=2021, style=style\n)\n</pre> end_year = widgets.IntSlider(     description='End Year:', value=2021, min=1984, max=2021, style=style ) In\u00a0[\u00a0]: Copied! <pre>hbox2 = widgets.HBox([start_year, end_year])\nhbox2\n</pre> hbox2 = widgets.HBox([start_year, end_year]) hbox2 In\u00a0[\u00a0]: Copied! <pre>speed = widgets.IntSlider(\n    description='Frames per second:',\n    tooltip='Frames per second:',\n    value=10,\n    min=1,\n    max=30,\n    style=style,\n)\n</pre> speed = widgets.IntSlider(     description='Frames per second:',     tooltip='Frames per second:',     value=10,     min=1,     max=30,     style=style, ) In\u00a0[\u00a0]: Copied! <pre>download = widgets.Checkbox(value=False, description='Download the GIF', style=style)\n</pre> download = widgets.Checkbox(value=False, description='Download the GIF', style=style) In\u00a0[\u00a0]: Copied! <pre>hbox3 = widgets.HBox([speed, download])\nhbox3\n</pre> hbox3 = widgets.HBox([speed, download]) hbox3 In\u00a0[\u00a0]: Copied! <pre>font_size = widgets.IntSlider(\n    description='Font size:', value=30, min=10, max=50, style=style\n)\n</pre> font_size = widgets.IntSlider(     description='Font size:', value=30, min=10, max=50, style=style ) In\u00a0[\u00a0]: Copied! <pre>font_color = widgets.ColorPicker(\n    concise=False, description='Font color:', value='white', style=style\n)\n</pre> font_color = widgets.ColorPicker(     concise=False, description='Font color:', value='white', style=style ) In\u00a0[\u00a0]: Copied! <pre>progress_bar_color = widgets.ColorPicker(\n    concise=False, description='Progress bar color:', value='blue', style=style\n)\n</pre> progress_bar_color = widgets.ColorPicker(     concise=False, description='Progress bar color:', value='blue', style=style ) In\u00a0[\u00a0]: Copied! <pre>hbox4 = widgets.HBox([font_size, font_color, progress_bar_color])\nhbox4\n</pre> hbox4 = widgets.HBox([font_size, font_color, progress_bar_color]) hbox4 In\u00a0[\u00a0]: Copied! <pre>submit = widgets.Button(\n    description='Submit',\n    button_style='primary',\n    tooltip='Click the submit the request to create timelapse',\n    style=style,\n)\n\noutput = widgets.Output()\n</pre> submit = widgets.Button(     description='Submit',     button_style='primary',     tooltip='Click the submit the request to create timelapse',     style=style, )  output = widgets.Output() In\u00a0[\u00a0]: Copied! <pre>def submit_clicked(b):\n    with output:\n        output.clear_output()\n        if start_year.value &gt;= end_year.value:\n            print('The end year must be great than the start year.')\n            return\n        print('Computing...')\n\n        Map.add_landsat_ts_gif(\n            roi=Map.user_roi,\n            label=title.value,\n            start_year=start_year.value,\n            end_year=end_year.value,\n            start_date='05-01',\n            end_date='10-31',\n            bands=bands.value.split('/'),\n            font_color=font_color.value,\n            frames_per_second=speed.value,\n            font_size=font_size.value,\n            progress_bar_color=progress_bar_color.value,\n            download=download.value,\n        )\n\n\nsubmit.on_click(submit_clicked)\n</pre> def submit_clicked(b):     with output:         output.clear_output()         if start_year.value &gt;= end_year.value:             print('The end year must be great than the start year.')             return         print('Computing...')          Map.add_landsat_ts_gif(             roi=Map.user_roi,             label=title.value,             start_year=start_year.value,             end_year=end_year.value,             start_date='05-01',             end_date='10-31',             bands=bands.value.split('/'),             font_color=font_color.value,             frames_per_second=speed.value,             font_size=font_size.value,             progress_bar_color=progress_bar_color.value,             download=download.value,         )   submit.on_click(submit_clicked) In\u00a0[\u00a0]: Copied! <pre>submit\n</pre> submit In\u00a0[\u00a0]: Copied! <pre>output\n</pre> output"},{"location":"notebooks/27_timelapse_app/#creating-landsat-timelapse","title":"Creating Landsat Timelapse\u00b6","text":"<p>Steps to create a Landsat timelapse:</p> <ol> <li>Pan and zoom to your region of interest.</li> <li>Use the drawing tool to draw a rectangle anywhere on the map.</li> <li>Adjust the parameters (e.g., start year, end year, title) if needed.</li> <li>Check <code>Download the GIF</code> if you would like to download the timelapse GIF.</li> <li>Click the Submit button to create a timelapse.</li> <li>Deploy the app to heroku. See https://github.com/giswqs/earthengine-apps</li> </ol>"},{"location":"notebooks/28_voila/","title":"28 voila","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\nimport ipywidgets as widgets\n</pre> import os import ee import geemap import ipywidgets as widgets In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map In\u00a0[\u00a0]: Copied! <pre>style = {'description_width': 'initial'}\ntitle = widgets.Text(\n    description='Title:', value='Landsat Timelapse', width=200, style=style\n)\n\nbands = widgets.Dropdown(\n    description='Select RGB Combo:',\n    options=[\n        'Red/Green/Blue',\n        'NIR/Red/Green',\n        'SWIR2/SWIR1/NIR',\n        'NIR/SWIR1/Red',\n        'SWIR2/NIR/Red',\n        'SWIR2/SWIR1/Red',\n        'SWIR1/NIR/Blue',\n        'NIR/SWIR1/Blue',\n        'SWIR2/NIR/Green',\n        'SWIR1/NIR/Red',\n    ],\n    value='NIR/Red/Green',\n    style=style,\n)\n\nhbox1 = widgets.HBox([title, bands])\nhbox1\n</pre> style = {'description_width': 'initial'} title = widgets.Text(     description='Title:', value='Landsat Timelapse', width=200, style=style )  bands = widgets.Dropdown(     description='Select RGB Combo:',     options=[         'Red/Green/Blue',         'NIR/Red/Green',         'SWIR2/SWIR1/NIR',         'NIR/SWIR1/Red',         'SWIR2/NIR/Red',         'SWIR2/SWIR1/Red',         'SWIR1/NIR/Blue',         'NIR/SWIR1/Blue',         'SWIR2/NIR/Green',         'SWIR1/NIR/Red',     ],     value='NIR/Red/Green',     style=style, )  hbox1 = widgets.HBox([title, bands]) hbox1 In\u00a0[\u00a0]: Copied! <pre>speed = widgets.IntSlider(\n    description='  Frames per second:',\n    tooltip='Frames per second:',\n    value=10,\n    min=1,\n    max=30,\n    style=style,\n)\n\ncloud = widgets.Checkbox(\n    value=True, description='Apply fmask (remove clouds, shadows, snow)', style=style\n)\n\nhbox2 = widgets.HBox([speed, cloud])\nhbox2\n</pre> speed = widgets.IntSlider(     description='  Frames per second:',     tooltip='Frames per second:',     value=10,     min=1,     max=30,     style=style, )  cloud = widgets.Checkbox(     value=True, description='Apply fmask (remove clouds, shadows, snow)', style=style )  hbox2 = widgets.HBox([speed, cloud]) hbox2 In\u00a0[\u00a0]: Copied! <pre>start_year = widgets.IntSlider(\n    description='Start Year:', value=1984, min=1984, max=2020, style=style\n)\nend_year = widgets.IntSlider(\n    description='End Year:', value=2020, min=1984, max=2020, style=style\n)\nstart_month = widgets.IntSlider(\n    description='Start Month:', value=5, min=1, max=12, style=style\n)\nend_month = widgets.IntSlider(\n    description='End Month:', value=10, min=1, max=12, style=style\n)\nhbox3 = widgets.HBox([start_year, end_year, start_month, end_month])\nhbox3\n</pre> start_year = widgets.IntSlider(     description='Start Year:', value=1984, min=1984, max=2020, style=style ) end_year = widgets.IntSlider(     description='End Year:', value=2020, min=1984, max=2020, style=style ) start_month = widgets.IntSlider(     description='Start Month:', value=5, min=1, max=12, style=style ) end_month = widgets.IntSlider(     description='End Month:', value=10, min=1, max=12, style=style ) hbox3 = widgets.HBox([start_year, end_year, start_month, end_month]) hbox3 In\u00a0[\u00a0]: Copied! <pre>font_size = widgets.IntSlider(\n    description='Font size:', value=30, min=10, max=50, style=style\n)\n\nfont_color = widgets.ColorPicker(\n    concise=False, description='Font color:', value='white', style=style\n)\n\nprogress_bar_color = widgets.ColorPicker(\n    concise=False, description='Progress bar color:', value='blue', style=style\n)\n\nhbox4 = widgets.HBox([font_size, font_color, progress_bar_color])\nhbox4\n</pre> font_size = widgets.IntSlider(     description='Font size:', value=30, min=10, max=50, style=style )  font_color = widgets.ColorPicker(     concise=False, description='Font color:', value='white', style=style )  progress_bar_color = widgets.ColorPicker(     concise=False, description='Progress bar color:', value='blue', style=style )  hbox4 = widgets.HBox([font_size, font_color, progress_bar_color]) hbox4 In\u00a0[\u00a0]: Copied! <pre>create_gif = widgets.Button(\n    description='Create timelapse',\n    button_style='primary',\n    tooltip='Click to create timelapse',\n    style=style,\n)\n\ndownload_gif = widgets.Button(\n    description='Download GIF',\n    button_style='primary',\n    tooltip='Click to download timelapse',\n    disabled=False,\n    style=style,\n)\n\noutput = widgets.Output()\n\nhbox5 = widgets.HBox([create_gif])\nhbox5\n</pre> create_gif = widgets.Button(     description='Create timelapse',     button_style='primary',     tooltip='Click to create timelapse',     style=style, )  download_gif = widgets.Button(     description='Download GIF',     button_style='primary',     tooltip='Click to download timelapse',     disabled=False,     style=style, )  output = widgets.Output()  hbox5 = widgets.HBox([create_gif]) hbox5 In\u00a0[\u00a0]: Copied! <pre>def submit_clicked(b):\n    with output:\n        output.clear_output()\n        if start_year.value &gt; end_year.value:\n            print('The end year must be great than the start year.')\n            return\n        if start_month.value &gt; end_month.value:\n            print('The end month must be great than the start month.')\n            return\n        if start_year.value == end_year.value:\n            add_progress_bar = False\n        else:\n            add_progress_bar = True\n\n        start_date = str(start_month.value).zfill(2) + '-01'\n        end_date = str(end_month.value).zfill(2) + '-30'\n\n        print('Computing...')\n\n        Map.add_landsat_ts_gif(\n            roi=Map.user_roi,\n            label=title.value,\n            start_year=start_year.value,\n            end_year=end_year.value,\n            start_date=start_date,\n            end_date=end_date,\n            bands=bands.value.split('/'),\n            font_color=font_color.value,\n            frames_per_second=speed.value,\n            font_size=font_size.value,\n            add_progress_bar=add_progress_bar,\n            progress_bar_color=progress_bar_color.value,\n            download=True,\n            apply_fmask=cloud.value,\n        )\n\n\ncreate_gif.on_click(submit_clicked)\n</pre> def submit_clicked(b):     with output:         output.clear_output()         if start_year.value &gt; end_year.value:             print('The end year must be great than the start year.')             return         if start_month.value &gt; end_month.value:             print('The end month must be great than the start month.')             return         if start_year.value == end_year.value:             add_progress_bar = False         else:             add_progress_bar = True          start_date = str(start_month.value).zfill(2) + '-01'         end_date = str(end_month.value).zfill(2) + '-30'          print('Computing...')          Map.add_landsat_ts_gif(             roi=Map.user_roi,             label=title.value,             start_year=start_year.value,             end_year=end_year.value,             start_date=start_date,             end_date=end_date,             bands=bands.value.split('/'),             font_color=font_color.value,             frames_per_second=speed.value,             font_size=font_size.value,             add_progress_bar=add_progress_bar,             progress_bar_color=progress_bar_color.value,             download=True,             apply_fmask=cloud.value,         )   create_gif.on_click(submit_clicked) In\u00a0[\u00a0]: Copied! <pre>output\n</pre> output"},{"location":"notebooks/28_voila/#deploy-earth-engine-apps-using-voila-and-ngrok","title":"Deploy Earth Engine Apps using Voila and ngrok\u00b6","text":"<p>Steps to deploy an Earth Engine App:</p> <ol> <li>Install ngrok by following the instruction</li> <li>Install voila by following the instruction</li> <li>Download the notebook 28_voila.ipynb</li> <li>Run this from the command line: <code>voila --no-browser 28_voila.ipynb</code></li> <li>Run this from the command line: <code>ngrok http 8866</code></li> <li>Copy the link from the ngrok terminal window. The links looks like the following: https://randomstring.ngrok.io</li> <li>Share the link with anyone.</li> </ol> <p>Optional steps:</p> <ul> <li>To show code cells from you app, run this from the command line: <code>voila --no-browser --strip_sources=False 28_voila.ipynb</code></li> <li>To protect your app with a password, run this: <code>ngrok http -auth=\"username:password\" 8866</code></li> <li>To run python simple http server in the directory, run this:<code>sudo python -m http.server 80</code></li> </ul>"},{"location":"notebooks/29_pydeck/","title":"29 pydeck","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>from pydeck_earthengine_layers import EarthEngineLayer\nimport pydeck as pdk\nimport ee\n\n# Initialize Earth Engine library\ntry:\n    ee.Initialize()\nexcept Exception as e:\n    ee.Authenticate()\n    ee.Initialize()\n\n# Create an Earth Engine object\nimage = ee.Image('CGIAR/SRTM90_V4')\n\n# Define Earth Engine visualization parameters\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Create a pydeck EarthEngineLayer object, using the Earth Engine object and\n# desired visualization parameters\nee_layer = EarthEngineLayer(image, vis_params)\n\n# Define the initial viewport for the map\nview_state = pdk.ViewState(\n    latitude=37.7749295, longitude=-122.4194155, zoom=10, bearing=0, pitch=45\n)\n\n# Create a Deck instance, and display in Jupyter\nr = pdk.Deck(layers=[ee_layer], initial_view_state=view_state)\nr.show()\n</pre> from pydeck_earthengine_layers import EarthEngineLayer import pydeck as pdk import ee  # Initialize Earth Engine library try:     ee.Initialize() except Exception as e:     ee.Authenticate()     ee.Initialize()  # Create an Earth Engine object image = ee.Image('CGIAR/SRTM90_V4')  # Define Earth Engine visualization parameters vis_params = {     \"min\": 0,     \"max\": 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Create a pydeck EarthEngineLayer object, using the Earth Engine object and # desired visualization parameters ee_layer = EarthEngineLayer(image, vis_params)  # Define the initial viewport for the map view_state = pdk.ViewState(     latitude=37.7749295, longitude=-122.4194155, zoom=10, bearing=0, pitch=45 )  # Create a Deck instance, and display in Jupyter r = pdk.Deck(layers=[ee_layer], initial_view_state=view_state) r.show() <p>Adding multiple Earth Engine images</p> In\u00a0[\u00a0]: Copied! <pre>from pydeck_earthengine_layers import EarthEngineLayer\nimport pydeck as pdk\nimport ee\n\n# Initialize Earth Engine library\ntry:\n    ee.Initialize()\nexcept Exception as e:\n    ee.Authenticate()\n    ee.Initialize()\n\n# Add Earth Engine dataset\nimage = ee.Image('USGS/SRTMGL1_003')\n\nhillshade = ee.Terrain.hillshade(image)\n\ndemRGB = image.visualize(\n    **{\n        'min': 0,\n        'max': 4000,\n        'bands': ['elevation'],\n        'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n        'opacity': 0.5,\n    }\n)\n\nhillshadeRGB = hillshade.visualize(**{'bands': ['hillshade']})\n\nblend = hillshadeRGB.blend(demRGB)\n\nee_layer = EarthEngineLayer(blend, {})\n\n# Define the initial viewport for the map\nview_state = pdk.ViewState(\n    latitude=37.7749295, longitude=-122.4194155, zoom=10, bearing=0, pitch=45\n)\n\n# Create a Deck instance, and display in Jupyter\nr = pdk.Deck(layers=[ee_layer], initial_view_state=view_state)\nr.show()\n</pre> from pydeck_earthengine_layers import EarthEngineLayer import pydeck as pdk import ee  # Initialize Earth Engine library try:     ee.Initialize() except Exception as e:     ee.Authenticate()     ee.Initialize()  # Add Earth Engine dataset image = ee.Image('USGS/SRTMGL1_003')  hillshade = ee.Terrain.hillshade(image)  demRGB = image.visualize(     **{         'min': 0,         'max': 4000,         'bands': ['elevation'],         'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],         'opacity': 0.5,     } )  hillshadeRGB = hillshade.visualize(**{'bands': ['hillshade']})  blend = hillshadeRGB.blend(demRGB)  ee_layer = EarthEngineLayer(blend, {})  # Define the initial viewport for the map view_state = pdk.ViewState(     latitude=37.7749295, longitude=-122.4194155, zoom=10, bearing=0, pitch=45 )  # Create a Deck instance, and display in Jupyter r = pdk.Deck(layers=[ee_layer], initial_view_state=view_state) r.show() In\u00a0[\u00a0]: Copied! <pre>from pydeck_earthengine_layers import EarthEngineLayer\nimport pydeck as pdk\nimport ee\n\n# Initialize Earth Engine library\ntry:\n    ee.Initialize()\nexcept Exception as e:\n    ee.Authenticate()\n    ee.Initialize()\n\n# Initialize an ee.ImageColllection object referencing the Global Forecast System dataset\nimage_collection = ee.ImageCollection('NOAA/GFS0P25')\n\n# Select images from December 22, 2018\nimage_collection = image_collection.filterDate('2018-12-22', '2018-12-23')\n\n# Choose the first 24 images in the ImageCollection\nimage_collection = image_collection.limit(24)\n\n# Select a single band to visualize\nimage_collection = image_collection.select('temperature_2m_above_ground')\n\n# Style temperature values between -40C and 35C,\n# with lower values shades of blue, purple, and cyan,\n# and higher values shades of green, yellow, and red\nvis_params = {\n    'min': -40.0,\n    'max': 35.0,\n    'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'],\n}\n\nlayer = EarthEngineLayer(\n    image_collection, vis_params, animate=True, id=\"global_weather\"\n)\n\nview_state = pdk.ViewState(latitude=36, longitude=10, zoom=1)\nr = pdk.Deck(layers=[layer], initial_view_state=view_state)\n\n# layer.visible = True\n# layer.opacity = 0.2\n\nr.show()\n</pre> from pydeck_earthengine_layers import EarthEngineLayer import pydeck as pdk import ee  # Initialize Earth Engine library try:     ee.Initialize() except Exception as e:     ee.Authenticate()     ee.Initialize()  # Initialize an ee.ImageColllection object referencing the Global Forecast System dataset image_collection = ee.ImageCollection('NOAA/GFS0P25')  # Select images from December 22, 2018 image_collection = image_collection.filterDate('2018-12-22', '2018-12-23')  # Choose the first 24 images in the ImageCollection image_collection = image_collection.limit(24)  # Select a single band to visualize image_collection = image_collection.select('temperature_2m_above_ground')  # Style temperature values between -40C and 35C, # with lower values shades of blue, purple, and cyan, # and higher values shades of green, yellow, and red vis_params = {     'min': -40.0,     'max': 35.0,     'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'], }  layer = EarthEngineLayer(     image_collection, vis_params, animate=True, id=\"global_weather\" )  view_state = pdk.ViewState(latitude=36, longitude=10, zoom=1) r = pdk.Deck(layers=[layer], initial_view_state=view_state)  # layer.visible = True # layer.opacity = 0.2  r.show() In\u00a0[\u00a0]: Copied! <pre>from pydeck_earthengine_layers import EarthEngineLayer\nimport pydeck as pdk\nimport ee\n\ntry:\n    ee.Initialize()\nexcept Exception as e:\n    ee.Authenticate()\n    ee.Initialize()\n\n# Load the FeatureCollection\ntable = ee.FeatureCollection(\"WRI/GPPD/power_plants\")\n\n# Create color palette\nfuel_color = ee.Dictionary(\n    {\n        'Coal': '000000',\n        'Oil': '593704',\n        'Gas': 'BC80BD',\n        'Hydro': '0565A6',\n        'Nuclear': 'E31A1C',\n        'Solar': 'FF7F00',\n        'Waste': '6A3D9A',\n        'Wind': '5CA2D1',\n        'Geothermal': 'FDBF6F',\n        'Biomass': '229A00',\n    }\n)\n\n# List of fuels to add to the map\nfuels = [\n    'Coal',\n    'Oil',\n    'Gas',\n    'Hydro',\n    'Nuclear',\n    'Solar',\n    'Waste',\n    'Wind',\n    'Geothermal',\n    'Biomass',\n]\n\n\ndef add_style(point):\n\"\"\"Computes size from capacity and color from fuel type.\n\n    Args:\n        - point: (ee.Geometry.Point) A Point\n\n    Returns:\n        (ee.Geometry.Point): Input point with added style dictionary\n    \"\"\"\n    size = ee.Number(point.get('capacitymw')).sqrt().divide(10).add(2)\n    color = fuel_color.get(point.get('fuel1'))\n    return point.set(\n        'styleProperty', ee.Dictionary({'pointSize': size, 'color': color})\n    )\n\n\n# Make a FeatureCollection out of the power plant data table\npp = ee.FeatureCollection(table).map(add_style)\n\n# Create a layer for each fuel type\nlayers = []\nfor fuel in fuels:\n    layer = EarthEngineLayer(\n        pp.filter(ee.Filter.eq('fuel1', fuel)).style(\n            styleProperty='styleProperty', neighborhood=50\n        ),\n        id=fuel,\n        opacity=0.65,\n    )\n    layers.append(layer)\n\nview_state = pdk.ViewState(latitude=36, longitude=-53, zoom=3)\n\nr = pdk.Deck(layers=layers, initial_view_state=view_state)\nr.show()\n</pre> from pydeck_earthengine_layers import EarthEngineLayer import pydeck as pdk import ee  try:     ee.Initialize() except Exception as e:     ee.Authenticate()     ee.Initialize()  # Load the FeatureCollection table = ee.FeatureCollection(\"WRI/GPPD/power_plants\")  # Create color palette fuel_color = ee.Dictionary(     {         'Coal': '000000',         'Oil': '593704',         'Gas': 'BC80BD',         'Hydro': '0565A6',         'Nuclear': 'E31A1C',         'Solar': 'FF7F00',         'Waste': '6A3D9A',         'Wind': '5CA2D1',         'Geothermal': 'FDBF6F',         'Biomass': '229A00',     } )  # List of fuels to add to the map fuels = [     'Coal',     'Oil',     'Gas',     'Hydro',     'Nuclear',     'Solar',     'Waste',     'Wind',     'Geothermal',     'Biomass', ]   def add_style(point):     \"\"\"Computes size from capacity and color from fuel type.      Args:         - point: (ee.Geometry.Point) A Point      Returns:         (ee.Geometry.Point): Input point with added style dictionary     \"\"\"     size = ee.Number(point.get('capacitymw')).sqrt().divide(10).add(2)     color = fuel_color.get(point.get('fuel1'))     return point.set(         'styleProperty', ee.Dictionary({'pointSize': size, 'color': color})     )   # Make a FeatureCollection out of the power plant data table pp = ee.FeatureCollection(table).map(add_style)  # Create a layer for each fuel type layers = [] for fuel in fuels:     layer = EarthEngineLayer(         pp.filter(ee.Filter.eq('fuel1', fuel)).style(             styleProperty='styleProperty', neighborhood=50         ),         id=fuel,         opacity=0.65,     )     layers.append(layer)  view_state = pdk.ViewState(latitude=36, longitude=-53, zoom=3)  r = pdk.Deck(layers=layers, initial_view_state=view_state) r.show() In\u00a0[\u00a0]: Copied! <pre>from pydeck_earthengine_layers import EarthEngineLayer\nimport pydeck as pdk\nimport ee\n\ntry:\n    ee.Initialize()\nexcept Exception as e:\n    ee.Authenticate()\n    ee.Initialize()\n\n# Hurricane tracks and points for 2017.\nhurricanes = ee.FeatureCollection('NOAA/NHC/HURDAT2/atlantic')\n\nyear = '2017'\npoints = hurricanes.filter(ee.Filter.date(ee.Date(year).getRange('year')))\n\n\n# Find all of the hurricane ids.\ndef get_id(point):\n    return ee.Feature(point).get('id')\n\n\nstorm_ids = points.toList(1000).map(get_id).distinct()\n\n\n# Create a line for each hurricane.\ndef create_line(storm_id):\n    pts = points.filter(ee.Filter.eq('id', ee.String(storm_id)))\n    pts = pts.sort('system:time_start')\n    line = ee.Geometry.LineString(pts.geometry().coordinates())\n    feature = ee.Feature(line)\n    return feature.set('id', storm_id)\n\n\nlines = ee.FeatureCollection(storm_ids.map(create_line))\n\n\nlines_layer = EarthEngineLayer(\n    lines,\n    {'color': 'red'},\n    id=\"tracks\",\n)\n\npoints_layer = EarthEngineLayer(\n    points,\n    {'color': 'green'},\n    id=\"points\",\n)\n\n\nview_state = pdk.ViewState(latitude=36, longitude=-53, zoom=3)\nr = pdk.Deck(layers=[points_layer, lines_layer], initial_view_state=view_state)\nr.show()\n</pre> from pydeck_earthengine_layers import EarthEngineLayer import pydeck as pdk import ee  try:     ee.Initialize() except Exception as e:     ee.Authenticate()     ee.Initialize()  # Hurricane tracks and points for 2017. hurricanes = ee.FeatureCollection('NOAA/NHC/HURDAT2/atlantic')  year = '2017' points = hurricanes.filter(ee.Filter.date(ee.Date(year).getRange('year')))   # Find all of the hurricane ids. def get_id(point):     return ee.Feature(point).get('id')   storm_ids = points.toList(1000).map(get_id).distinct()   # Create a line for each hurricane. def create_line(storm_id):     pts = points.filter(ee.Filter.eq('id', ee.String(storm_id)))     pts = pts.sort('system:time_start')     line = ee.Geometry.LineString(pts.geometry().coordinates())     feature = ee.Feature(line)     return feature.set('id', storm_id)   lines = ee.FeatureCollection(storm_ids.map(create_line))   lines_layer = EarthEngineLayer(     lines,     {'color': 'red'},     id=\"tracks\", )  points_layer = EarthEngineLayer(     points,     {'color': 'green'},     id=\"points\", )   view_state = pdk.ViewState(latitude=36, longitude=-53, zoom=3) r = pdk.Deck(layers=[points_layer, lines_layer], initial_view_state=view_state) r.show() In\u00a0[\u00a0]: Copied! <pre>from pydeck_earthengine_layers import EarthEngineLayer\nimport pydeck as pdk\nimport ee\n\ntry:\n    ee.Initialize()\nexcept Exception as e:\n    ee.Authenticate()\n    ee.Initialize()\n\ndataset = ee.FeatureCollection('FAO/GAUL/2015/level0')\n\ncountries = dataset.style(fillColor='b5ffb4', color='00909F', width=3)\n\nlayer = EarthEngineLayer(countries, id=\"international_boundaries\")\nview_state = pdk.ViewState(latitude=36, longitude=10, zoom=3)\nr = pdk.Deck(layers=[layer], initial_view_state=view_state)\nr.show()\n</pre> from pydeck_earthengine_layers import EarthEngineLayer import pydeck as pdk import ee  try:     ee.Initialize() except Exception as e:     ee.Authenticate()     ee.Initialize()  dataset = ee.FeatureCollection('FAO/GAUL/2015/level0')  countries = dataset.style(fillColor='b5ffb4', color='00909F', width=3)  layer = EarthEngineLayer(countries, id=\"international_boundaries\") view_state = pdk.ViewState(latitude=36, longitude=10, zoom=3) r = pdk.Deck(layers=[layer], initial_view_state=view_state) r.show()"},{"location":"notebooks/29_pydeck/#how-to-use-earth-engine-with-pydeck-for-3d-visualization","title":"How to use Earth Engine with pydeck for 3D visualization\u00b6","text":""},{"location":"notebooks/29_pydeck/#requirements","title":"Requirements\u00b6","text":"<ul> <li>earthengine-api: a Python client library for calling the Google Earth Engine API.</li> <li>pydeck: a WebGL-powered framework for visual exploratory data analysis of large datasets.</li> <li>pydeck-earthengine-layers: a pydeck wrapper for Google Earth Engine. For documentation please visit this website.</li> <li>Mapbox API key: you will need this add basemap tiles to pydeck.</li> </ul>"},{"location":"notebooks/29_pydeck/#installation","title":"Installation\u00b6","text":"<ul> <li>conda create -n deck python</li> <li>conda activate deck</li> <li>conda install mamba -c conda-forge</li> <li>mamba install earthengine-api pydeck pydeck-earthengine-layers -c conda-forge</li> <li>jupyter nbextension install --sys-prefix --symlink --overwrite --py pydeck</li> <li>jupyter nbextension enable --sys-prefix --py pydeck</li> </ul>"},{"location":"notebooks/29_pydeck/#using-eeimage-with-pydeck","title":"Using ee.Image with pydeck\u00b6","text":""},{"location":"notebooks/29_pydeck/#using-eeimagecollection-with-pydeck","title":"Using ee.ImageCollection with pydeck\u00b6","text":""},{"location":"notebooks/29_pydeck/#using-eefeaturecollection-points-with-pydeck","title":"Using ee.FeatureCollection (points) with pydeck\u00b6","text":""},{"location":"notebooks/29_pydeck/#using-eefeaturecollection-lines-with-pydeck","title":"Using ee.FeatureCollection (lines) with pydeck\u00b6","text":""},{"location":"notebooks/30_image_props_stats/","title":"30 image props stats","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>centroid = ee.Geometry.Point([-122.4439, 37.7538])\n\nlandsat = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n\nlandsat_vis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(centroid, 8)\nMap.addLayer(landsat, landsat_vis, \"Landsat-8\")\n</pre> centroid = ee.Geometry.Point([-122.4439, 37.7538])  landsat = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()  landsat_vis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(centroid, 8) Map.addLayer(landsat, landsat_vis, \"Landsat-8\") In\u00a0[\u00a0]: Copied! <pre>naip = ee.ImageCollection('USDA/NAIP/DOQQ').filterBounds(centroid).first()\n\nnaip_vis = {'bands': ['N', 'R', 'G']}\n\nMap.addLayer(naip, naip_vis, 'NAIP')\n</pre> naip = ee.ImageCollection('USDA/NAIP/DOQQ').filterBounds(centroid).first()  naip_vis = {'bands': ['N', 'R', 'G']}  Map.addLayer(naip, naip_vis, 'NAIP') In\u00a0[\u00a0]: Copied! <pre>landsat.propertyNames().getInfo()\n</pre> landsat.propertyNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>landsat.get('CLOUD_COVER').getInfo()\n</pre> landsat.get('CLOUD_COVER').getInfo() In\u00a0[\u00a0]: Copied! <pre># The number of milliseconds since 1970-01-01T00:00:00Z.\nlandsat.get('system:time_start').getInfo()\n</pre> # The number of milliseconds since 1970-01-01T00:00:00Z. landsat.get('system:time_start').getInfo() In\u00a0[\u00a0]: Copied! <pre>ee.Date(landsat.get('system:time_start')).format('YYYY-MM-dd').getInfo()\n</pre> ee.Date(landsat.get('system:time_start')).format('YYYY-MM-dd').getInfo() In\u00a0[\u00a0]: Copied! <pre>landsat_props = geemap.image_props(landsat)\nlandsat_props.getInfo()\n</pre> landsat_props = geemap.image_props(landsat) landsat_props.getInfo() In\u00a0[\u00a0]: Copied! <pre>landsat_props.get('IMAGE_DATE').getInfo()\n</pre> landsat_props.get('IMAGE_DATE').getInfo() In\u00a0[\u00a0]: Copied! <pre>naip_props = geemap.image_props(naip)\nnaip_props.getInfo()\n</pre> naip_props = geemap.image_props(naip) naip_props.getInfo() In\u00a0[\u00a0]: Copied! <pre>naip_props.get('NOMINAL_SCALE').getInfo()\n</pre> naip_props.get('NOMINAL_SCALE').getInfo() In\u00a0[\u00a0]: Copied! <pre>landsat_stats = geemap.image_stats(landsat, scale=90)\nlandsat_stats.getInfo()\n</pre> landsat_stats = geemap.image_stats(landsat, scale=90) landsat_stats.getInfo() In\u00a0[\u00a0]: Copied! <pre>naip_stats = geemap.image_stats(naip, scale=10)\nnaip_stats.getInfo()\n</pre> naip_stats = geemap.image_stats(naip, scale=10) naip_stats.getInfo()"},{"location":"notebooks/30_image_props_stats/#how-to-get-image-basic-properties-and-descriptive-statistics","title":"How to get image basic properties and descriptive statistics\u00b6","text":""},{"location":"notebooks/30_image_props_stats/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/30_image_props_stats/#add-images-to-the-map","title":"Add images to the map\u00b6","text":""},{"location":"notebooks/30_image_props_stats/#get-image-property-names","title":"Get image property names\u00b6","text":""},{"location":"notebooks/30_image_props_stats/#get-image-properties-all-at-once","title":"Get image properties all at once\u00b6","text":""},{"location":"notebooks/30_image_props_stats/#get-image-descriptive-statistics","title":"Get image descriptive statistics\u00b6","text":"<p>Including minimum, maximum, mean, standard deviation, and sum.</p>"},{"location":"notebooks/31_unsupervised_classification/","title":"31 unsupervised classification","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p></p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># point = ee.Geometry.Point([-122.4439, 37.7538])\npoint = ee.Geometry.Point([-87.7719, 41.8799])\n\nimage = (\n    ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n    .filterBounds(point)\n    .filterDate('2019-01-01', '2019-12-31')\n    .sort('CLOUD_COVER')\n    .first()\n    .select('B[1-7]')\n)\n\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(point, 8)\nMap.addLayer(image, vis_params, \"Landsat-8\")\n</pre> # point = ee.Geometry.Point([-122.4439, 37.7538]) point = ee.Geometry.Point([-87.7719, 41.8799])  image = (     ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')     .filterBounds(point)     .filterDate('2019-01-01', '2019-12-31')     .sort('CLOUD_COVER')     .first()     .select('B[1-7]') )  vis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(point, 8) Map.addLayer(image, vis_params, \"Landsat-8\") In\u00a0[\u00a0]: Copied! <pre>props = geemap.image_props(image)\nprops.getInfo()\n</pre> props = geemap.image_props(image) props.getInfo() In\u00a0[\u00a0]: Copied! <pre>props.get('IMAGE_DATE').getInfo()\n</pre> props.get('IMAGE_DATE').getInfo() In\u00a0[\u00a0]: Copied! <pre>props.get('CLOUD_COVER').getInfo()\n</pre> props.get('CLOUD_COVER').getInfo() In\u00a0[\u00a0]: Copied! <pre># region = Map.user_roi\n# region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])\n# region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)\n</pre> # region = Map.user_roi # region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288]) # region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000) In\u00a0[\u00a0]: Copied! <pre># Make the training dataset.\ntraining = image.sample(\n    **{\n        #     'region': region,\n        'scale': 30,\n        'numPixels': 5000,\n        'seed': 0,\n        'geometries': True,  # Set this to False to ignore geometries\n    }\n)\n\nMap.addLayer(training, {}, 'training', False)\nMap\n</pre> # Make the training dataset. training = image.sample(     **{         #     'region': region,         'scale': 30,         'numPixels': 5000,         'seed': 0,         'geometries': True,  # Set this to False to ignore geometries     } )  Map.addLayer(training, {}, 'training', False) Map In\u00a0[\u00a0]: Copied! <pre># Instantiate the clusterer and train it.\nn_clusters = 5\nclusterer = ee.Clusterer.wekaKMeans(n_clusters).train(training)\n</pre> # Instantiate the clusterer and train it. n_clusters = 5 clusterer = ee.Clusterer.wekaKMeans(n_clusters).train(training) In\u00a0[\u00a0]: Copied! <pre># Cluster the input using the trained clusterer.\nresult = image.cluster(clusterer)\n\n# # Display the clusters with random colors.\nMap.addLayer(result.randomVisualizer(), {}, 'clusters')\nMap\n</pre> # Cluster the input using the trained clusterer. result = image.cluster(clusterer)  # # Display the clusters with random colors. Map.addLayer(result.randomVisualizer(), {}, 'clusters') Map In\u00a0[\u00a0]: Copied! <pre>legend_keys = ['One', 'Two', 'Three', 'Four', 'ect']\nlegend_colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']\n\n# Reclassify the map\nresult = result.remap([0, 1, 2, 3, 4], [1, 2, 3, 4, 5])\n\nMap.addLayer(\n    result, {'min': 1, 'max': 5, 'palette': legend_colors}, 'Labelled clusters'\n)\nMap.add_legend(\n    legend_keys=legend_keys, legend_colors=legend_colors, position='bottomright'\n)\nMap\n</pre> legend_keys = ['One', 'Two', 'Three', 'Four', 'ect'] legend_colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']  # Reclassify the map result = result.remap([0, 1, 2, 3, 4], [1, 2, 3, 4, 5])  Map.addLayer(     result, {'min': 1, 'max': 5, 'palette': legend_colors}, 'Labelled clusters' ) Map.add_legend(     legend_keys=legend_keys, legend_colors=legend_colors, position='bottomright' ) Map In\u00a0[\u00a0]: Copied! <pre>print('Change layer opacity:')\ncluster_layer = Map.layers[-1]\ncluster_layer.interact(opacity=(0, 1, 0.1))\n</pre> print('Change layer opacity:') cluster_layer = Map.layers[-1] cluster_layer.interact(opacity=(0, 1, 0.1)) In\u00a0[\u00a0]: Copied! <pre>import os\n\nout_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nout_file = os.path.join(out_dir, 'cluster.tif')\n</pre> import os  out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') out_file = os.path.join(out_dir, 'cluster.tif') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(result, filename=out_file, scale=90)\n</pre> geemap.ee_export_image(result, filename=out_file, scale=90) <p>Export the result to Google Drive:</p> In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_to_drive(\n    result, description='clusters', folder='export', scale=90\n)\n</pre> geemap.ee_export_image_to_drive(     result, description='clusters', folder='export', scale=90 )"},{"location":"notebooks/31_unsupervised_classification/#machine-learning-with-earth-engine-unsupervised-classification","title":"Machine Learning with Earth Engine - Unsupervised Classification\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#unsupervised-classification-algorithms-available-in-earth-engine","title":"Unsupervised classification algorithms available in Earth Engine\u00b6","text":"<p>Source: https://developers.google.com/earth-engine/clustering</p> <p>The <code>ee.Clusterer</code> package handles unsupervised classification (or clustering) in Earth Engine. These algorithms are currently based on the algorithms with the same name in Weka. More details about each Clusterer are available in the reference docs in the Code Editor.</p> <p>Clusterers are used in the same manner as classifiers in Earth Engine. The general workflow for clustering is:</p> <ol> <li>Assemble features with numeric properties in which to find clusters.</li> <li>Instantiate a clusterer. Set its parameters if necessary.</li> <li>Train the clusterer using the training data.</li> <li>Apply the clusterer to an image or feature collection.</li> <li>Label the clusters.</li> </ol> <p>The training data is a <code>FeatureCollection</code> with properties that will be input to the clusterer. Unlike classifiers, there is no input class value for an <code>Clusterer</code>. Like classifiers, the data for the train and apply steps are expected to have the same number of values. When a trained clusterer is applied to an image or table, it assigns an integer cluster ID to each pixel or feature.</p> <p>Here is a simple example of building and using an ee.Clusterer:</p>"},{"location":"notebooks/31_unsupervised_classification/#step-by-step-tutorial","title":"Step-by-step tutorial\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#add-data-to-the-map","title":"Add data to the map\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#check-image-properties","title":"Check image properties\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#make-training-dataset","title":"Make training dataset\u00b6","text":"<p>There are several ways you can create a region for generating the training dataset.</p> <ul> <li>Draw a shape (e.g., rectangle) on the map and the use <code>region = Map.user_roi</code></li> <li>Define a geometry, such as <code>region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])</code></li> <li>Create a buffer zone around a point, such as <code>region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)</code></li> <li>If you don't define a region, it will use the image footprint by default</li> </ul>"},{"location":"notebooks/31_unsupervised_classification/#train-the-clusterer","title":"Train the clusterer\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#classify-the-image","title":"Classify the image\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#label-the-clusters","title":"Label the clusters\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#visualize-the-result","title":"Visualize the result\u00b6","text":""},{"location":"notebooks/31_unsupervised_classification/#export-the-result","title":"Export the result\u00b6","text":"<p>Export the result directly to your computer:</p>"},{"location":"notebooks/32_supervised_classification/","title":"32 supervised classification","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p></p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>point = ee.Geometry.Point([-122.4439, 37.7538])\n# point = ee.Geometry.Point([-87.7719, 41.8799])\n\nimage = (\n    ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n    .filterBounds(point)\n    .filterDate('2016-01-01', '2016-12-31')\n    .sort('CLOUD_COVER')\n    .first()\n    .select('B[1-7]')\n)\n\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(point, 8)\nMap.addLayer(image, vis_params, \"Landsat-8\")\n</pre> point = ee.Geometry.Point([-122.4439, 37.7538]) # point = ee.Geometry.Point([-87.7719, 41.8799])  image = (     ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')     .filterBounds(point)     .filterDate('2016-01-01', '2016-12-31')     .sort('CLOUD_COVER')     .first()     .select('B[1-7]') )  vis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(point, 8) Map.addLayer(image, vis_params, \"Landsat-8\") In\u00a0[\u00a0]: Copied! <pre>ee.Date(image.get('system:time_start')).format('YYYY-MM-dd').getInfo()\n</pre> ee.Date(image.get('system:time_start')).format('YYYY-MM-dd').getInfo() In\u00a0[\u00a0]: Copied! <pre>image.get('CLOUD_COVER').getInfo()\n</pre> image.get('CLOUD_COVER').getInfo() In\u00a0[\u00a0]: Copied! <pre># region = Map.user_roi\n# region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])\n# region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)\n</pre> # region = Map.user_roi # region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288]) # region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000) <p>In this example, we are going to use the USGS National Land Cover Database (NLCD) to create label dataset for training</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>nlcd = ee.Image('USGS/NLCD/NLCD2016').select('landcover').clip(image.geometry())\nMap.addLayer(nlcd, {}, 'NLCD')\nMap\n</pre> nlcd = ee.Image('USGS/NLCD/NLCD2016').select('landcover').clip(image.geometry()) Map.addLayer(nlcd, {}, 'NLCD') Map In\u00a0[\u00a0]: Copied! <pre># Make the training dataset.\npoints = nlcd.sample(\n    **{\n        'region': image.geometry(),\n        'scale': 30,\n        'numPixels': 5000,\n        'seed': 0,\n        'geometries': True,  # Set this to False to ignore geometries\n    }\n)\n\nMap.addLayer(points, {}, 'training', False)\n</pre> # Make the training dataset. points = nlcd.sample(     **{         'region': image.geometry(),         'scale': 30,         'numPixels': 5000,         'seed': 0,         'geometries': True,  # Set this to False to ignore geometries     } )  Map.addLayer(points, {}, 'training', False) In\u00a0[\u00a0]: Copied! <pre>print(points.size().getInfo())\n</pre> print(points.size().getInfo()) In\u00a0[\u00a0]: Copied! <pre>print(points.first().getInfo())\n</pre> print(points.first().getInfo()) In\u00a0[\u00a0]: Copied! <pre># Use these bands for prediction.\nbands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']\n\n\n# This property of the table stores the land cover labels.\nlabel = 'landcover'\n\n# Overlay the points on the imagery to get training.\ntraining = image.select(bands).sampleRegions(\n    **{'collection': points, 'properties': [label], 'scale': 30}\n)\n\n# Train a CART classifier with default parameters.\ntrained = ee.Classifier.smileCart().train(training, label, bands)\n</pre> # Use these bands for prediction. bands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']   # This property of the table stores the land cover labels. label = 'landcover'  # Overlay the points on the imagery to get training. training = image.select(bands).sampleRegions(     **{'collection': points, 'properties': [label], 'scale': 30} )  # Train a CART classifier with default parameters. trained = ee.Classifier.smileCart().train(training, label, bands) In\u00a0[\u00a0]: Copied! <pre>print(training.first().getInfo())\n</pre> print(training.first().getInfo()) In\u00a0[\u00a0]: Copied! <pre># Classify the image with the same bands used for training.\nresult = image.select(bands).classify(trained)\n\n# # Display the clusters with random colors.\nMap.addLayer(result.randomVisualizer(), {}, 'classified')\nMap\n</pre> # Classify the image with the same bands used for training. result = image.select(bands).classify(trained)  # # Display the clusters with random colors. Map.addLayer(result.randomVisualizer(), {}, 'classified') Map In\u00a0[\u00a0]: Copied! <pre>class_values = nlcd.get('landcover_class_values').getInfo()\nclass_values\n</pre> class_values = nlcd.get('landcover_class_values').getInfo() class_values In\u00a0[\u00a0]: Copied! <pre>class_palette = nlcd.get('landcover_class_palette').getInfo()\nclass_palette\n</pre> class_palette = nlcd.get('landcover_class_palette').getInfo() class_palette In\u00a0[\u00a0]: Copied! <pre>landcover = result.set('classification_class_values', class_values)\nlandcover = landcover.set('classification_class_palette', class_palette)\n</pre> landcover = result.set('classification_class_values', class_values) landcover = landcover.set('classification_class_palette', class_palette) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(landcover, {}, 'Land cover')\nMap\n</pre> Map.addLayer(landcover, {}, 'Land cover') Map In\u00a0[\u00a0]: Copied! <pre>print('Change layer opacity:')\ncluster_layer = Map.layers[-1]\ncluster_layer.interact(opacity=(0, 1, 0.1))\n</pre> print('Change layer opacity:') cluster_layer = Map.layers[-1] cluster_layer.interact(opacity=(0, 1, 0.1)) In\u00a0[\u00a0]: Copied! <pre>Map.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>import os\n\nout_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nout_file = os.path.join(out_dir, 'landcover.tif')\n</pre> import os  out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') out_file = os.path.join(out_dir, 'landcover.tif') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(landcover, filename=out_file, scale=900)\n</pre> geemap.ee_export_image(landcover, filename=out_file, scale=900) <p>Export the result to Google Drive:</p> In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_to_drive(\n    landcover, description='landcover', folder='export', scale=900\n)\n</pre> geemap.ee_export_image_to_drive(     landcover, description='landcover', folder='export', scale=900 )"},{"location":"notebooks/32_supervised_classification/#machine-learning-with-earth-engine-supervised-classification","title":"Machine Learning with Earth Engine - Supervised Classification\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#supervised-classification-algorithms-available-in-earth-engine","title":"Supervised classification algorithms available in Earth Engine\u00b6","text":"<p>Source: https://developers.google.com/earth-engine/classification</p> <p>The <code>Classifier</code> package handles supervised classification by traditional ML algorithms running in Earth Engine. These classifiers include CART, RandomForest, NaiveBayes and SVM. The general workflow for classification is:</p> <ol> <li>Collect training data. Assemble features which have a property that stores the known class label and properties storing numeric values for the predictors.</li> <li>Instantiate a classifier. Set its parameters if necessary.</li> <li>Train the classifier using the training data.</li> <li>Classify an image or feature collection.</li> <li>Estimate classification error with independent validation data.</li> </ol> <p>The training data is a <code>FeatureCollection</code> with a property storing the class label and properties storing predictor variables. Class labels should be consecutive, integers starting from 0. If necessary, use remap() to convert class values to consecutive integers. The predictors should be numeric.</p>"},{"location":"notebooks/32_supervised_classification/#step-by-step-tutorial","title":"Step-by-step tutorial\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#add-data-to-the-map","title":"Add data to the map\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#check-image-properties","title":"Check image properties\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#make-training-dataset","title":"Make training dataset\u00b6","text":"<p>There are several ways you can create a region for generating the training dataset.</p> <ul> <li>Draw a shape (e.g., rectangle) on the map and the use <code>region = Map.user_roi</code></li> <li>Define a geometry, such as <code>region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])</code></li> <li>Create a buffer zone around a point, such as <code>region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)</code></li> <li>If you don't define a region, it will use the image footprint by default</li> </ul>"},{"location":"notebooks/32_supervised_classification/#train-the-classifier","title":"Train the classifier\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#classify-the-image","title":"Classify the image\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#render-categorical-map","title":"Render categorical map\u00b6","text":"<p>To render a categorical map, we can set two image properties: <code>landcover_class_values</code> and <code>landcover_class_palette</code>. We can use the same style as the NLCD so that it is easy to compare the two maps.</p>"},{"location":"notebooks/32_supervised_classification/#visualize-the-result","title":"Visualize the result\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#add-a-legend-to-the-map","title":"Add a legend to the map\u00b6","text":""},{"location":"notebooks/32_supervised_classification/#export-the-result","title":"Export the result\u00b6","text":"<p>Export the result directly to your computer:</p>"},{"location":"notebooks/33_accuracy_assessment/","title":"33 accuracy assessment","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p></p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>NLCD2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(NLCD2016, {}, 'NLCD 2016')\n</pre> NLCD2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(NLCD2016, {}, 'NLCD 2016') <p>Load the NLCD metadata to find out the Landsat image IDs used to generate the land cover data.</p> In\u00a0[\u00a0]: Copied! <pre>NLCD_metadata = ee.FeatureCollection(\"users/giswqs/landcover/NLCD2016_metadata\")\nMap.addLayer(NLCD_metadata, {}, 'NLCD Metadata')\n</pre> NLCD_metadata = ee.FeatureCollection(\"users/giswqs/landcover/NLCD2016_metadata\") Map.addLayer(NLCD_metadata, {}, 'NLCD Metadata') In\u00a0[\u00a0]: Copied! <pre># point = ee.Geometry.Point([-122.4439, 37.7538])  # Sanfrancisco, CA\n# point = ee.Geometry.Point([-83.9293, 36.0526])   # Knoxville, TN\npoint = ee.Geometry.Point([-88.3070, 41.7471])  # Chicago, IL\n</pre> # point = ee.Geometry.Point([-122.4439, 37.7538])  # Sanfrancisco, CA # point = ee.Geometry.Point([-83.9293, 36.0526])   # Knoxville, TN point = ee.Geometry.Point([-88.3070, 41.7471])  # Chicago, IL In\u00a0[\u00a0]: Copied! <pre>metadata = NLCD_metadata.filterBounds(point).first()\nregion = metadata.geometry()\n</pre> metadata = NLCD_metadata.filterBounds(point).first() region = metadata.geometry() In\u00a0[\u00a0]: Copied! <pre>metadata.get('2016on_bas').getInfo()\n</pre> metadata.get('2016on_bas').getInfo() In\u00a0[\u00a0]: Copied! <pre>doy = metadata.get('2016on_bas').getInfo().replace('LC08_', '')\ndoy\n</pre> doy = metadata.get('2016on_bas').getInfo().replace('LC08_', '') doy In\u00a0[\u00a0]: Copied! <pre>ee.Date.parse('YYYYDDD', doy).format('YYYY-MM-dd').getInfo()\n</pre> ee.Date.parse('YYYYDDD', doy).format('YYYY-MM-dd').getInfo() In\u00a0[\u00a0]: Copied! <pre>start_date = ee.Date.parse('YYYYDDD', doy)\nend_date = start_date.advance(1, 'day')\n</pre> start_date = ee.Date.parse('YYYYDDD', doy) end_date = start_date.advance(1, 'day') In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n    .filterBounds(point)\n    .filterDate(start_date, end_date)\n    .first()\n    .select('B[1-7]')\n    .clip(region)\n)\n\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(point, 8)\nMap.addLayer(image, vis_params, \"Landsat-8\")\nMap\n</pre> image = (     ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')     .filterBounds(point)     .filterDate(start_date, end_date)     .first()     .select('B[1-7]')     .clip(region) )  vis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(point, 8) Map.addLayer(image, vis_params, \"Landsat-8\") Map In\u00a0[\u00a0]: Copied! <pre>nlcd_raw = NLCD2016.clip(region)\nMap.addLayer(nlcd_raw, {}, 'NLCD')\n</pre> nlcd_raw = NLCD2016.clip(region) Map.addLayer(nlcd_raw, {}, 'NLCD') In\u00a0[\u00a0]: Copied! <pre>raw_class_values = nlcd_raw.get('landcover_class_values').getInfo()\nprint(raw_class_values)\n</pre> raw_class_values = nlcd_raw.get('landcover_class_values').getInfo() print(raw_class_values) In\u00a0[\u00a0]: Copied! <pre>n_classes = len(raw_class_values)\nnew_class_values = list(range(0, n_classes))\nnew_class_values\n</pre> n_classes = len(raw_class_values) new_class_values = list(range(0, n_classes)) new_class_values In\u00a0[\u00a0]: Copied! <pre>class_palette = nlcd_raw.get('landcover_class_palette').getInfo()\nprint(class_palette)\n</pre> class_palette = nlcd_raw.get('landcover_class_palette').getInfo() print(class_palette) In\u00a0[\u00a0]: Copied! <pre>nlcd = nlcd_raw.remap(raw_class_values, new_class_values).select(\n    ['remapped'], ['landcover']\n)\nnlcd = nlcd.set('landcover_class_values', new_class_values)\nnlcd = nlcd.set('landcover_class_palette', class_palette)\n</pre> nlcd = nlcd_raw.remap(raw_class_values, new_class_values).select(     ['remapped'], ['landcover'] ) nlcd = nlcd.set('landcover_class_values', new_class_values) nlcd = nlcd.set('landcover_class_palette', class_palette) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(nlcd, {}, 'NLCD')\nMap\n</pre> Map.addLayer(nlcd, {}, 'NLCD') Map In\u00a0[\u00a0]: Copied! <pre># Make the training dataset.\npoints = nlcd.sample(\n    **{\n        'region': region,\n        'scale': 30,\n        'numPixels': 5000,\n        'seed': 0,\n        'geometries': True,  # Set this to False to ignore geometries\n    }\n)\n\nMap.addLayer(points, {}, 'training', False)\n</pre> # Make the training dataset. points = nlcd.sample(     **{         'region': region,         'scale': 30,         'numPixels': 5000,         'seed': 0,         'geometries': True,  # Set this to False to ignore geometries     } )  Map.addLayer(points, {}, 'training', False) In\u00a0[\u00a0]: Copied! <pre>print(points.size().getInfo())\n</pre> print(points.size().getInfo()) In\u00a0[\u00a0]: Copied! <pre>print(points.first().getInfo())\n</pre> print(points.first().getInfo()) In\u00a0[\u00a0]: Copied! <pre># Use these bands for prediction.\nbands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']\n\n# This property of the table stores the land cover labels.\nlabel = 'landcover'\n\n# Overlay the points on the imagery to get training.\nsample = image.select(bands).sampleRegions(\n    **{'collection': points, 'properties': [label], 'scale': 30}\n)\n\n# Adds a column of deterministic pseudorandom numbers.\nsample = sample.randomColumn()\n\nsplit = 0.7\n\ntraining = sample.filter(ee.Filter.lt('random', split))\nvalidation = sample.filter(ee.Filter.gte('random', split))\n</pre> # Use these bands for prediction. bands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']  # This property of the table stores the land cover labels. label = 'landcover'  # Overlay the points on the imagery to get training. sample = image.select(bands).sampleRegions(     **{'collection': points, 'properties': [label], 'scale': 30} )  # Adds a column of deterministic pseudorandom numbers. sample = sample.randomColumn()  split = 0.7  training = sample.filter(ee.Filter.lt('random', split)) validation = sample.filter(ee.Filter.gte('random', split)) In\u00a0[\u00a0]: Copied! <pre>training.first().getInfo()\n</pre> training.first().getInfo() In\u00a0[\u00a0]: Copied! <pre>validation.first().getInfo()\n</pre> validation.first().getInfo() In\u00a0[\u00a0]: Copied! <pre>classifier = ee.Classifier.smileRandomForest(10).train(training, label, bands)\n</pre> classifier = ee.Classifier.smileRandomForest(10).train(training, label, bands) In\u00a0[\u00a0]: Copied! <pre># Classify the image with the same bands used for training.\nresult = image.select(bands).classify(classifier)\n\n# # Display the clusters with random colors.\nMap.addLayer(result.randomVisualizer(), {}, 'classfied')\nMap\n</pre> # Classify the image with the same bands used for training. result = image.select(bands).classify(classifier)  # # Display the clusters with random colors. Map.addLayer(result.randomVisualizer(), {}, 'classfied') Map In\u00a0[\u00a0]: Copied! <pre>class_values = nlcd.get('landcover_class_values').getInfo()\nprint(class_values)\n</pre> class_values = nlcd.get('landcover_class_values').getInfo() print(class_values) In\u00a0[\u00a0]: Copied! <pre>class_palette = nlcd.get('landcover_class_palette').getInfo()\nprint(class_palette)\n</pre> class_palette = nlcd.get('landcover_class_palette').getInfo() print(class_palette) In\u00a0[\u00a0]: Copied! <pre>landcover = result.set('classification_class_values', class_values)\nlandcover = landcover.set('classification_class_palette', class_palette)\n</pre> landcover = result.set('classification_class_values', class_values) landcover = landcover.set('classification_class_palette', class_palette) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(landcover, {}, 'Land cover')\nMap\n</pre> Map.addLayer(landcover, {}, 'Land cover') Map In\u00a0[\u00a0]: Copied! <pre>print('Change layer opacity:')\ncluster_layer = Map.layers[-1]\ncluster_layer.interact(opacity=(0, 1, 0.1))\n</pre> print('Change layer opacity:') cluster_layer = Map.layers[-1] cluster_layer.interact(opacity=(0, 1, 0.1)) In\u00a0[\u00a0]: Copied! <pre>Map.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>train_accuracy = classifier.confusionMatrix()\n</pre> train_accuracy = classifier.confusionMatrix() In\u00a0[\u00a0]: Copied! <pre>train_accuracy.getInfo()\n</pre> train_accuracy.getInfo() <p>Overall Accuracy essentially tells us out of all of the reference sites what proportion were mapped correctly. The overall accuracy is usually expressed as a percent, with 100% accuracy being a perfect classification where all reference site were classified correctly. Overall accuracy is the easiest to calculate and understand but ultimately only provides the map user and producer with basic accuracy information.</p> In\u00a0[\u00a0]: Copied! <pre>train_accuracy.accuracy().getInfo()\n</pre> train_accuracy.accuracy().getInfo() <p>The Kappa Coefficient is generated from a statistical test to evaluate the accuracy of a classification. Kappa essentially evaluates how well the classification performed as compared to just randomly assigning values, i.e. did the classification do better than random. The Kappa Coefficient can range from -1 t0 1. A value of 0 indicated that the classification is no better than a random classification. A negative number indicates the classification is significantly worse than random. A value close to 1 indicates that the classification is significantly better than random.</p> In\u00a0[\u00a0]: Copied! <pre>train_accuracy.kappa().getInfo()\n</pre> train_accuracy.kappa().getInfo() <p>Producer's Accuracy is the map accuracy from the point of view of the map maker (the producer). This is how often are real features on the ground correctly shown on the classified map or the probability that a certain land cover of an area on the ground is classified as such. The Producer's Accuracy is complement of the Omission Error, Producer's Accuracy = 100%-Omission Error. It is also the number of reference sites classified accurately divided by the total number of reference sites for that class.</p> In\u00a0[\u00a0]: Copied! <pre>train_accuracy.producersAccuracy().getInfo()\n</pre> train_accuracy.producersAccuracy().getInfo() <p>The Consumer's Accuracy is the accuracy from the point of view of a map user, not the map maker. the User's accuracy essentially tells use how often the class on the map will actually be present on the ground. This is referred to as reliability. The User's Accuracy is complement of the Commission Error, User's Accuracy = 100%-Commission Error. The User's Accuracy is calculating by taking the total number of correct classifications for a particular class and dividing it by the row total.</p> In\u00a0[\u00a0]: Copied! <pre>train_accuracy.consumersAccuracy().getInfo()\n</pre> train_accuracy.consumersAccuracy().getInfo() In\u00a0[\u00a0]: Copied! <pre>validated = validation.classify(classifier)\n</pre> validated = validation.classify(classifier) In\u00a0[\u00a0]: Copied! <pre>validated.first().getInfo()\n</pre> validated.first().getInfo() <p><code>errorMatrix</code> computes a 2D error matrix for a collection by comparing two columns of a collection: one containing the actual values, and one containing predicted values.</p> In\u00a0[\u00a0]: Copied! <pre>test_accuracy = validated.errorMatrix('landcover', 'classification')\n</pre> test_accuracy = validated.errorMatrix('landcover', 'classification') In\u00a0[\u00a0]: Copied! <pre>test_accuracy.getInfo()\n</pre> test_accuracy.getInfo() In\u00a0[\u00a0]: Copied! <pre>test_accuracy.accuracy().getInfo()\n</pre> test_accuracy.accuracy().getInfo() In\u00a0[\u00a0]: Copied! <pre>test_accuracy.kappa().getInfo()\n</pre> test_accuracy.kappa().getInfo() In\u00a0[\u00a0]: Copied! <pre>test_accuracy.producersAccuracy().getInfo()\n</pre> test_accuracy.producersAccuracy().getInfo() In\u00a0[\u00a0]: Copied! <pre>test_accuracy.consumersAccuracy().getInfo()\n</pre> test_accuracy.consumersAccuracy().getInfo() In\u00a0[\u00a0]: Copied! <pre>import csv\nimport os\n\nout_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\ntraining_csv = os.path.join(out_dir, 'train_accuracy.csv')\ntesting_csv = os.path.join(out_dir, 'test_accuracy.csv')\n\nwith open(training_csv, \"w\", newline=\"\") as f:\n    writer = csv.writer(f)\n    writer.writerows(train_accuracy.getInfo())\n\nwith open(testing_csv, \"w\", newline=\"\") as f:\n    writer = csv.writer(f)\n    writer.writerows(test_accuracy.getInfo())\n</pre> import csv import os  out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') training_csv = os.path.join(out_dir, 'train_accuracy.csv') testing_csv = os.path.join(out_dir, 'test_accuracy.csv')  with open(training_csv, \"w\", newline=\"\") as f:     writer = csv.writer(f)     writer.writerows(train_accuracy.getInfo())  with open(testing_csv, \"w\", newline=\"\") as f:     writer = csv.writer(f)     writer.writerows(test_accuracy.getInfo()) In\u00a0[\u00a0]: Copied! <pre>landcover = landcover.remap(new_class_values, raw_class_values).select(\n    ['remapped'], ['classification']\n)\n</pre> landcover = landcover.remap(new_class_values, raw_class_values).select(     ['remapped'], ['classification'] ) In\u00a0[\u00a0]: Copied! <pre>landcover = landcover.set('classification_class_values', raw_class_values)\nlandcover = landcover.set('classification_class_palette', class_palette)\n</pre> landcover = landcover.set('classification_class_values', raw_class_values) landcover = landcover.set('classification_class_palette', class_palette) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(landcover, {}, 'Final land cover')\nMap\n</pre> Map.addLayer(landcover, {}, 'Final land cover') Map In\u00a0[\u00a0]: Copied! <pre>import os\n\nout_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\nout_file = os.path.join(out_dir, 'landcover.tif')\n</pre> import os  out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') out_file = os.path.join(out_dir, 'landcover.tif') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(landcover, filename=out_file, scale=900)\n</pre> geemap.ee_export_image(landcover, filename=out_file, scale=900) <p>Export the result to Google Drive:</p> In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_to_drive(\n    landcover, description='landcover', folder='export', scale=900\n)\n</pre> geemap.ee_export_image_to_drive(     landcover, description='landcover', folder='export', scale=900 )"},{"location":"notebooks/33_accuracy_assessment/#machine-learning-with-earth-engine-accuracy-assessment","title":"Machine Learning with Earth Engine - Accuracy Assessment\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#supervised-classification-algorithms-available-in-earth-engine","title":"Supervised classification algorithms available in Earth Engine\u00b6","text":"<p>Source: https://developers.google.com/earth-engine/classification</p> <p>The <code>Classifier</code> package handles supervised classification by traditional ML algorithms running in Earth Engine. These classifiers include CART, RandomForest, NaiveBayes and SVM. The general workflow for classification is:</p> <ol> <li>Collect training data. Assemble features which have a property that stores the known class label and properties storing numeric values for the predictors.</li> <li>Instantiate a classifier. Set its parameters if necessary.</li> <li>Train the classifier using the training data.</li> <li>Classify an image or feature collection.</li> <li>Estimate classification error with independent validation data.</li> </ol> <p>The training data is a <code>FeatureCollection</code> with a property storing the class label and properties storing predictor variables. Class labels should be consecutive, integers starting from 0. If necessary, use remap() to convert class values to consecutive integers. The predictors should be numeric.</p> <p>To assess the accuracy of a classifier, use a <code>ConfusionMatrix</code>. The <code>sample()</code> method generates two random samples from the input data: one for training and one for validation. The training sample is used to train the classifier. You can get resubstitution accuracy on the training data from <code>classifier.confusionMatrix()</code>. To get validation accuracy, classify the validation data. This adds a <code>classification</code> property to the validation <code>FeatureCollection</code>. Call <code>errorMatrix()</code> on the classified <code>FeatureCollection</code> to get a confusion matrix representing validation (expected) accuracy.</p>"},{"location":"notebooks/33_accuracy_assessment/#step-by-step-tutorial","title":"Step-by-step tutorial\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#add-data-to-the-map","title":"Add data to the map\u00b6","text":"<p>Let's add the USGS National Land Cover Database, which can be used to create training data with class labels.</p> <p></p>"},{"location":"notebooks/33_accuracy_assessment/#prepare-for-consecutive-class-labels","title":"Prepare for consecutive class labels\u00b6","text":"<p>In this example, we are going to use the USGS National Land Cover Database (NLCD) to create label dataset for training.</p> <p>First, we need to use the <code>remap()</code> function to turn class labels into consecutive integers.</p>"},{"location":"notebooks/33_accuracy_assessment/#make-training-data","title":"Make training data\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#split-training-and-testing","title":"Split training and testing\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#train-the-classifier","title":"Train the classifier\u00b6","text":"<p>In this examples, we will use random forest classification.</p>"},{"location":"notebooks/33_accuracy_assessment/#classify-the-image","title":"Classify the image\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#render-categorical-map","title":"Render categorical map\u00b6","text":"<p>To render a categorical map, we can set two image properties: <code>classification_class_values</code> and <code>classification_class_palette</code>. We can use the same style as the NLCD so that it is easy to compare the two maps.</p>"},{"location":"notebooks/33_accuracy_assessment/#visualize-the-result","title":"Visualize the result\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#add-a-legend-to-the-map","title":"Add a legend to the map\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#accuracy-assessment","title":"Accuracy assessment\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#training-dataset","title":"Training dataset\u00b6","text":"<p><code>confusionMatrix()</code> computes a 2D confusion matrix for a classifier based on its training data (ie: resubstitution error). Axis 0 of the matrix correspond to the input classes (i.e., reference data), and axis 1 to the output classes (i.e., classification data). The rows and columns start at class 0 and increase sequentially up to the maximum class value</p>"},{"location":"notebooks/33_accuracy_assessment/#validation-dataset","title":"Validation dataset\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#download-confusion-matrix","title":"Download confusion matrix\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#reclassify-land-cover-map","title":"Reclassify land cover map\u00b6","text":""},{"location":"notebooks/33_accuracy_assessment/#export-the-result","title":"Export the result\u00b6","text":"<p>Export the result directly to your computer:</p>"},{"location":"notebooks/34_extract_values/","title":"34 extract values","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select([0, 1, 2, 3, 4, 6])\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat7, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")\n\nMap.set_plot_options(add_marker_cluster=True)\n</pre> landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select([0, 1, 2, 3, 4, 6]) landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat7, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")  Map.set_plot_options(add_marker_cluster=True) In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\n# out_csv = os.path.join(out_dir, 'points.csv')\nout_shp = os.path.join(out_dir, 'points.shp')\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') # out_csv = os.path.join(out_dir, 'points.csv') out_shp = os.path.join(out_dir, 'points.shp') In\u00a0[\u00a0]: Copied! <pre>Map.extract_values_to_points(out_shp)\n</pre> Map.extract_values_to_points(out_shp) In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\n</pre> m = geemap.Map() In\u00a0[\u00a0]: Copied! <pre>collection = (\n    ee.ImageCollection('MODIS/006/MOD13A2')\n    .filterDate('2015-01-01', '2019-12-31')\n    .select('NDVI')\n)\n\n# Convert the image collection to an image.\nimage = collection.toBands()\n\nndvi_vis = {\n    'min': 0.0,\n    'max': 9000.0,\n    'palette': [\n        'FFFFFF',\n        'CE7E45',\n        'DF923D',\n        'F1B555',\n        'FCD163',\n        '99B718',\n        '74A901',\n        '66A000',\n        '529400',\n        '3E8601',\n        '207401',\n        '056201',\n        '004C00',\n        '023B01',\n        '012E01',\n        '011D01',\n        '011301',\n    ],\n}\n\nm.addLayer(image, {}, 'MODIS NDVI Time-series')\nm.addLayer(image.select(0), ndvi_vis, 'MODIS NDVI VIS')\n\nm\n</pre> collection = (     ee.ImageCollection('MODIS/006/MOD13A2')     .filterDate('2015-01-01', '2019-12-31')     .select('NDVI') )  # Convert the image collection to an image. image = collection.toBands()  ndvi_vis = {     'min': 0.0,     'max': 9000.0,     'palette': [         'FFFFFF',         'CE7E45',         'DF923D',         'F1B555',         'FCD163',         '99B718',         '74A901',         '66A000',         '529400',         '3E8601',         '207401',         '056201',         '004C00',         '023B01',         '012E01',         '011D01',         '011301',     ], }  m.addLayer(image, {}, 'MODIS NDVI Time-series') m.addLayer(image.select(0), ndvi_vis, 'MODIS NDVI VIS')  m In\u00a0[\u00a0]: Copied! <pre>m.set_plot_options(add_marker_cluster=True, marker=None)\nm.roi_reducer = ee.Reducer.mean()\n</pre> m.set_plot_options(add_marker_cluster=True, marker=None) m.roi_reducer = ee.Reducer.mean() In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\n# out_csv = os.path.join(out_dir, 'points.csv')\nout_shp = os.path.join(out_dir, 'ndvi.shp')\nm.extract_values_to_points(out_shp)\n</pre> out_dir = os.path.join(os.path.expanduser('~'), 'Downloads') # out_csv = os.path.join(out_dir, 'points.csv') out_shp = os.path.join(out_dir, 'ndvi.shp') m.extract_values_to_points(out_shp)"},{"location":"notebooks/34_extract_values/#interactive-extraction-of-pixel-values-and-interactive-region-reduction","title":"Interactive extraction of pixel values and interactive region reduction\u00b6","text":""},{"location":"notebooks/34_extract_values/#interactive-extraction-of-pixel-values","title":"Interactive extraction of pixel values\u00b6","text":""},{"location":"notebooks/34_extract_values/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/34_extract_values/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/34_extract_values/#add-data-to-the-map","title":"Add data to the map\u00b6","text":""},{"location":"notebooks/34_extract_values/#activate-the-plotting-tool","title":"Activate the plotting tool\u00b6","text":"<p>Tick the <code>Plotting</code> checkbox and click the mouse on the map to start displaying charts.</p>"},{"location":"notebooks/34_extract_values/#export-pixel-values-to-shapefilecsv","title":"Export pixel values to shapefile/csv\u00b6","text":""},{"location":"notebooks/34_extract_values/#interactive-region-reduction","title":"Interactive Region Reduction\u00b6","text":""},{"location":"notebooks/34_extract_values/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/34_extract_values/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/34_extract_values/#add-add-to-the-map","title":"Add add to the map\u00b6","text":""},{"location":"notebooks/34_extract_values/#set-reducer","title":"Set reducer\u00b6","text":""},{"location":"notebooks/34_extract_values/#export-data","title":"Export data\u00b6","text":""},{"location":"notebooks/35_geemap_colab/","title":"35 geemap colab","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\nimage = ee.Image('USGS/SRTMGL1_003')\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Print the elevation of Mount Everest.\nxy = ee.Geometry.Point([86.9250, 27.9881])\nelev = image.sample(xy, 30).first().get('elevation').getInfo()\nprint('Mount Everest elevation (m):', elev)\n\n# Add Earth Engine layers to Map\nMap.addLayer(image, vis_params, 'DEM')\nMap.addLayer(xy, {'color': 'red'}, 'Mount Everest')\n\n# Center the map based on an Earth Engine object or coordinates (longitude, latitude)\n# Map.centerObject(xy, 4)\nMap.setCenter(86.9250, 27.9881, 4)\n</pre> # Add Earth Engine dataset image = ee.Image('USGS/SRTMGL1_003')  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Print the elevation of Mount Everest. xy = ee.Geometry.Point([86.9250, 27.9881]) elev = image.sample(xy, 30).first().get('elevation').getInfo() print('Mount Everest elevation (m):', elev)  # Add Earth Engine layers to Map Map.addLayer(image, vis_params, 'DEM') Map.addLayer(xy, {'color': 'red'}, 'Mount Everest')  # Center the map based on an Earth Engine object or coordinates (longitude, latitude) # Map.centerObject(xy, 4) Map.setCenter(86.9250, 27.9881, 4) In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map"},{"location":"notebooks/35_geemap_colab/#import-geemap-library","title":"Import geemap library\u00b6","text":"<p>The geemap Python package has two plotting backends: ipyleaflet and folium. A key difference between folium and ipyleaflet is that ipyleaflet is built upon ipywidgets and allows bidirectional communication between the front-end and the backend enabling the use of the map to capture user input, while folium is meant for displaying static data only (source). Note that Google Colab currently does not support ipyleaflet (source). Therefore, if you are using geemap with Google Colab, geemap will automatically use the folium plotting backend.</p>"},{"location":"notebooks/35_geemap_colab/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/35_geemap_colab/#add-earth-engine-data","title":"Add Earth Engine data\u00b6","text":""},{"location":"notebooks/35_geemap_colab/#display-the-map","title":"Display the map\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/","title":"36 quality mosaic","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>countries = ee.FeatureCollection('users/giswqs/public/countries')\nMap.addLayer(countries, {}, 'coutries')\n</pre> countries = ee.FeatureCollection('users/giswqs/public/countries') Map.addLayer(countries, {}, 'coutries') In\u00a0[\u00a0]: Copied! <pre>roi = countries.filter(ee.Filter.eq('id', 'USA'))\nMap.addLayer(roi, {}, 'roi')\n</pre> roi = countries.filter(ee.Filter.eq('id', 'USA')) Map.addLayer(roi, {}, 'roi') In\u00a0[\u00a0]: Copied! <pre>start_date = '2019-01-01'\nend_date = '2019-12-31'\n\nl8 = (\n    ee.ImageCollection('LANDSAT/LC08/C01/T1_TOA')\n    .filterBounds(roi)\n    .filterDate(start_date, end_date)\n)\n</pre> start_date = '2019-01-01' end_date = '2019-12-31'  l8 = (     ee.ImageCollection('LANDSAT/LC08/C01/T1_TOA')     .filterBounds(roi)     .filterDate(start_date, end_date) ) In\u00a0[\u00a0]: Copied! <pre># print(l8.size().getInfo())\n</pre> # print(l8.size().getInfo()) In\u00a0[\u00a0]: Copied! <pre>median = l8.median()\n\nvisParams = {\n    'bands': ['B4', 'B3', 'B2'],\n    'min': 0,\n    'max': 0.4,\n}\n\nMap.addLayer(median, visParams, 'Median')\n</pre> median = l8.median()  visParams = {     'bands': ['B4', 'B3', 'B2'],     'min': 0,     'max': 0.4, }  Map.addLayer(median, visParams, 'Median') In\u00a0[\u00a0]: Copied! <pre>def addNDVI(image):\n    ndvi = image.normalizedDifference(['B5', 'B4']).rename('NDVI')\n    return image.addBands(ndvi)\n</pre> def addNDVI(image):     ndvi = image.normalizedDifference(['B5', 'B4']).rename('NDVI')     return image.addBands(ndvi) In\u00a0[\u00a0]: Copied! <pre>def addDate(image):\n    img_date = ee.Date(image.date())\n    img_date = ee.Number.parse(img_date.format('YYYYMMdd'))\n    return image.addBands(ee.Image(img_date).rename('date').toInt())\n</pre> def addDate(image):     img_date = ee.Date(image.date())     img_date = ee.Number.parse(img_date.format('YYYYMMdd'))     return image.addBands(ee.Image(img_date).rename('date').toInt()) In\u00a0[\u00a0]: Copied! <pre>def addMonth(image):\n    img_date = ee.Date(image.date())\n    img_doy = ee.Number.parse(img_date.format('M'))\n    return image.addBands(ee.Image(img_doy).rename('month').toInt())\n</pre> def addMonth(image):     img_date = ee.Date(image.date())     img_doy = ee.Number.parse(img_date.format('M'))     return image.addBands(ee.Image(img_doy).rename('month').toInt()) In\u00a0[\u00a0]: Copied! <pre>def addDOY(image):\n    img_date = ee.Date(image.date())\n    img_doy = ee.Number.parse(img_date.format('D'))\n    return image.addBands(ee.Image(img_doy).rename('doy').toInt())\n</pre> def addDOY(image):     img_date = ee.Date(image.date())     img_doy = ee.Number.parse(img_date.format('D'))     return image.addBands(ee.Image(img_doy).rename('doy').toInt()) In\u00a0[\u00a0]: Copied! <pre>withNDVI = l8.map(addNDVI).map(addDate).map(addMonth).map(addDOY)\n</pre> withNDVI = l8.map(addNDVI).map(addDate).map(addMonth).map(addDOY) In\u00a0[\u00a0]: Copied! <pre>greenest = withNDVI.qualityMosaic('NDVI')\n</pre> greenest = withNDVI.qualityMosaic('NDVI') In\u00a0[\u00a0]: Copied! <pre>greenest.bandNames().getInfo()\n</pre> greenest.bandNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>ndvi = greenest.select('NDVI')\npalette = [\n    '#d73027',\n    '#f46d43',\n    '#fdae61',\n    '#fee08b',\n    '#d9ef8b',\n    '#a6d96a',\n    '#66bd63',\n    '#1a9850',\n]\nMap.addLayer(ndvi, {'palette': palette}, 'NDVI')\n</pre> ndvi = greenest.select('NDVI') palette = [     '#d73027',     '#f46d43',     '#fdae61',     '#fee08b',     '#d9ef8b',     '#a6d96a',     '#66bd63',     '#1a9850', ] Map.addLayer(ndvi, {'palette': palette}, 'NDVI') In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(greenest, visParams, 'Greenest pixel')\nMap\n</pre> Map.addLayer(greenest, visParams, 'Greenest pixel') Map In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(\n    greenest.select('month'),\n    {'palette': ['red', 'blue'], 'min': 1, 'max': 12},\n    'Greenest month',\n)\n</pre> Map.addLayer(     greenest.select('month'),     {'palette': ['red', 'blue'], 'min': 1, 'max': 12},     'Greenest month', ) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(\n    greenest.select('doy'),\n    {'palette': ['brown', 'green'], 'min': 1, 'max': 365},\n    'Greenest doy',\n)\n</pre> Map.addLayer(     greenest.select('doy'),     {'palette': ['brown', 'green'], 'min': 1, 'max': 365},     'Greenest doy', )"},{"location":"notebooks/36_quality_mosaic/#how-to-find-out-the-greenest-day-of-the-year","title":"How to find out the greenest day of the year\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#define-a-region-of-interest-roi","title":"Define a region of interest (ROI)\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#filter-imagecollection","title":"Filter ImageCollection\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#create-a-median-composite","title":"Create a median composite\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#define-functions-to-add-time-bands","title":"Define functions to add time bands\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#map-over-an-imagecollection","title":"Map over an ImageCollection\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#create-a-quality-mosaic","title":"Create a quality mosaic\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#display-the-max-value-band","title":"Display the max value band\u00b6","text":""},{"location":"notebooks/36_quality_mosaic/#display-time-bands","title":"Display time bands\u00b6","text":""},{"location":"notebooks/37_pydeck_3d/","title":"37 pydeck 3d","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p>This example is adopted from here. Credits to the developers of the pydeck-earthengine-layers package.</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('USGS/NED').select('elevation')\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(image, vis_params, 'NED')\n</pre> image = ee.Image('USGS/NED').select('elevation') vis_params = {     \"min\": 0,     \"max\": 4000,     \"palette\": ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(image, vis_params, 'NED') <p>First, import required packages. Note that here we import the <code>EarthEngineTerrainLayer</code> instead of the <code>EarthEngineLayer</code>.</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport pydeck as pdk\nfrom pydeck_earthengine_layers import EarthEngineTerrainLayer\n</pre> import ee import pydeck as pdk from pydeck_earthengine_layers import EarthEngineTerrainLayer In\u00a0[\u00a0]: Copied! <pre>try:\n    ee.Initialize()\nexcept Exception as e:\n    ee.Authenticate()\n    ee.Initialize()\n</pre> try:     ee.Initialize() except Exception as e:     ee.Authenticate()     ee.Initialize() In\u00a0[\u00a0]: Copied! <pre># image = ee.Image('USGS/SRTMGL1_003')\nimage = ee.Image('USGS/NED').select('elevation')\nterrain = ee.Image('USGS/NED').select('elevation')\n</pre> # image = ee.Image('USGS/SRTMGL1_003') image = ee.Image('USGS/NED').select('elevation') terrain = ee.Image('USGS/NED').select('elevation') <p>Here <code>vis_params</code> consists of parameters that will be passed to the Earth Engine <code>visParams</code> argument. Any parameters that you could pass directly to Earth Engine in the code editor, you can also pass here to the <code>EarthEngineLayer</code>.</p> In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n</pre> vis_params = {     \"min\": 0,     \"max\": 4000,     \"palette\": ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } <p>Now we're ready to create the Pydeck layer. The <code>EarthEngineLayer</code> makes this simple. Just pass the Earth Engine object to the class.</p> <p>Including the <code>id</code> argument isn't necessary when you only have one pydeck layer, but it is necessary to distinguish multiple layers, so it's good to get into the habit of including an <code>id</code> parameter.</p> In\u00a0[\u00a0]: Copied! <pre>ee_layer = EarthEngineTerrainLayer(image, terrain, vis_params, id=\"EETerrainLayer\")\n</pre> ee_layer = EarthEngineTerrainLayer(image, terrain, vis_params, id=\"EETerrainLayer\") <p>Then just pass this layer to a <code>pydeck.Deck</code> instance, and call <code>.show()</code> to create a map:</p> In\u00a0[\u00a0]: Copied! <pre>view_state = pdk.ViewState(\n    latitude=36.15, longitude=-111.96, zoom=10.5, bearing=-66.16, pitch=60\n)\n\nr = pdk.Deck(layers=[ee_layer], initial_view_state=view_state)\n\nr.show()\n</pre> view_state = pdk.ViewState(     latitude=36.15, longitude=-111.96, zoom=10.5, bearing=-66.16, pitch=60 )  r = pdk.Deck(layers=[ee_layer], initial_view_state=view_state)  r.show()"},{"location":"notebooks/37_pydeck_3d/#how-to-use-earth-engine-with-pydeck-for-3d-terrain-visualization","title":"How to use Earth Engine with pydeck for 3D terrain visualization\u00b6","text":"<p>Pydeck + Earth Engine: Terrain Visualization</p> <p>Requirements</p> <ul> <li>earthengine-api: a Python client library for calling the Google Earth Engine API.</li> <li>pydeck: a WebGL-powered framework for visual exploratory data analysis of large datasets.</li> <li>pydeck-earthengine-layers: a pydekc wrapper for Google Earth Engine. For documentation please visit this website.</li> <li>Mapbox API key: you will need this add basemap tiles to pydeck.</li> </ul> <p>Installation</p> <ul> <li>conda create -n deck python</li> <li>conda activate deck</li> <li>conda install mamba -c conda-forge</li> <li>mamba install earthengine-api pydeck pydeck-earthengine-layers -c conda-forge</li> <li>jupyter nbextension install --sys-prefix --symlink --overwrite --py pydeck</li> <li>jupyter nbextension enable --sys-prefix --py pydeck</li> </ul>"},{"location":"notebooks/37_pydeck_3d/#2d-visualization","title":"2D Visualization\u00b6","text":""},{"location":"notebooks/37_pydeck_3d/#3d-visualization","title":"3D Visualization\u00b6","text":""},{"location":"notebooks/37_pydeck_3d/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/37_pydeck_3d/#authenticate-with-earth-engine","title":"Authenticate with Earth Engine\u00b6","text":"<p>Using Earth Engine requires authentication. If you don't have a Google account approved for use with Earth Engine, you'll need to request access. For more information and to sign up, go to https://signup.earthengine.google.com/.</p>"},{"location":"notebooks/37_pydeck_3d/#terrain-example","title":"Terrain Example\u00b6","text":"<p>In contrast to the <code>EarthEngineLayer</code>, where you need to supply one Earth Engine object to render, with the <code>EarthEngineTerrainLayer</code> you must supply two Earth Engine objects. The first is used to render the image in the same way as the <code>EarthEngineLayer</code>; the second supplies elevation values used to extrude terrain in 3D. Hence the former can be any <code>Image</code> object; the latter must be an <code>Image</code> object whose values represents terrain heights.</p> <p>It's important for the terrain source to have relatively high spatial resolution. In previous examples, we used SRTM90 as an elevation source, but that only has a resolution of 90 meters. When used as an elevation source, it looks very blocky/pixelated at high zoom levels. In this example we'll use SRTM30 (30-meter resolution) as the <code>Image</code> source and the USGS's National Elevation Dataset (10-meter resolution, U.S. only) as the terrain source. SRTM30 is generally the best-resolution worldwide data source available.</p>"},{"location":"notebooks/38_cloud_geotiff/","title":"38 cloud geotiff","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>URL = 'https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif'\n# URL = 'gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif'\n</pre> URL = 'https://storage.googleapis.com/pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif' # URL = 'gs://pdd-stac/disasters/hurricane-harvey/0831/20170831_172754_101c_3B_AnalyticMS.tif' In\u00a0[\u00a0]: Copied! <pre>image = geemap.load_GeoTIFF(URL)\n</pre> image = geemap.load_GeoTIFF(URL) In\u00a0[\u00a0]: Copied! <pre>vis = {\"bands\": [\"B3\", \"B2\", \"B1\"], \"min\": 3000, \"max\": 13500}\n\nMap.addLayer(image, vis, 'Cloud Image')\nMap.centerObject(image.geometry(), 12)\n</pre> vis = {\"bands\": [\"B3\", \"B2\", \"B1\"], \"min\": 3000, \"max\": 13500}  Map.addLayer(image, vis, 'Cloud Image') Map.centerObject(image.geometry(), 12) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>B3 = 'gs://gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B3.TIF'\nB4 = 'gs://gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B4.TIF'\nB5 = 'gs://gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF'\n</pre> B3 = 'gs://gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B3.TIF' B4 = 'gs://gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B4.TIF' B5 = 'gs://gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1/LC08_L1TP_044034_20131228_20170307_01_T1_B5.TIF' In\u00a0[\u00a0]: Copied! <pre>URLs = [B3, B4, B5]\n</pre> URLs = [B3, B4, B5] In\u00a0[\u00a0]: Copied! <pre>collection = geemap.load_GeoTIFFs(URLs)\n</pre> collection = geemap.load_GeoTIFFs(URLs) In\u00a0[\u00a0]: Copied! <pre>image = collection.toBands().rename(['Green', 'Red', 'NIR']).selfMask()\n</pre> image = collection.toBands().rename(['Green', 'Red', 'NIR']).selfMask() In\u00a0[\u00a0]: Copied! <pre>vis = {'bands': ['NIR', 'Red', 'Green'], 'min': 100, 'max': 12000, 'gamma': 0.8}\n\nMap.addLayer(image, vis, 'Image')\nMap.centerObject(image.geometry(), 8)\n</pre> vis = {'bands': ['NIR', 'Red', 'Green'], 'min': 100, 'max': 12000, 'gamma': 0.8}  Map.addLayer(image, vis, 'Image') Map.centerObject(image.geometry(), 8) In\u00a0[\u00a0]: Copied! <pre>ndvi = image.normalizedDifference(['NIR', 'Red'])\nndvi_vis = {'min': 0, 'max': 1, 'palette': ['blue', 'green']}\nMap.addLayer(ndvi, {}, 'NDVI')\n</pre> ndvi = image.normalizedDifference(['NIR', 'Red']) ndvi_vis = {'min': 0, 'max': 1, 'palette': ['blue', 'green']} Map.addLayer(ndvi, {}, 'NDVI')"},{"location":"notebooks/38_cloud_geotiff/#how-to-use-cloud-optimized-geotiff-with-earth-engine","title":"How to use Cloud Optimized GeoTIFF with Earth Engine\u00b6","text":"<p>A Cloud Optimized GeoTIFF (COG) is a regular GeoTIFF file, aimed at being hosted on a HTTP file server, with an internal organization that enables more efficient workflows on the cloud. It does this by leveraging the ability of clients issuing HTTP GET range requests to ask for just the parts of a file they need.</p> <p>More information about COG can be found at https://www.cogeo.org/in-depth.html</p> <p>Some publicly available Cloud Optimized GeoTIFFs:</p> <ul> <li>https://stacindex.org/</li> <li>https://cloud.google.com/storage/docs/public-datasets/landsat</li> </ul>"},{"location":"notebooks/38_cloud_geotiff/#loading-a-cloud-optimized-geotiff-as-an-eeimage","title":"Loading a Cloud Optimized GeoTIFF as an ee.Image\u00b6","text":"<p>Note that only Cloud Optimized GeoTIFF hosted on Google Cloud Storage is supported. Other cloud storage providers (e.g., AWS) are not supported.</p> <p>In this example, we are going to use the Planet Disaster Data.</p>"},{"location":"notebooks/38_cloud_geotiff/#loading-a-list-of-cloud-optimized-geotiffs-as-an-eeimagecollection","title":"Loading a list of Cloud Optimized GeoTIFFs as an ee.ImageCollection\u00b6","text":"<p>In this example, we are going to use the Landsat data hosted on Google Cloud.</p> <p>https://cloud.google.com/storage/docs/public-datasets/landsat</p> <p>https://console.cloud.google.com/storage/browser/gcp-public-data-landsat/LC08/01/044/034/LC08_L1TP_044034_20131228_20170307_01_T1</p>"},{"location":"notebooks/39_timelapse/","title":"39 timelapse","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\nimport ipywidgets as widgets\n</pre> import os import ee import geemap import ipywidgets as widgets In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map In\u00a0[\u00a0]: Copied! <pre>style = {'description_width': 'initial'}\ntitle = widgets.Text(\n    description='Title:', value='Landsat Timelapse', width=200, style=style\n)\n\nbands = widgets.Dropdown(\n    description='Select RGB Combo:',\n    options=[\n        'Red/Green/Blue',\n        'NIR/Red/Green',\n        'SWIR2/SWIR1/NIR',\n        'NIR/SWIR1/Red',\n        'SWIR2/NIR/Red',\n        'SWIR2/SWIR1/Red',\n        'SWIR1/NIR/Blue',\n        'NIR/SWIR1/Blue',\n        'SWIR2/NIR/Green',\n        'SWIR1/NIR/Red',\n    ],\n    value='NIR/Red/Green',\n    style=style,\n)\n\nhbox1 = widgets.HBox([title, bands])\nhbox1\n</pre> style = {'description_width': 'initial'} title = widgets.Text(     description='Title:', value='Landsat Timelapse', width=200, style=style )  bands = widgets.Dropdown(     description='Select RGB Combo:',     options=[         'Red/Green/Blue',         'NIR/Red/Green',         'SWIR2/SWIR1/NIR',         'NIR/SWIR1/Red',         'SWIR2/NIR/Red',         'SWIR2/SWIR1/Red',         'SWIR1/NIR/Blue',         'NIR/SWIR1/Blue',         'SWIR2/NIR/Green',         'SWIR1/NIR/Red',     ],     value='NIR/Red/Green',     style=style, )  hbox1 = widgets.HBox([title, bands]) hbox1 In\u00a0[\u00a0]: Copied! <pre>speed = widgets.IntSlider(\n    description='  Frames per second:',\n    tooltip='Frames per second:',\n    value=10,\n    min=1,\n    max=30,\n    style=style,\n)\n\ncloud = widgets.Checkbox(\n    value=True, description='Apply fmask (remove clouds, shadows, snow)', style=style\n)\n\nhbox2 = widgets.HBox([speed, cloud])\nhbox2\n</pre> speed = widgets.IntSlider(     description='  Frames per second:',     tooltip='Frames per second:',     value=10,     min=1,     max=30,     style=style, )  cloud = widgets.Checkbox(     value=True, description='Apply fmask (remove clouds, shadows, snow)', style=style )  hbox2 = widgets.HBox([speed, cloud]) hbox2 In\u00a0[\u00a0]: Copied! <pre>start_year = widgets.IntSlider(\n    description='Start Year:', value=1984, min=1984, max=2020, style=style\n)\nend_year = widgets.IntSlider(\n    description='End Year:', value=2020, min=1984, max=2020, style=style\n)\nstart_month = widgets.IntSlider(\n    description='Start Month:', value=5, min=1, max=12, style=style\n)\nend_month = widgets.IntSlider(\n    description='End Month:', value=10, min=1, max=12, style=style\n)\nhbox3 = widgets.HBox([start_year, end_year, start_month, end_month])\nhbox3\n</pre> start_year = widgets.IntSlider(     description='Start Year:', value=1984, min=1984, max=2020, style=style ) end_year = widgets.IntSlider(     description='End Year:', value=2020, min=1984, max=2020, style=style ) start_month = widgets.IntSlider(     description='Start Month:', value=5, min=1, max=12, style=style ) end_month = widgets.IntSlider(     description='End Month:', value=10, min=1, max=12, style=style ) hbox3 = widgets.HBox([start_year, end_year, start_month, end_month]) hbox3 In\u00a0[\u00a0]: Copied! <pre>font_size = widgets.IntSlider(\n    description='Font size:', value=30, min=10, max=50, style=style\n)\n\nfont_color = widgets.ColorPicker(\n    concise=False, description='Font color:', value='white', style=style\n)\n\nprogress_bar_color = widgets.ColorPicker(\n    concise=False, description='Progress bar color:', value='blue', style=style\n)\n\nhbox4 = widgets.HBox([font_size, font_color, progress_bar_color])\nhbox4\n</pre> font_size = widgets.IntSlider(     description='Font size:', value=30, min=10, max=50, style=style )  font_color = widgets.ColorPicker(     concise=False, description='Font color:', value='white', style=style )  progress_bar_color = widgets.ColorPicker(     concise=False, description='Progress bar color:', value='blue', style=style )  hbox4 = widgets.HBox([font_size, font_color, progress_bar_color]) hbox4 In\u00a0[\u00a0]: Copied! <pre># Normalized Satellite Indices: https://www.usna.edu/Users/oceano/pguth/md_help/html/norm_sat.htm\n\nnd_options = [\n    'Vegetation Index (NDVI)',\n    'Water Index (NDWI)',\n    'Modified Water Index (MNDWI)',\n    'Snow Index (NDSI)',\n    'Soil Index (NDSI)',\n    'Burn Ratio (NBR)',\n    'Customized',\n]\nnd_indices = widgets.Dropdown(\n    options=nd_options,\n    value=None,\n    description='Normalized Difference Index:',\n    style=style,\n)\n\nfirst_band = widgets.Dropdown(\n    description='1st band:',\n    options=['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'],\n    value=None,\n    style=style,\n)\n\nsecond_band = widgets.Dropdown(\n    description='2nd band:',\n    options=['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'],\n    value=None,\n    style=style,\n)\n\nnd_threshold = widgets.FloatSlider(\n    value=0,\n    min=-1,\n    max=1,\n    step=0.01,\n    description='Threshold:',\n    orientation='horizontal',\n)\n\nnd_color = widgets.ColorPicker(\n    concise=False, description='Color:', value='blue', style=style\n)\n\n\ndef nd_index_change(change):\n    if nd_indices.value == 'Vegetation Index (NDVI)':\n        first_band.value = 'NIR'\n        second_band.value = 'Red'\n    elif nd_indices.value == 'Water Index (NDWI)':\n        first_band.value = 'NIR'\n        second_band.value = 'SWIR1'\n    elif nd_indices.value == 'Modified Water Index (MNDWI)':\n        first_band.value = 'Green'\n        second_band.value = 'SWIR1'\n    elif nd_indices.value == 'Snow Index (NDSI)':\n        first_band.value = 'Green'\n        second_band.value = 'SWIR1'\n    elif nd_indices.value == 'Soil Index (NDSI)':\n        first_band.value = 'SWIR1'\n        second_band.value = 'NIR'\n    elif nd_indices.value == 'Burn Ratio (NBR)':\n        first_band.value = 'NIR'\n        second_band.value = 'SWIR2'\n    elif nd_indices.value == 'Customized':\n        first_band.value = None\n        second_band.value = None\n\n\nnd_indices.observe(nd_index_change, names='value')\n\nhbox5 = widgets.HBox([nd_indices, first_band, second_band, nd_threshold, nd_color])\nhbox5\n</pre> # Normalized Satellite Indices: https://www.usna.edu/Users/oceano/pguth/md_help/html/norm_sat.htm  nd_options = [     'Vegetation Index (NDVI)',     'Water Index (NDWI)',     'Modified Water Index (MNDWI)',     'Snow Index (NDSI)',     'Soil Index (NDSI)',     'Burn Ratio (NBR)',     'Customized', ] nd_indices = widgets.Dropdown(     options=nd_options,     value=None,     description='Normalized Difference Index:',     style=style, )  first_band = widgets.Dropdown(     description='1st band:',     options=['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'],     value=None,     style=style, )  second_band = widgets.Dropdown(     description='2nd band:',     options=['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'],     value=None,     style=style, )  nd_threshold = widgets.FloatSlider(     value=0,     min=-1,     max=1,     step=0.01,     description='Threshold:',     orientation='horizontal', )  nd_color = widgets.ColorPicker(     concise=False, description='Color:', value='blue', style=style )   def nd_index_change(change):     if nd_indices.value == 'Vegetation Index (NDVI)':         first_band.value = 'NIR'         second_band.value = 'Red'     elif nd_indices.value == 'Water Index (NDWI)':         first_band.value = 'NIR'         second_band.value = 'SWIR1'     elif nd_indices.value == 'Modified Water Index (MNDWI)':         first_band.value = 'Green'         second_band.value = 'SWIR1'     elif nd_indices.value == 'Snow Index (NDSI)':         first_band.value = 'Green'         second_band.value = 'SWIR1'     elif nd_indices.value == 'Soil Index (NDSI)':         first_band.value = 'SWIR1'         second_band.value = 'NIR'     elif nd_indices.value == 'Burn Ratio (NBR)':         first_band.value = 'NIR'         second_band.value = 'SWIR2'     elif nd_indices.value == 'Customized':         first_band.value = None         second_band.value = None   nd_indices.observe(nd_index_change, names='value')  hbox5 = widgets.HBox([nd_indices, first_band, second_band, nd_threshold, nd_color]) hbox5 In\u00a0[\u00a0]: Copied! <pre>create_gif = widgets.Button(\n    description='Create timelapse',\n    button_style='primary',\n    tooltip='Click to create timelapse',\n    style=style,\n)\n\ndownload_gif = widgets.Button(\n    description='Download GIF',\n    button_style='primary',\n    tooltip='Click to download timelapse',\n    disabled=False,\n    style=style,\n)\n\noutput = widgets.Output()\n\nhbox5 = widgets.HBox([create_gif])\nhbox5\n</pre> create_gif = widgets.Button(     description='Create timelapse',     button_style='primary',     tooltip='Click to create timelapse',     style=style, )  download_gif = widgets.Button(     description='Download GIF',     button_style='primary',     tooltip='Click to download timelapse',     disabled=False,     style=style, )  output = widgets.Output()  hbox5 = widgets.HBox([create_gif]) hbox5 In\u00a0[\u00a0]: Copied! <pre>def submit_clicked(b):\n    with output:\n        output.clear_output()\n        if start_year.value &gt; end_year.value:\n            print('The end year must be great than the start year.')\n            return\n        if start_month.value &gt; end_month.value:\n            print('The end month must be great than the start month.')\n            return\n        if start_year.value == end_year.value:\n            add_progress_bar = False\n        else:\n            add_progress_bar = True\n\n        start_date = str(start_month.value).zfill(2) + '-01'\n        end_date = str(end_month.value).zfill(2) + '-30'\n\n        print('Computing...')\n\n        nd_bands = None\n        if (first_band.value is not None) and (second_band.value is not None):\n            nd_bands = [first_band.value, second_band.value]\n\n        Map.add_landsat_ts_gif(\n            roi=Map.user_roi,\n            label=title.value,\n            start_year=start_year.value,\n            end_year=end_year.value,\n            start_date=start_date,\n            end_date=end_date,\n            bands=bands.value.split('/'),\n            font_color=font_color.value,\n            frames_per_second=speed.value,\n            font_size=font_size.value,\n            add_progress_bar=add_progress_bar,\n            progress_bar_color=progress_bar_color.value,\n            download=True,\n            apply_fmask=cloud.value,\n            nd_bands=nd_bands,\n            nd_threshold=nd_threshold.value,\n            nd_palette=['black', nd_color.value],\n        )\n\n\ncreate_gif.on_click(submit_clicked)\n</pre> def submit_clicked(b):     with output:         output.clear_output()         if start_year.value &gt; end_year.value:             print('The end year must be great than the start year.')             return         if start_month.value &gt; end_month.value:             print('The end month must be great than the start month.')             return         if start_year.value == end_year.value:             add_progress_bar = False         else:             add_progress_bar = True          start_date = str(start_month.value).zfill(2) + '-01'         end_date = str(end_month.value).zfill(2) + '-30'          print('Computing...')          nd_bands = None         if (first_band.value is not None) and (second_band.value is not None):             nd_bands = [first_band.value, second_band.value]          Map.add_landsat_ts_gif(             roi=Map.user_roi,             label=title.value,             start_year=start_year.value,             end_year=end_year.value,             start_date=start_date,             end_date=end_date,             bands=bands.value.split('/'),             font_color=font_color.value,             frames_per_second=speed.value,             font_size=font_size.value,             add_progress_bar=add_progress_bar,             progress_bar_color=progress_bar_color.value,             download=True,             apply_fmask=cloud.value,             nd_bands=nd_bands,             nd_threshold=nd_threshold.value,             nd_palette=['black', nd_color.value],         )   create_gif.on_click(submit_clicked) In\u00a0[\u00a0]: Copied! <pre>output\n</pre> output"},{"location":"notebooks/39_timelapse/#creating-landsat-timelapse","title":"Creating Landsat Timelapse\u00b6","text":"<p>Steps to create a Landsat timelapse:</p> <ol> <li>Pan and zoom to your area of interest, or click the globe icon at the upper left corner to search for a location.</li> <li>Use the drawing tool to draw a rectangle anywhere on the map.</li> <li>Adjust the parameters (e.g., start year, end year, title) if needed.</li> <li>Click the <code>Create timelapse</code> button to create a timelapse.</li> <li>Once the timelapse has been added to the map, click the hyperlink at the end if you want to download the GIF.</li> </ol> <p>Web Apps: https://streamlit.geemap.org</p> <p>Contact: Dr. Qiusheng Wu (Website, LinkedIn, Twitter, YouTube)</p>"},{"location":"notebooks/40_ipywidgets/","title":"40 ipywidgets","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport ipyleaflet\nimport ipywidgets as widgets\n</pre> import ee import geemap import ipyleaflet import ipywidgets as widgets In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map In\u00a0[\u00a0]: Copied! <pre>dem = ee.Image('USGS/SRTMGL1_003')\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'DEM')\n</pre> dem = ee.Image('USGS/SRTMGL1_003')  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'DEM') In\u00a0[\u00a0]: Copied! <pre>fc = ee.FeatureCollection('TIGER/2018/States')\nMap.addLayer(fc, {}, 'US States')\n</pre> fc = ee.FeatureCollection('TIGER/2018/States') Map.addLayer(fc, {}, 'US States') In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map In\u00a0[\u00a0]: Copied! <pre>dem_layer = Map.find_layer('DEM')\ndem_layer.interact(opacity=(0, 1, 0.1))\n</pre> dem_layer = Map.find_layer('DEM') dem_layer.interact(opacity=(0, 1, 0.1)) In\u00a0[\u00a0]: Copied! <pre>vector_layer = Map.find_layer('US States')\nvector_layer.interact(opacity=(0, 1, 0.1))\n</pre> vector_layer = Map.find_layer('US States') vector_layer.interact(opacity=(0, 1, 0.1)) In\u00a0[\u00a0]: Copied! <pre>int_slider = widgets.IntSlider(\n    value=2000, min=1984, max=2020, step=1, description='Year:'\n)\nint_slider\n</pre> int_slider = widgets.IntSlider(     value=2000, min=1984, max=2020, step=1, description='Year:' ) int_slider In\u00a0[\u00a0]: Copied! <pre>int_slider.value\n</pre> int_slider.value In\u00a0[\u00a0]: Copied! <pre>float_slider = widgets.FloatSlider(\n    value=0, min=-1, max=1, step=0.05, description='Threshold:'\n)\nfloat_slider\n</pre> float_slider = widgets.FloatSlider(     value=0, min=-1, max=1, step=0.05, description='Threshold:' ) float_slider In\u00a0[\u00a0]: Copied! <pre>float_slider.value\n</pre> float_slider.value In\u00a0[\u00a0]: Copied! <pre>int_progress = widgets.IntProgress(\n    value=7,\n    min=0,\n    max=10,\n    step=1,\n    description='Loading:',\n    bar_style='',  # 'success', 'info', 'warning', 'danger' or ''\n    orientation='horizontal',\n)\nint_progress\n</pre> int_progress = widgets.IntProgress(     value=7,     min=0,     max=10,     step=1,     description='Loading:',     bar_style='',  # 'success', 'info', 'warning', 'danger' or ''     orientation='horizontal', ) int_progress In\u00a0[\u00a0]: Copied! <pre>int_text = widgets.IntText(\n    value=7,\n    description='Any:',\n)\nint_text\n</pre> int_text = widgets.IntText(     value=7,     description='Any:', ) int_text In\u00a0[\u00a0]: Copied! <pre>float_text = widgets.FloatText(\n    value=7.5,\n    description='Any:',\n)\nfloat_text\n</pre> float_text = widgets.FloatText(     value=7.5,     description='Any:', ) float_text In\u00a0[\u00a0]: Copied! <pre>toggle_button = widgets.ToggleButton(\n    value=False,\n    description='Click me',\n    disabled=False,\n    button_style='success',  # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Description',\n    icon='check',  # (FontAwesome names without the `fa-` prefix)\n)\ntoggle_button\n</pre> toggle_button = widgets.ToggleButton(     value=False,     description='Click me',     disabled=False,     button_style='success',  # 'success', 'info', 'warning', 'danger' or ''     tooltip='Description',     icon='check',  # (FontAwesome names without the `fa-` prefix) ) toggle_button In\u00a0[\u00a0]: Copied! <pre>toggle_button.value\n</pre> toggle_button.value In\u00a0[\u00a0]: Copied! <pre>checkbox = widgets.Checkbox(\n    value=False, description='Check me', disabled=False, indent=False\n)\ncheckbox\n</pre> checkbox = widgets.Checkbox(     value=False, description='Check me', disabled=False, indent=False ) checkbox In\u00a0[\u00a0]: Copied! <pre>checkbox.value\n</pre> checkbox.value In\u00a0[\u00a0]: Copied! <pre>dropdown = widgets.Dropdown(\n    options=['USA', 'Canada', 'Mexico'], value='Canada', description='Country:'\n)\ndropdown\n</pre> dropdown = widgets.Dropdown(     options=['USA', 'Canada', 'Mexico'], value='Canada', description='Country:' ) dropdown In\u00a0[\u00a0]: Copied! <pre>dropdown.value\n</pre> dropdown.value In\u00a0[\u00a0]: Copied! <pre>radio_buttons = widgets.RadioButtons(\n    options=['USA', 'Canada', 'Mexico'], value='Canada', description='Country:'\n)\nradio_buttons\n</pre> radio_buttons = widgets.RadioButtons(     options=['USA', 'Canada', 'Mexico'], value='Canada', description='Country:' ) radio_buttons In\u00a0[\u00a0]: Copied! <pre>radio_buttons.value\n</pre> radio_buttons.value In\u00a0[\u00a0]: Copied! <pre>text = widgets.Text(\n    value='USA',\n    placeholder='Enter a country name',\n    description='Country:',\n    disabled=False,\n)\ntext\n</pre> text = widgets.Text(     value='USA',     placeholder='Enter a country name',     description='Country:',     disabled=False, ) text In\u00a0[\u00a0]: Copied! <pre>text.value\n</pre> text.value In\u00a0[\u00a0]: Copied! <pre>widgets.Textarea(\n    value='Hello World',\n    placeholder='Type something',\n    description='String:',\n    disabled=False,\n)\n</pre> widgets.Textarea(     value='Hello World',     placeholder='Type something',     description='String:',     disabled=False, ) In\u00a0[\u00a0]: Copied! <pre>widgets.HTML(\n    value=\"Hello &lt;b&gt;World&lt;/b&gt;\",\n    placeholder='Some HTML',\n    description='Some HTML',\n)\n</pre> widgets.HTML(     value=\"Hello World\",     placeholder='Some HTML',     description='Some HTML', ) In\u00a0[\u00a0]: Copied! <pre>widgets.HTML(\n    value='&lt;img src=\"https://earthengine.google.com/static/images/earth-engine-logo.png\" width=\"100\" height=\"100\"&gt;'\n)\n</pre> widgets.HTML(     value='' ) In\u00a0[\u00a0]: Copied! <pre>button = widgets.Button(\n    description='Click me',\n    button_style='info',  # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click me',\n    icon='check',  # (FontAwesome names without the `fa-` prefix)\n)\nbutton\n</pre> button = widgets.Button(     description='Click me',     button_style='info',  # 'success', 'info', 'warning', 'danger' or ''     tooltip='Click me',     icon='check',  # (FontAwesome names without the `fa-` prefix) ) button In\u00a0[\u00a0]: Copied! <pre>date_picker = widgets.DatePicker(description='Pick a Date', disabled=False)\ndate_picker\n</pre> date_picker = widgets.DatePicker(description='Pick a Date', disabled=False) date_picker In\u00a0[\u00a0]: Copied! <pre>date_picker.value\n</pre> date_picker.value In\u00a0[\u00a0]: Copied! <pre>color_picker = widgets.ColorPicker(\n    concise=False, description='Pick a color', value='blue', disabled=False\n)\ncolor_picker\n</pre> color_picker = widgets.ColorPicker(     concise=False, description='Pick a color', value='blue', disabled=False ) color_picker In\u00a0[\u00a0]: Copied! <pre>color_picker.value\n</pre> color_picker.value In\u00a0[\u00a0]: Copied! <pre>out = widgets.Output(layout={'border': '1px solid black'})\nout\n</pre> out = widgets.Output(layout={'border': '1px solid black'}) out In\u00a0[\u00a0]: Copied! <pre>with out:\n    for i in range(10):\n        print(i, 'Hello world!')\n</pre> with out:     for i in range(10):         print(i, 'Hello world!') In\u00a0[\u00a0]: Copied! <pre>from IPython.display import YouTubeVideo\n\nout.clear_output()\nwith out:\n    display(YouTubeVideo('7qRtsTCnnSM'))\nout\n</pre> from IPython.display import YouTubeVideo  out.clear_output() with out:     display(YouTubeVideo('7qRtsTCnnSM')) out In\u00a0[\u00a0]: Copied! <pre>out.clear_output()\nwith out:\n    display(widgets.IntSlider())\nout\n</pre> out.clear_output() with out:     display(widgets.IntSlider()) out In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nfc = ee.FeatureCollection('TIGER/2018/States')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'DEM')\nMap.addLayer(fc, {}, 'US States')\n\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') fc = ee.FeatureCollection('TIGER/2018/States') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'DEM') Map.addLayer(fc, {}, 'US States')  Map In\u00a0[\u00a0]: Copied! <pre>output_widget = widgets.Output(layout={'border': '1px solid black'})\noutput_control = ipyleaflet.WidgetControl(widget=output_widget, position='bottomright')\nMap.add_control(output_control)\n</pre> output_widget = widgets.Output(layout={'border': '1px solid black'}) output_control = ipyleaflet.WidgetControl(widget=output_widget, position='bottomright') Map.add_control(output_control) In\u00a0[\u00a0]: Copied! <pre>with output_widget:\n    print('Nice map!')\n</pre> with output_widget:     print('Nice map!') In\u00a0[\u00a0]: Copied! <pre>output_widget.clear_output()\nlogo = widgets.HTML(\n    value='&lt;img src=\"https://earthengine.google.com/static/images/earth-engine-logo.png\" width=\"100\" height=\"100\"&gt;'\n)\nwith output_widget:\n    display(logo)\n</pre> output_widget.clear_output() logo = widgets.HTML(     value='' ) with output_widget:     display(logo) In\u00a0[\u00a0]: Copied! <pre>def handle_interaction(**kwargs):\n    latlon = kwargs.get('coordinates')\n    if kwargs.get('type') == 'click':\n        Map.default_style = {'cursor': 'wait'}\n        xy = ee.Geometry.Point(latlon[::-1])\n        selected_fc = fc.filterBounds(xy)\n\n        with output_widget:\n            output_widget.clear_output()\n\n            try:\n                name = selected_fc.first().get('NAME').getInfo()\n                usps = selected_fc.first().get('STUSPS').getInfo()\n                Map.layers = Map.layers[:4]\n                geom = selected_fc.geometry()\n                layer_name = name + '-' + usps\n                Map.addLayer(\n                    ee.Image().paint(geom, 0, 2), {'palette': 'red'}, layer_name\n                )\n                print(layer_name)\n            except Exception as e:\n                print('No feature could be found')\n                Map.layers = Map.layers[:4]\n\n        Map.default_style = {'cursor': 'pointer'}\n\n\nMap.on_interaction(handle_interaction)\n</pre> def handle_interaction(**kwargs):     latlon = kwargs.get('coordinates')     if kwargs.get('type') == 'click':         Map.default_style = {'cursor': 'wait'}         xy = ee.Geometry.Point(latlon[::-1])         selected_fc = fc.filterBounds(xy)          with output_widget:             output_widget.clear_output()              try:                 name = selected_fc.first().get('NAME').getInfo()                 usps = selected_fc.first().get('STUSPS').getInfo()                 Map.layers = Map.layers[:4]                 geom = selected_fc.geometry()                 layer_name = name + '-' + usps                 Map.addLayer(                     ee.Image().paint(geom, 0, 2), {'palette': 'red'}, layer_name                 )                 print(layer_name)             except Exception as e:                 print('No feature could be found')                 Map.layers = Map.layers[:4]          Map.default_style = {'cursor': 'pointer'}   Map.on_interaction(handle_interaction)"},{"location":"notebooks/40_ipywidgets/#how-to-add-interactive-widgets-to-the-map","title":"How to add interactive widgets to the map\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#add-earth-engine-data","title":"Add Earth Engine data\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#add-raster-data","title":"Add raster data\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#add-vector-data","title":"Add vector data\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#change-layer-opacity","title":"Change layer opacity\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#widget-list","title":"Widget list\u00b6","text":"<p>https://ipywidgets.readthedocs.io/en/latest/examples/Widget%20List.html</p>"},{"location":"notebooks/40_ipywidgets/#numeric-widgets","title":"Numeric widgets\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#intslider","title":"IntSlider\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#floatslider","title":"FloatSlider\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#intprogress","title":"IntProgress\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#boolean-widgets","title":"Boolean widgets\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#togglebutton","title":"ToggleButton\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#checkbox","title":"Checkbox\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#selection-widgets","title":"Selection widgets\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#dropdown","title":"Dropdown\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#radiobuttons","title":"RadioButtons\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#string-widgets","title":"String widgets\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#text","title":"Text\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#textarea","title":"Textarea\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#html","title":"HTML\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#button","title":"Button\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#date-picker","title":"Date picker\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#color-picker","title":"Color picker\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#output-widget","title":"Output widget\u00b6","text":""},{"location":"notebooks/40_ipywidgets/#add-a-widget-to-the-map","title":"Add a widget to the map\u00b6","text":""},{"location":"notebooks/41_water_app/","title":"41 water app","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre># Check geemap installation\nimport subprocess\n\ntry:\n    import geemap\nexcept ImportError:\n    print('geemap package is not installed. Installing ...')\n    subprocess.check_call([\"python\", '-m', 'pip', 'install', 'geemap'])\n</pre> # Check geemap installation import subprocess  try:     import geemap except ImportError:     print('geemap package is not installed. Installing ...')     subprocess.check_call([\"python\", '-m', 'pip', 'install', 'geemap']) In\u00a0[\u00a0]: Copied! <pre># Import libraries\nimport os\nimport ee\nimport geemap\nimport ipywidgets as widgets\nfrom bqplot import pyplot as plt\nfrom ipyleaflet import WidgetControl\n</pre> # Import libraries import os import ee import geemap import ipywidgets as widgets from bqplot import pyplot as plt from ipyleaflet import WidgetControl In\u00a0[\u00a0]: Copied! <pre># Create an interactive map\nMap = geemap.Map(center=[40, -100], zoom=4, add_google_map=False)\nMap.add_basemap('HYBRID')\nMap.add_basemap('ROADMAP')\n\n# Add Earth Engine data\nfc = ee.FeatureCollection('TIGER/2018/Counties')\nMap.addLayer(fc, {}, 'US Counties')\n\nstates = ee.FeatureCollection('TIGER/2018/States')\n# Map.addLayer(states, {}, 'US States')\n\nMap\n</pre> # Create an interactive map Map = geemap.Map(center=[40, -100], zoom=4, add_google_map=False) Map.add_basemap('HYBRID') Map.add_basemap('ROADMAP')  # Add Earth Engine data fc = ee.FeatureCollection('TIGER/2018/Counties') Map.addLayer(fc, {}, 'US Counties')  states = ee.FeatureCollection('TIGER/2018/States') # Map.addLayer(states, {}, 'US States')  Map In\u00a0[\u00a0]: Copied! <pre># Designe interactive widgets\n\nstyle = {'description_width': 'initial'}\n\noutput_widget = widgets.Output(layout={'border': '1px solid black'})\noutput_control = WidgetControl(widget=output_widget, position='bottomright')\nMap.add_control(output_control)\n\nadmin1_widget = widgets.Text(\n    description='State:', value='Tennessee', width=200, style=style\n)\n\nadmin2_widget = widgets.Text(\n    description='County:', value='Knox', width=300, style=style\n)\n\naoi_widget = widgets.Checkbox(\n    value=False, description='Use user-drawn AOI', style=style\n)\n\ndownload_widget = widgets.Checkbox(\n    value=False, description='Download chart data', style=style\n)\n\n\ndef aoi_change(change):\n    Map.layers = Map.layers[:4]\n    Map.user_roi = None\n    Map.user_rois = None\n    Map.draw_count = 0\n    admin1_widget.value = ''\n    admin2_widget.value = ''\n    output_widget.clear_output()\n\n\naoi_widget.observe(aoi_change, names='value')\n\nband_combo = widgets.Dropdown(\n    description='Band combo:',\n    options=[\n        'Red/Green/Blue',\n        'NIR/Red/Green',\n        'SWIR2/SWIR1/NIR',\n        'NIR/SWIR1/Red',\n        'SWIR2/NIR/Red',\n        'SWIR2/SWIR1/Red',\n        'SWIR1/NIR/Blue',\n        'NIR/SWIR1/Blue',\n        'SWIR2/NIR/Green',\n        'SWIR1/NIR/Red',\n    ],\n    value='NIR/Red/Green',\n    style=style,\n)\n\nyear_widget = widgets.IntSlider(\n    min=1984, max=2020, value=2010, description='Selected year:', width=400, style=style\n)\n\nfmask_widget = widgets.Checkbox(\n    value=True, description='Apply fmask(remove cloud, shadow, snow)', style=style\n)\n\n\n# Normalized Satellite Indices: https://www.usna.edu/Users/oceano/pguth/md_help/html/norm_sat.htm\n\nnd_options = [\n    'Vegetation Index (NDVI)',\n    'Water Index (NDWI)',\n    'Modified Water Index (MNDWI)',\n    'Snow Index (NDSI)',\n    'Soil Index (NDSI)',\n    'Burn Ratio (NBR)',\n    'Customized',\n]\nnd_indices = widgets.Dropdown(\n    options=nd_options,\n    value='Modified Water Index (MNDWI)',\n    description='Normalized Difference Index:',\n    style=style,\n)\n\nfirst_band = widgets.Dropdown(\n    description='1st band:',\n    options=['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'],\n    value='Green',\n    style=style,\n)\n\nsecond_band = widgets.Dropdown(\n    description='2nd band:',\n    options=['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'],\n    value='SWIR1',\n    style=style,\n)\n\nnd_threshold = widgets.FloatSlider(\n    value=0,\n    min=-1,\n    max=1,\n    step=0.01,\n    description='Threshold:',\n    orientation='horizontal',\n    style=style,\n)\n\nnd_color = widgets.ColorPicker(\n    concise=False, description='Color:', value='blue', style=style\n)\n\n\ndef nd_index_change(change):\n    if nd_indices.value == 'Vegetation Index (NDVI)':\n        first_band.value = 'NIR'\n        second_band.value = 'Red'\n    elif nd_indices.value == 'Water Index (NDWI)':\n        first_band.value = 'NIR'\n        second_band.value = 'SWIR1'\n    elif nd_indices.value == 'Modified Water Index (MNDWI)':\n        first_band.value = 'Green'\n        second_band.value = 'SWIR1'\n    elif nd_indices.value == 'Snow Index (NDSI)':\n        first_band.value = 'Green'\n        second_band.value = 'SWIR1'\n    elif nd_indices.value == 'Soil Index (NDSI)':\n        first_band.value = 'SWIR1'\n        second_band.value = 'NIR'\n    elif nd_indices.value == 'Burn Ratio (NBR)':\n        first_band.value = 'NIR'\n        second_band.value = 'SWIR2'\n    elif nd_indices.value == 'Customized':\n        first_band.value = None\n        second_band.value = None\n\n\nnd_indices.observe(nd_index_change, names='value')\n\nsubmit = widgets.Button(\n    description='Submit', button_style='primary', tooltip='Click me', style=style\n)\n\nfull_widget = widgets.VBox(\n    [\n        widgets.HBox([admin1_widget, admin2_widget, aoi_widget, download_widget]),\n        widgets.HBox([band_combo, year_widget, fmask_widget]),\n        widgets.HBox([nd_indices, first_band, second_band, nd_threshold, nd_color]),\n        submit,\n    ]\n)\n\nfull_widget\n</pre> # Designe interactive widgets  style = {'description_width': 'initial'}  output_widget = widgets.Output(layout={'border': '1px solid black'}) output_control = WidgetControl(widget=output_widget, position='bottomright') Map.add_control(output_control)  admin1_widget = widgets.Text(     description='State:', value='Tennessee', width=200, style=style )  admin2_widget = widgets.Text(     description='County:', value='Knox', width=300, style=style )  aoi_widget = widgets.Checkbox(     value=False, description='Use user-drawn AOI', style=style )  download_widget = widgets.Checkbox(     value=False, description='Download chart data', style=style )   def aoi_change(change):     Map.layers = Map.layers[:4]     Map.user_roi = None     Map.user_rois = None     Map.draw_count = 0     admin1_widget.value = ''     admin2_widget.value = ''     output_widget.clear_output()   aoi_widget.observe(aoi_change, names='value')  band_combo = widgets.Dropdown(     description='Band combo:',     options=[         'Red/Green/Blue',         'NIR/Red/Green',         'SWIR2/SWIR1/NIR',         'NIR/SWIR1/Red',         'SWIR2/NIR/Red',         'SWIR2/SWIR1/Red',         'SWIR1/NIR/Blue',         'NIR/SWIR1/Blue',         'SWIR2/NIR/Green',         'SWIR1/NIR/Red',     ],     value='NIR/Red/Green',     style=style, )  year_widget = widgets.IntSlider(     min=1984, max=2020, value=2010, description='Selected year:', width=400, style=style )  fmask_widget = widgets.Checkbox(     value=True, description='Apply fmask(remove cloud, shadow, snow)', style=style )   # Normalized Satellite Indices: https://www.usna.edu/Users/oceano/pguth/md_help/html/norm_sat.htm  nd_options = [     'Vegetation Index (NDVI)',     'Water Index (NDWI)',     'Modified Water Index (MNDWI)',     'Snow Index (NDSI)',     'Soil Index (NDSI)',     'Burn Ratio (NBR)',     'Customized', ] nd_indices = widgets.Dropdown(     options=nd_options,     value='Modified Water Index (MNDWI)',     description='Normalized Difference Index:',     style=style, )  first_band = widgets.Dropdown(     description='1st band:',     options=['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'],     value='Green',     style=style, )  second_band = widgets.Dropdown(     description='2nd band:',     options=['Blue', 'Green', 'Red', 'NIR', 'SWIR1', 'SWIR2'],     value='SWIR1',     style=style, )  nd_threshold = widgets.FloatSlider(     value=0,     min=-1,     max=1,     step=0.01,     description='Threshold:',     orientation='horizontal',     style=style, )  nd_color = widgets.ColorPicker(     concise=False, description='Color:', value='blue', style=style )   def nd_index_change(change):     if nd_indices.value == 'Vegetation Index (NDVI)':         first_band.value = 'NIR'         second_band.value = 'Red'     elif nd_indices.value == 'Water Index (NDWI)':         first_band.value = 'NIR'         second_band.value = 'SWIR1'     elif nd_indices.value == 'Modified Water Index (MNDWI)':         first_band.value = 'Green'         second_band.value = 'SWIR1'     elif nd_indices.value == 'Snow Index (NDSI)':         first_band.value = 'Green'         second_band.value = 'SWIR1'     elif nd_indices.value == 'Soil Index (NDSI)':         first_band.value = 'SWIR1'         second_band.value = 'NIR'     elif nd_indices.value == 'Burn Ratio (NBR)':         first_band.value = 'NIR'         second_band.value = 'SWIR2'     elif nd_indices.value == 'Customized':         first_band.value = None         second_band.value = None   nd_indices.observe(nd_index_change, names='value')  submit = widgets.Button(     description='Submit', button_style='primary', tooltip='Click me', style=style )  full_widget = widgets.VBox(     [         widgets.HBox([admin1_widget, admin2_widget, aoi_widget, download_widget]),         widgets.HBox([band_combo, year_widget, fmask_widget]),         widgets.HBox([nd_indices, first_band, second_band, nd_threshold, nd_color]),         submit,     ] )  full_widget In\u00a0[\u00a0]: Copied! <pre># Capture user interaction with the map\n\n\ndef handle_interaction(**kwargs):\n    latlon = kwargs.get('coordinates')\n    if kwargs.get('type') == 'click' and not aoi_widget.value:\n        Map.default_style = {'cursor': 'wait'}\n        xy = ee.Geometry.Point(latlon[::-1])\n        selected_fc = fc.filterBounds(xy)\n\n        with output_widget:\n            output_widget.clear_output()\n\n            try:\n                feature = selected_fc.first()\n                admin2_id = feature.get('NAME').getInfo()\n                statefp = feature.get('STATEFP')\n                admin1_fc = ee.Feature(\n                    states.filter(ee.Filter.eq('STATEFP', statefp)).first()\n                )\n                admin1_id = admin1_fc.get('NAME').getInfo()\n                admin1_widget.value = admin1_id\n                admin2_widget.value = admin2_id\n                Map.layers = Map.layers[:4]\n                geom = selected_fc.geometry()\n                layer_name = admin1_id + '-' + admin2_id\n                Map.addLayer(\n                    ee.Image().paint(geom, 0, 2), {'palette': 'red'}, layer_name\n                )\n                print(layer_name)\n            except:\n                print('No feature could be found')\n                Map.layers = Map.layers[:4]\n\n        Map.default_style = {'cursor': 'pointer'}\n    else:\n        Map.draw_count = 0\n\n\nMap.on_interaction(handle_interaction)\n</pre> # Capture user interaction with the map   def handle_interaction(**kwargs):     latlon = kwargs.get('coordinates')     if kwargs.get('type') == 'click' and not aoi_widget.value:         Map.default_style = {'cursor': 'wait'}         xy = ee.Geometry.Point(latlon[::-1])         selected_fc = fc.filterBounds(xy)          with output_widget:             output_widget.clear_output()              try:                 feature = selected_fc.first()                 admin2_id = feature.get('NAME').getInfo()                 statefp = feature.get('STATEFP')                 admin1_fc = ee.Feature(                     states.filter(ee.Filter.eq('STATEFP', statefp)).first()                 )                 admin1_id = admin1_fc.get('NAME').getInfo()                 admin1_widget.value = admin1_id                 admin2_widget.value = admin2_id                 Map.layers = Map.layers[:4]                 geom = selected_fc.geometry()                 layer_name = admin1_id + '-' + admin2_id                 Map.addLayer(                     ee.Image().paint(geom, 0, 2), {'palette': 'red'}, layer_name                 )                 print(layer_name)             except:                 print('No feature could be found')                 Map.layers = Map.layers[:4]          Map.default_style = {'cursor': 'pointer'}     else:         Map.draw_count = 0   Map.on_interaction(handle_interaction) In\u00a0[\u00a0]: Copied! <pre># Click event handler\n\n\ndef submit_clicked(b):\n    with output_widget:\n        output_widget.clear_output()\n        print('Computing...')\n        Map.default_style = {'cursor': 'wait'}\n\n        try:\n            admin1_id = admin1_widget.value\n            admin2_id = admin2_widget.value\n            band1 = first_band.value\n            band2 = second_band.value\n            selected_year = year_widget.value\n            threshold = nd_threshold.value\n            bands = band_combo.value.split('/')\n            apply_fmask = fmask_widget.value\n            palette = nd_color.value\n            use_aoi = aoi_widget.value\n            download = download_widget.value\n\n            if use_aoi:\n                if Map.user_roi is not None:\n                    roi = Map.user_roi\n                    layer_name = 'User drawn AOI'\n                    geom = roi\n                else:\n                    output_widget.clear_output()\n                    print('No user AOI could be found.')\n                    return\n            else:\n                statefp = ee.Feature(\n                    states.filter(ee.Filter.eq('NAME', admin1_id)).first()\n                ).get('STATEFP')\n                roi = fc.filter(\n                    ee.Filter.And(\n                        ee.Filter.eq('NAME', admin2_id),\n                        ee.Filter.eq('STATEFP', statefp),\n                    )\n                )\n                layer_name = admin1_id + '-' + admin2_id\n                geom = roi.geometry()\n\n            Map.layers = Map.layers[:4]\n            Map.addLayer(ee.Image().paint(geom, 0, 2), {'palette': 'red'}, layer_name)\n\n            images = geemap.landsat_timeseries(\n                roi=roi,\n                start_year=1984,\n                end_year=2020,\n                start_date='01-01',\n                end_date='12-31',\n                apply_fmask=apply_fmask,\n            )\n            nd_images = images.map(lambda img: img.normalizedDifference([band1, band2]))\n            result_images = nd_images.map(lambda img: img.gt(threshold))\n\n            selected_image = ee.Image(\n                images.toList(images.size()).get(selected_year - 1984)\n            )\n            selected_result_image = ee.Image(\n                result_images.toList(result_images.size()).get(selected_year - 1984)\n            ).selfMask()\n\n            vis_params = {'bands': bands, 'min': 0, 'max': 3000}\n\n            Map.addLayer(selected_image, vis_params, 'Landsat ' + str(selected_year))\n            Map.addLayer(\n                selected_result_image,\n                {'palette': palette},\n                'Result ' + str(selected_year),\n            )\n\n            def cal_area(img):\n                pixel_area = img.multiply(ee.Image.pixelArea()).divide(1e4)\n                img_area = pixel_area.reduceRegion(\n                    **{\n                        'geometry': geom,\n                        'reducer': ee.Reducer.sum(),\n                        'scale': 1000,\n                        'maxPixels': 1e12,\n                        'bestEffort': True,\n                    }\n                )\n                return img.set({'area': img_area})\n\n            areas = result_images.map(cal_area)\n            stats = areas.aggregate_array('area').getInfo()\n            x = list(range(1984, 2021))\n            y = [item.get('nd') for item in stats]\n\n            fig = plt.figure(1)\n            fig.layout.height = '270px'\n            plt.clear()\n            plt.plot(x, y)\n            plt.title('Temporal trend (1984-2020)')\n            plt.xlabel('Year')\n            plt.ylabel('Area (ha)')\n\n            output_widget.clear_output()\n\n            plt.show()\n\n            if download:\n                out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\n                out_name = 'chart_' + geemap.random_string() + '.csv'\n                out_csv = os.path.join(out_dir, out_name)\n                if not os.path.exists(out_dir):\n                    os.makedirs(out_dir)\n                with open(out_csv, 'w') as f:\n                    f.write('year, area (ha)\\n')\n                    for index, item in enumerate(x):\n                        line = '{},{:.2f}\\n'.format(item, y[index])\n                        f.write(line)\n                link = geemap.create_download_link(\n                    out_csv, title=\"Click here to download the chart data: \"\n                )\n                display(link)\n\n        except Exception as e:\n            print(e)\n            print('An error occurred during computation.')\n\n        Map.default_style = {'cursor': 'default'}\n\n\nsubmit.on_click(submit_clicked)\n</pre> # Click event handler   def submit_clicked(b):     with output_widget:         output_widget.clear_output()         print('Computing...')         Map.default_style = {'cursor': 'wait'}          try:             admin1_id = admin1_widget.value             admin2_id = admin2_widget.value             band1 = first_band.value             band2 = second_band.value             selected_year = year_widget.value             threshold = nd_threshold.value             bands = band_combo.value.split('/')             apply_fmask = fmask_widget.value             palette = nd_color.value             use_aoi = aoi_widget.value             download = download_widget.value              if use_aoi:                 if Map.user_roi is not None:                     roi = Map.user_roi                     layer_name = 'User drawn AOI'                     geom = roi                 else:                     output_widget.clear_output()                     print('No user AOI could be found.')                     return             else:                 statefp = ee.Feature(                     states.filter(ee.Filter.eq('NAME', admin1_id)).first()                 ).get('STATEFP')                 roi = fc.filter(                     ee.Filter.And(                         ee.Filter.eq('NAME', admin2_id),                         ee.Filter.eq('STATEFP', statefp),                     )                 )                 layer_name = admin1_id + '-' + admin2_id                 geom = roi.geometry()              Map.layers = Map.layers[:4]             Map.addLayer(ee.Image().paint(geom, 0, 2), {'palette': 'red'}, layer_name)              images = geemap.landsat_timeseries(                 roi=roi,                 start_year=1984,                 end_year=2020,                 start_date='01-01',                 end_date='12-31',                 apply_fmask=apply_fmask,             )             nd_images = images.map(lambda img: img.normalizedDifference([band1, band2]))             result_images = nd_images.map(lambda img: img.gt(threshold))              selected_image = ee.Image(                 images.toList(images.size()).get(selected_year - 1984)             )             selected_result_image = ee.Image(                 result_images.toList(result_images.size()).get(selected_year - 1984)             ).selfMask()              vis_params = {'bands': bands, 'min': 0, 'max': 3000}              Map.addLayer(selected_image, vis_params, 'Landsat ' + str(selected_year))             Map.addLayer(                 selected_result_image,                 {'palette': palette},                 'Result ' + str(selected_year),             )              def cal_area(img):                 pixel_area = img.multiply(ee.Image.pixelArea()).divide(1e4)                 img_area = pixel_area.reduceRegion(                     **{                         'geometry': geom,                         'reducer': ee.Reducer.sum(),                         'scale': 1000,                         'maxPixels': 1e12,                         'bestEffort': True,                     }                 )                 return img.set({'area': img_area})              areas = result_images.map(cal_area)             stats = areas.aggregate_array('area').getInfo()             x = list(range(1984, 2021))             y = [item.get('nd') for item in stats]              fig = plt.figure(1)             fig.layout.height = '270px'             plt.clear()             plt.plot(x, y)             plt.title('Temporal trend (1984-2020)')             plt.xlabel('Year')             plt.ylabel('Area (ha)')              output_widget.clear_output()              plt.show()              if download:                 out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')                 out_name = 'chart_' + geemap.random_string() + '.csv'                 out_csv = os.path.join(out_dir, out_name)                 if not os.path.exists(out_dir):                     os.makedirs(out_dir)                 with open(out_csv, 'w') as f:                     f.write('year, area (ha)\\n')                     for index, item in enumerate(x):                         line = '{},{:.2f}\\n'.format(item, y[index])                         f.write(line)                 link = geemap.create_download_link(                     out_csv, title=\"Click here to download the chart data: \"                 )                 display(link)          except Exception as e:             print(e)             print('An error occurred during computation.')          Map.default_style = {'cursor': 'default'}   submit.on_click(submit_clicked)"},{"location":"notebooks/41_water_app/#using-earth-engine-and-geemap-for-mapping-surface-water-dynamics","title":"Using Earth Engine and geemap for mapping surface water dynamics\u00b6","text":"<p>Steps to create Landsat timeseries:</p> <ol> <li>Pan and zoom to your area of interest (AOI), and click on the map to select a polygon. Alternatively, you can enable <code>Use user-drawn AOI</code> and use the Drawing tools (e.g., rectangle) to draw a shape on the map.</li> <li>Adjust the parameters (e.g., band combination, threshold, color, download chart data) if needed.</li> <li>Click the <code>Submit</code> button to create timeseries of Landsat imagery and normalized difference indices.</li> </ol> <p>Contact: Dr. Qiusheng Wu (Website, LinkedIn, Twitter, YouTube)</p>"},{"location":"notebooks/42_upload_data/","title":"42 upload data","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\nimport ipywidgets as widgets\nfrom ipyleaflet import WidgetControl\n</pre> import os import ee import geemap import ipywidgets as widgets from ipyleaflet import WidgetControl In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4, height='750px')\n</pre> Map = geemap.Map(center=(40, -100), zoom=4, height='750px') In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.7)\n\nMap\n</pre> # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003')  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.7)  Map In\u00a0[\u00a0]: Copied! <pre>output_widget = widgets.Output(layout={'border': '1px solid black'})\noutput_control = WidgetControl(widget=output_widget, position='bottomright')\nMap.add_control(output_control)\n</pre> output_widget = widgets.Output(layout={'border': '1px solid black'}) output_control = WidgetControl(widget=output_widget, position='bottomright') Map.add_control(output_control) In\u00a0[\u00a0]: Copied! <pre>style = {'description_width': 'initial'}\nuploader = widgets.FileUpload(\n    description='Upload data',\n    accept='.zip, .json, .geojson',\n    multiple=False,\n    button_style='primary',\n    style=style,\n)\n\nsubmit = widgets.Button(\n    description='Display data', button_style='success', tooltip='Click me', style=style\n)\n\nreset = widgets.Button(\n    description='Reset', button_style='warning', tooltip='Click me', style=style\n)\n</pre> style = {'description_width': 'initial'} uploader = widgets.FileUpload(     description='Upload data',     accept='.zip, .json, .geojson',     multiple=False,     button_style='primary',     style=style, )  submit = widgets.Button(     description='Display data', button_style='success', tooltip='Click me', style=style )  reset = widgets.Button(     description='Reset', button_style='warning', tooltip='Click me', style=style ) In\u00a0[\u00a0]: Copied! <pre>with output_widget:\n    print('Upload shapefile or \\ngeojson as a zip file')\n    display(uploader)\n    display(submit)\n    display(reset)\n</pre> with output_widget:     print('Upload shapefile or \\ngeojson as a zip file')     display(uploader)     display(submit)     display(reset) In\u00a0[\u00a0]: Copied! <pre>def get_vector(upload_widget, out_dir=None):\n    import zipfile\n    import glob\n\n    if out_dir is None:\n        out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    vector = None\n\n    try:\n        [uploaded_file] = upload_widget.value\n        file = upload_widget.value[0]\n        name = file['name']\n        content = file['content']\n        out_file = os.path.join(out_dir, name)\n        with open(out_file, \"wb\") as fp:\n            fp.write(content)\n\n        if name.endswith('.zip'):\n            with zipfile.ZipFile(out_file, \"r\") as zip_ref:\n                extract_dir = os.path.join(\n                    out_dir, name[:-4] + \"_\" + geemap.random_string(3)\n                )\n                zip_ref.extractall(extract_dir)\n                files = glob.glob(extract_dir + '/*.shp')\n                if len(files) &gt; 0:\n                    shp = files[0]\n                    vector = geemap.shp_to_ee(shp)\n                else:\n                    files = glob.glob(extract_dir + '/*.geojson')\n                    if len(files) &gt; 0:\n                        geojson = files[0]\n                        vector = geemap.geojson_to_ee(geojson)\n        else:\n            vector = geemap.geojson_to_ee(out_file)\n\n    except Exception as e:\n        print(e)\n\n    return vector\n</pre> def get_vector(upload_widget, out_dir=None):     import zipfile     import glob      if out_dir is None:         out_dir = os.path.join(os.path.expanduser('~'), 'Downloads')     if not os.path.exists(out_dir):         os.makedirs(out_dir)      vector = None      try:         [uploaded_file] = upload_widget.value         file = upload_widget.value[0]         name = file['name']         content = file['content']         out_file = os.path.join(out_dir, name)         with open(out_file, \"wb\") as fp:             fp.write(content)          if name.endswith('.zip'):             with zipfile.ZipFile(out_file, \"r\") as zip_ref:                 extract_dir = os.path.join(                     out_dir, name[:-4] + \"_\" + geemap.random_string(3)                 )                 zip_ref.extractall(extract_dir)                 files = glob.glob(extract_dir + '/*.shp')                 if len(files) &gt; 0:                     shp = files[0]                     vector = geemap.shp_to_ee(shp)                 else:                     files = glob.glob(extract_dir + '/*.geojson')                     if len(files) &gt; 0:                         geojson = files[0]                         vector = geemap.geojson_to_ee(geojson)         else:             vector = geemap.geojson_to_ee(out_file)      except Exception as e:         print(e)      return vector In\u00a0[\u00a0]: Copied! <pre>def submit_clicked(b):\n    if len(uploader.value) &gt; 0:\n        Map.default_style = {'cursor': 'wait'}\n        try:\n            fc = get_vector(uploader)\n            layer_name = 'Layer ' + geemap.random_string(3)\n            Map.addLayer(fc, {}, layer_name)\n            Map.centerObject(fc)\n            uploader.value = ()\n        except Exception as e:\n            print(e)\n        Map.default_style = {'cursor': 'pointer'}\n\n\nsubmit.on_click(submit_clicked)\n\n\ndef reset_clicked(b):\n    Map.layers = Map.layers[:3]\n    output_widget.clear_output()\n    with output_widget:\n        print('Upload shapefile or \\ngeojson as a zip file')\n        display(uploader)\n        display(submit)\n        display(reset)\n    uploader.value = ()\n\n\nreset.on_click(reset_clicked)\n</pre> def submit_clicked(b):     if len(uploader.value) &gt; 0:         Map.default_style = {'cursor': 'wait'}         try:             fc = get_vector(uploader)             layer_name = 'Layer ' + geemap.random_string(3)             Map.addLayer(fc, {}, layer_name)             Map.centerObject(fc)             uploader.value = ()         except Exception as e:             print(e)         Map.default_style = {'cursor': 'pointer'}   submit.on_click(submit_clicked)   def reset_clicked(b):     Map.layers = Map.layers[:3]     output_widget.clear_output()     with output_widget:         print('Upload shapefile or \\ngeojson as a zip file')         display(uploader)         display(submit)         display(reset)     uploader.value = ()   reset.on_click(reset_clicked)"},{"location":"notebooks/43_extract_values_to_points/","title":"43 extract values to points","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap <p>Upgrade geemap to the latest version</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(\n    landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7'\n)\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\n</pre> # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(     landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7' ) Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) <p>Download sample data</p> In\u00a0[\u00a0]: Copied! <pre>work_dir = os.path.expanduser('~/Downloads')\nin_shp = os.path.join(work_dir, 'us_cities.shp')\nif not os.path.exists(in_shp):\n    data_url = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip'\n    geemap.download_from_url(data_url, out_dir=work_dir)\n</pre> work_dir = os.path.expanduser('~/Downloads') in_shp = os.path.join(work_dir, 'us_cities.shp') if not os.path.exists(in_shp):     data_url = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip'     geemap.download_from_url(data_url, out_dir=work_dir) In\u00a0[\u00a0]: Copied! <pre>in_fc = geemap.shp_to_ee(in_shp)\nMap.addLayer(in_fc, {}, 'Cities')\n</pre> in_fc = geemap.shp_to_ee(in_shp) Map.addLayer(in_fc, {}, 'Cities') <p>Export pixel values as a shapefile</p> In\u00a0[\u00a0]: Copied! <pre>out_shp = os.path.join(work_dir, 'dem.shp')\ngeemap.extract_values_to_points(in_fc, dem, out_shp)\n</pre> out_shp = os.path.join(work_dir, 'dem.shp') geemap.extract_values_to_points(in_fc, dem, out_shp) <p>Export pixel values as a csv</p> In\u00a0[\u00a0]: Copied! <pre>out_csv = os.path.join(work_dir, 'landsat.csv')\ngeemap.extract_values_to_points(in_fc, landsat7, out_csv)\n</pre> out_csv = os.path.join(work_dir, 'landsat.csv') geemap.extract_values_to_points(in_fc, landsat7, out_csv)"},{"location":"notebooks/44_cog_stac/","title":"44 cog stac","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre>os.environ['TITILER_ENDPOINT'] = 'https://titiler.xyz'\n</pre> os.environ['TITILER_ENDPOINT'] = 'https://titiler.xyz' In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>url = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\n</pre> url = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif' In\u00a0[\u00a0]: Copied! <pre>geemap.cog_bounds(url)\n</pre> geemap.cog_bounds(url) In\u00a0[\u00a0]: Copied! <pre>geemap.cog_center(url)\n</pre> geemap.cog_center(url) In\u00a0[\u00a0]: Copied! <pre>geemap.cog_bands(url)\n</pre> geemap.cog_bands(url) In\u00a0[\u00a0]: Copied! <pre>geemap.cog_tile(url)\n</pre> geemap.cog_tile(url) In\u00a0[\u00a0]: Copied! <pre>Map.add_cog_layer(url, name=\"Fire (pre-event)\")\n</pre> Map.add_cog_layer(url, name=\"Fire (pre-event)\") In\u00a0[\u00a0]: Copied! <pre>url2 = 'https://opendata.digitalglobe.com/events/california-fire-2020/post-event/2020-08-14/pine-gulch-fire20/10300100AAC8DD00.tif'\n</pre> url2 = 'https://opendata.digitalglobe.com/events/california-fire-2020/post-event/2020-08-14/pine-gulch-fire20/10300100AAC8DD00.tif' In\u00a0[\u00a0]: Copied! <pre>Map.add_cog_layer(url2, name=\"Fire (post-event)\")\n</pre> Map.add_cog_layer(url2, name=\"Fire (post-event)\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>url = 'https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json'\n</pre> url = 'https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json' In\u00a0[\u00a0]: Copied! <pre>geemap.stac_bounds(url)\n</pre> geemap.stac_bounds(url) In\u00a0[\u00a0]: Copied! <pre>geemap.stac_center(url)\n</pre> geemap.stac_center(url) In\u00a0[\u00a0]: Copied! <pre>geemap.stac_bands(url)\n</pre> geemap.stac_bands(url) In\u00a0[\u00a0]: Copied! <pre>geemap.stac_tile(url, bands=['B3', 'B2', 'B1'])\n</pre> geemap.stac_tile(url, bands=['B3', 'B2', 'B1']) In\u00a0[\u00a0]: Copied! <pre>Map.add_stac_layer(url, bands=['pan'], name='Panchromatic')\n</pre> Map.add_stac_layer(url, bands=['pan'], name='Panchromatic') In\u00a0[\u00a0]: Copied! <pre>Map.add_stac_layer(url, bands=['B3', 'B2', 'B1'], name='False color')\n</pre> Map.add_stac_layer(url, bands=['B3', 'B2', 'B1'], name='False color')"},{"location":"notebooks/44_cog_stac/#working-with-cloud-optimized-geotiff-cog","title":"Working with Cloud Optimized GeoTIFF (COG)\u00b6","text":"<p>A Cloud Optimized GeoTIFF (COG) is a regular GeoTIFF file, aimed at being hosted on a HTTP file server, with an internal organization that enables more efficient workflows on the cloud. It does this by leveraging the ability of clients issuing HTTP GET range requests to ask for just the parts of a file they need.</p> <p>More information about COG can be found at https://www.cogeo.org/in-depth.html</p> <p>Some publicly available Cloud Optimized GeoTIFFs:</p> <ul> <li>https://stacindex.org/</li> <li>https://cloud.google.com/storage/docs/public-datasets/landsat</li> <li>https://www.digitalglobe.com/ecosystem/open-data</li> <li>https://earthexplorer.usgs.gov/</li> </ul> <p>For this demo, we will use data from https://www.maxar.com/open-data/california-colorado-fires for mapping California and Colorado fires. A List of COGs can be found here.</p>"},{"location":"notebooks/44_cog_stac/#working-with-spatiotemporal-asset-catalog-stac","title":"Working with  SpatioTemporal Asset Catalog (STAC)\u00b6","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification provides a common language to describe a range of geospatial information, so it can more easily be indexed and discovered. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. The initial focus is primarily remotely-sensed imagery (from satellites, but also planes, drones, balloons, etc), but the core is designed to be extensible to SAR, full motion video, point clouds, hyperspectral, LiDAR and derived data like NDVI, Digital Elevation Models, mosaics, etc. More information about STAC can be found at https://stacspec.org/</p> <p>Some publicly available SpatioTemporal Asset Catalog (STAC):</p> <ul> <li>https://stacindex.org</li> </ul> <p>For this demo, we will use STAC assets from https://stacindex.org/catalogs/spot-orthoimages-canada-2005#/?t=catalogs</p>"},{"location":"notebooks/45_cog_mosaic/","title":"45 cog mosaic","text":"<p>Uncomment the following line to install geemap if needed.</p> <p>Important Note: This notebook no longer works. The <code>add_cog_mosaic()</code> has been removed from geemap. See https://github.com/giswqs/leafmap/issues/180</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(ee_initialize=False, layer_ctrl=True, toolbar_ctrl=False)\nMap\n</pre> Map = geemap.Map(ee_initialize=False, layer_ctrl=True, toolbar_ctrl=False) Map <p>For this demo, we will use data from https://www.maxar.com/open-data/california-colorado-fires for mapping California and Colorado fires. A List of COGs can be found here.</p> In\u00a0[\u00a0]: Copied! <pre>URL = (\n    'https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/cog_files.txt'\n)\n</pre> URL = (     'https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/cog_files.txt' ) In\u00a0[\u00a0]: Copied! <pre>import urllib\n\ndata = urllib.request.urlopen(URL)\nlinks = []\nfor line in data:\n    links.append(line.decode(\"utf-8\").strip())\n</pre> import urllib  data = urllib.request.urlopen(URL) links = [] for line in data:     links.append(line.decode(\"utf-8\").strip()) In\u00a0[\u00a0]: Copied! <pre>links = links[1:]  # remove the first line that does not contain .tif\n</pre> links = links[1:]  # remove the first line that does not contain .tif In\u00a0[\u00a0]: Copied! <pre># links\n</pre> # links In\u00a0[\u00a0]: Copied! <pre>Map.add_cog_mosaic(links, name=\"CA Fire\", show_footprints=True, verbose=True)\n</pre> Map.add_cog_mosaic(links, name=\"CA Fire\", show_footprints=True, verbose=True) In\u00a0[\u00a0]: Copied! <pre>Map.addLayerControl()\nMap\n</pre> Map.addLayerControl() Map"},{"location":"notebooks/46_local_rf_training/","title":"46 local rf training","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap scikit-learn\n</pre> # !pip install geemap scikit-learn In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport pandas as pd\n\nfrom geemap import ml\nfrom sklearn import ensemble\n</pre> import ee import geemap import pandas as pd  from geemap import ml from sklearn import ensemble In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre># read the feature table to train our RandomForest model\n# data taken from ee.FeatureCollection('GOOGLE/EE/DEMOS/demo_landcover_labels')\n\nurl = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/rf_example.csv\"\ndf = pd.read_csv(url)\n</pre> # read the feature table to train our RandomForest model # data taken from ee.FeatureCollection('GOOGLE/EE/DEMOS/demo_landcover_labels')  url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/rf_example.csv\" df = pd.read_csv(url) In\u00a0[\u00a0]: Copied! <pre>df\n</pre> df In\u00a0[\u00a0]: Copied! <pre># specify the names of the features (i.e. band names) and label\n# feature names used to extract out features and define what bands\n\nfeature_names = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7']\nlabel = \"landcover\"\n</pre> # specify the names of the features (i.e. band names) and label # feature names used to extract out features and define what bands  feature_names = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7'] label = \"landcover\" In\u00a0[\u00a0]: Copied! <pre># get the features and labels into separate variables\nX = df[feature_names]\ny = df[label]\n</pre> # get the features and labels into separate variables X = df[feature_names] y = df[label] In\u00a0[\u00a0]: Copied! <pre># create a classifier and fit\nn_trees = 10\nrf = ensemble.RandomForestClassifier(n_trees).fit(X, y)\n</pre> # create a classifier and fit n_trees = 10 rf = ensemble.RandomForestClassifier(n_trees).fit(X, y) In\u00a0[\u00a0]: Copied! <pre># convert the estimator into a list of strings\n# this function also works with the ensemble.ExtraTrees estimator\ntrees = ml.rf_to_strings(rf, feature_names)\n</pre> # convert the estimator into a list of strings # this function also works with the ensemble.ExtraTrees estimator trees = ml.rf_to_strings(rf, feature_names) In\u00a0[\u00a0]: Copied! <pre># print the first tree to see the result\nprint(trees[0])\n</pre> # print the first tree to see the result print(trees[0]) In\u00a0[\u00a0]: Copied! <pre>print(trees[1])\n</pre> print(trees[1]) In\u00a0[\u00a0]: Copied! <pre># number of trees we converted should equal the number of trees we defined for the model\nlen(trees) == n_trees\n</pre> # number of trees we converted should equal the number of trees we defined for the model len(trees) == n_trees In\u00a0[\u00a0]: Copied! <pre># create a ee classifier to use with ee objects from the trees\nee_classifier = ml.strings_to_classifier(trees)\n</pre> # create a ee classifier to use with ee objects from the trees ee_classifier = ml.strings_to_classifier(trees) In\u00a0[\u00a0]: Copied! <pre># ee_classifier.getInfo()\n</pre> # ee_classifier.getInfo() In\u00a0[\u00a0]: Copied! <pre># Make a cloud-free Landsat 8 TOA composite (from raw imagery).\nl8 = ee.ImageCollection('LANDSAT/LC08/C01/T1')\n\nimage = ee.Algorithms.Landsat.simpleComposite(\n    collection=l8.filterDate('2018-01-01', '2018-12-31'), asFloat=True\n)\n</pre> # Make a cloud-free Landsat 8 TOA composite (from raw imagery). l8 = ee.ImageCollection('LANDSAT/LC08/C01/T1')  image = ee.Algorithms.Landsat.simpleComposite(     collection=l8.filterDate('2018-01-01', '2018-12-31'), asFloat=True ) In\u00a0[\u00a0]: Copied! <pre># classify the image using the classifier we created from the local training\n# note: here we select the feature_names from the image that way the classifier knows which bands to use\nclassified = image.select(feature_names).classify(ee_classifier)\n</pre> # classify the image using the classifier we created from the local training # note: here we select the feature_names from the image that way the classifier knows which bands to use classified = image.select(feature_names).classify(ee_classifier) In\u00a0[\u00a0]: Copied! <pre># display results\nMap = geemap.Map(center=(37.75, -122.25), zoom=11)\n\nMap.addLayer(\n    image,\n    {\"bands\": ['B7', 'B5', 'B3'], \"min\": 0.05, \"max\": 0.55, \"gamma\": 1.5},\n    'image',\n)\nMap.addLayer(\n    classified,\n    {\"min\": 0, \"max\": 2, \"palette\": ['red', 'green', 'blue']},\n    'classification',\n)\n\nMap\n</pre> # display results Map = geemap.Map(center=(37.75, -122.25), zoom=11)  Map.addLayer(     image,     {\"bands\": ['B7', 'B5', 'B3'], \"min\": 0.05, \"max\": 0.55, \"gamma\": 1.5},     'image', ) Map.addLayer(     classified,     {\"min\": 0, \"max\": 2, \"palette\": ['red', 'green', 'blue']},     'classification', )  Map <p>Yay!! \ud83c\udf89 Looks like our example works. Don't party too much because there is a catch...</p> <p>This workflow has several limitations particularly due to how much data you can pass from the client to the server and how large of a model ee can actually handle. EE can only handle 40MB of data passed to the server, so if you have a lot of large decision tree strings then this will not work. Also, creating a classifier from strings has limitation (see this ee-forum discussion: https://groups.google.com/g/google-earth-engine-developers/c/lFFU1GBPzi8/m/6MewQk1FBwAJ), this is again limited by string lengths when ee creates a computation graph.</p> <p>So, you can use this but know you will probably run into errors when training large models.</p> In\u00a0[\u00a0]: Copied! <pre>user_id = geemap.ee_user_id()\nuser_id\n</pre> user_id = geemap.ee_user_id() user_id In\u00a0[\u00a0]: Copied! <pre># specify asset id where to save trees\n# be sure to change &lt;user_name&gt; to your ee user name\nasset_id = user_id + \"/random_forest_strings_test\"\nasset_id\n</pre> # specify asset id where to save trees # be sure to change  to your ee user name asset_id = user_id + \"/random_forest_strings_test\" asset_id In\u00a0[\u00a0]: Copied! <pre># kick off an export process so it will be saved to the ee asset\nml.export_trees_to_fc(trees, asset_id)\n\n# this will kick off an export task, so wait a few minutes before moving on\n</pre> # kick off an export process so it will be saved to the ee asset ml.export_trees_to_fc(trees, asset_id)  # this will kick off an export task, so wait a few minutes before moving on In\u00a0[\u00a0]: Copied! <pre># read the exported tree feature collection\nrf_fc = ee.FeatureCollection(asset_id)\n\n# convert it to a classifier, very similar to the `ml.trees_to_classifier` function\nanother_classifier = ml.fc_to_classifier(rf_fc)\n\n# classify the image again but with the classifier from the persisted trees\nclassified = image.select(feature_names).classify(another_classifier)\n</pre> # read the exported tree feature collection rf_fc = ee.FeatureCollection(asset_id)  # convert it to a classifier, very similar to the `ml.trees_to_classifier` function another_classifier = ml.fc_to_classifier(rf_fc)  # classify the image again but with the classifier from the persisted trees classified = image.select(feature_names).classify(another_classifier) In\u00a0[\u00a0]: Copied! <pre># display results\n# we should get the exact same results as before\nMap = geemap.Map(center=(37.75, -122.25), zoom=11)\n\nMap.addLayer(\n    image,\n    {\"bands\": ['B7', 'B5', 'B3'], \"min\": 0.05, \"max\": 0.55, \"gamma\": 1.5},\n    'image',\n)\nMap.addLayer(\n    classified,\n    {\"min\": 0, \"max\": 2, \"palette\": ['red', 'green', 'blue']},\n    'classification',\n)\n\nMap\n</pre> # display results # we should get the exact same results as before Map = geemap.Map(center=(37.75, -122.25), zoom=11)  Map.addLayer(     image,     {\"bands\": ['B7', 'B5', 'B3'], \"min\": 0.05, \"max\": 0.55, \"gamma\": 1.5},     'image', ) Map.addLayer(     classified,     {\"min\": 0, \"max\": 2, \"palette\": ['red', 'green', 'blue']},     'classification', )  Map In\u00a0[\u00a0]: Copied! <pre>import os\n\nout_csv = os.path.expanduser(\"~/Downloads/trees.csv\")\n</pre> import os  out_csv = os.path.expanduser(\"~/Downloads/trees.csv\") In\u00a0[\u00a0]: Copied! <pre>ml.trees_to_csv(trees, out_csv)\n</pre> ml.trees_to_csv(trees, out_csv) In\u00a0[\u00a0]: Copied! <pre>another_classifier = ml.csv_to_classifier(out_csv)\n</pre> another_classifier = ml.csv_to_classifier(out_csv) In\u00a0[\u00a0]: Copied! <pre>classified = image.select(feature_names).classify(another_classifier)\n</pre> classified = image.select(feature_names).classify(another_classifier) In\u00a0[\u00a0]: Copied! <pre># display results\n# we should get the exact same results as before\nMap = geemap.Map(center=(37.75, -122.25), zoom=11)\n\nMap.addLayer(\n    image,\n    {\"bands\": ['B7', 'B5', 'B3'], \"min\": 0.05, \"max\": 0.55, \"gamma\": 1.5},\n    'image',\n)\nMap.addLayer(\n    classified,\n    {\"min\": 0, \"max\": 2, \"palette\": ['red', 'green', 'blue']},\n    'classification',\n)\n\nMap\n</pre> # display results # we should get the exact same results as before Map = geemap.Map(center=(37.75, -122.25), zoom=11)  Map.addLayer(     image,     {\"bands\": ['B7', 'B5', 'B3'], \"min\": 0.05, \"max\": 0.55, \"gamma\": 1.5},     'image', ) Map.addLayer(     classified,     {\"min\": 0, \"max\": 2, \"palette\": ['red', 'green', 'blue']},     'classification', )  Map"},{"location":"notebooks/46_local_rf_training/#how-to-use-locally-trained-machine-learning-models-with-gee","title":"How to use locally trained machine learning models with GEE\u00b6","text":"<p>This notebook illustrates how to train a random forest (or any other ensemble tree estimator) locally using scikit-learn, convert the estimator into a string representation that Earth Engine can interpret, and how to apply the machine learning model with EE. The notebook and the geemap machine learning module (ml.py) were contributed by Kel Markert. A huge thank you to him.</p>"},{"location":"notebooks/46_local_rf_training/#train-a-model-locally-using-scikit-learn","title":"Train a model locally using scikit-learn\u00b6","text":"<p>In this demo, we are going to use the training data from here.</p>"},{"location":"notebooks/46_local_rf_training/#convert-a-sklearn-classifier-object-to-a-list-of-strings","title":"Convert a sklearn classifier object to a list of strings\u00b6","text":""},{"location":"notebooks/46_local_rf_training/#convert-sklearn-classifier-to-gee-classifier","title":"Convert sklearn classifier to GEE classifier\u00b6","text":"<p>At this point you can take the list of strings and save them locally to avoid training again. However, we want to use the model with EE so we need to create an ee.Classifier and persist the data on ee for best results.</p>"},{"location":"notebooks/46_local_rf_training/#classify-image-using-gee-classifier","title":"Classify image using GEE classifier\u00b6","text":""},{"location":"notebooks/46_local_rf_training/#save-trees-to-the-cloud","title":"Save trees to the cloud\u00b6","text":"<p>Now we have the strings in a format that ee can use, we want to save it for later use. There is a function to export a list of tree strings to a feature collection. The feature collection will have a pro</p>"},{"location":"notebooks/46_local_rf_training/#save-trees-locally","title":"Save trees locally\u00b6","text":""},{"location":"notebooks/47_image_thumbnails/","title":"47 image thumbnails","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() In\u00a0[\u00a0]: Copied! <pre>roi = ee.Geometry.Point([-122.44, 37.75])\ncollection = (\n    ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n    .filterBounds(roi)\n    .sort(\"CLOUD_COVER\")\n    .limit(10)\n)\n\nimage = collection.first()\n</pre> roi = ee.Geometry.Point([-122.44, 37.75]) collection = (     ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')     .filterBounds(roi)     .sort(\"CLOUD_COVER\")     .limit(10) )  image = collection.first() In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'bands': ['B6', 'B5', 'B4'],\n    'min': 0,\n    'max': 6000,\n    'gamma': 1.4,\n}\n\nMap.addLayer(image, vis_params, \"LANDSAT 7\")\nMap.setCenter(-122.44, 37.75, 8)\nMap\n</pre> vis_params = {     'bands': ['B6', 'B5', 'B4'],     'min': 0,     'max': 6000,     'gamma': 1.4, }  Map.addLayer(image, vis_params, \"LANDSAT 7\") Map.setCenter(-122.44, 37.75, 8) Map In\u00a0[\u00a0]: Copied! <pre>out_img = os.path.expanduser(\"~/Downloads/landsat.png\")\n</pre> out_img = os.path.expanduser(\"~/Downloads/landsat.png\") In\u00a0[\u00a0]: Copied! <pre>geemap.get_image_thumbnail(image, out_img, vis_params, dimensions=500, format='png')\n</pre> geemap.get_image_thumbnail(image, out_img, vis_params, dimensions=500, format='png') In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_img)\n</pre> geemap.show_image(out_img) In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser(\"~/Downloads\")\n</pre> out_dir = os.path.expanduser(\"~/Downloads\") In\u00a0[\u00a0]: Copied! <pre>geemap.get_image_collection_thumbnails(\n    collection, out_dir, vis_params, dimensions=500, format=\"jpg\"\n)\n</pre> geemap.get_image_collection_thumbnails(     collection, out_dir, vis_params, dimensions=500, format=\"jpg\" )"},{"location":"notebooks/47_image_thumbnails/#how-to-download-image-thumbnails-from-an-imagecollection","title":"How to download image thumbnails from an ImageCollection\u00b6","text":""},{"location":"notebooks/48_folium_legend/","title":"48 folium legend","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\n</pre> import ee import geemap.foliumap as geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>legends = geemap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = geemap.builtin_legends for legend in legends:     print(legend) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\n\nMap.add_legend(builtin_legend='NLCD')\n\nMap.addLayerControl()\n\nMap\n</pre> Map = geemap.Map()  landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover')  Map.add_legend(builtin_legend='NLCD')  Map.addLayerControl()  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlandcover = ee.Image('MODIS/006/MCD12Q1/2013_01_01').select('LC_Type1')\nigbpLandCoverVis = {\n    'min': 1.0,\n    'max': 17.0,\n    'palette': [\n        '05450a',\n        '086a10',\n        '54a708',\n        '78d203',\n        '009900',\n        'c6b044',\n        'dcd159',\n        'dade48',\n        'fbff13',\n        'b6ff05',\n        '27ff87',\n        'c24f44',\n        'a5a5a5',\n        'ff6d4c',\n        '69fff8',\n        'f9ffa4',\n        '1c0dff',\n    ],\n}\n\nMap.setCenter(6.746, 46.529, 2)\nMap.addLayer(landcover, igbpLandCoverVis, 'MODIS Land Cover')\n\nMap.setCenter(6.746, 46.529, 2)\nMap.addLayer(landcover, igbpLandCoverVis, 'MODIS Land Cover')\nMap.add_legend(builtin_legend='MODIS/006/MCD12Q1')\n\nMap.addLayerControl()\n\nMap\n</pre> Map = geemap.Map()  landcover = ee.Image('MODIS/006/MCD12Q1/2013_01_01').select('LC_Type1') igbpLandCoverVis = {     'min': 1.0,     'max': 17.0,     'palette': [         '05450a',         '086a10',         '54a708',         '78d203',         '009900',         'c6b044',         'dcd159',         'dade48',         'fbff13',         'b6ff05',         '27ff87',         'c24f44',         'a5a5a5',         'ff6d4c',         '69fff8',         'f9ffa4',         '1c0dff',     ], }  Map.setCenter(6.746, 46.529, 2) Map.addLayer(landcover, igbpLandCoverVis, 'MODIS Land Cover')  Map.setCenter(6.746, 46.529, 2) Map.addLayer(landcover, igbpLandCoverVis, 'MODIS Land Cover') Map.add_legend(builtin_legend='MODIS/006/MCD12Q1')  Map.addLayerControl()  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlabels = ['One', 'Two', 'Three', 'Four', 'ect']\n# color can be defined using either hex code or RGB (0-255, 0-255, 0-255)\ncolors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']\n# colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]\n\nMap.add_legend(title='Legend', labels=labels, colors=colors)\nMap\n</pre> Map = geemap.Map()  labels = ['One', 'Two', 'Three', 'Four', 'ect'] # color can be defined using either hex code or RGB (0-255, 0-255, 0-255) colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3'] # colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]  Map.add_legend(title='Legend', labels=labels, colors=colors) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlegend_dict = {\n    '11 Open Water': '466b9f',\n    '12 Perennial Ice/Snow': 'd1def8',\n    '21 Developed, Open Space': 'dec5c5',\n    '22 Developed, Low Intensity': 'd99282',\n    '23 Developed, Medium Intensity': 'eb0000',\n    '24 Developed High Intensity': 'ab0000',\n    '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',\n    '41 Deciduous Forest': '68ab5f',\n    '42 Evergreen Forest': '1c5f2c',\n    '43 Mixed Forest': 'b5c58f',\n    '51 Dwarf Scrub': 'af963c',\n    '52 Shrub/Scrub': 'ccb879',\n    '71 Grassland/Herbaceous': 'dfdfc2',\n    '72 Sedge/Herbaceous': 'd1d182',\n    '73 Lichens': 'a3cc51',\n    '74 Moss': '82ba9e',\n    '81 Pasture/Hay': 'dcd939',\n    '82 Cultivated Crops': 'ab6c28',\n    '90 Woody Wetlands': 'b8d9eb',\n    '95 Emergent Herbaceous Wetlands': '6c9fb8',\n}\n\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\n\nMap.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\n\nMap.addLayerControl()\n\nMap\n</pre> Map = geemap.Map()  legend_dict = {     '11 Open Water': '466b9f',     '12 Perennial Ice/Snow': 'd1def8',     '21 Developed, Open Space': 'dec5c5',     '22 Developed, Low Intensity': 'd99282',     '23 Developed, Medium Intensity': 'eb0000',     '24 Developed High Intensity': 'ab0000',     '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',     '41 Deciduous Forest': '68ab5f',     '42 Evergreen Forest': '1c5f2c',     '43 Mixed Forest': 'b5c58f',     '51 Dwarf Scrub': 'af963c',     '52 Shrub/Scrub': 'ccb879',     '71 Grassland/Herbaceous': 'dfdfc2',     '72 Sedge/Herbaceous': 'd1d182',     '73 Lichens': 'a3cc51',     '74 Moss': '82ba9e',     '81 Pasture/Hay': 'dcd939',     '82 Cultivated Crops': 'ab6c28',     '90 Woody Wetlands': 'b8d9eb',     '95 Emergent Herbaceous Wetlands': '6c9fb8', }  landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover')  Map.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)  Map.addLayerControl()  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nee_class_table = \"\"\"\n\nValue\tColor\tDescription\n0\t1c0dff\tWater\n1\t05450a\tEvergreen needleleaf forest\n2\t086a10\tEvergreen broadleaf forest\n3\t54a708\tDeciduous needleleaf forest\n4\t78d203\tDeciduous broadleaf forest\n5\t009900\tMixed forest\n6\tc6b044\tClosed shrublands\n7\tdcd159\tOpen shrublands\n8\tdade48\tWoody savannas\n9\tfbff13\tSavannas\n10\tb6ff05\tGrasslands\n11\t27ff87\tPermanent wetlands\n12\tc24f44\tCroplands\n13\ta5a5a5\tUrban and built-up\n14\tff6d4c\tCropland/natural vegetation mosaic\n15\t69fff8\tSnow and ice\n16\tf9ffa4\tBarren or sparsely vegetated\n254\tffffff\tUnclassified\n\n\"\"\"\n\nlandcover = ee.Image('MODIS/006/MCD12Q1/2013_01_01').select('LC_Type1')\nigbpLandCoverVis = {\n    'min': 1.0,\n    'max': 17.0,\n    'palette': [\n        '05450a',\n        '086a10',\n        '54a708',\n        '78d203',\n        '009900',\n        'c6b044',\n        'dcd159',\n        'dade48',\n        'fbff13',\n        'b6ff05',\n        '27ff87',\n        'c24f44',\n        'a5a5a5',\n        'ff6d4c',\n        '69fff8',\n        'f9ffa4',\n        '1c0dff',\n    ],\n}\n\nMap.setCenter(6.746, 46.529, 2)\nMap.addLayer(landcover, igbpLandCoverVis, 'MODIS Land Cover')\n\nlegend_dict = geemap.legend_from_ee(ee_class_table)\nMap.add_legend(title=\"MODIS Global Land Cover\", legend_dict=legend_dict)\n\nMap.addLayerControl()\n\nMap\n</pre> Map = geemap.Map()  ee_class_table = \"\"\"  Value\tColor\tDescription 0\t1c0dff\tWater 1\t05450a\tEvergreen needleleaf forest 2\t086a10\tEvergreen broadleaf forest 3\t54a708\tDeciduous needleleaf forest 4\t78d203\tDeciduous broadleaf forest 5\t009900\tMixed forest 6\tc6b044\tClosed shrublands 7\tdcd159\tOpen shrublands 8\tdade48\tWoody savannas 9\tfbff13\tSavannas 10\tb6ff05\tGrasslands 11\t27ff87\tPermanent wetlands 12\tc24f44\tCroplands 13\ta5a5a5\tUrban and built-up 14\tff6d4c\tCropland/natural vegetation mosaic 15\t69fff8\tSnow and ice 16\tf9ffa4\tBarren or sparsely vegetated 254\tffffff\tUnclassified  \"\"\"  landcover = ee.Image('MODIS/006/MCD12Q1/2013_01_01').select('LC_Type1') igbpLandCoverVis = {     'min': 1.0,     'max': 17.0,     'palette': [         '05450a',         '086a10',         '54a708',         '78d203',         '009900',         'c6b044',         'dcd159',         'dade48',         'fbff13',         'b6ff05',         '27ff87',         'c24f44',         'a5a5a5',         'ff6d4c',         '69fff8',         'f9ffa4',         '1c0dff',     ], }  Map.setCenter(6.746, 46.529, 2) Map.addLayer(landcover, igbpLandCoverVis, 'MODIS Land Cover')  legend_dict = geemap.legend_from_ee(ee_class_table) Map.add_legend(title=\"MODIS Global Land Cover\", legend_dict=legend_dict)  Map.addLayerControl()  Map"},{"location":"notebooks/48_folium_legend/#how-to-add-a-draggable-legend-to-the-map","title":"How to add a draggable legend to the map\u00b6","text":""},{"location":"notebooks/48_folium_legend/#add-a-builtin-legend-to-the-map","title":"Add a builtin legend to the map\u00b6","text":""},{"location":"notebooks/48_folium_legend/#available-land-cover-datasets-in-earth-engine","title":"Available Land Cover Datasets in Earth Engine\u00b6","text":"<p>https://developers.google.com/earth-engine/datasets/tags/landcover</p>"},{"location":"notebooks/48_folium_legend/#national-land-cover-database-nlcd","title":"National Land Cover Database (NLCD)\u00b6","text":"<p>https://developers.google.com/earth-engine/datasets/catalog/USGS_NLCD</p>"},{"location":"notebooks/48_folium_legend/#modis-land-cover-type-yearly-global-500m","title":"MODIS Land Cover Type Yearly Global 500m\u00b6","text":"<p>https://developers.google.com/earth-engine/datasets/catalog/MODIS_006_MCD12Q1</p>"},{"location":"notebooks/48_folium_legend/#add-customized-legends-for-earth-engine-data","title":"Add customized legends for Earth Engine data\u00b6","text":"<p>There are three ways you can add customized legends for Earth Engine data</p> <ol> <li>Define legend labels and colors</li> <li>Define legend dictionary</li> <li>Convert Earth Engine class table to legend dictionary</li> </ol>"},{"location":"notebooks/48_folium_legend/#define-legend-keys-and-colors","title":"Define legend keys and colors\u00b6","text":""},{"location":"notebooks/48_folium_legend/#define-a-legend-dictionary","title":"Define a legend dictionary\u00b6","text":""},{"location":"notebooks/48_folium_legend/#convert-an-earth-engine-class-table-to-legend","title":"Convert an Earth Engine class table to legend\u00b6","text":"<p>For example: MCD12Q1 Land Cover Type Yearly Global 500m</p> <p>https://developers.google.com/earth-engine/datasets/catalog/MODIS_006_MCD12Q1</p>"},{"location":"notebooks/49_colorbar/","title":"49 colorbar","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\n\ncolors = vis_params['palette']\nvmin = vis_params['min']\nvmax = vis_params['max']\n\nMap.add_colorbar_branca(colors=colors, vmin=vmin, vmax=vmax, layer_name=\"SRTM DEM\")\n\n# nlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\n# Map.addLayer(nlcd_2016, {}, \"NLCD\")\n# Map.add_legend(legend_title=\"NLCD\", builtin_legend=\"NLCD\", layer_name=\"NLCD\")\n\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM')  colors = vis_params['palette'] vmin = vis_params['min'] vmax = vis_params['max']  Map.add_colorbar_branca(colors=colors, vmin=vmin, vmax=vmax, layer_name=\"SRTM DEM\")  # nlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover') # Map.addLayer(nlcd_2016, {}, \"NLCD\") # Map.add_legend(legend_title=\"NLCD\", builtin_legend=\"NLCD\", layer_name=\"NLCD\")  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\n\ncolors = vis_params['palette']\nvmin = vis_params['min']\nvmax = vis_params['max']\n\nMap.add_colorbar_branca(\n    colors=colors, vmin=vmin, vmax=vmax, categorical=True, step=4, layer_name=\"SRTM DEM\"\n)\n\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM')  colors = vis_params['palette'] vmin = vis_params['min'] vmax = vis_params['max']  Map.add_colorbar_branca(     colors=colors, vmin=vmin, vmax=vmax, categorical=True, step=4, layer_name=\"SRTM DEM\" )  Map In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\n</pre> import ee import geemap.foliumap as geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\n\ncolors = vis_params['palette']\nvmin = vis_params['min']\nvmax = vis_params['max']\n\nMap.add_colorbar(vis_params, label='Elevation (m)')\n\nMap.addLayerControl()\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM')  colors = vis_params['palette'] vmin = vis_params['min'] vmax = vis_params['max']  Map.add_colorbar(vis_params, label='Elevation (m)')  Map.addLayerControl() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\n\ncolors = vis_params['palette']\nvmin = vis_params['min']\nvmax = vis_params['max']\n\nMap.add_colorbar(vis_params, categorical=True, step=4)\n\nMap.addLayerControl()\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM')  colors = vis_params['palette'] vmin = vis_params['min'] vmax = vis_params['max']  Map.add_colorbar(vis_params, categorical=True, step=4)  Map.addLayerControl() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlegend_dict = {\n    '11 Open Water': '466b9f',\n    '12 Perennial Ice/Snow': 'd1def8',\n    '21 Developed, Open Space': 'dec5c5',\n    '22 Developed, Low Intensity': 'd99282',\n    '23 Developed, Medium Intensity': 'eb0000',\n    '24 Developed High Intensity': 'ab0000',\n    '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',\n    '41 Deciduous Forest': '68ab5f',\n    '42 Evergreen Forest': '1c5f2c',\n    '43 Mixed Forest': 'b5c58f',\n    '51 Dwarf Scrub': 'af963c',\n    '52 Shrub/Scrub': 'ccb879',\n    '71 Grassland/Herbaceous': 'dfdfc2',\n    '72 Sedge/Herbaceous': 'd1d182',\n    '73 Lichens': 'a3cc51',\n    '74 Moss': '82ba9e',\n    '81 Pasture/Hay': 'dcd939',\n    '82 Cultivated Crops': 'ab6c28',\n    '90 Woody Wetlands': 'b8d9eb',\n    '95 Emergent Herbaceous Wetlands': '6c9fb8',\n}\n\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\n\nMap.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\n\nMap.addLayerControl()\n\nMap\n</pre> Map = geemap.Map()  legend_dict = {     '11 Open Water': '466b9f',     '12 Perennial Ice/Snow': 'd1def8',     '21 Developed, Open Space': 'dec5c5',     '22 Developed, Low Intensity': 'd99282',     '23 Developed, Medium Intensity': 'eb0000',     '24 Developed High Intensity': 'ab0000',     '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',     '41 Deciduous Forest': '68ab5f',     '42 Evergreen Forest': '1c5f2c',     '43 Mixed Forest': 'b5c58f',     '51 Dwarf Scrub': 'af963c',     '52 Shrub/Scrub': 'ccb879',     '71 Grassland/Herbaceous': 'dfdfc2',     '72 Sedge/Herbaceous': 'd1d182',     '73 Lichens': 'a3cc51',     '74 Moss': '82ba9e',     '81 Pasture/Hay': 'dcd939',     '82 Cultivated Crops': 'ab6c28',     '90 Woody Wetlands': 'b8d9eb',     '95 Emergent Herbaceous Wetlands': '6c9fb8', }  landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover')  Map.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)  Map.addLayerControl()  Map"},{"location":"notebooks/49_colorbar/#how-to-add-a-colorbar-to-the-map","title":"How to add a colorbar to the map\u00b6","text":""},{"location":"notebooks/49_colorbar/#for-ipyleaflet-maps","title":"For ipyleaflet maps\u00b6","text":""},{"location":"notebooks/49_colorbar/#continuous-colorbar","title":"Continuous colorbar\u00b6","text":""},{"location":"notebooks/49_colorbar/#categorical-colorbar","title":"Categorical colorbar\u00b6","text":""},{"location":"notebooks/49_colorbar/#for-folium-maps","title":"For folium maps\u00b6","text":""},{"location":"notebooks/49_colorbar/#continuous-colorbar","title":"Continuous colorbar\u00b6","text":""},{"location":"notebooks/49_colorbar/#categorical-colorbar","title":"Categorical colorbar\u00b6","text":""},{"location":"notebooks/49_colorbar/#draggable-legend","title":"Draggable legend\u00b6","text":""},{"location":"notebooks/50_cartoee_quickstart/","title":"50 cartoee quickstart","text":"<p>Uncomment the following line to install geemap and cartopy if needed. Keep in mind that cartopy can be challenging to install. If you are unable to install cartopy on your computer, you can try Google Colab with this the notebook example.</p> <p>See below the commands to install cartopy and geemap using conda/mamba:</p> <pre><code>conda create -n carto python=3.8\nconda activate carto\nconda install mamba -c conda-forge\nmamba install cartopy scipy -c conda-forge\nmamba install geemap -c conda-forge\njupyter notebook\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># !pip install cartopy scipy\n# !pip install geemap\n</pre> # !pip install cartopy scipy # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>%pylab inline\n\nimport ee\nimport geemap\n\n# import the cartoee functionality from geemap\nfrom geemap import cartoee\n</pre> %pylab inline  import ee import geemap  # import the cartoee functionality from geemap from geemap import cartoee In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre># get an image\nsrtm = ee.Image(\"CGIAR/SRTM90_V4\")\n</pre> # get an image srtm = ee.Image(\"CGIAR/SRTM90_V4\") In\u00a0[\u00a0]: Copied! <pre># geospatial region in format [E,S,W,N]\nregion = [180, -60, -180, 85]  # define bounding box to request data\nvis = {'min': 0, 'max': 3000}  # define visualization parameters for image\n</pre> # geospatial region in format [E,S,W,N] region = [180, -60, -180, 85]  # define bounding box to request data vis = {'min': 0, 'max': 3000}  # define visualization parameters for image In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(srtm, region=region, vis_params=vis)\n\n# add a colorbar to the map using the visualization params we passed to the map\ncartoee.add_colorbar(ax, vis, loc=\"bottom\", label=\"Elevation\", orientation=\"horizontal\")\n\n# add gridlines to the map at a specified interval\ncartoee.add_gridlines(ax, interval=[60, 30], linestyle=\":\")\n\n# add coastlines using the cartopy api\nax.coastlines(color=\"red\")\n\nshow()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(srtm, region=region, vis_params=vis)  # add a colorbar to the map using the visualization params we passed to the map cartoee.add_colorbar(ax, vis, loc=\"bottom\", label=\"Elevation\", orientation=\"horizontal\")  # add gridlines to the map at a specified interval cartoee.add_gridlines(ax, interval=[60, 30], linestyle=\":\")  # add coastlines using the cartopy api ax.coastlines(color=\"red\")  show() <p>This is a decent map for minimal amount of code. But we can also easily use matplotlib colormaps to visualize our EE results to add more color. Here we add a <code>cmap</code> keyword to the <code>.get_map()</code> and <code>.add_colorbar()</code> functions.</p> In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\ncmap = \"gist_earth\"  # colormap we want to use\n# cmap = \"terrain\"\n\n# use cartoee to get a map\nax = cartoee.get_map(srtm, region=region, vis_params=vis, cmap=cmap)\n\n# add a colorbar to the map using the visualization params we passed to the map\ncartoee.add_colorbar(\n    ax, vis, cmap=cmap, loc=\"right\", label=\"Elevation\", orientation=\"vertical\"\n)\n\n# add gridlines to the map at a specified interval\ncartoee.add_gridlines(ax, interval=[60, 30], linestyle=\"--\")\n\n# add coastlines using the cartopy api\nax.coastlines(color=\"red\")\n\nax.set_title(label='Global Elevation Map', fontsize=15)\n\nshow()\n</pre> fig = plt.figure(figsize=(15, 10))  cmap = \"gist_earth\"  # colormap we want to use # cmap = \"terrain\"  # use cartoee to get a map ax = cartoee.get_map(srtm, region=region, vis_params=vis, cmap=cmap)  # add a colorbar to the map using the visualization params we passed to the map cartoee.add_colorbar(     ax, vis, cmap=cmap, loc=\"right\", label=\"Elevation\", orientation=\"vertical\" )  # add gridlines to the map at a specified interval cartoee.add_gridlines(ax, interval=[60, 30], linestyle=\"--\")  # add coastlines using the cartopy api ax.coastlines(color=\"red\")  ax.set_title(label='Global Elevation Map', fontsize=15)  show() In\u00a0[\u00a0]: Copied! <pre># get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n\n# define the visualization parameters to view\nvis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3}\n</pre> # get a landsat image to visualize image = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')  # define the visualization parameters to view vis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3} In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=45, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"yellow\")\n\nshow()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=45, linestyle=\":\")  # add the coastline ax.coastlines(color=\"yellow\")  show() <p>By default, if a region is not provided via the <code>region</code> keyword the whole extent of the image will be plotted as seen in the previous Landsat example. We can also zoom to a specific region of an image by defining the region to plot.</p> In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# here is the bounding box of the map extent we want to use\n# formatted a [E,S,W,N]\nzoom_region = [-121.8025, 37.3458, -122.6265, 37.9178]\n\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.15, xtick_rotation=45, linestyle=\":\")\n\n# add coastline\nax.coastlines(color=\"yellow\")\n\nshow()\n</pre> fig = plt.figure(figsize=(15, 10))  # here is the bounding box of the map extent we want to use # formatted a [E,S,W,N] zoom_region = [-121.8025, 37.3458, -122.6265, 37.9178]  # plot the map over the region of interest ax = cartoee.get_map(image, vis_params=vis, region=zoom_region)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.15, xtick_rotation=45, linestyle=\":\")  # add coastline ax.coastlines(color=\"yellow\")  show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# here is the bounding box of the map extent we want to use\n# formatted a [E,S,W,N]\nzoom_region = [-121.8025, 37.3458, -122.6265, 37.9178]\n\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.15, xtick_rotation=45, linestyle=\":\")\n\n# add coastline\nax.coastlines(color=\"yellow\")\n\n# add north arrow\ncartoee.add_north_arrow(\n    ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20\n)\n\n# add scale bar\ncartoee.add_scale_bar_lite(\n    ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\"\n)\n\nax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)\n\nshow()\n</pre> fig = plt.figure(figsize=(15, 10))  # here is the bounding box of the map extent we want to use # formatted a [E,S,W,N] zoom_region = [-121.8025, 37.3458, -122.6265, 37.9178]  # plot the map over the region of interest ax = cartoee.get_map(image, vis_params=vis, region=zoom_region)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.15, xtick_rotation=45, linestyle=\":\")  # add coastline ax.coastlines(color=\"yellow\")  # add north arrow cartoee.add_north_arrow(     ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20 )  # add scale bar cartoee.add_scale_bar_lite(     ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\" )  ax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)  show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/50_cartoee_quickstart/#how-to-create-publication-quality-maps-using-cartoee","title":"How to create publication quality maps using <code>cartoee</code>\u00b6","text":"<p><code>cartoee</code> is a lightweight module to aid in creating publication quality maps from Earth Engine processing results without having to download data. The <code>cartoee</code> package does this by requesting png images from EE results (which are usually good enough for visualization) and <code>cartopy</code> is used to create the plots. Utility functions are available to create plot aesthetics such as gridlines or color bars. The notebook and the geemap cartoee module (cartoee.py) were contributed by Kel Markert. A huge thank you to him.</p>"},{"location":"notebooks/50_cartoee_quickstart/#plotting-an-image","title":"Plotting an image\u00b6","text":"<p>In this first example we will explore the most basic functionality including plotting and image, adding a colorbar, and adding visual aethetic features. Here we will use SRTM data to plot global elevation.</p>"},{"location":"notebooks/50_cartoee_quickstart/#plotting-an-rgb-image","title":"Plotting an RGB image\u00b6","text":"<p><code>cartoee</code> also allows for plotting of RGB image results directly. Here is an example of plotting a Landsat false-color scene.</p>"},{"location":"notebooks/50_cartoee_quickstart/#adding-north-arrow-and-scale-bar","title":"Adding north arrow and scale bar\u00b6","text":""},{"location":"notebooks/51_cartoee_projections/","title":"51 cartoee projections","text":"<p>Uncomment the following line to install geemap and cartopy if needed. Keep in mind that cartopy can be challenging to install. If you are unable to install cartopy on your computer, you can try Google Colab with this the notebook example.</p> <p>See below the commands to install cartopy and geemap using conda/mamba:</p> <pre><code>conda create -n carto python=3.8\nconda activate carto\nconda install mamba -c conda-forge\nmamba install cartopy scipy -c conda-forge\nmamba install geemap -c conda-forge\njupyter notebook\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># !pip install cartopy scipy\n# !pip install geemap\n</pre> # !pip install cartopy scipy # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom geemap import cartoee\nimport cartopy.crs as ccrs\n\n%pylab inline\n</pre> import ee import geemap from geemap import cartoee import cartopy.crs as ccrs  %pylab inline In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre># get an earth engine image of ocean data for Jan-Mar 2018\nocean = (\n    ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')\n    .filter(ee.Filter.date('2018-01-01', '2018-03-01'))\n    .median()\n    .select([\"sst\"], [\"SST\"])\n)\n</pre> # get an earth engine image of ocean data for Jan-Mar 2018 ocean = (     ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')     .filter(ee.Filter.date('2018-01-01', '2018-03-01'))     .median()     .select([\"sst\"], [\"SST\"]) ) In\u00a0[\u00a0]: Copied! <pre># set parameters for plotting\n# will plot the Sea Surface Temp with specific range and colormap\nvisualization = {'bands': \"SST\", 'min': -2, 'max': 30}\n# specify region to focus on\nbbox = [180, -88, -180, 88]\n</pre> # set parameters for plotting # will plot the Sea Surface Temp with specific range and colormap visualization = {'bands': \"SST\", 'min': -2, 'max': 30} # specify region to focus on bbox = [180, -88, -180, 88] In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(ocean, cmap='plasma', vis_params=visualization, region=bbox)\ncb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')\n\nax.set_title(label='Sea Surface Temperature', fontsize=15)\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(ocean, cmap='plasma', vis_params=visualization, region=bbox) cb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')  ax.set_title(label='Sea Surface Temperature', fontsize=15)  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new Mollweide projection centered on the Pacific\nprojection = ccrs.Mollweide(central_longitude=-180)\n\n# plot the result with cartoee using the Mollweide projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal'\n)\n\nax.set_title(\"Mollweide projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new Mollweide projection centered on the Pacific projection = ccrs.Mollweide(central_longitude=-180)  # plot the result with cartoee using the Mollweide projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal' )  ax.set_title(\"Mollweide projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new Goode homolosine projection centered on the Pacific\nprojection = ccrs.Robinson(central_longitude=-180)\n\n# plot the result with cartoee using the Goode homolosine projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal'\n)\n\nax.set_title(\"Robinson projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new Goode homolosine projection centered on the Pacific projection = ccrs.Robinson(central_longitude=-180)  # plot the result with cartoee using the Goode homolosine projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal' )  ax.set_title(\"Robinson projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new Goode homolosine projection centered on the Pacific\nprojection = ccrs.InterruptedGoodeHomolosine(central_longitude=-180)\n\n# plot the result with cartoee using the Goode homolosine projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal'\n)\n\nax.set_title(\"Goode homolosine projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new Goode homolosine projection centered on the Pacific projection = ccrs.InterruptedGoodeHomolosine(central_longitude=-180)  # plot the result with cartoee using the Goode homolosine projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal' )  ax.set_title(\"Goode homolosine projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new orographic projection focused on the Pacific\nprojection = ccrs.EqualEarth(central_longitude=-180)\n\n# plot the result with cartoee using the orographic projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical'\n)\n\nax.set_title(\"Equal Earth projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new orographic projection focused on the Pacific projection = ccrs.EqualEarth(central_longitude=-180)  # plot the result with cartoee using the orographic projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical' )  ax.set_title(\"Equal Earth projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new orographic projection focused on the Pacific\nprojection = ccrs.Orthographic(-130, -10)\n\n# plot the result with cartoee using the orographic projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical'\n)\n\nax.set_title(\"Orographic projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new orographic projection focused on the Pacific projection = ccrs.Orthographic(-130, -10)  # plot the result with cartoee using the orographic projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical' )  ax.set_title(\"Orographic projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# Create a new region to focus on\nspole = [180, -88, -180, 0]\n\nprojection = ccrs.SouthPolarStereo()\n\n# plot the result with cartoee focusing on the south pole\nax = cartoee.get_map(\n    ocean, cmap='plasma', vis_params=visualization, region=spole, proj=projection\n)\ncb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')\n\nax.coastlines()\nax.set_title('The South Pole')\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # Create a new region to focus on spole = [180, -88, -180, 0]  projection = ccrs.SouthPolarStereo()  # plot the result with cartoee focusing on the south pole ax = cartoee.get_map(     ocean, cmap='plasma', vis_params=visualization, region=spole, proj=projection ) cb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')  ax.coastlines() ax.set_title('The South Pole') plt.show() <p>As you can see from the result there are warping effects on the plotted image. There is really no way of getting around this (other than requesting a larger extent of data which may not always be the case).</p> <p>So, what we can do is set the extent of the map to a more realistic view after plotting the image as in the following example:</p> In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee focusing on the south pole\nax = cartoee.get_map(\n    ocean, cmap='plasma', vis_params=visualization, region=spole, proj=projection\n)\ncb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')\n\nax.coastlines()\nax.set_title('The South Pole')\n\n# get bounding box coordinates of a zoom area\nzoom = spole\nzoom[-1] = -20\n\n# convert bbox coordinate from [W,S,E,N] to [W,E,S,N] as matplotlib expects\nzoom_extent = cartoee.bbox_to_extent(zoom)\n\n# set the extent of the map to the zoom area\nax.set_extent(zoom_extent, ccrs.PlateCarree())\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee focusing on the south pole ax = cartoee.get_map(     ocean, cmap='plasma', vis_params=visualization, region=spole, proj=projection ) cb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')  ax.coastlines() ax.set_title('The South Pole')  # get bounding box coordinates of a zoom area zoom = spole zoom[-1] = -20  # convert bbox coordinate from [W,S,E,N] to [W,E,S,N] as matplotlib expects zoom_extent = cartoee.bbox_to_extent(zoom)  # set the extent of the map to the zoom area ax.set_extent(zoom_extent, ccrs.PlateCarree())  plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/51_cartoee_projections/#working-with-projections-in-cartoee","title":"Working with projections in cartoee\u00b6","text":"<p><code>cartoee</code> is a lightweight module to aid in creatig publication quality maps from Earth Engine processing results without having to download data. The <code>cartoee</code> package does this by requesting png images from EE results (which are usually good enough for visualization) and <code>cartopy</code> is used to create the plots. Utility functions are available to create plot aethetics such as gridlines or color bars. The notebook and the geemap cartoee module (cartoee.py) were contributed by Kel Markert. A huge thank you to him.</p>"},{"location":"notebooks/51_cartoee_projections/#plotting-an-image-on-a-map","title":"Plotting an image on a map\u00b6","text":"<p>Here we are going to show another example of creating a map with EE results. We will use global sea surface temperature data for Jan-Mar 2018.</p>"},{"location":"notebooks/51_cartoee_projections/#mapping-with-different-projections","title":"Mapping with different projections\u00b6","text":"<p>You can specify what ever projection is available within <code>cartopy</code> to display the results from Earth Engine. Here are a couple examples of global and regions maps using the sea surface temperature example. Please refer to the <code>cartopy</code> projection documentation for more examples with different projections.</p>"},{"location":"notebooks/51_cartoee_projections/#warping-artifacts","title":"Warping artifacts\u00b6","text":"<p>Often times global projections are not needed so we use specific projection for the map that provides the best view for the geographic region of interest. When we use these, sometimes image warping effects occur. This is because <code>cartoee</code> only requests data for region of interest and when mapping with <code>cartopy</code> the pixels get warped to fit the view extent as best as possible. Consider the following example where we want to map SST over the south pole:</p>"},{"location":"notebooks/52_cartoee_gif/","title":"52 cartoee gif","text":"<p>Uncomment the following line to install geemap and cartopy if needed. Keep in mind that cartopy can be challenging to install. If you are unable to install cartopy on your computer, you can try Google Colab with this the notebook example.</p> <p>See below the commands to install cartopy and geemap using conda/mamba:</p> <pre><code>conda create -n carto python=3.8\nconda activate carto\nconda install mamba -c conda-forge\nmamba install cartopy scipy -c conda-forge\nmamba install geemap -c conda-forge\njupyter notebook\n</code></pre> In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\nfrom geemap import cartoee\n\n%pylab inline\n</pre> import os import ee import geemap from geemap import cartoee  %pylab inline In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>lon = -115.1585\nlat = 36.1500\nstart_year = 1984\nend_year = 2011\n\npoint = ee.Geometry.Point(lon, lat)\nyears = ee.List.sequence(start_year, end_year)\n\n\ndef get_best_image(year):\n    start_date = ee.Date.fromYMD(year, 1, 1)\n    end_date = ee.Date.fromYMD(year, 12, 31)\n    image = (\n        ee.ImageCollection(\"LANDSAT/LT05/C01/T1_SR\")\n        .filterBounds(point)\n        .filterDate(start_date, end_date)\n        .sort(\"CLOUD_COVER\")\n        .first()\n    )\n    return ee.Image(image)\n\n\ncollection = ee.ImageCollection(years.map(get_best_image))\n</pre> lon = -115.1585 lat = 36.1500 start_year = 1984 end_year = 2011  point = ee.Geometry.Point(lon, lat) years = ee.List.sequence(start_year, end_year)   def get_best_image(year):     start_date = ee.Date.fromYMD(year, 1, 1)     end_date = ee.Date.fromYMD(year, 12, 31)     image = (         ee.ImageCollection(\"LANDSAT/LT05/C01/T1_SR\")         .filterBounds(point)         .filterDate(start_date, end_date)         .sort(\"CLOUD_COVER\")         .first()     )     return ee.Image(image)   collection = ee.ImageCollection(years.map(get_best_image)) In\u00a0[\u00a0]: Copied! <pre>vis_params = {\"bands\": ['B4', 'B3', 'B2'], \"min\": 0, \"max\": 5000}\n\nimage = ee.Image(collection.first())\nMap.addLayer(image, vis_params, 'First image')\nMap.setCenter(lon, lat, 8)\nMap\n</pre> vis_params = {\"bands\": ['B4', 'B3', 'B2'], \"min\": 0, \"max\": 5000}  image = ee.Image(collection.first()) Map.addLayer(image, vis_params, 'First image') Map.setCenter(lon, lat, 8) Map In\u00a0[\u00a0]: Copied! <pre>w = 0.4\nh = 0.3\n\nregion = [lon + w, lat - h, lon - w, lat + h]\n\nfig = plt.figure(figsize=(10, 8))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, region=region, vis_params=vis_params)\n\n# add gridlines to the map at a specified interval\ncartoee.add_gridlines(ax, interval=[0.2, 0.2], linestyle=\":\")\n\n# add north arrow\nnorth_arrow_dict = {\n    \"text\": \"N\",\n    \"xy\": (0.1, 0.3),\n    \"arrow_length\": 0.15,\n    \"text_color\": \"white\",\n    \"arrow_color\": \"white\",\n    \"fontsize\": 20,\n    \"width\": 5,\n    \"headwidth\": 15,\n    \"ha\": \"center\",\n    \"va\": \"center\",\n}\ncartoee.add_north_arrow(ax, **north_arrow_dict)\n\n# add scale bar\nscale_bar_dict = {\n    \"length\": 10,\n    \"xy\": (0.1, 0.05),\n    \"linewidth\": 3,\n    \"fontsize\": 20,\n    \"color\": \"white\",\n    \"unit\": \"km\",\n    \"ha\": \"center\",\n    \"va\": \"bottom\",\n}\ncartoee.add_scale_bar_lite(ax, **scale_bar_dict)\n\nax.set_title(label='Las Vegas, NV', fontsize=15)\n\nshow()\n</pre> w = 0.4 h = 0.3  region = [lon + w, lat - h, lon - w, lat + h]  fig = plt.figure(figsize=(10, 8))  # use cartoee to get a map ax = cartoee.get_map(image, region=region, vis_params=vis_params)  # add gridlines to the map at a specified interval cartoee.add_gridlines(ax, interval=[0.2, 0.2], linestyle=\":\")  # add north arrow north_arrow_dict = {     \"text\": \"N\",     \"xy\": (0.1, 0.3),     \"arrow_length\": 0.15,     \"text_color\": \"white\",     \"arrow_color\": \"white\",     \"fontsize\": 20,     \"width\": 5,     \"headwidth\": 15,     \"ha\": \"center\",     \"va\": \"center\", } cartoee.add_north_arrow(ax, **north_arrow_dict)  # add scale bar scale_bar_dict = {     \"length\": 10,     \"xy\": (0.1, 0.05),     \"linewidth\": 3,     \"fontsize\": 20,     \"color\": \"white\",     \"unit\": \"km\",     \"ha\": \"center\",     \"va\": \"bottom\", } cartoee.add_scale_bar_lite(ax, **scale_bar_dict)  ax.set_title(label='Las Vegas, NV', fontsize=15)  show() In\u00a0[\u00a0]: Copied! <pre>cartoee.get_image_collection_gif(\n    ee_ic=collection,\n    out_dir=os.path.expanduser(\"~/Downloads/timelapse\"),\n    out_gif=\"animation.gif\",\n    vis_params=vis_params,\n    region=region,\n    fps=5,\n    mp4=True,\n    grid_interval=(0.2, 0.2),\n    plot_title=\"Las Vegas, NV\",\n    date_format='YYYY-MM-dd',\n    fig_size=(10, 8),\n    dpi_plot=100,\n    file_format=\"png\",\n    north_arrow_dict=north_arrow_dict,\n    scale_bar_dict=scale_bar_dict,\n    verbose=True,\n)\n</pre> cartoee.get_image_collection_gif(     ee_ic=collection,     out_dir=os.path.expanduser(\"~/Downloads/timelapse\"),     out_gif=\"animation.gif\",     vis_params=vis_params,     region=region,     fps=5,     mp4=True,     grid_interval=(0.2, 0.2),     plot_title=\"Las Vegas, NV\",     date_format='YYYY-MM-dd',     fig_size=(10, 8),     dpi_plot=100,     file_format=\"png\",     north_arrow_dict=north_arrow_dict,     scale_bar_dict=scale_bar_dict,     verbose=True, )"},{"location":"notebooks/52_cartoee_gif/#how-to-create-timelapse-animations-using-cartoee","title":"How to create timelapse animations using cartoee\u00b6","text":""},{"location":"notebooks/52_cartoee_gif/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/52_cartoee_gif/#create-an-imagecollection","title":"Create an ImageCollection\u00b6","text":""},{"location":"notebooks/52_cartoee_gif/#display-a-sample-image","title":"Display a sample image\u00b6","text":""},{"location":"notebooks/52_cartoee_gif/#get-a-sample-output-image","title":"Get a sample output image\u00b6","text":""},{"location":"notebooks/52_cartoee_gif/#create-timelapse-animations","title":"Create timelapse animations\u00b6","text":""},{"location":"notebooks/53_layer_vis/","title":"53 layer vis","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\", False)\n\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\", False)  Map"},{"location":"notebooks/53_layer_vis/#how-to-change-layer-visualization-interactively-with-a-gui","title":"How to change layer visualization interactively with a GUI\u00b6","text":""},{"location":"notebooks/54_vector_vis/","title":"54 vector vis","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\ncities = ee.FeatureCollection('users/giswqs/public/us_cities')\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True)\nMap.addLayer(landcover, {}, 'Land cover', False)\nMap.addLayer(\n    landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7', False\n)\nMap.addLayer(states, {}, \"US States\", True)\nMap.addLayer(cities, {}, 'Cities', False)\n\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\") cities = ee.FeatureCollection('users/giswqs/public/us_cities')  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True) Map.addLayer(landcover, {}, 'Land cover', False) Map.addLayer(     landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7', False ) Map.addLayer(states, {}, \"US States\", True) Map.addLayer(cities, {}, 'Cities', False)  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\")  Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'color': '000000',\n    'colorOpacity': 1,\n    'pointSize': 3,\n    'pointShape': 'circle',\n    'width': 2,\n    'lineType': 'solid',\n    'fillColorOpacity': 0.66,\n}\n\npalette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']\n\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\n</pre> vis_params = {     'color': '000000',     'colorOpacity': 1,     'pointSize': 3,     'pointShape': 'circle',     'width': 2,     'lineType': 'solid',     'fillColorOpacity': 0.66, }  palette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']  Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params )"},{"location":"notebooks/54_vector_vis/#how-to-visualize-earth-engine-vector-data-interactively-with-a-gui","title":"How to visualize Earth Engine vector data interactively with a GUI\u00b6","text":""},{"location":"notebooks/55_raster_vis/","title":"55 raster vis","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\n# landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\n# Map.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\", False)\n\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') # landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) # Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\", False)  Map"},{"location":"notebooks/55_raster_vis/#how-to-visualize-earth-engine-raster-data-interactively-with-a-gui","title":"How to visualize Earth Engine raster data interactively with a GUI\u00b6","text":""},{"location":"notebooks/56_local_data/","title":"56 local data","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap\n</pre> import os import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>out_dir = os.getcwd()\n</pre> out_dir = os.getcwd() In\u00a0[\u00a0]: Copied! <pre>countries_url = \"https://github.com/giswqs/data/raw/main/world/countries.zip\"\nus_states_url = (\n    \"https://raw.githubusercontent.com/giswqs/data/main/us/us_states.geojson\"\n)\ndem_url = (\n    'https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing'\n)\nlandsat_url = (\n    'https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing'\n)\n</pre> countries_url = \"https://github.com/giswqs/data/raw/main/world/countries.zip\" us_states_url = (     \"https://raw.githubusercontent.com/giswqs/data/main/us/us_states.geojson\" ) dem_url = (     'https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing' ) landsat_url = (     'https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing' ) In\u00a0[\u00a0]: Copied! <pre>geemap.download_from_url(countries_url)\n</pre> geemap.download_from_url(countries_url) In\u00a0[\u00a0]: Copied! <pre>geemap.download_from_url(us_states_url)\n</pre> geemap.download_from_url(us_states_url) In\u00a0[\u00a0]: Copied! <pre>geemap.download_from_gdrive(dem_url, 'dem.tif', unzip=False)\n</pre> geemap.download_from_gdrive(dem_url, 'dem.tif', unzip=False) In\u00a0[\u00a0]: Copied! <pre>geemap.download_from_gdrive(landsat_url, 'landsat.tif', unzip=False)\n</pre> geemap.download_from_gdrive(landsat_url, 'landsat.tif', unzip=False) In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map"},{"location":"notebooks/56_local_data/#how-to-add-local-vector-and-raster-data-to-the-map-with-a-few-clicks","title":"How to add local vector and raster data to the map with a few clicks\u00b6","text":""},{"location":"notebooks/56_local_data/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/56_local_data/#download-sample-datasets","title":"Download sample datasets\u00b6","text":"<p>Note that geemap only supports vector data using WGS84 (EPSG:4326).</p>"},{"location":"notebooks/56_local_data/#add-data-to-the-map-using-the-toolbar","title":"Add data to the map using the toolbar\u00b6","text":""},{"location":"notebooks/57_cartoee_blend/","title":"57 cartoee blend","text":"<p>Uncomment the following line to install geemap and cartopy if needed. Keep in mind that cartopy can be challenging to install. If you are unable to install cartopy on your computer, you can try Google Colab with this the notebook example.</p> <p>See below the commands to install cartopy and geemap using conda/mamba:</p> <pre><code>conda create -n carto python=3.8\nconda activate carto\nconda install mamba -c conda-forge\nmamba install cartopy scipy -c conda-forge\nmamba install geemap -c conda-forge\njupyter notebook\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># !pip install cartopy scipy\n# !pip install geemap\n</pre> # !pip install cartopy scipy # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom geemap import cartoee\nimport cartopy.crs as ccrs\n\n%pylab inline\n</pre> import ee import geemap from geemap import cartoee import cartopy.crs as ccrs  %pylab inline In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = (\n    ee.ImageCollection('MODIS/MCD43A4_006_NDVI')\n    .filter(ee.Filter.date('2018-04-01', '2018-05-01'))\n    .select(\"NDVI\")\n    .first()\n)\n\nvis_params = {\n    'min': 0.0,\n    'max': 1.0,\n    'palette': [\n        'FFFFFF',\n        'CE7E45',\n        'DF923D',\n        'F1B555',\n        'FCD163',\n        '99B718',\n        '74A901',\n        '66A000',\n        '529400',\n        '3E8601',\n        '207401',\n        '056201',\n        '004C00',\n        '023B01',\n        '012E01',\n        '011D01',\n        '011301',\n    ],\n}\nMap.setCenter(-7.03125, 31.0529339857, 2)\nMap.addLayer(image, vis_params, 'MODIS NDVI')\n\ncountries = ee.FeatureCollection('users/giswqs/public/countries')\nstyle = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"}\nMap.addLayer(countries.style(**style), {}, \"Countries\")\n\nndvi = image.visualize(**vis_params)\nblend = ndvi.blend(countries.style(**style))\n\nMap.addLayer(blend, {}, \"Blend\")\n\nMap\n</pre> Map = geemap.Map()  image = (     ee.ImageCollection('MODIS/MCD43A4_006_NDVI')     .filter(ee.Filter.date('2018-04-01', '2018-05-01'))     .select(\"NDVI\")     .first() )  vis_params = {     'min': 0.0,     'max': 1.0,     'palette': [         'FFFFFF',         'CE7E45',         'DF923D',         'F1B555',         'FCD163',         '99B718',         '74A901',         '66A000',         '529400',         '3E8601',         '207401',         '056201',         '004C00',         '023B01',         '012E01',         '011D01',         '011301',     ], } Map.setCenter(-7.03125, 31.0529339857, 2) Map.addLayer(image, vis_params, 'MODIS NDVI')  countries = ee.FeatureCollection('users/giswqs/public/countries') style = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"} Map.addLayer(countries.style(**style), {}, \"Countries\")  ndvi = image.visualize(**vis_params) blend = ndvi.blend(countries.style(**style))  Map.addLayer(blend, {}, \"Blend\")  Map In\u00a0[\u00a0]: Copied! <pre># specify region to focus on\nbbox = [180, -88, -180, 88]\n</pre> # specify region to focus on bbox = [180, -88, -180, 88] In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(blend, region=bbox)\ncb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')\n\nax.set_title(label='MODIS NDVI', fontsize=15)\n\n# ax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(blend, region=bbox) cb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')  ax.set_title(label='MODIS NDVI', fontsize=15)  # ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\nprojection = ccrs.EqualEarth(central_longitude=-180)\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(blend, region=bbox, proj=projection)\ncb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')\n\nax.set_title(label='MODIS NDVI', fontsize=15)\n\n# ax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  projection = ccrs.EqualEarth(central_longitude=-180)  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(blend, region=bbox, proj=projection) cb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')  ax.set_title(label='MODIS NDVI', fontsize=15)  # ax.coastlines() plt.show()"},{"location":"notebooks/57_cartoee_blend/#creating-publication-quality-maps-with-multiple-earth-engine-layers","title":"Creating publication-quality maps with multiple Earth Engine layers\u00b6","text":""},{"location":"notebooks/57_cartoee_blend/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/57_cartoee_blend/#plot-an-image-with-the-default-projection","title":"Plot an image with the default projection\u00b6","text":""},{"location":"notebooks/57_cartoee_blend/#plot-an-image-with-a-different-projection","title":"Plot an image with a different projection\u00b6","text":""},{"location":"notebooks/58_add_vector/","title":"58 add vector","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[0, 0], zoom=2)\n\nin_geojson = 'https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/cable_geo.geojson'\nMap.add_geojson(in_geojson, layer_name=\"Cable lines\")\n\nMap\n</pre> Map = geemap.Map(center=[0, 0], zoom=2)  in_geojson = 'https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/cable_geo.geojson' Map.add_geojson(in_geojson, layer_name=\"Cable lines\")  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"\nMap.add_geojson(\n    url, layer_name=\"Countries\", fill_colors=['red', 'yellow', 'green', 'orange']\n)\nMap\n</pre> Map = geemap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\" Map.add_geojson(     url, layer_name=\"Countries\", fill_colors=['red', 'yellow', 'green', 'orange'] ) Map In\u00a0[\u00a0]: Copied! <pre>import random\n\nMap = geemap.Map(center=[0, 0], zoom=2)\n\nurl = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"\n\n\ndef random_color(feature):\n    return {\n        'color': 'black',\n        'fillColor': random.choice(['red', 'yellow', 'green', 'orange']),\n    }\n\n\nMap.add_geojson(url, layer_name=\"Countries\", style_callback=random_color)\nMap\n</pre> import random  Map = geemap.Map(center=[0, 0], zoom=2)  url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"   def random_color(feature):     return {         'color': 'black',         'fillColor': random.choice(['red', 'yellow', 'green', 'orange']),     }   Map.add_geojson(url, layer_name=\"Countries\", style_callback=random_color) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[0, 0], zoom=2)\n\nurl = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"\n\nstyle = {\n    \"stroke\": True,\n    \"color\": \"#0000ff\",\n    \"weight\": 2,\n    \"opacity\": 1,\n    \"fill\": True,\n    \"fillColor\": \"#0000ff\",\n    \"fillOpacity\": 0.1,\n}\n\nhover_style = {\"fillOpacity\": 0.7}\n\nMap.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style)\nMap\n</pre> Map = geemap.Map(center=[0, 0], zoom=2)  url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"  style = {     \"stroke\": True,     \"color\": \"#0000ff\",     \"weight\": 2,     \"opacity\": 1,     \"fill\": True,     \"fillColor\": \"#0000ff\",     \"fillOpacity\": 0.1, }  hover_style = {\"fillOpacity\": 0.7}  Map.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[0, 0], zoom=2)\n\nin_shp = '../data/countries.shp'\nMap.add_shapefile(in_shp, layer_name=\"Countries\")\n\nMap\n</pre> Map = geemap.Map(center=[0, 0], zoom=2)  in_shp = '../data/countries.shp' Map.add_shapefile(in_shp, layer_name=\"Countries\")  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nin_kml = '../data/us_states.kml'\nMap.add_kml(in_kml, layer_name=\"US States KML\")\n\nMap\n</pre> Map = geemap.Map()  in_kml = '../data/us_states.kml' Map.add_kml(in_kml, layer_name=\"US States KML\")  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"\nMap.add_vector(\n    url, layer_name=\"Countries\", fill_colors=['red', 'yellow', 'green', 'orange']\n)\nMap\n</pre> Map = geemap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\" Map.add_vector(     url, layer_name=\"Countries\", fill_colors=['red', 'yellow', 'green', 'orange'] ) Map In\u00a0[\u00a0]: Copied! <pre>import geemap.foliumap as geemap\n</pre> import geemap.foliumap as geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() In\u00a0[\u00a0]: Copied! <pre>in_shp = '../data/countries.shp'\nin_geojson = '../data/us_states.json'\nin_kml = '../data/us_states.kml'\n</pre> in_shp = '../data/countries.shp' in_geojson = '../data/us_states.json' in_kml = '../data/us_states.kml' In\u00a0[\u00a0]: Copied! <pre>Map.add_shapefile(in_shp, layer_name=\"Shapefile\")\n</pre> Map.add_shapefile(in_shp, layer_name=\"Shapefile\") In\u00a0[\u00a0]: Copied! <pre>Map.add_geojson(in_geojson, layer_name=\"GeoJSON\")\n</pre> Map.add_geojson(in_geojson, layer_name=\"GeoJSON\") In\u00a0[\u00a0]: Copied! <pre>Map.add_kml(in_kml, layer_name=\"KML\")\n</pre> Map.add_kml(in_kml, layer_name=\"KML\") In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map"},{"location":"notebooks/58_add_vector/#how-to-add-a-shapefile-geojson-and-kml-to-the-map","title":"How to add a shapefile, GeoJSON, and KML to the map\u00b6","text":""},{"location":"notebooks/58_add_vector/#for-ipyleaflet","title":"For ipyleaflet\u00b6","text":""},{"location":"notebooks/58_add_vector/#for-folium","title":"For folium\u00b6","text":""},{"location":"notebooks/59_whitebox/","title":"59 whitebox","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap\nimport whiteboxgui\n</pre> import os import geemap import whiteboxgui In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\ndem = os.path.join(out_dir, 'dem.tif')\n\nif not os.path.exists(dem):\n    dem_url = 'https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing'\n    geemap.download_from_gdrive(dem_url, 'dem.tif', out_dir, unzip=False)\n</pre> out_dir = os.path.expanduser('~/Downloads') dem = os.path.join(out_dir, 'dem.tif')  if not os.path.exists(dem):     dem_url = 'https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing'     geemap.download_from_gdrive(dem_url, 'dem.tif', out_dir, unzip=False) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>whiteboxgui.show()\n</pre> whiteboxgui.show() In\u00a0[\u00a0]: Copied! <pre>whiteboxgui.show(tree=True)\n</pre> whiteboxgui.show(tree=True)"},{"location":"notebooks/60_colormaps/","title":"60 colormaps","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport geemap.colormaps as cm\n</pre> import ee import geemap import geemap.colormaps as cm In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>cm.palettes.dem\n</pre> cm.palettes.dem In\u00a0[\u00a0]: Copied! <pre>cm.palettes.ndvi\n</pre> cm.palettes.ndvi In\u00a0[\u00a0]: Copied! <pre>cm.palettes.ndwi\n</pre> cm.palettes.ndwi In\u00a0[\u00a0]: Copied! <pre>cm.get_palette('terrain', n_class=8)\n</pre> cm.get_palette('terrain', n_class=8) In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap('terrain', width=8.0, height=0.4, orientation='horizontal')\n</pre> cm.plot_colormap('terrain', width=8.0, height=0.4, orientation='horizontal') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\npalette = cm.palettes.dem\n# palette = cm.palettes.terrain\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {'min': 0, 'max': 4000, 'palette': palette}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", font_size=9)\nMap\n</pre> Map = geemap.Map()  palette = cm.palettes.dem # palette = cm.palettes.terrain  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {'min': 0, 'max': 4000, 'palette': palette}  Map.addLayer(dem, vis_params, 'SRTM DEM') Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", font_size=9) Map In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params, label=\"Elevation (m)\", orientation=\"vertical\", layer_name=\"SRTM DEM\"\n)\n</pre> Map.add_colorbar(     vis_params, label=\"Elevation (m)\", orientation=\"vertical\", layer_name=\"SRTM DEM\" ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    orientation=\"vertical\",\n    layer_name=\"SRTM DEM\",\n    transparent_bg=True,\n)\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     orientation=\"vertical\",     layer_name=\"SRTM DEM\",     transparent_bg=True, ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    discrete=True,\n    label=\"Elevation (m)\",\n    orientation=\"vertical\",\n    layer_name=\"SRTM DEM\",\n)\n</pre> Map.add_colorbar(     vis_params,     discrete=True,     label=\"Elevation (m)\",     orientation=\"vertical\",     layer_name=\"SRTM DEM\", ) In\u00a0[\u00a0]: Copied! <pre># cm.list_colormaps()\n</pre> # cm.list_colormaps() In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormaps(width=12, height=0.4)\n</pre> cm.plot_colormaps(width=12, height=0.4)"},{"location":"notebooks/61_cartoee_scalebar/","title":"61 cartoee scalebar","text":"In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom geemap import cartoee\nimport matplotlib.pyplot as plt\n</pre> import ee import geemap from geemap import cartoee import matplotlib.pyplot as plt In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre># Get image\nlon = -115.1585\nlat = 36.1500\nstart_year = 1984\nend_year = 2011\n\npoint = ee.Geometry.Point(lon, lat)\nyears = ee.List.sequence(start_year, end_year)\n\n\ndef get_best_image(year):\n    start_date = ee.Date.fromYMD(year, 1, 1)\n    end_date = ee.Date.fromYMD(year, 12, 31)\n    image = (\n        ee.ImageCollection(\"LANDSAT/LT05/C01/T1_SR\")\n        .filterBounds(point)\n        .filterDate(start_date, end_date)\n        .sort(\"CLOUD_COVER\")\n        .first()\n    )\n    return ee.Image(image)\n\n\ncollection = ee.ImageCollection(years.map(get_best_image))\n\n\nvis_params = {\"bands\": ['B4', 'B3', 'B2'], \"min\": 0, \"max\": 5000}\n\nimage = ee.Image(collection.first())\n</pre> # Get image lon = -115.1585 lat = 36.1500 start_year = 1984 end_year = 2011  point = ee.Geometry.Point(lon, lat) years = ee.List.sequence(start_year, end_year)   def get_best_image(year):     start_date = ee.Date.fromYMD(year, 1, 1)     end_date = ee.Date.fromYMD(year, 12, 31)     image = (         ee.ImageCollection(\"LANDSAT/LT05/C01/T1_SR\")         .filterBounds(point)         .filterDate(start_date, end_date)         .sort(\"CLOUD_COVER\")         .first()     )     return ee.Image(image)   collection = ee.ImageCollection(years.map(get_best_image))   vis_params = {\"bands\": ['B4', 'B3', 'B2'], \"min\": 0, \"max\": 5000}  image = ee.Image(collection.first()) In\u00a0[\u00a0]: Copied! <pre>w = 0.4\nh = 0.3\n\nregion = [lon + w, lat - h, lon - w, lat + h]\n\nfig = plt.figure(figsize=(10, 8))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, region=region, vis_params=vis_params)\n\n# add gridlines to the map at a specified interval\ncartoee.add_gridlines(ax, interval=[0.2, 0.2], linestyle=\":\")\n\n# add north arrow\nnorth_arrow_dict = {\n    \"text\": \"N\",\n    \"xy\": (0.10, 0.36),\n    \"arrow_length\": 0.15,\n    \"text_color\": \"white\",\n    \"arrow_color\": \"white\",\n    \"fontsize\": 20,\n    \"width\": 5,\n    \"headwidth\": 15,\n    \"ha\": \"center\",\n    \"va\": \"center\",\n}\ncartoee.add_north_arrow(ax, **north_arrow_dict)\n\n# add scale bar\nscale_bar_dict = {\n    'metric_distance': 4,\n    'unit': \"km\",\n    'at_x': (0.05, 0.2),\n    'at_y': (0.08, 0.11),\n    'max_stripes': 5,\n    'ytick_label_margins': 0.25,\n    'fontsize': 8,\n    'font_weight': \"bold\",\n    'rotation': 0,\n    'zorder': 999,\n    'paddings': {\"xmin\": 0.05, \"xmax\": 0.05, \"ymin\": 1.5, \"ymax\": 0.5},\n}\n\ncartoee.add_scale_bar(ax, **scale_bar_dict)\n\nax.set_title(label='Las Vegas, NV', fontsize=15)\nplt.show()\n</pre> w = 0.4 h = 0.3  region = [lon + w, lat - h, lon - w, lat + h]  fig = plt.figure(figsize=(10, 8))  # use cartoee to get a map ax = cartoee.get_map(image, region=region, vis_params=vis_params)  # add gridlines to the map at a specified interval cartoee.add_gridlines(ax, interval=[0.2, 0.2], linestyle=\":\")  # add north arrow north_arrow_dict = {     \"text\": \"N\",     \"xy\": (0.10, 0.36),     \"arrow_length\": 0.15,     \"text_color\": \"white\",     \"arrow_color\": \"white\",     \"fontsize\": 20,     \"width\": 5,     \"headwidth\": 15,     \"ha\": \"center\",     \"va\": \"center\", } cartoee.add_north_arrow(ax, **north_arrow_dict)  # add scale bar scale_bar_dict = {     'metric_distance': 4,     'unit': \"km\",     'at_x': (0.05, 0.2),     'at_y': (0.08, 0.11),     'max_stripes': 5,     'ytick_label_margins': 0.25,     'fontsize': 8,     'font_weight': \"bold\",     'rotation': 0,     'zorder': 999,     'paddings': {\"xmin\": 0.05, \"xmax\": 0.05, \"ymin\": 1.5, \"ymax\": 0.5}, }  cartoee.add_scale_bar(ax, **scale_bar_dict)  ax.set_title(label='Las Vegas, NV', fontsize=15) plt.show()"},{"location":"notebooks/62_time_slider/","title":"62 time slider","text":"In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = (\n    ee.ImageCollection('NOAA/GFS0P25')\n    .filterDate('2018-12-22', '2018-12-23')\n    .limit(24)\n    .select('temperature_2m_above_ground')\n)\n\nvis_params = {\n    'min': -40.0,\n    'max': 35.0,\n    'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'],\n}\n\nfirst_image = collection.first()\n\nMap.addLayer(first_image, vis_params, \"First image\", False)\nMap.setCenter(-0.3490, 25.7900, 2)\nMap\n</pre> Map = geemap.Map()  collection = (     ee.ImageCollection('NOAA/GFS0P25')     .filterDate('2018-12-22', '2018-12-23')     .limit(24)     .select('temperature_2m_above_ground') )  vis_params = {     'min': -40.0,     'max': 35.0,     'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'], }  first_image = collection.first()  Map.addLayer(first_image, vis_params, \"First image\", False) Map.setCenter(-0.3490, 25.7900, 2) Map In\u00a0[\u00a0]: Copied! <pre>labels = [str(n).zfill(2) + \":00\" for n in range(0, 24)]\nprint(labels)\n</pre> labels = [str(n).zfill(2) + \":00\" for n in range(0, 24)] print(labels) In\u00a0[\u00a0]: Copied! <pre>Map.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8)\n</pre> Map.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = (\n    ee.ImageCollection('MODIS/MCD43A4_006_NDVI')\n    .filter(ee.Filter.date('2018-04-01', '2018-05-01'))\n    .select(\"NDVI\")\n)\nvis_params = {\n    'min': 0.0,\n    'max': 1.0,\n    'palette': [\n        'FFFFFF',\n        'CE7E45',\n        'DF923D',\n        'F1B555',\n        'FCD163',\n        '99B718',\n        '74A901',\n        '66A000',\n        '529400',\n        '3E8601',\n        '207401',\n        '056201',\n        '004C00',\n        '023B01',\n        '012E01',\n        '011D01',\n        '011301',\n    ],\n}\n\nfirst_image = collection.first()\n\nMap.addLayer(first_image, vis_params, \"First image\", False)\nMap.setCenter(-7.03125, 31.0529339857, 2)\nMap\n</pre> Map = geemap.Map()  collection = (     ee.ImageCollection('MODIS/MCD43A4_006_NDVI')     .filter(ee.Filter.date('2018-04-01', '2018-05-01'))     .select(\"NDVI\") ) vis_params = {     'min': 0.0,     'max': 1.0,     'palette': [         'FFFFFF',         'CE7E45',         'DF923D',         'F1B555',         'FCD163',         '99B718',         '74A901',         '66A000',         '529400',         '3E8601',         '207401',         '056201',         '004C00',         '023B01',         '012E01',         '011D01',         '011301',     ], }  first_image = collection.first()  Map.addLayer(first_image, vis_params, \"First image\", False) Map.setCenter(-7.03125, 31.0529339857, 2) Map In\u00a0[\u00a0]: Copied! <pre>Map.add_time_slider(collection, vis_params, time_interval=1)\n</pre> Map.add_time_slider(collection, vis_params, time_interval=1) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nbands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\nimage = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(bands)\nvis_params = {'min': 20, 'max': 200, 'gamma': 2.0}\n\nMap.add_time_slider(image, vis_params, time_interval=1)\nMap\n</pre> Map = geemap.Map()  bands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] image = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(bands) vis_params = {'min': 20, 'max': 200, 'gamma': 2.0}  Map.add_time_slider(image, vis_params, time_interval=1) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[37.75, -122.45], zoom=12)\n\nS2 = (\n    ee.ImageCollection('COPERNICUS/S2_SR')\n    .filterBounds(ee.Geometry.Point([-122.45, 37.75]))\n    .filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10)\n)\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\n\nMap.addLayer(S2, {}, \"Sentinel-2\", False)\nMap.add_time_slider(S2, vis_params)\nMap\n</pre> Map = geemap.Map(center=[37.75, -122.45], zoom=12)  S2 = (     ee.ImageCollection('COPERNICUS/S2_SR')     .filterBounds(ee.Geometry.Point([-122.45, 37.75]))     .filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10) )  vis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}  Map.addLayer(S2, {}, \"Sentinel-2\", False) Map.add_time_slider(S2, vis_params) Map"},{"location":"notebooks/62_time_slider/#visualizing-weather-data","title":"Visualizing weather data\u00b6","text":""},{"location":"notebooks/62_time_slider/#visualizing-vegetation-data","title":"Visualizing vegetation data\u00b6","text":""},{"location":"notebooks/62_time_slider/#visualizing-landsat-imagery","title":"Visualizing Landsat imagery\u00b6","text":""},{"location":"notebooks/62_time_slider/#visualizing-sentinel-2-imagery","title":"Visualizing Sentinel-2 imagery\u00b6","text":""},{"location":"notebooks/63_charts/","title":"63 charts","text":"<p>Chart Overview</p> <p>Reference: https://developers.google.com/earth-engine/guides/charts_feature#column_chart</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport geemap.chart as chart\n\n# from geemap import chart\n</pre> import ee import geemap import geemap.chart as chart  # from geemap import chart In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nfeatures = ee.FeatureCollection('projects/google/charts_feature_example').select(\n    '[0-9][0-9]_tmean|label'\n)\n\nMap.addLayer(features, {}, \"Ecoregions\")\nMap\n</pre> Map = geemap.Map()  features = ee.FeatureCollection('projects/google/charts_feature_example').select(     '[0-9][0-9]_tmean|label' )  Map.addLayer(features, {}, \"Ecoregions\") Map In\u00a0[\u00a0]: Copied! <pre>df = geemap.ee_to_pandas(features)\ndf\n</pre> df = geemap.ee_to_pandas(features) df In\u00a0[\u00a0]: Copied! <pre>xProperty = \"label\"\nyProperties = [str(x).zfill(2) + \"_tmean\" for x in range(1, 13)]\n\nlabels = [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec',\n]\ncolors = [\n    '#604791',\n    '#1d6b99',\n    '#39a8a7',\n    '#0f8755',\n    '#76b349',\n    '#f0af07',\n    '#e37d05',\n    '#cf513e',\n    '#96356f',\n    '#724173',\n    '#9c4f97',\n    '#696969',\n]\ntitle = \"Average Monthly Temperature by Ecoregion\"\nxlabel = \"Ecoregion\"\nylabel = \"Temperature\"\n</pre> xProperty = \"label\" yProperties = [str(x).zfill(2) + \"_tmean\" for x in range(1, 13)]  labels = [     'Jan',     'Feb',     'Mar',     'Apr',     'May',     'Jun',     'Jul',     'Aug',     'Sep',     'Oct',     'Nov',     'Dec', ] colors = [     '#604791',     '#1d6b99',     '#39a8a7',     '#0f8755',     '#76b349',     '#f0af07',     '#e37d05',     '#cf513e',     '#96356f',     '#724173',     '#9c4f97',     '#696969', ] title = \"Average Monthly Temperature by Ecoregion\" xlabel = \"Ecoregion\" ylabel = \"Temperature\" In\u00a0[\u00a0]: Copied! <pre>options = {\n    \"labels\": labels,\n    \"colors\": colors,\n    \"title\": title,\n    \"xlabel\": xlabel,\n    \"ylabel\": ylabel,\n    \"legend_location\": \"top-left\",\n    \"height\": \"500px\",\n}\n</pre> options = {     \"labels\": labels,     \"colors\": colors,     \"title\": title,     \"xlabel\": xlabel,     \"ylabel\": ylabel,     \"legend_location\": \"top-left\",     \"height\": \"500px\", } In\u00a0[\u00a0]: Copied! <pre>chart.feature_byFeature(features, xProperty, yProperties, **options)\n</pre> chart.feature_byFeature(features, xProperty, yProperties, **options) <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nfeatures = ee.FeatureCollection('projects/google/charts_feature_example').select(\n    '[0-9][0-9]_ppt|label'\n)\n\nMap.addLayer(features, {}, 'Features')\nMap\n</pre> Map = geemap.Map()  features = ee.FeatureCollection('projects/google/charts_feature_example').select(     '[0-9][0-9]_ppt|label' )  Map.addLayer(features, {}, 'Features') Map In\u00a0[\u00a0]: Copied! <pre>df = geemap.ee_to_pandas(features)\ndf\n</pre> df = geemap.ee_to_pandas(features) df In\u00a0[\u00a0]: Copied! <pre>keys = [str(x).zfill(2) + \"_ppt\" for x in range(1, 13)]\nvalues = [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec',\n]\n</pre> keys = [str(x).zfill(2) + \"_ppt\" for x in range(1, 13)] values = [     'Jan',     'Feb',     'Mar',     'Apr',     'May',     'Jun',     'Jul',     'Aug',     'Sep',     'Oct',     'Nov',     'Dec', ] In\u00a0[\u00a0]: Copied! <pre>xProperties = dict(zip(keys, values))\nseriesProperty = \"label\"\n</pre> xProperties = dict(zip(keys, values)) seriesProperty = \"label\" In\u00a0[\u00a0]: Copied! <pre>options = {\n    'title': \"Average Ecoregion Precipitation by Month\",\n    'colors': ['#f0af07', '#0f8755', '#76b349'],\n    'xlabel': \"Month\",\n    'ylabel': \"Precipitation (mm)\",\n    'legend_location': \"top-left\",\n    \"height\": \"500px\",\n}\n</pre> options = {     'title': \"Average Ecoregion Precipitation by Month\",     'colors': ['#f0af07', '#0f8755', '#76b349'],     'xlabel': \"Month\",     'ylabel': \"Precipitation (mm)\",     'legend_location': \"top-left\",     \"height\": \"500px\", } In\u00a0[\u00a0]: Copied! <pre>chart.feature_byProperty(features, xProperties, seriesProperty, **options)\n</pre> chart.feature_byProperty(features, xProperties, seriesProperty, **options) <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nfeatures = ee.FeatureCollection('projects/google/charts_feature_example')\nxProperty = 'label'\nyProperty = '01_tmean'\nseriesProperty = 'warm'\n</pre> Map = geemap.Map()  features = ee.FeatureCollection('projects/google/charts_feature_example') xProperty = 'label' yProperty = '01_tmean' seriesProperty = 'warm' In\u00a0[\u00a0]: Copied! <pre>options = {\n    'title': \"Average January Temperature by Ecoregion\",\n    'colors': ['#cf513e', '#1d6b99'],\n    'xlabel': \"Ecoregion\",\n    'ylabel': \"Jan temp (C)\",\n    'legend_location': \"top-right\",\n    'height': \"500px\",\n    'labels': [\"Warm\", \"Cold\"],\n}\n</pre> options = {     'title': \"Average January Temperature by Ecoregion\",     'colors': ['#cf513e', '#1d6b99'],     'xlabel': \"Ecoregion\",     'ylabel': \"Jan temp (C)\",     'legend_location': \"top-right\",     'height': \"500px\",     'labels': [\"Warm\", \"Cold\"], } In\u00a0[\u00a0]: Copied! <pre>chart.feature_groups(features, xProperty, yProperty, seriesProperty, **options)\n</pre> chart.feature_groups(features, xProperty, yProperty, seriesProperty, **options)"},{"location":"notebooks/63_charts/#creating-a-chart-from-eefeaturecollection-by-feature","title":"Creating a chart from ee.FeatureCollection by feature\u00b6","text":"<p>Reference: https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturebyfeature</p>"},{"location":"notebooks/63_charts/#creating-a-chart-from-eefeaturecollection-by-property","title":"Creating a chart from ee.FeatureCollection by property\u00b6","text":"<p>Reference: https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturebyproperty</p>"},{"location":"notebooks/63_charts/#creating-a-chart-from-eefeaturecollection-from-a-group-of-features","title":"Creating a chart from ee.FeatureCollection from a group of features\u00b6","text":"<p>Reference: https://developers.google.com/earth-engine/guides/charts_feature#uichartfeaturegroups</p>"},{"location":"notebooks/64_data_catalog/","title":"64 data catalog","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import DATA, get_metadata\n</pre> from geemap.datasets import DATA, get_metadata In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = ee.Geometry.Point(-122.4488, 37.7589)\n</pre> roi = ee.Geometry.Point(-122.4488, 37.7589) In\u00a0[\u00a0]: Copied! <pre>collection = (\n    ee.ImageCollection(DATA.LANDSAT_LC08_C01_T1_SR)\n    .filterDate('2020-01-01', '2020-12-31')\n    .filterBounds(roi)\n    .sort(\"CLOUD_COVER\")\n)\n</pre> collection = (     ee.ImageCollection(DATA.LANDSAT_LC08_C01_T1_SR)     .filterDate('2020-01-01', '2020-12-31')     .filterBounds(roi)     .sort(\"CLOUD_COVER\") ) In\u00a0[\u00a0]: Copied! <pre>image = collection.first()\n</pre> image = collection.first() In\u00a0[\u00a0]: Copied! <pre>vis_params = {'min': 0, 'max': 2000, 'bands': ['B5', 'B4', 'B3'], 'gamma': 1.5}\n</pre> vis_params = {'min': 0, 'max': 2000, 'bands': ['B5', 'B4', 'B3'], 'gamma': 1.5} In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(image, vis_params, \"Landsat\")\nMap.centerObject(image)\n</pre> Map.addLayer(image, vis_params, \"Landsat\") Map.centerObject(image) In\u00a0[\u00a0]: Copied! <pre>get_metadata(DATA.LANDSAT_LC08_C01_T1_SR)\n</pre> get_metadata(DATA.LANDSAT_LC08_C01_T1_SR) In\u00a0[\u00a0]: Copied! <pre>get_metadata(DATA.COPERNICUS_S2_SR)\n</pre> get_metadata(DATA.COPERNICUS_S2_SR) In\u00a0[\u00a0]: Copied! <pre>get_metadata(DATA.USGS_GAP_CONUS_2011)\n</pre> get_metadata(DATA.USGS_GAP_CONUS_2011) In\u00a0[\u00a0]: Copied! <pre>get_metadata(DATA.NOAA_GFS0P25)\n</pre> get_metadata(DATA.NOAA_GFS0P25)"},{"location":"notebooks/65_vector_styling/","title":"65 vector styling","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p>Styling Earth Engine vector data</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\")  Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nimage = ee.Image().paint(states, 0, 3)\n\nMap.addLayer(image, {'palette': 'red'}, \"US States\")\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\") image = ee.Image().paint(states, 0, 3)  Map.addLayer(image, {'palette': 'red'}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {'color': '0000ffff', 'width': 2, 'lineType': 'solid', 'fillColor': '00000080'}\n\nMap.addLayer(states.style(**style), {}, \"US States\")\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\") style = {'color': '0000ffff', 'width': 2, 'lineType': 'solid', 'fillColor': '00000080'}  Map.addLayer(states.style(**style), {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    'color': '000000',\n    'colorOpacity': 1,\n    'pointSize': 3,\n    'pointShape': 'circle',\n    'width': 2,\n    'lineType': 'solid',\n    'fillColorOpacity': 0.66,\n}\n\npalette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']\n\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\")  vis_params = {     'color': '000000',     'colorOpacity': 1,     'pointSize': 3,     'pointShape': 'circle',     'width': 2,     'lineType': 'solid',     'fillColorOpacity': 0.66, }  palette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']  Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params ) Map In\u00a0[\u00a0]: Copied! <pre>import geemap.colormaps as cm\n</pre> import geemap.colormaps as cm In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    'color': '000000',\n    'colorOpacity': 1,\n    'pointSize': 3,\n    'pointShape': 'circle',\n    'width': 2,\n    'lineType': 'solid',\n    'fillColorOpacity': 0.66,\n}\n\npalette = list(cm.palettes.gist_earth.n12)\n\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\")  vis_params = {     'color': '000000',     'colorOpacity': 1,     'pointSize': 3,     'pointShape': 'circle',     'width': 2,     'lineType': 'solid',     'fillColorOpacity': 0.66, }  palette = list(cm.palettes.gist_earth.n12)  Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\").filter(\n    ee.Filter.inList('NAME', ['California', 'Nevada', 'Utah', 'Arizona'])\n)\n\npalette = {\n    'California': 'ff0000',\n    'Nevada': '00ff00',\n    'Utah': '0000ff',\n    'Arizona': 'ffff00',\n}\n\nvis_params = {\n    'color': '000000',\n    'colorOpacity': 1,\n    'width': 2,\n    'lineType': 'solid',\n    'fillColorOpacity': 0.66,\n}\n\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\n\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\").filter(     ee.Filter.inList('NAME', ['California', 'Nevada', 'Utah', 'Arizona']) )  palette = {     'California': 'ff0000',     'Nevada': '00ff00',     'Utah': '0000ff',     'Arizona': 'ffff00', }  vis_params = {     'color': '000000',     'colorOpacity': 1,     'width': 2,     'lineType': 'solid',     'fillColorOpacity': 0.66, }  Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params )  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\")  Map.addLayer(states, {}, \"US States\") Map"},{"location":"notebooks/65_vector_styling/#use-the-default-style","title":"Use the default style\u00b6","text":""},{"location":"notebooks/65_vector_styling/#use-imagepaint","title":"Use Image.paint()\u00b6","text":""},{"location":"notebooks/65_vector_styling/#use-featurecollectionstyle","title":"Use FeatureCollection.style()\u00b6","text":""},{"location":"notebooks/65_vector_styling/#use-add_styled_vector","title":"Use add_styled_vector()\u00b6","text":""},{"location":"notebooks/65_vector_styling/#use-interactive-gui","title":"Use interactive GUI\u00b6","text":""},{"location":"notebooks/66_cartoee_legend/","title":"66 cartoee legend","text":"<p>Uncomment the following line to install geemap and cartopy if needed. Keep in mind that cartopy can be challenging to install. If you are unable to install cartopy on your computer, you can try Google Colab with this the notebook example.</p> <p>See below the commands to install cartopy and geemap using conda/mamba:</p> <pre><code>conda create -n carto python=3.8\nconda activate carto\nconda install mamba -c conda-forge\nmamba install cartopy scipy -c conda-forge\nmamba install geemap -c conda-forge\njupyter notebook\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># !pip install cartopy scipy\n# !pip install geemap\n</pre> # !pip install cartopy scipy # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>%pylab inline\n\nimport ee\nimport geemap\n\n# import the cartoee functionality from geemap\nfrom geemap import cartoee\n</pre> %pylab inline  import ee import geemap  # import the cartoee functionality from geemap from geemap import cartoee In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre># get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n\n# define the visualization parameters to view\nvis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3}\n</pre> # get a landsat image to visualize image = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')  # define the visualization parameters to view vis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3} In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, vis_params=vis)\n\n# pad the view for some visual appeal\ncartoee.pad_view(ax)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")\n\n# add the coastline\nax.coastlines(color=\"cyan\")\n\nshow()\n</pre> fig = plt.figure(figsize=(15, 10))  # use cartoee to get a map ax = cartoee.get_map(image, vis_params=vis)  # pad the view for some visual appeal cartoee.pad_view(ax)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.5, xtick_rotation=0, linestyle=\":\")  # add the coastline ax.coastlines(color=\"cyan\")  show() <p>By default, if a region is not provided via the <code>region</code> keyword the whole extent of the image will be plotted as seen in the previous Landsat example. We can also zoom to a specific region of an image by defining the region to plot.</p> In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# here is the bounding box of the map extent we want to use\n# formatted a [E,S,W,N]\nzoom_region = [-121.8025, 37.3458, -122.6265, 37.9178]\n\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.15, xtick_rotation=0, linestyle=\":\")\n\n# add coastline\nax.coastlines(color=\"cyan\")\n\nshow()\n</pre> fig = plt.figure(figsize=(15, 10))  # here is the bounding box of the map extent we want to use # formatted a [E,S,W,N] zoom_region = [-121.8025, 37.3458, -122.6265, 37.9178]  # plot the map over the region of interest ax = cartoee.get_map(image, vis_params=vis, region=zoom_region)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.15, xtick_rotation=0, linestyle=\":\")  # add coastline ax.coastlines(color=\"cyan\")  show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# here is the bounding box of the map extent we want to use\n# formatted a [E,S,W,N]\nzoom_region = [-121.8025, 37.3458, -122.6265, 37.9178]\n\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.15, xtick_rotation=0, linestyle=\":\")\n\n# add coastline\nax.coastlines(color=\"cyan\")\n\n# add north arrow\ncartoee.add_north_arrow(\n    ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20\n)\n\n# add scale bar\ncartoee.add_scale_bar_lite(\n    ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\"\n)\n\nax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)\n\n# add legend\nlegend_elements = [\n    Line2D([], [], color='#00ffff', lw=2, label='Coastline'),\n    Line2D(\n        [],\n        [],\n        marker='o',\n        color='#A8321D',\n        label='City',\n        markerfacecolor='#A8321D',\n        markersize=10,\n        ls='',\n    ),\n]\n\ncartoee.add_legend(ax, legend_elements, loc='lower right')\n\nshow()\n</pre> fig = plt.figure(figsize=(15, 10))  # here is the bounding box of the map extent we want to use # formatted a [E,S,W,N] zoom_region = [-121.8025, 37.3458, -122.6265, 37.9178]  # plot the map over the region of interest ax = cartoee.get_map(image, vis_params=vis, region=zoom_region)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.15, xtick_rotation=0, linestyle=\":\")  # add coastline ax.coastlines(color=\"cyan\")  # add north arrow cartoee.add_north_arrow(     ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20 )  # add scale bar cartoee.add_scale_bar_lite(     ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\" )  ax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)  # add legend legend_elements = [     Line2D([], [], color='#00ffff', lw=2, label='Coastline'),     Line2D(         [],         [],         marker='o',         color='#A8321D',         label='City',         markerfacecolor='#A8321D',         markersize=10,         ls='',     ), ]  cartoee.add_legend(ax, legend_elements, loc='lower right')  show()"},{"location":"notebooks/66_cartoee_legend/#plot-an-rgb-image","title":"Plot an RGB image\u00b6","text":""},{"location":"notebooks/66_cartoee_legend/#adding-north-arrow-scale-bar-and-legend","title":"Adding north arrow, scale bar, and legend\u00b6","text":""},{"location":"notebooks/67_training_samples/","title":"67 training samples","text":"In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube(\"https://youtu.be/VWh5PxXPZw0\")\n</pre> geemap.show_youtube(\"https://youtu.be/VWh5PxXPZw0\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>if Map.user_rois is not None:\n    training_samples = Map.user_rois\n    print(training_samples.getInfo())\n</pre> if Map.user_rois is not None:     training_samples = Map.user_rois     print(training_samples.getInfo())"},{"location":"notebooks/68_netcdf_to_ee/","title":"68 netcdf to ee","text":"<p>Uncomment the following line to install geemap if needed.</p> <p>You will also need to install the following package:</p> <ul> <li><code>xarray</code></li> </ul> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\n</pre> import os import ee import geemap import geemap.colormaps as cm In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>nc_file = '../data/wind_global.nc'\n</pre> nc_file = '../data/wind_global.nc' In\u00a0[\u00a0]: Copied! <pre>if not os.path.exists(nc_file):\n    url = 'https://github.com/gee-community/geemap/blob/master/examples/data/wind_global.nc'\n    import requests\n\n    r = requests.get(url)\n    wind_data = r.content\n    with open('wind_global.nc', 'wb') as f:\n        f.write(wind_data)\n</pre> if not os.path.exists(nc_file):     url = 'https://github.com/gee-community/geemap/blob/master/examples/data/wind_global.nc'     import requests      r = requests.get(url)     wind_data = r.content     with open('wind_global.nc', 'wb') as f:         f.write(wind_data) In\u00a0[\u00a0]: Copied! <pre># Test with only one variable\nimg = geemap.netcdf_to_ee(nc_file=nc_file, var_names='u_wind')\npalette = cm.palettes.YlOrRd\n\nMap = geemap.Map()\nMap.addLayer(img, {'min': -20, 'max': 25, 'palette': palette, 'opacity': 0.6}, \"u_wind\")\nMap\n</pre> # Test with only one variable img = geemap.netcdf_to_ee(nc_file=nc_file, var_names='u_wind') palette = cm.palettes.YlOrRd  Map = geemap.Map() Map.addLayer(img, {'min': -20, 'max': 25, 'palette': palette, 'opacity': 0.6}, \"u_wind\") Map In\u00a0[\u00a0]: Copied! <pre># Test with two variables\nimg2 = geemap.netcdf_to_ee(nc_file=nc_file, var_names=['u_wind', 'v_wind'])\nMap2 = geemap.Map()\nMap2.addLayer(\n    img2,\n    {'bands': ['u_wind'], 'min': -20, 'max': 25, 'palette': palette, 'opacity': 0.6},\n    \"uv_wind\",\n)\nMap2\n</pre> # Test with two variables img2 = geemap.netcdf_to_ee(nc_file=nc_file, var_names=['u_wind', 'v_wind']) Map2 = geemap.Map() Map2.addLayer(     img2,     {'bands': ['u_wind'], 'min': -20, 'max': 25, 'palette': palette, 'opacity': 0.6},     \"uv_wind\", ) Map2"},{"location":"notebooks/69_cartoee_vector/","title":"69 cartoee vector","text":"<p>Plotting Earth Engine vector data with cartoee</p> <p>Uncomment the following line to install geemap and cartopy if needed. Keep in mind that cartopy can be challenging to install. If you are unable to install cartopy on your computer, you can try Google Colab with this the notebook example.</p> <p>See below the commands to install cartopy and geemap using conda/mamba:</p> <pre><code>conda create -n carto python=3.8\nconda activate carto\nconda install cartopy scipy -c conda-forge\nconda install geemap -c conda-forge\njupyter notebook\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># !pip install cartopy scipy\n# !pip install geemap\n</pre> # !pip install cartopy scipy # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom geemap import cartoee\nfrom geemap.datasets import DATA\nimport geemap.colormaps as cmap\nimport cartopy.crs as ccrs\n\n%pylab inline\n</pre> import ee import geemap from geemap import cartoee from geemap.datasets import DATA import geemap.colormaps as cmap import cartopy.crs as ccrs  %pylab inline In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nfeatures = ee.FeatureCollection(DATA.users_giswqs_public_countries)\n\nstyle = {'color': '000000ff', 'width': 1, 'lineType': 'solid', 'fillColor': '0000ff40'}\n\nMap.addLayer(features.style(**style), {}, \"Polygons\")\nMap.setCenter(-14.77, 34.70, 2)\nMap\n</pre> Map = geemap.Map()  features = ee.FeatureCollection(DATA.users_giswqs_public_countries)  style = {'color': '000000ff', 'width': 1, 'lineType': 'solid', 'fillColor': '0000ff40'}  Map.addLayer(features.style(**style), {}, \"Polygons\") Map.setCenter(-14.77, 34.70, 2) Map In\u00a0[\u00a0]: Copied! <pre># specify region to focus on\nbbox = [180, -88, -180, 88]\n</pre> # specify region to focus on bbox = [180, -88, -180, 88] In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(features, region=bbox, style=style)\nax.set_title(label='Countries', fontsize=15)\ncartoee.add_gridlines(ax, interval=30)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(features, region=bbox, style=style) ax.set_title(label='Countries', fontsize=15) cartoee.add_gridlines(ax, interval=30)  plt.show() <p></p> In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\nprojection = ccrs.EqualEarth(central_longitude=-180)\nax = cartoee.get_map(features, region=bbox, proj=projection, style=style)\nax.set_title(label='Countries', fontsize=15)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  projection = ccrs.EqualEarth(central_longitude=-180) ax = cartoee.get_map(features, region=bbox, proj=projection, style=style) ax.set_title(label='Countries', fontsize=15)  plt.show() <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nfeatures = ee.FeatureCollection(DATA.users_giswqs_public_countries)\n\npalette = cmap.palettes.gist_earth\nfeatures_styled = geemap.vector_styling(features, column=\"name\", palette=palette)\n\nMap.add_styled_vector(features, column=\"name\", palette=palette, layer_name='Polygon')\nMap.setCenter(-14.77, 34.70, 2)\nMap\n</pre> Map = geemap.Map()  features = ee.FeatureCollection(DATA.users_giswqs_public_countries)  palette = cmap.palettes.gist_earth features_styled = geemap.vector_styling(features, column=\"name\", palette=palette)  Map.add_styled_vector(features, column=\"name\", palette=palette, layer_name='Polygon') Map.setCenter(-14.77, 34.70, 2) Map In\u00a0[\u00a0]: Copied! <pre>bbox = [180, -88, -180, 88]\nfig = plt.figure(figsize=(15, 10))\n\nax = cartoee.get_map(features_styled, region=bbox)\nax.set_title(label='Countries', fontsize=15)\ncartoee.add_gridlines(ax, interval=30)\n\nplt.show()\n</pre> bbox = [180, -88, -180, 88] fig = plt.figure(figsize=(15, 10))  ax = cartoee.get_map(features_styled, region=bbox) ax.set_title(label='Countries', fontsize=15) cartoee.add_gridlines(ax, interval=30)  plt.show() <p></p> In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\nprojection = ccrs.EqualEarth(central_longitude=-180)\nax = cartoee.get_map(features_styled, region=bbox, proj=projection)\nax.set_title(label='Countries', fontsize=15)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  projection = ccrs.EqualEarth(central_longitude=-180) ax = cartoee.get_map(features_styled, region=bbox, proj=projection) ax.set_title(label='Countries', fontsize=15)  plt.show() <p></p>"},{"location":"notebooks/69_cartoee_vector/#plot-a-simple-vector","title":"Plot a simple vector\u00b6","text":""},{"location":"notebooks/69_cartoee_vector/#plot-a-styled-vector","title":"Plot a styled vector\u00b6","text":""},{"location":"notebooks/70_linked_maps/","title":"70 linked maps","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>geemap.linked_maps(rows=1, cols=2, height=\"400px\", center=[38.4151, 21.2712], zoom=12)\n</pre> geemap.linked_maps(rows=1, cols=2, height=\"400px\", center=[38.4151, 21.2712], zoom=12) In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection('COPERNICUS/S2')\n    .filterDate('2018-09-01', '2018-09-30')\n    .map(lambda img: img.divide(10000))\n    .median()\n)\n</pre> image = (     ee.ImageCollection('COPERNICUS/S2')     .filterDate('2018-09-01', '2018-09-30')     .map(lambda img: img.divide(10000))     .median() ) In\u00a0[\u00a0]: Copied! <pre>vis_params = [\n    {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n]\n</pre> vis_params = [     {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3}, ] In\u00a0[\u00a0]: Copied! <pre>labels = [\n    'Natural Color (B4/B3/B2)',\n    'Land/Water (B8/B11/B4)',\n    'Color Infrared (B8/B4/B3)',\n    'Vegetation (B12/B11/B4)',\n]\n</pre> labels = [     'Natural Color (B4/B3/B2)',     'Land/Water (B8/B11/B4)',     'Color Infrared (B8/B4/B3)',     'Vegetation (B12/B11/B4)', ] In\u00a0[\u00a0]: Copied! <pre>geemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"400px\",\n    center=[38.4151, 21.2712],\n    zoom=12,\n    ee_objects=[image],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n</pre> geemap.linked_maps(     rows=2,     cols=2,     height=\"400px\",     center=[38.4151, 21.2712],     zoom=12,     ee_objects=[image],     vis_params=vis_params,     labels=labels,     label_position=\"topright\", )"},{"location":"notebooks/71_timelapse/","title":"71 timelapse","text":"<p>Try it out: https://streamlit.geemap.org</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map <p></p>"},{"location":"notebooks/72_time_slider_gui/","title":"72 time slider gui","text":"In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[37.75, -122.45], zoom=12)\n\nS2 = (\n    ee.ImageCollection('COPERNICUS/S2_SR')\n    .filterBounds(ee.Geometry.Point([-122.45, 37.75]))\n    .filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10)\n)\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\n\nMap.addLayer(S2, {}, \"Sentinel-2\", False)\nMap.add_time_slider(S2, vis_params)\nMap\n</pre> Map = geemap.Map(center=[37.75, -122.45], zoom=12)  S2 = (     ee.ImageCollection('COPERNICUS/S2_SR')     .filterBounds(ee.Geometry.Point([-122.45, 37.75]))     .filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10) )  vis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}  Map.addLayer(S2, {}, \"Sentinel-2\", False) Map.add_time_slider(S2, vis_params) Map In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/73_transect/","title":"73 transect","text":"In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom bqplot import pyplot as plt\n</pre> import ee import geemap from bqplot import pyplot as plt In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap(\"TERRAIN\")\nMap\n</pre> Map = geemap.Map() Map.add_basemap(\"TERRAIN\") Map In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(image, vis_params, 'SRTM DEM', True, 0.5)\n</pre> image = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(image, vis_params, 'SRTM DEM', True, 0.5) In\u00a0[\u00a0]: Copied! <pre># Use the drawing tool to draw any line on the map.\nline = Map.user_roi\nif line is None:\n    line = ee.Geometry.LineString(\n        [[-120.223279, 36.314849], [-118.926969, 36.712192], [-117.202217, 36.756215]]\n    )\n    Map.addLayer(line, {}, \"ROI\")\nMap.centerObject(line)\n</pre> # Use the drawing tool to draw any line on the map. line = Map.user_roi if line is None:     line = ee.Geometry.LineString(         [[-120.223279, 36.314849], [-118.926969, 36.712192], [-117.202217, 36.756215]]     )     Map.addLayer(line, {}, \"ROI\") Map.centerObject(line) In\u00a0[\u00a0]: Copied! <pre>line.getInfo()\n</pre> line.getInfo() In\u00a0[\u00a0]: Copied! <pre>reducer = 'mean'  # Any ee.Reducer, e.g., mean, median, min, max, stdDev\ntransect = geemap.extract_transect(\n    image, line, n_segments=100, reducer=reducer, to_pandas=True\n)\n</pre> reducer = 'mean'  # Any ee.Reducer, e.g., mean, median, min, max, stdDev transect = geemap.extract_transect(     image, line, n_segments=100, reducer=reducer, to_pandas=True ) In\u00a0[\u00a0]: Copied! <pre>transect\n</pre> transect In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure()\nplt.plot(transect['distance'], transect[reducer])\nplt.xlabel('Distance')\nplt.ylabel(\"Elevation\")\nplt.show()\n</pre> fig = plt.figure() plt.plot(transect['distance'], transect[reducer]) plt.xlabel('Distance') plt.ylabel(\"Elevation\") plt.show()"},{"location":"notebooks/74_csv_to_points/","title":"74 csv to points","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap\n</pre> import os import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>in_csv = 'https://raw.githubusercontent.com/giswqs/data/main/world/world_cities.csv'\n</pre> in_csv = 'https://raw.githubusercontent.com/giswqs/data/main/world/world_cities.csv' In\u00a0[\u00a0]: Copied! <pre>df = geemap.csv_to_df(in_csv)\ndf\n</pre> df = geemap.csv_to_df(in_csv) df In\u00a0[\u00a0]: Copied! <pre>Map.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"csv to ee\", to_ee=True)\n</pre> Map.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"csv to ee\", to_ee=True) In\u00a0[\u00a0]: Copied! <pre>fc = geemap.csv_to_ee(in_csv)\n</pre> fc = geemap.csv_to_ee(in_csv) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(fc, {}, 'csv to ee 2')\n</pre> Map.addLayer(fc, {}, 'csv to ee 2') In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\nout_shp = os.path.join(out_dir, 'world_cities.shp')\n</pre> out_dir = os.path.expanduser('~/Downloads') if not os.path.exists(out_dir):     os.makedirs(out_dir) out_shp = os.path.join(out_dir, 'world_cities.shp') In\u00a0[\u00a0]: Copied! <pre>geemap.csv_to_shp(in_csv, out_shp)\n</pre> geemap.csv_to_shp(in_csv, out_shp) In\u00a0[\u00a0]: Copied! <pre>out_geojson = os.path.join(out_dir, 'world_cities.geojson')\ngeemap.csv_to_geojson(in_csv, out_geojson)\n</pre> out_geojson = os.path.join(out_dir, 'world_cities.geojson') geemap.csv_to_geojson(in_csv, out_geojson) In\u00a0[\u00a0]: Copied! <pre>gdf = geemap.csv_to_gdf(in_csv)\ngdf\n</pre> gdf = geemap.csv_to_gdf(in_csv) gdf In\u00a0[\u00a0]: Copied! <pre>Map.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"Marker cluster\")\nMap\n</pre> Map.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"Marker cluster\") Map"},{"location":"notebooks/75_sankee/","title":"75 sankee","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map"},{"location":"notebooks/76_osm_to_ee/","title":"76 osm to ee","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># %%capture\n# # optional\n# ! sudo add-apt-repository -y ppa:ubuntugis/ubuntugis-unstable\n# ! sudo apt-get update\n# ! sudo apt-get install libudunits2-dev libgdal-dev libgeos-dev libproj-dev\n# ! sudo apt-get install libprotobuf-dev protobuf-compiler libv8-dev libjq-dev\n\n# # packages\n# ! pip install geopandas cartopy osmnx geemap\n</pre> # %%capture # # optional # ! sudo add-apt-repository -y ppa:ubuntugis/ubuntugis-unstable # ! sudo apt-get update # ! sudo apt-get install libudunits2-dev libgdal-dev libgeos-dev libproj-dev # ! sudo apt-get install libprotobuf-dev protobuf-compiler libv8-dev libjq-dev  # # packages # ! pip install geopandas cartopy osmnx geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nfc = geemap.osm_to_ee(\"Provincia de Lima, Lima, Per\u00fa\")\nMap.addLayer(fc, {}, \"Lima, Peru\")\nMap.centerObject(fc, 9)\n\nMap\n</pre> Map = geemap.Map()  fc = geemap.osm_to_ee(\"Provincia de Lima, Lima, Per\u00fa\") Map.addLayer(fc, {}, \"Lima, Peru\") Map.centerObject(fc, 9)  Map In\u00a0[\u00a0]: Copied! <pre>geemap.osm_to_geopandas(\"Provincia de Lima, Lima, Per\u00fa\")\n</pre> geemap.osm_to_geopandas(\"Provincia de Lima, Lima, Per\u00fa\") In\u00a0[\u00a0]: Copied! <pre># geemap.osm_to_geojson(\"Provincia de Lima, Lima, Per\u00fa\")\n</pre> # geemap.osm_to_geojson(\"Provincia de Lima, Lima, Per\u00fa\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nMap.add_osm(\"Provincia de Lima, Lima, Per\u00fa\", layer_name=\"Lima, Peru\")\n\nMap\n</pre> Map = geemap.Map()  Map.add_osm(\"Provincia de Lima, Lima, Per\u00fa\", layer_name=\"Lima, Peru\")  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nMap.add_osm(\"Provincia de Lima, Lima, Per\u00fa\", layer_name=\"Lima, Peru\", to_ee=True)\n\nMap\n</pre> Map = geemap.Map()  Map.add_osm(\"Provincia de Lima, Lima, Per\u00fa\", layer_name=\"Lima, Peru\", to_ee=True)  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nMap.add_osm(\"('\u4eac\u90fd\u5e02, \u65e5\u672c\u56fd')\", layer_name='Kyoto, Japan')\n\nMap\n</pre> Map = geemap.Map()  Map.add_osm(\"('\u4eac\u90fd\u5e02, \u65e5\u672c\u56fd')\", layer_name='Kyoto, Japan')  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nMap.add_osm(\"Knoxville, Tennessee\", layer_name='Knoxville, TN')\n\nMap\n</pre> Map = geemap.Map()  Map.add_osm(\"Knoxville, Tennessee\", layer_name='Knoxville, TN')  Map"},{"location":"notebooks/76_osm_to_ee/#converting-openstreetmap-data-to-eefeaturecollection","title":"Converting OpenStreetMap data to ee.FeatureCollection\u00b6","text":"<p>Credits to Erik Seras for making this feature request and providing examples.</p>"},{"location":"notebooks/77_planet_imagery/","title":"77 planet imagery","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap\n</pre> import os import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>First, you need to sign up a Planet account and get an API key. See https://developers.planet.com/quickstart/apis. Uncomment the following line to pass in your API key.</p> In\u00a0[\u00a0]: Copied! <pre># os.environ[\"PLANET_API_KEY\"] = \"12345\"\n</pre> # os.environ[\"PLANET_API_KEY\"] = \"12345\" In\u00a0[\u00a0]: Copied! <pre>tile_format = \"ipyleaflet\"\n\nif os.environ.get(\"USE_FOLIUM\") is not None:\n    tile_format = \"folium\"\n</pre> tile_format = \"ipyleaflet\"  if os.environ.get(\"USE_FOLIUM\") is not None:     tile_format = \"folium\" In\u00a0[\u00a0]: Copied! <pre># geemap.planet_quarterly()\n</pre> # geemap.planet_quarterly() In\u00a0[\u00a0]: Copied! <pre># geemap.planet_monthly()\n</pre> # geemap.planet_monthly() In\u00a0[\u00a0]: Copied! <pre># geemap.planet_catalog()\n</pre> # geemap.planet_catalog() In\u00a0[\u00a0]: Copied! <pre>quarterly_tiles = geemap.planet_quarterly_tiles(tile_format=tile_format)\n</pre> quarterly_tiles = geemap.planet_quarterly_tiles(tile_format=tile_format) In\u00a0[\u00a0]: Copied! <pre>monthly_tiles = geemap.planet_monthly_tiles(tile_format=tile_format)\n</pre> monthly_tiles = geemap.planet_monthly_tiles(tile_format=tile_format) In\u00a0[\u00a0]: Copied! <pre>for tile in quarterly_tiles:\n    print(tile)\n</pre> for tile in quarterly_tiles:     print(tile) In\u00a0[\u00a0]: Copied! <pre>for tile in monthly_tiles:\n    print(tile)\n</pre> for tile in monthly_tiles:     print(tile) In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_planet_by_month(year=2020, month=8)\nm\n</pre> m = geemap.Map() m.add_planet_by_month(year=2020, month=8) m In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_planet_by_quarter(year=2019, quarter=2)\nm\n</pre> m = geemap.Map() m.add_planet_by_quarter(year=2019, quarter=2) m"},{"location":"notebooks/78_ts_inspector/","title":"78 ts inspector","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap.geemap as geemap\n</pre> import os import geemap.geemap as geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>First, you need to sign up a Planet account and get an API key. See https://developers.planet.com/quickstart/apis. Uncomment the following line to pass in your API key.</p> In\u00a0[\u00a0]: Copied! <pre># os.environ[\"PLANET_API_KEY\"] = \"12345\"\n</pre> # os.environ[\"PLANET_API_KEY\"] = \"12345\" In\u00a0[\u00a0]: Copied! <pre>monthly_tiles = geemap.planet_monthly_tiles()\n</pre> monthly_tiles = geemap.planet_monthly_tiles() In\u00a0[\u00a0]: Copied! <pre>geemap.ts_inspector(monthly_tiles)\n</pre> geemap.ts_inspector(monthly_tiles) In\u00a0[\u00a0]: Copied! <pre>quarterly_tiles = geemap.planet_quarterly_tiles()\n</pre> quarterly_tiles = geemap.planet_quarterly_tiles() In\u00a0[\u00a0]: Copied! <pre>geemap.ts_inspector(quarterly_tiles)\n</pre> geemap.ts_inspector(quarterly_tiles) In\u00a0[\u00a0]: Copied! <pre>tiles = geemap.planet_tiles()\n</pre> tiles = geemap.planet_tiles() In\u00a0[\u00a0]: Copied! <pre>geemap.ts_inspector(tiles)\n</pre> geemap.ts_inspector(tiles) In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm\n</pre> m = geemap.Map() m <p></p>"},{"location":"notebooks/79_chart_histogram/","title":"79 chart histogram","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p>Install the necessary libraries.</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport geemap.chart as chart\n</pre> import ee import geemap import geemap.chart as chart <p>Initialize GEE.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() <p>Set the data and plot options.</p> In\u00a0[\u00a0]: Copied! <pre>source = ee.ImageCollection('OREGONSTATE/PRISM/Norm81m').toBands()\nregion = ee.Geometry.Rectangle(-123.41, 40.43, -116.38, 45.14)\nmy_sample = source.sample(region, 5000)\nproperty = '07_ppt'\n</pre> source = ee.ImageCollection('OREGONSTATE/PRISM/Norm81m').toBands() region = ee.Geometry.Rectangle(-123.41, 40.43, -116.38, 45.14) my_sample = source.sample(region, 5000) property = '07_ppt' In\u00a0[\u00a0]: Copied! <pre>options = {\n    \"title\": 'July Precipitation Distribution for NW USA',\n    \"xlabel\": 'Precipitation (mm)',\n    \"ylabel\": 'Pixel count',\n    \"colors\": ['#1d6b99'],\n}\n</pre> options = {     \"title\": 'July Precipitation Distribution for NW USA',     \"xlabel\": 'Precipitation (mm)',     \"ylabel\": 'Pixel count',     \"colors\": ['#1d6b99'], } <p>Generate histogram with default number of bins:</p> In\u00a0[\u00a0]: Copied! <pre>chart.feature_histogram(my_sample, property, **options)\n</pre> chart.feature_histogram(my_sample, property, **options) <p></p> <p>Generate histogram and set a maximum number of bins:</p> In\u00a0[\u00a0]: Copied! <pre>chart.feature_histogram(my_sample, property, maxBuckets=30, **options)\n</pre> chart.feature_histogram(my_sample, property, maxBuckets=30, **options) <p></p> <p>Generate histogram and set a minimum bin size:</p> In\u00a0[\u00a0]: Copied! <pre>chart.feature_histogram(my_sample, property, minBucketWidth=0.5, **options)\n</pre> chart.feature_histogram(my_sample, property, minBucketWidth=0.5, **options) <p>Generate histogram, set a maximum number of bins and a minimum bin size:</p> In\u00a0[\u00a0]: Copied! <pre>chart.feature_histogram(my_sample, property, minBucketWidth=3, maxBuckets=30, **options)\n</pre> chart.feature_histogram(my_sample, property, minBucketWidth=3, maxBuckets=30, **options)"},{"location":"notebooks/80_point_layer/","title":"80 point layer","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\n</pre> m = geemap.Map() In\u00a0[\u00a0]: Copied! <pre>url = \"https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/us_cities.geojson\"\n</pre> url = \"https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/us_cities.geojson\" In\u00a0[\u00a0]: Copied! <pre>m.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\")\nm\n</pre> m.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\") m"},{"location":"notebooks/81_goes_timelapse/","title":"81 goes timelapse","text":"<p>Uncomment the following line to install geemap if needed.</p> <p>This notebook is adapted from Justin Braaten's JavaScript example. Credits to Justin Braaten. See also his Medium post - GOES in Earth Engine.</p> In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>m = geemap.ee_initialize()\n</pre> m = geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>region = ee.Geometry.Polygon(\n    [\n        [\n            [-159.5954379282731, 60.40883060191719],\n            [-159.5954379282731, 24.517881970830725],\n            [-114.2438754282731, 24.517881970830725],\n            [-114.2438754282731, 60.40883060191719],\n        ]\n    ],\n    None,\n    False,\n)\n</pre> region = ee.Geometry.Polygon(     [         [             [-159.5954379282731, 60.40883060191719],             [-159.5954379282731, 24.517881970830725],             [-114.2438754282731, 24.517881970830725],             [-114.2438754282731, 60.40883060191719],         ]     ],     None,     False, ) In\u00a0[\u00a0]: Copied! <pre>start_date = \"2021-10-24T14:00:00\"\nend_date = \"2021-10-25T01:00:00\"\ndata = \"GOES-17\"\nscan = \"full_disk\"\n</pre> start_date = \"2021-10-24T14:00:00\" end_date = \"2021-10-25T01:00:00\" data = \"GOES-17\" scan = \"full_disk\" In\u00a0[\u00a0]: Copied! <pre>col = geemap.goes_timeseries(start_date, end_date, data, scan, region)\n</pre> col = geemap.goes_timeseries(start_date, end_date, data, scan, region) In\u00a0[\u00a0]: Copied! <pre>visParams = {\n    'bands': ['CMI_C02', 'CMI_GREEN', 'CMI_C01'],\n    'min': 0,\n    'max': 0.8,\n    'dimensions': 700,\n    'framesPerSecond': 9,\n    'region': region,\n    'crs': col.first().projection(),\n}\n</pre> visParams = {     'bands': ['CMI_C02', 'CMI_GREEN', 'CMI_C01'],     'min': 0,     'max': 0.8,     'dimensions': 700,     'framesPerSecond': 9,     'region': region,     'crs': col.first().projection(), } In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser(\"~/Downloads\")\nout_gif = os.path.join(out_dir, \"goes_timelapse.gif\")\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n</pre> out_dir = os.path.expanduser(\"~/Downloads\") out_gif = os.path.join(out_dir, \"goes_timelapse.gif\") if not os.path.exists(out_dir):     os.makedirs(out_dir) In\u00a0[\u00a0]: Copied! <pre>geemap.download_ee_video(col, visParams, out_gif)\n</pre> geemap.download_ee_video(col, visParams, out_gif) In\u00a0[\u00a0]: Copied! <pre>timestamps = geemap.image_dates(col, date_format='YYYY-MM-dd HH:mm').getInfo()\n</pre> timestamps = geemap.image_dates(col, date_format='YYYY-MM-dd HH:mm').getInfo() In\u00a0[\u00a0]: Copied! <pre>geemap.add_text_to_gif(\n    out_gif,\n    out_gif,\n    xy=('3%', '3%'),\n    text_sequence=timestamps,\n    font_size=20,\n    font_color='#ffffff',\n)\n</pre> geemap.add_text_to_gif(     out_gif,     out_gif,     xy=('3%', '3%'),     text_sequence=timestamps,     font_size=20,     font_color='#ffffff', ) <p>All the above steps can be reduced to just one line of code using the <code>goes_timelapse()</code> function.</p> In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.goes_timelapse(\n    region, out_gif, start_date, end_date, data, scan, framesPerSecond=10\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.goes_timelapse(     region, out_gif, start_date, end_date, data, scan, framesPerSecond=10 ) geemap.show_image(timelapse)"},{"location":"notebooks/82_contours/","title":"82 contours","text":"In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport geemap.colormaps as cm\n</pre> import ee import geemap import geemap.colormaps as cm In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>image = ee.Image(\"USGS/SRTMGL1_003\")\n</pre> image = ee.Image(\"USGS/SRTMGL1_003\") In\u00a0[\u00a0]: Copied! <pre>hillshade = ee.Terrain.hillshade(image)\n</pre> hillshade = ee.Terrain.hillshade(image) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(hillshade, {}, \"Hillshade\")\n</pre> Map.addLayer(hillshade, {}, \"Hillshade\") In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(\n    image, {'min': 0, \"max\": 5000, \"palette\": cm.palettes.dem}, \"dem\", True, 0.5\n)\n</pre> Map.addLayer(     image, {'min': 0, \"max\": 5000, \"palette\": cm.palettes.dem}, \"dem\", True, 0.5 ) In\u00a0[\u00a0]: Copied! <pre>contours = geemap.create_contours(image, 0, 5000, 100, region=None)\n</pre> contours = geemap.create_contours(image, 0, 5000, 100, region=None) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(\n    contours, {'min': 0, \"max\": 5000, 'palette': cm.palettes.terrain}, 'contours'\n)\n</pre> Map.addLayer(     contours, {'min': 0, \"max\": 5000, 'palette': cm.palettes.terrain}, 'contours' )"},{"location":"notebooks/83_local_tile/","title":"83 local tile","text":"<p>Using local raster datasets or remote Cloud Optimized GeoTIFFs (COG) with geemap</p> <p>Uncomment the following line to install geemap and localtileserver if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap localtileserver\n</pre> # !pip install geemap localtileserver In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap\n</pre> import os import geemap <p>Specify input raster datasets</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\ndem = os.path.join(out_dir, 'dem.tif')\n</pre> out_dir = os.path.expanduser('~/Downloads')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  dem = os.path.join(out_dir, 'dem.tif') <p>Download samples raster datasets.</p> In\u00a0[\u00a0]: Copied! <pre>if not os.path.exists(dem):\n    dem_url = 'https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing'\n    geemap.download_file(dem_url, dem, unzip=False)\n</pre> if not os.path.exists(dem):     dem_url = 'https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing'     geemap.download_file(dem_url, dem, unzip=False) <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\n</pre> m = geemap.Map() <p>Add local raster datasets to the map. The available palettes can be found at https://jiffyclub.github.io/palettable/</p> In\u00a0[\u00a0]: Copied! <pre>m.add_local_tile(dem, palette='terrain', layer_name=\"DEM\")\n</pre> m.add_local_tile(dem, palette='terrain', layer_name=\"DEM\") In\u00a0[\u00a0]: Copied! <pre>m\n</pre> m <p>Add a remote Cloud Optimized GeoTIFF(COG) to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\n</pre> m = geemap.Map() In\u00a0[\u00a0]: Copied! <pre>url = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\n</pre> url = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif' In\u00a0[\u00a0]: Copied! <pre>m.add_remote_tile(url, layer_name=\"CA Fire\")\n</pre> m.add_remote_tile(url, layer_name=\"CA Fire\") In\u00a0[\u00a0]: Copied! <pre>m\n</pre> m"},{"location":"notebooks/84_openstreetmap/","title":"84 openstreetmap","text":"<p>Downloading OpenStreetMap data with a single line of code</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geopandas osmnx geemap\n</pre> # !pip install geopandas osmnx geemap In\u00a0[\u00a0]: Copied! <pre>import geemap.foliumap as geemap\n</pre> import geemap.foliumap as geemap <p>Add OSM data of place(s) by name or ID to the map. Note that the geemap custom layer control does not support GeoJSON, we need to use the ipyleaflet built-in layer control.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"New York City\", layer_name='NYC')\nm\n</pre> m = geemap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"New York City\", layer_name='NYC') m In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"Chicago, Illinois\", layer_name='Chicago, IL')\nm\n</pre> m = geemap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"Chicago, Illinois\", layer_name='Chicago, IL') m <p>Add OSM entities within boundaries of geocodable place(s) to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(toolbar_control=False, layers_control=True)\nplace = \"Bunker Hill, Los Angeles, California\"\ntags = {\"building\": True}\nm.add_osm_from_place(place, tags, layer_name=\"Los Angeles, CA\")\nm\n</pre> m = geemap.Map(toolbar_control=False, layers_control=True) place = \"Bunker Hill, Los Angeles, California\" tags = {\"building\": True} m.add_osm_from_place(place, tags, layer_name=\"Los Angeles, CA\") m <p>Show OSM feature tags.</p> <p>https://wiki.openstreetmap.org/wiki/Map_features</p> In\u00a0[\u00a0]: Copied! <pre># geemap.osm_tags_list()\n</pre> # geemap.osm_tags_list() <p>Add OSM entities within some distance N, S, E, W of address to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\"\n)\nm\n</pre> m = geemap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\" ) m In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\",\n    tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},\n    dist=1000,\n    layer_name=\"NYC buildings\",\n)\nm\n</pre> m = geemap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\",     tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},     dist=1000,     layer_name=\"NYC buildings\", ) m <p>Add OSM entities within a N, S, E, W bounding box to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(toolbar_control=False, layers_control=True)\nnorth, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965\nm.add_osm_from_bbox(\n    north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\"\n)\nm\n</pre> m = geemap.Map(toolbar_control=False, layers_control=True) north, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965 m.add_osm_from_bbox(     north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\" ) m <p>Add OSM entities within some distance N, S, E, W of a point to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(\n    center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(46.7808, -96.0156),\n    tags={\"natural\": \"water\"},\n    dist=10000,\n    layer_name=\"Lakes\",\n)\nm\n</pre> m = geemap.Map(     center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(46.7808, -96.0156),     tags={\"natural\": \"water\"},     dist=10000,     layer_name=\"Lakes\", ) m In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(\n    center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(39.9170, 116.3908),\n    tags={\"building\": True, \"natural\": \"water\"},\n    dist=1000,\n    layer_name=\"Beijing\",\n)\nm\n</pre> m = geemap.Map(     center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(39.9170, 116.3908),     tags={\"building\": True, \"natural\": \"water\"},     dist=1000,     layer_name=\"Beijing\", ) m <p>Add OSM entities within the current map view to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(toolbar_control=False, layers_control=True)\nm.set_center(-73.9854, 40.7500, 16)\nm\n</pre> m = geemap.Map(toolbar_control=False, layers_control=True) m.set_center(-73.9854, 40.7500, 16) m <p>The <code>add_osm_from_view()</code> is only available for the ipyleaflet plotting backend.</p> In\u00a0[\u00a0]: Copied! <pre># m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\")\n</pre> # m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\") <p>Create a GeoPandas GeoDataFrame from place.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = geemap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"})\ngdf\n</pre> gdf = geemap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"}) gdf"},{"location":"notebooks/85_postgis/","title":"85 postgis","text":"<p>Adding data from a PostGIS database to the map</p> <p>Setting up the conda env:</p> <pre><code>conda create -n geo python=3.8\nconda activate geo\nconda install geopandas\nconda install mamba -c conda-forge\nmamba install geemap sqlalchemy psycopg2 -c conda-forge\n</code></pre> <p>Sample dataset:</p> <ul> <li>nyc_data.zip (Watch this video to load data into PostGIS)</li> </ul> <p>Connecting to the database</p> In\u00a0[\u00a0]: Copied! <pre>import geemap\nfrom IPython.display import display\n</pre> import geemap from IPython.display import display <p>You can directly pass in the user name and password to access the database. Alternative, you can define environment variables. The default environment variables for user and password are <code>SQL_USER</code> and <code>SQL_PASSWORD</code>, respectively.</p> <p>The <code>try...except...</code> statements are only used for building the documentation website (https://geemap.org) because the PostGIS database is not available on GitHub. If you are running the notebook with Jupyter installed locally and PostGIS set up properly, you don't need these <code>try...except...</code> statements.</p> In\u00a0[\u00a0]: Copied! <pre>try:\n    con = geemap.connect_postgis(\n        database=\"nyc\", host=\"localhost\", user=None, password=None, use_env_var=True\n    )\nexcept:\n    pass\n</pre> try:     con = geemap.connect_postgis(         database=\"nyc\", host=\"localhost\", user=None, password=None, use_env_var=True     ) except:     pass <p>Create a GeoDataFrame from a sql query.</p> In\u00a0[\u00a0]: Copied! <pre>sql = 'SELECT * FROM nyc_neighborhoods'\n</pre> sql = 'SELECT * FROM nyc_neighborhoods' In\u00a0[\u00a0]: Copied! <pre>try:\n    gdf = geemap.read_postgis(sql, con)\n    display(gdf)\nexcept:\n    pass\n</pre> try:     gdf = geemap.read_postgis(sql, con)     display(gdf) except:     pass <p>Convert gdf to ee.FeatureCollection</p> In\u00a0[\u00a0]: Copied! <pre>try:\n    m = geemap.Map()\n    fc = geemap.gdf_to_ee(gdf)\n    m.addLayer(fc, {}, \"NYC EE\")\n    m.centerObject(fc)\n    display(m)\nexcept:\n    pass\n</pre> try:     m = geemap.Map()     fc = geemap.gdf_to_ee(gdf)     m.addLayer(fc, {}, \"NYC EE\")     m.centerObject(fc)     display(m) except:     pass <p>Display the GeoDataFrame on the interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>try:\n    m = geemap.Map()\n    m.add_gdf_from_postgis(\n        sql, con, layer_name=\"NYC Neighborhoods\", fill_colors=[\"red\", \"green\", \"blue\"]\n    )\n    display(m)\nexcept:\n    pass\n</pre> try:     m = geemap.Map()     m.add_gdf_from_postgis(         sql, con, layer_name=\"NYC Neighborhoods\", fill_colors=[\"red\", \"green\", \"blue\"]     )     display(m) except:     pass <p></p>"},{"location":"notebooks/86_image_overlay/","title":"86 image overlay","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nfrom geemap import geemap\n</pre> import os from geemap import geemap <p>If you are using a recently implemented geemap feature that has not yet been released to PyPI or conda-forge, you can uncomment the following line to install the development version from GitHub.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>Using local files</p> <p>Download the sample png from https://i.imgur.com/06Q1fSz.png to your <code>Downloads</code> folder.</p> In\u00a0[\u00a0]: Copied! <pre>filepath = '06Q1fSz.png'\nif not os.path.exists(filepath):\n    geemap.download_from_url(\"https://i.imgur.com/06Q1fSz.png\", filepath)\n</pre> filepath = '06Q1fSz.png' if not os.path.exists(filepath):     geemap.download_from_url(\"https://i.imgur.com/06Q1fSz.png\", filepath) In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=(25, -115), zoom=4)\n\nimage = geemap.ImageOverlay(url=filepath, bounds=((13, -130), (32, -100)))\n\nm.add_layer(image)\nm\n</pre> m = geemap.Map(center=(25, -115), zoom=4)  image = geemap.ImageOverlay(url=filepath, bounds=((13, -130), (32, -100)))  m.add_layer(image) m <p>Using remote files</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=(25, -115), zoom=4)\n\nimage = geemap.ImageOverlay(\n    url=\"https://i.imgur.com/06Q1fSz.png\", bounds=((13, -130), (32, -100))\n)\n\nm.add_layer(image)\nm\n</pre> m = geemap.Map(center=(25, -115), zoom=4)  image = geemap.ImageOverlay(     url=\"https://i.imgur.com/06Q1fSz.png\", bounds=((13, -130), (32, -100)) )  m.add_layer(image) m <p>Update image url</p> In\u00a0[\u00a0]: Copied! <pre>image.url = \"https://i.imgur.com/J9qCf4E.png\"\n</pre> image.url = \"https://i.imgur.com/J9qCf4E.png\""},{"location":"notebooks/87_add_points_from_xy/","title":"87 add points from xy","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\nimport pandas as pd\n</pre> import geemap import pandas as pd In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>Using a CSV file containing xy coordinates</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\ndata = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/us_cities.csv'\nm.add_points_from_xy(data, x=\"longitude\", y=\"latitude\")\nm\n</pre> m = geemap.Map() data = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/us_cities.csv' m.add_points_from_xy(data, x=\"longitude\", y=\"latitude\") m <p>Using a Pandas DataFrame containing xy coordinates.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\ndata = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/us_cities.csv'\ndf = pd.read_csv(data)\nm.add_points_from_xy(df, x=\"longitude\", y=\"latitude\")\nm\n</pre> m = geemap.Map() data = 'https://raw.githubusercontent.com/giswqs/leafmap/master/examples/data/us_cities.csv' df = pd.read_csv(data) m.add_points_from_xy(df, x=\"longitude\", y=\"latitude\") m"},{"location":"notebooks/88_circle_markers/","title":"88 circle markers","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap.foliumap as geemap\n</pre> import geemap.foliumap as geemap <p>If you are using a recently implemented geemap feature that has not yet been released to PyPI or conda-forge, you can uncomment the following line to install the development version from GitHub.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>For a list of options for circle markers, see https://ipyleaflet.readthedocs.io/en/latest/api_reference/circle_marker.html</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\ndata = (\n    \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/us_cities.csv\"\n)\nm.add_circle_markers_from_xy(\n    data, x=\"longitude\", y=\"latitude\", radius=10, color=\"blue\", fill_color=\"black\"\n)\nm\n</pre> m = geemap.Map() data = (     \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/us_cities.csv\" ) m.add_circle_markers_from_xy(     data, x=\"longitude\", y=\"latitude\", radius=10, color=\"blue\", fill_color=\"black\" ) m"},{"location":"notebooks/89_add_labels/","title":"89 add labels","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap <p>Update the package if needed.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4, add_google_map=False)\n</pre> Map = geemap.Map(center=[40, -100], zoom=4, add_google_map=False) In\u00a0[\u00a0]: Copied! <pre>states = ee.FeatureCollection(\"TIGER/2018/States\")\n</pre> states = ee.FeatureCollection(\"TIGER/2018/States\") In\u00a0[\u00a0]: Copied! <pre>style = {'color': 'black', 'fillColor': \"00000000\"}\n</pre> style = {'color': 'black', 'fillColor': \"00000000\"} <p>Add an ee.FeatureCollection to the map.</p> In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(states.style(**style), {}, \"US States\")\n</pre> Map.addLayer(states.style(**style), {}, \"US States\") <p>Labeling an ee.FeatureCollection.</p> In\u00a0[\u00a0]: Copied! <pre>Map.add_labels(\n    states,\n    \"STUSPS\",\n    font_size=\"12pt\",\n    font_color=\"blue\",\n    font_family=\"arial\",\n    font_weight=\"bold\",\n)\nMap\n</pre> Map.add_labels(     states,     \"STUSPS\",     font_size=\"12pt\",     font_color=\"blue\",     font_family=\"arial\",     font_weight=\"bold\", ) Map <p>Remove labels</p> In\u00a0[\u00a0]: Copied! <pre>Map.remove_labels()\n</pre> Map.remove_labels() <p>Labeling a Pandas DataFrame</p> In\u00a0[\u00a0]: Copied! <pre>centroids = geemap.vector_centroids(states)\n</pre> centroids = geemap.vector_centroids(states) In\u00a0[\u00a0]: Copied! <pre>df = geemap.ee_to_df(centroids)\n</pre> df = geemap.ee_to_df(centroids) In\u00a0[\u00a0]: Copied! <pre>Map.add_labels(\n    df,\n    \"STUSPS\",\n    font_size=\"12pt\",\n    font_color=\"blue\",\n    font_family=\"arial\",\n    font_weight=\"bold\",\n)\nMap\n</pre> Map.add_labels(     df,     \"STUSPS\",     font_size=\"12pt\",     font_color=\"blue\",     font_family=\"arial\",     font_weight=\"bold\", ) Map <p></p>"},{"location":"notebooks/90_naip_timelapse/","title":"90 naip timelapse","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap <p>If run into errors, uncomment the following line to update the package and restart the kernel to take effect.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map <p>Create a region of interest.</p> In\u00a0[\u00a0]: Copied! <pre>region = ee.Geometry.Polygon(\n    [\n        [\n            [-99.101934, 47.12745],\n            [-99.101934, 47.156232],\n            [-99.033441, 47.156232],\n            [-99.033441, 47.12745],\n            [-99.101934, 47.12745],\n        ]\n    ]\n)\n</pre> region = ee.Geometry.Polygon(     [         [             [-99.101934, 47.12745],             [-99.101934, 47.156232],             [-99.033441, 47.156232],             [-99.033441, 47.12745],             [-99.101934, 47.12745],         ]     ] ) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(region)\nMap.centerObject(region)\n</pre> Map.addLayer(region) Map.centerObject(region) <p>Create a timeseries</p> In\u00a0[\u00a0]: Copied! <pre>collection = geemap.naip_timeseries(region, RGBN=True)\n</pre> collection = geemap.naip_timeseries(region, RGBN=True) In\u00a0[\u00a0]: Copied! <pre>images = collection.toList(collection.size())\n</pre> images = collection.toList(collection.size()) <p>Get image dates</p> In\u00a0[\u00a0]: Copied! <pre>dates = geemap.image_dates(collection).getInfo()\n</pre> dates = geemap.image_dates(collection).getInfo() In\u00a0[\u00a0]: Copied! <pre>size = images.size().getInfo()\n</pre> size = images.size().getInfo() <p>Add images to the map</p> In\u00a0[\u00a0]: Copied! <pre>for i in range(size):\n    image = ee.Image(images.get(i))\n    Map.addLayer(image, {'bands': ['N', 'R', 'G']}, dates[i][:4])\n</pre> for i in range(size):     image = ee.Image(images.get(i))     Map.addLayer(image, {'bands': ['N', 'R', 'G']}, dates[i][:4]) <p>Create s timelapse</p> In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.naip_timelapse(\n    region, out_gif=\"naip.gif\", bands=['N', 'R', 'G'], frames_per_second=3, mp4=True\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.naip_timelapse(     region, out_gif=\"naip.gif\", bands=['N', 'R', 'G'], frames_per_second=3, mp4=True ) geemap.show_image(timelapse)"},{"location":"notebooks/91_planetary_computer/","title":"91 planetary computer","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap <p>If you are using a recently implemented geemap feature that has not yet been released to PyPI or conda-forge, you can uncomment the following line to install the development version from GitHub.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>Add a STAC item via an HTTP URL</p> In\u00a0[\u00a0]: Copied! <pre>url = 'https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json'\n</pre> url = 'https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json' In\u00a0[\u00a0]: Copied! <pre>geemap.stac_assets(url)\n</pre> geemap.stac_assets(url) In\u00a0[\u00a0]: Copied! <pre>geemap.stac_bounds(url)\n</pre> geemap.stac_bounds(url) In\u00a0[\u00a0]: Copied! <pre>geemap.stac_center(url)\n</pre> geemap.stac_center(url) In\u00a0[\u00a0]: Copied! <pre># geemap.stac_info(url)\n</pre> # geemap.stac_info(url) In\u00a0[\u00a0]: Copied! <pre># geemap.stac_stats(url)\n</pre> # geemap.stac_stats(url) In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"])\nm\n</pre> m = geemap.Map() m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"]) m <p>Add a Microsoft Planetry Computer STAC item. The titiler endpoint can set in one of the ways below:</p> <pre><code>os.environ[\"TITILER_ENDPOINT\"] = \"planetary-computer\"\ntitiler_endpoint=\"pc\"\ntitiler_endpoint=\"planetary-computer\"\n</code></pre> In\u00a0[\u00a0]: Copied! <pre># import os\n# os.environ[\"TITILER_ENDPOINT\"] = \"planetary-computer\"\n</pre> # import os # os.environ[\"TITILER_ENDPOINT\"] = \"planetary-computer\" In\u00a0[\u00a0]: Copied! <pre>collection = \"landsat-8-c2-l2\"\n</pre> collection = \"landsat-8-c2-l2\" In\u00a0[\u00a0]: Copied! <pre>items = \"LC08_L2SP_047027_20201204_02_T1\"\n</pre> items = \"LC08_L2SP_047027_20201204_02_T1\" In\u00a0[\u00a0]: Copied! <pre>geemap.stac_assets(collection=collection, items=items, titiler_endpoint=\"pc\")\n</pre> geemap.stac_assets(collection=collection, items=items, titiler_endpoint=\"pc\") In\u00a0[\u00a0]: Copied! <pre>geemap.stac_bounds(collection=collection, items=items)\n</pre> geemap.stac_bounds(collection=collection, items=items) In\u00a0[\u00a0]: Copied! <pre>geemap.stac_info(collection=collection, items=items, assets=\"SR_B7\")\n</pre> geemap.stac_info(collection=collection, items=items, assets=\"SR_B7\") In\u00a0[\u00a0]: Copied! <pre>geemap.stac_stats(collection=collection, items=items, assets=\"SR_B7\")\n</pre> geemap.stac_stats(collection=collection, items=items, assets=\"SR_B7\") <p>Color infrared composite.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_stac_layer(\n    collection=collection,\n    items=items,\n    assets=\"SR_B5,SR_B4,SR_B3\",\n    name=\"Color infrared\",\n)\nm\n</pre> m = geemap.Map() m.add_stac_layer(     collection=collection,     items=items,     assets=\"SR_B5,SR_B4,SR_B3\",     name=\"Color infrared\", ) m <p>False color composite.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_stac_layer(\n    collection=collection, items=items, assets=\"SR_B7,SR_B5,SR_B4\", name=\"False color\"\n)\nm\n</pre> m = geemap.Map() m.add_stac_layer(     collection=collection, items=items, assets=\"SR_B7,SR_B5,SR_B4\", name=\"False color\" ) m <p>Calculate NDVI.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.stac_stats(\n    collection=collection,\n    items=items,\n    expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",\n)\n</pre> geemap.stac_stats(     collection=collection,     items=items,     expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\", ) In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_stac_layer(\n    collection=collection,\n    items=items,\n    expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",\n    name=\"NDVI\",\n)\nm\n</pre> m = geemap.Map() m.add_stac_layer(     collection=collection,     items=items,     expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",     name=\"NDVI\", ) m <p>Calculate NDVI and add a colormap. See available colormaps at https://planetarycomputer.microsoft.com/docs/reference/data/</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_stac_layer(\n    collection=collection,\n    items=items,\n    assets=\"SR_B5,SR_B4,SR_B3\",\n    name=\"Color infrared\",\n)\nm.add_stac_layer(\n    collection=collection,\n    items=items,\n    expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",\n    colormap_name=\"greens\",\n    name=\"NDVI Green\",\n)\nm\n</pre> m = geemap.Map() m.add_stac_layer(     collection=collection,     items=items,     assets=\"SR_B5,SR_B4,SR_B3\",     name=\"Color infrared\", ) m.add_stac_layer(     collection=collection,     items=items,     expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",     colormap_name=\"greens\",     name=\"NDVI Green\", ) m"},{"location":"notebooks/92_plotly/","title":"92 plotly","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geema\n</pre> # !pip install geema In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap.plotlymap as geemap\n</pre> import ee import geemap.plotlymap as geemap <p>If you are using a recently implemented geema feature that has not yet been released to PyPI or conda-forge, you can uncomment the following line to install the development version from GitHub.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>If you run into an error saying \"FigureWidget - 'mapbox._derived' Value Error\" (source), uncomment the following line and run it.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.fix_widget_error()\n</pre> # geemap.fix_widget_error() <p>Create an interactive map using default settings.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm\n</pre> m = geemap.Map() m <p>Change default setting when creating a map.</p> <p>Can be one of string from \"open-street-map\", \"carto-positron\", \"carto-darkmatter\", \"stamen-terrain\", \"stamen-toner\" or \"stamen-watercolor\" .</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=(40, -100), zoom=3, basemap=\"stamen-terrain\", height=500)\nm\n</pre> m = geemap.Map(center=(40, -100), zoom=3, basemap=\"stamen-terrain\", height=500) m <p>Set map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(basemap=\"stamen-watercolor\")\nm.set_center(lat=20, lon=0, zoom=2)\nm\n</pre> m = geemap.Map(basemap=\"stamen-watercolor\") m.set_center(lat=20, lon=0, zoom=2) m <p>Print out available basemaps.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.basemaps.keys()\n</pre> geemap.basemaps.keys() <p>Add a basemap.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm\n</pre> m = geemap.Map() m.add_basemap(\"OpenTopoMap\") m <p>Add XYZ tile layer.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\ntile_url = \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\"\nm.add_tile_layer(tile_url, name=\"Google Satellite\", attribution=\"Google\", opacity=1.0)\nm\n</pre> m = geemap.Map() tile_url = \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\" m.add_tile_layer(tile_url, name=\"Google Satellite\", attribution=\"Google\", opacity=1.0) m <p>Add a mapbox tile layer. You will need a mapbox token. The map style can be Can be \"basic\", \"streets\", \"outdoors\", \"light\", \"dark\", \"satellite\", or \"satellite-streets\".</p> In\u00a0[\u00a0]: Copied! <pre>import os\n</pre> import os In\u00a0[\u00a0]: Copied! <pre># os.environ[\"MAPBOX_TOKEN\"] = \"your-mapbox-token\"\n</pre> # os.environ[\"MAPBOX_TOKEN\"] = \"your-mapbox-token\" In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_mapbox_layer(style=\"streets\")\nm\n</pre> m = geemap.Map() m.add_mapbox_layer(style=\"streets\") m <p>Remove the modebar in the upper-right corner.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(basemap=\"stamen-toner\")\nm\n</pre> m = geemap.Map(basemap=\"stamen-toner\") m In\u00a0[\u00a0]: Copied! <pre>m.clear_controls()\n</pre> m.clear_controls() <p>Add more buttons to the modebar.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(basemap=\"carto-positron\")\ncontrols = [\n    'drawline',\n    'drawopenpath',\n    'drawclosedpath',\n    'drawcircle',\n    'drawrect',\n    'eraseshape',\n]\nm.add_controls(controls)\nm\n</pre> m = geemap.Map(basemap=\"carto-positron\") controls = [     'drawline',     'drawopenpath',     'drawclosedpath',     'drawcircle',     'drawrect',     'eraseshape', ] m.add_controls(controls) m <p>Add Cloud Optimized GeoTIFF.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nurl = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif'\nm.add_cog_layer(url, name=\"Fire (pre-event)\")\nm\n</pre> m = geemap.Map() url = 'https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif' m.add_cog_layer(url, name=\"Fire (pre-event)\") m <p>Add a STAC item via HTTP URL.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nurl = 'https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json'\nm.add_stac_layer(url, bands=['B3', 'B2', 'B1'], name='False color')\nm\n</pre> m = geemap.Map() url = 'https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json' m.add_stac_layer(url, bands=['B3', 'B2', 'B1'], name='False color') m <p>Add a STAC item from Microsoft Planetary Computer.</p> In\u00a0[\u00a0]: Copied! <pre>collection = \"landsat-8-c2-l2\"\nitem = \"LC08_L2SP_047027_20201204_02_T1\"\n</pre> collection = \"landsat-8-c2-l2\" item = \"LC08_L2SP_047027_20201204_02_T1\" In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_stac_layer(\n    collection=collection,\n    item=item,\n    bands=[\"SR_B7\", \"SR_B5\", \"SR_B4\"],\n    titiler_endpoint=\"pc\",\n)\nm\n</pre> m = geemap.Map() m.add_stac_layer(     collection=collection,     item=item,     bands=[\"SR_B7\", \"SR_B5\", \"SR_B4\"],     titiler_endpoint=\"pc\", ) m <p>Add a heat map.</p> In\u00a0[\u00a0]: Copied! <pre>url = 'https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv'\n</pre> url = 'https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv' In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(basemap=\"stamen-terrain\")\nm.add_heatmap(\n    url, latitude=\"Latitude\", longitude=\"Longitude\", z=\"Magnitude\", name=\"Earthquake\"\n)\nm\n</pre> m = geemap.Map(basemap=\"stamen-terrain\") m.add_heatmap(     url, latitude=\"Latitude\", longitude=\"Longitude\", z=\"Magnitude\", name=\"Earthquake\" ) m <p>Add a choropleth map.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"\n</pre> url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\" In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(basemap=\"stamen-terrain\")\nm.add_choropleth_map(url, name=\"Pop\", z=\"POP_EST\", colorscale=\"Viridis\")\nm\n</pre> m = geemap.Map(basemap=\"stamen-terrain\") m.add_choropleth_map(url, name=\"Pop\", z=\"POP_EST\", colorscale=\"Viridis\") m <p>Add Earth Engine layers.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"HYBRID\")\n</pre> m = geemap.Map() m.add_basemap(\"HYBRID\") In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nm.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nm.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},\n    'Landsat 7',\n)\nm.addLayer(states, {}, \"US States\")\n</pre> # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map m.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) m.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},     'Landsat 7', ) m.addLayer(states, {}, \"US States\") In\u00a0[\u00a0]: Copied! <pre>m.show()\n</pre> m.show() <p></p>"},{"location":"notebooks/93_cog_inspector/","title":"93 cog inspector","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap <p>If you are using a recently implemented geemap feature that has not yet been released to PyPI or conda-forge, you can uncomment the following line to install the development version from GitHub.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\n</pre> m = geemap.Map() <p>Add Cloud Optimized GeoTIFF (COG) from Planetary Computer.</p> In\u00a0[\u00a0]: Copied! <pre>collection = \"landsat-8-c2-l2\"\nitems = \"LC08_L2SP_047027_20201204_02_T1\"\n</pre> collection = \"landsat-8-c2-l2\" items = \"LC08_L2SP_047027_20201204_02_T1\" In\u00a0[\u00a0]: Copied! <pre>m.add_stac_layer(\n    collection=collection,\n    items=items,\n    assets=\"SR_B7,SR_B5,SR_B4\",\n    name=\"Landsat Band-754\",\n)\n</pre> m.add_stac_layer(     collection=collection,     items=items,     assets=\"SR_B7,SR_B5,SR_B4\",     name=\"Landsat Band-754\", ) In\u00a0[\u00a0]: Copied! <pre>m.add_stac_layer(\n    collection=collection,\n    items=items,\n    assets=\"SR_B5,SR_B4,SR_B3\",\n    name=\"Landsat Band-543\",\n)\n</pre> m.add_stac_layer(     collection=collection,     items=items,     assets=\"SR_B5,SR_B4,SR_B3\",     name=\"Landsat Band-543\", ) In\u00a0[\u00a0]: Copied! <pre>m\n</pre> m <p></p>"},{"location":"notebooks/94_heremap/","title":"94 heremap","text":"<p>Using HERE Map Widget for Jupyter as a plotting backend</p> <p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import os\nimport geemap.heremap as geemap\n</pre> import os import geemap.heremap as geemap In\u00a0[\u00a0]: Copied! <pre># Read api_key from environment\n\napi_key = os.environ[\"HEREMAPS_API_KEY\"]\n</pre> # Read api_key from environment  api_key = os.environ[\"HEREMAPS_API_KEY\"] <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm\n</pre> m = geemap.Map() m <p>Specify the default map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[50, 19], zoom=4)  # center=[lat, lon]\nm\n</pre> m = geemap.Map(center=[50, 19], zoom=4)  # center=[lat, lon] m <p>Set the visibility of map controls.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(fullscreen_control=False)\nm\n</pre> m = geemap.Map(fullscreen_control=False) m <p>Change the map width and height.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(height=\"450px\")\nm\n</pre> m = geemap.Map(height=\"450px\") m <p>Use built-in basemaps.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(basemap=\"HERE_RASTER_TERRAIN_MAP\")\nm\n</pre> m = geemap.Map(basemap=\"HERE_RASTER_TERRAIN_MAP\") m <p>Zoom to map to a bounding box [South, West, North, East].</p> In\u00a0[\u00a0]: Copied! <pre>m.zoom_to_bounds((-9.0882278, -55.3228175, 168.2249543, 72.2460938))  #\n</pre> m.zoom_to_bounds((-9.0882278, -55.3228175, 168.2249543, 72.2460938))  # In\u00a0[\u00a0]: Copied! <pre>m.add_basemap(basemap=\"Esri.WorldTopoMap\")\n</pre> m.add_basemap(basemap=\"Esri.WorldTopoMap\") <p>Add a custom XYZ tile layer.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(layers_control=True)\nm.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Satellite\",\n    attribution=\"Google\",\n)\nm\n</pre> m = geemap.Map(layers_control=True) m.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Satellite\",     attribution=\"Google\", ) m <p>Add a GeoJSON from an HTTP URL to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[0, 0], zoom=2, layers_control=True)\n\nin_geojson = 'https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/cable_geo.geojson'\nm.add_geojson(in_geojson, layer_name=\"Cable lines\")\n\nm\n</pre> m = geemap.Map(center=[0, 0], zoom=2, layers_control=True)  in_geojson = 'https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/cable_geo.geojson' m.add_geojson(in_geojson, layer_name=\"Cable lines\")  m <p>Add a local GeoJSON file to the map.</p> In\u00a0[\u00a0]: Copied! <pre>import json\n\nm = geemap.Map(center=[0, 0], zoom=2)\nwith open(\"../data/countries.geojson\") as fh:\n    geo = json.load(fh)\nm.add_geojson(geo, layer_name=\"Countries\")\nm\n</pre> import json  m = geemap.Map(center=[0, 0], zoom=2) with open(\"../data/countries.geojson\") as fh:     geo = json.load(fh) m.add_geojson(geo, layer_name=\"Countries\") m <p>Customize style for the GeoJSON layer.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[0, 0], zoom=2)\n\nurl = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"\n\nstyle = {\n    \"fillColor\": \"rgba(0, 0, 255, 0.2)\",\n    \"strokeColor\": \"blue\",\n}\n\nhover_style = {\"fillColor\": \"rgba(0, 0, 255, 0.7)\"}\n\nm.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style)\nm\n</pre> m = geemap.Map(center=[0, 0], zoom=2)  url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"  style = {     \"fillColor\": \"rgba(0, 0, 255, 0.2)\",     \"strokeColor\": \"blue\", }  hover_style = {\"fillColor\": \"rgba(0, 0, 255, 0.7)\"}  m.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style) m In\u00a0[\u00a0]: Copied! <pre>in_shp = '../data/countries.shp'\nin_geojson = '../data/us_states.json'\nin_kml = '../data/us_states.kml'\n</pre> in_shp = '../data/countries.shp' in_geojson = '../data/us_states.json' in_kml = '../data/us_states.kml' <p>Add a shapefile to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[0, 0], zoom=2)\nm.add_shp(in_shp, layer_name=\"Shapefile\")\nm\n</pre> m = geemap.Map(center=[0, 0], zoom=2) m.add_shp(in_shp, layer_name=\"Shapefile\") m <p>Add a KML file to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[40.273502, -86.126976], zoom=4)\nm.add_kml(in_kml, layer_name=\"KML\")\nm\n</pre> m = geemap.Map(center=[40.273502, -86.126976], zoom=4) m.add_kml(in_kml, layer_name=\"KML\") m <p>The add_vector function supports any vector data format supported by GeoPandas.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\"\nm.add_vector(url, layer_name=\"Countries\")\nm\n</pre> m = geemap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson\" m.add_vector(url, layer_name=\"Countries\") m <p>Customize the style of point layers.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map(center=[0, 0], zoom=2)\n\nurl = \"http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_month.geojson\"\npoint_style = {\n    \"strokeColor\": 'white',\n    \"lineWidth\": 1,\n    \"fillColor\": \"red\",\n    \"fillOpacity\": 0.7,\n    \"radius\": 5,\n}\nm.add_geojson(url, layer_name=\"Countries\", point_style=point_style, default_popup=True)\nm\n</pre> m = geemap.Map(center=[0, 0], zoom=2)  url = \"http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_month.geojson\" point_style = {     \"strokeColor\": 'white',     \"lineWidth\": 1,     \"fillColor\": \"red\",     \"fillOpacity\": 0.7,     \"radius\": 5, } m.add_geojson(url, layer_name=\"Countries\", point_style=point_style, default_popup=True) m In\u00a0[\u00a0]: Copied! <pre>import geopandas\nimport json\nimport os\n\ncountries = geopandas.read_file(geopandas.datasets.get_path(\"naturalearth_cities\"))\npoint_style = {\n    \"strokeColor\": 'white',\n    \"lineWidth\": 1,\n    \"fillColor\": \"blue\",\n    \"fillOpacity\": 0.7,\n    \"radius\": 5,\n}\n\nm = geemap.Map(center=[0, 0], zoom=3)\nm.add_gdf(countries, zoom_to_layer=False, point_style=point_style, default_popup=True)\nm\n</pre> import geopandas import json import os  countries = geopandas.read_file(geopandas.datasets.get_path(\"naturalearth_cities\")) point_style = {     \"strokeColor\": 'white',     \"lineWidth\": 1,     \"fillColor\": \"blue\",     \"fillOpacity\": 0.7,     \"radius\": 5, }  m = geemap.Map(center=[0, 0], zoom=3) m.add_gdf(countries, zoom_to_layer=False, point_style=point_style, default_popup=True) m In\u00a0[\u00a0]: Copied! <pre>import ee\n</pre> import ee In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"HYBRID\")\n</pre> m = geemap.Map() m.add_basemap(\"HYBRID\") In\u00a0[\u00a0]: Copied! <pre># Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nm.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nm.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},\n    'Landsat 7',\n)\nm.addLayer(states, {}, \"US States\")\n</pre> # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map m.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) m.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},     'Landsat 7', ) m.addLayer(states, {}, \"US States\") In\u00a0[\u00a0]: Copied! <pre>m.add_layer_control()\nm\n</pre> m.add_layer_control() m"},{"location":"notebooks/94_heremap/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Before you run the below cells make sure you have:</p> <ul> <li><p>A HERE developer account, free and available under HERE Developer Portal</p> </li> <li><p>An API key from the HERE Developer Portal</p> </li> <li><p>Export API key into environment variable <code>HEREMAPS_API_KEY</code></p> <pre>export HEREMAPS_API_KEY=YOUR-ACTUAL-API-KEY\n</pre> </li> </ul>"},{"location":"notebooks/94_heremap/#here-default-basemap","title":"HERE default basemap\u00b6","text":""},{"location":"notebooks/94_heremap/#basemaps","title":"Basemaps\u00b6","text":""},{"location":"notebooks/94_heremap/#zoom-to-bounds","title":"zoom to bounds\u00b6","text":""},{"location":"notebooks/94_heremap/#add-vector-data","title":"Add vector data\u00b6","text":"<p>How to add GeoJSON to the map</p>"},{"location":"notebooks/94_heremap/#point-style-for-geojson","title":"Point style for GeoJSON\u00b6","text":""},{"location":"notebooks/94_heremap/#add-earth-engine-layers","title":"Add Earth Engine layers\u00b6","text":""},{"location":"notebooks/95_create_cog/","title":"95 create cog","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap <p>If you are using a recently implemented geemap feature that has not yet been released to PyPI or conda-forge, you can uncomment the following line to install the development version from GitHub.</p> In\u00a0[\u00a0]: Copied! <pre># geemap.update_package()\n</pre> # geemap.update_package() <p>Provide a dataset path or URL.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://github.com/giswqs/data/raw/main/raster/srtm90.tif\"\n</pre> url = \"https://github.com/giswqs/data/raw/main/raster/srtm90.tif\" <p>Validate COG.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.cog_validate(url)\n</pre> geemap.cog_validate(url) In\u00a0[\u00a0]: Copied! <pre>geemap.cog_validate(url, verbose=True)\n</pre> geemap.cog_validate(url, verbose=True) <p>Convert the image to tiled COG.</p> In\u00a0[\u00a0]: Copied! <pre>out_cog = \"cog.tif\"\ngeemap.image_to_cog(url, out_cog)\n</pre> out_cog = \"cog.tif\" geemap.image_to_cog(url, out_cog) <p>Validate COG.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.cog_validate(out_cog)\n</pre> geemap.cog_validate(out_cog) In\u00a0[\u00a0]: Copied! <pre>geemap.cog_validate(out_cog, verbose=True)\n</pre> geemap.cog_validate(out_cog, verbose=True) <p>Add COG to map.</p> In\u00a0[\u00a0]: Copied! <pre>m = geemap.Map()\nm.add_local_tile(out_cog, palette=\"dem\", layer_name=\"Local COG\")\nm.add_cog_layer(url, palette=\"gist_earth\", name=\"Remote COG\")\nm\n</pre> m = geemap.Map() m.add_local_tile(out_cog, palette=\"dem\", layer_name=\"Local COG\") m.add_cog_layer(url, palette=\"gist_earth\", name=\"Remote COG\") m"},{"location":"notebooks/96_image_chips/","title":"96 image chips","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install geemap retry\n</pre> # !pip install geemap retry In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nimport logging\nimport multiprocessing\nimport os\nimport requests\nimport shutil\nfrom retry import retry\n</pre> import ee import geemap import logging import multiprocessing import os import requests import shutil from retry import retry In\u00a0[\u00a0]: Copied! <pre>ee.Initialize(opt_url='https://earthengine-highvolume.googleapis.com')\n</pre> ee.Initialize(opt_url='https://earthengine-highvolume.googleapis.com') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># region = Map.user_roi\nregion = ee.Geometry.Polygon(\n    [\n        [\n            [-122.513695, 37.707998],\n            [-122.513695, 37.804359],\n            [-122.371902, 37.804359],\n            [-122.371902, 37.707998],\n            [-122.513695, 37.707998],\n        ]\n    ],\n    None,\n    False,\n)\n</pre> # region = Map.user_roi region = ee.Geometry.Polygon(     [         [             [-122.513695, 37.707998],             [-122.513695, 37.804359],             [-122.371902, 37.804359],             [-122.371902, 37.707998],             [-122.513695, 37.707998],         ]     ],     None,     False, ) In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(region)\n    .filterDate('2020', '2021')\n    .mosaic()\n    .clip(region)\n    .select('N', 'R', 'G')\n)\n</pre> image = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(region)     .filterDate('2020', '2021')     .mosaic()     .clip(region)     .select('N', 'R', 'G') ) <p>Using the 10-m Sentinel-2 imagery.</p> In\u00a0[\u00a0]: Copied! <pre># image = ee.ImageCollection('COPERNICUS/S2_SR') \\\n#             .filterBounds(region) \\\n#             .filterDate('2021', '2022') \\\n#             .select('B8', 'B4', 'B3') \\\n#             .median() \\\n#             .visualize(min=0, max=4000) \\\n#             .clip(region)\n</pre> # image = ee.ImageCollection('COPERNICUS/S2_SR') \\ #             .filterBounds(region) \\ #             .filterDate('2021', '2022') \\ #             .select('B8', 'B4', 'B3') \\ #             .median() \\ #             .visualize(min=0, max=4000) \\ #             .clip(region) In\u00a0[\u00a0]: Copied! <pre>params = {\n    'count': 100,  # How many image chips to export\n    'buffer': 127,  # The buffer distance (m) around each point\n    'scale': 100,  # The scale to do stratified sampling\n    'seed': 1,  # A randomization seed to use for subsampling.\n    'dimensions': '256x256',  # The dimension of each image chip\n    'format': \"png\",  # The output image format, can be png, jpg, ZIPPED_GEO_TIFF, GEO_TIFF, NPY\n    'prefix': 'tile_',  # The filename prefix\n    'processes': 25,  # How many processes to used for parallel processing\n    'out_dir': '.',  # The output directory. Default to the current working directly\n}\n</pre> params = {     'count': 100,  # How many image chips to export     'buffer': 127,  # The buffer distance (m) around each point     'scale': 100,  # The scale to do stratified sampling     'seed': 1,  # A randomization seed to use for subsampling.     'dimensions': '256x256',  # The dimension of each image chip     'format': \"png\",  # The output image format, can be png, jpg, ZIPPED_GEO_TIFF, GEO_TIFF, NPY     'prefix': 'tile_',  # The filename prefix     'processes': 25,  # How many processes to used for parallel processing     'out_dir': '.',  # The output directory. Default to the current working directly } In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(image, {}, \"Image\")\nMap.addLayer(region, {}, \"ROI\", False)\nMap.setCenter(-122.4415, 37.7555, 12)\nMap\n</pre> Map.addLayer(image, {}, \"Image\") Map.addLayer(region, {}, \"ROI\", False) Map.setCenter(-122.4415, 37.7555, 12) Map In\u00a0[\u00a0]: Copied! <pre>def getRequests():\n    img = ee.Image(1).rename(\"Class\").addBands(image)\n    points = img.stratifiedSample(\n        numPoints=params['count'],\n        region=region,\n        scale=params['scale'],\n        seed=params['seed'],\n        geometries=True,\n    )\n    Map.data = points\n    return points.aggregate_array('.geo').getInfo()\n</pre> def getRequests():     img = ee.Image(1).rename(\"Class\").addBands(image)     points = img.stratifiedSample(         numPoints=params['count'],         region=region,         scale=params['scale'],         seed=params['seed'],         geometries=True,     )     Map.data = points     return points.aggregate_array('.geo').getInfo() <p>The <code>getResult()</code> function then takes one of those points and generates an image centered on that location, which is then downloaded as a PNG and saved to a file. This function uses <code>image.getThumbURL()</code> to select the pixels, however you could also use <code>image.getDownloadURL()</code> if you wanted the output to be in GeoTIFF or NumPy format (source).</p> In\u00a0[\u00a0]: Copied! <pre>@retry(tries=10, delay=1, backoff=2)\ndef getResult(index, point):\n    point = ee.Geometry.Point(point['coordinates'])\n    region = point.buffer(params['buffer']).bounds()\n\n    if params['format'] in ['png', 'jpg']:\n        url = image.getThumbURL(\n            {\n                'region': region,\n                'dimensions': params['dimensions'],\n                'format': params['format'],\n            }\n        )\n    else:\n        url = image.getDownloadURL(\n            {\n                'region': region,\n                'dimensions': params['dimensions'],\n                'format': params['format'],\n            }\n        )\n\n    if params['format'] == \"GEO_TIFF\":\n        ext = 'tif'\n    else:\n        ext = params['format']\n\n    r = requests.get(url, stream=True)\n    if r.status_code != 200:\n        r.raise_for_status()\n\n    out_dir = os.path.abspath(params['out_dir'])\n    basename = str(index).zfill(len(str(params['count'])))\n    filename = f\"{out_dir}/{params['prefix']}{basename}.{ext}\"\n    with open(filename, 'wb') as out_file:\n        shutil.copyfileobj(r.raw, out_file)\n    print(\"Done: \", basename)\n</pre> @retry(tries=10, delay=1, backoff=2) def getResult(index, point):     point = ee.Geometry.Point(point['coordinates'])     region = point.buffer(params['buffer']).bounds()      if params['format'] in ['png', 'jpg']:         url = image.getThumbURL(             {                 'region': region,                 'dimensions': params['dimensions'],                 'format': params['format'],             }         )     else:         url = image.getDownloadURL(             {                 'region': region,                 'dimensions': params['dimensions'],                 'format': params['format'],             }         )      if params['format'] == \"GEO_TIFF\":         ext = 'tif'     else:         ext = params['format']      r = requests.get(url, stream=True)     if r.status_code != 200:         r.raise_for_status()      out_dir = os.path.abspath(params['out_dir'])     basename = str(index).zfill(len(str(params['count'])))     filename = f\"{out_dir}/{params['prefix']}{basename}.{ext}\"     with open(filename, 'wb') as out_file:         shutil.copyfileobj(r.raw, out_file)     print(\"Done: \", basename) In\u00a0[\u00a0]: Copied! <pre>%%time\nlogging.basicConfig()\nitems = getRequests()\n\npool = multiprocessing.Pool(params['processes'])\npool.starmap(getResult, enumerate(items))\n\npool.close()\n</pre> %%time logging.basicConfig() items = getRequests()  pool = multiprocessing.Pool(params['processes']) pool.starmap(getResult, enumerate(items))  pool.close() In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(Map.data, {}, \"Sample points\")\nMap\n</pre> Map.addLayer(Map.data, {}, \"Sample points\") Map"},{"location":"notebooks/96_image_chips/#how-to-export-thousands-of-image-chips-from-earth-engine-in-a-few-minutes","title":"How to export thousands of image chips from Earth Engine in a few minutes\u00b6","text":"<p>This source code of this notebook was adopted from the Medium post - Fast(er) Downloads by Noel Gorelick. Credits to Noel.</p> <p>Due to the limitation of the multiprocessing package, the functionality of this notebook can only be run in the top-level. Therefore, it could not be implemented as a function under geemap.</p>"},{"location":"notebooks/96_image_chips/#install-packages","title":"Install packages\u00b6","text":"<p>Uncomment the following line to install the required packages.</p>"},{"location":"notebooks/96_image_chips/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/96_image_chips/#initialize-gee-to-use-the-high-volume-endpoint","title":"Initialize GEE to use the high-volume endpoint\u00b6","text":"<ul> <li>high-volume endpoint</li> </ul>"},{"location":"notebooks/96_image_chips/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/96_image_chips/#define-the-region-of-interest-roi","title":"Define the Region of Interest (ROI)\u00b6","text":"<p>You can use the drawing tools on the map to draw an ROI, then you can use <code>Map.user_roi</code> to retrieve the geometry. Alternatively, you can define the ROI as an ee.Geometry as shown below.</p>"},{"location":"notebooks/96_image_chips/#define-the-image-source","title":"Define the image source\u00b6","text":"<p>Using the 1-m NAIP imagery.</p>"},{"location":"notebooks/96_image_chips/#set-parameters","title":"Set parameters\u00b6","text":"<p>If you want the exported images to have coordinate system, change <code>format</code> to <code>GEO_TIFF</code>. Otherwise, you can use <code>png</code> or <code>jpg</code> formats.</p>"},{"location":"notebooks/96_image_chips/#add-layers-to-map","title":"Add layers to map\u00b6","text":""},{"location":"notebooks/96_image_chips/#generate-a-list-of-work-items","title":"Generate a list of work items\u00b6","text":"<p>In the example, we are going to generate 1000 points using the stratified random sampling, which requires a <code>classBand</code>. It is the name of the band containing the classes to use for stratification. If unspecified, the first band of the input image is used. Therefore, we have toADD a new band with a constant value (e.g., 1) to the image. The result of the <code>getRequests()</code>function returns a list of dictionaries containing points.</p>"},{"location":"notebooks/96_image_chips/#create-a-function-for-downloading-image","title":"Create a function for downloading image\u00b6","text":""},{"location":"notebooks/96_image_chips/#download-images","title":"Download images\u00b6","text":""},{"location":"notebooks/96_image_chips/#retrieve-sample-points","title":"Retrieve sample points\u00b6","text":""},{"location":"notebooks/97_join_table/","title":"97 join table","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap <p>Add data to the map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ncountries = ee.FeatureCollection('users/giswqs/public/countries')\nMap.addLayer(countries, {}, 'Countries')\nMap\n</pre> Map = geemap.Map() countries = ee.FeatureCollection('users/giswqs/public/countries') Map.addLayer(countries, {}, 'Countries') Map <p>Display the attribute table.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_df(countries)\n</pre> geemap.ee_to_df(countries) <p>Get data to be joined to the attribute table.</p> In\u00a0[\u00a0]: Copied! <pre>data = 'https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson'\n</pre> data = 'https://raw.githubusercontent.com/gee-community/geemap/master/examples/data/countries.geojson' <p>Join data to the attribute table.</p> In\u00a0[\u00a0]: Copied! <pre>fc = geemap.ee_join_table(countries, data, src_key='id', dst_key='ISO_A3')\n</pre> fc = geemap.ee_join_table(countries, data, src_key='id', dst_key='ISO_A3') <p>Display the new attribute table.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_df(fc)\n</pre> geemap.ee_to_df(fc) <p>Add the new data to the map.</p> In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(fc, {}, 'Countries New')\n</pre> Map.addLayer(fc, {}, 'Countries New')"},{"location":"notebooks/98_timelapse_fading/","title":"98 timelapse fading","text":"<p>Uncomment the following line to install geemap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap <p>Add fading effect to existing GIF.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://i.imgur.com/ZWSZC5z.gif\"\n</pre> url = \"https://i.imgur.com/ZWSZC5z.gif\" In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(url, verbose=False)\n</pre> geemap.show_image(url, verbose=False) In\u00a0[\u00a0]: Copied! <pre>out_gif = \"gif_fading.gif\"\n</pre> out_gif = \"gif_fading.gif\" In\u00a0[\u00a0]: Copied! <pre>geemap.gif_fading(url, out_gif, verbose=False)\n</pre> geemap.gif_fading(url, out_gif, verbose=False) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif) <p></p> <p>Create a timelapse from scratch and add fading effect.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap(\"HYBRID\")\nMap\n</pre> Map = geemap.Map() Map.add_basemap(\"HYBRID\") Map <p>Sierra Gorda and Spence copper mines, Chile</p> In\u00a0[\u00a0]: Copied! <pre>roi = ee.Geometry.Polygon(\n    [\n        [\n            [-69.315491, -22.837104],\n            [-69.315491, -22.751488],\n            [-69.190006, -22.751488],\n            [-69.190006, -22.837104],\n            [-69.315491, -22.837104],\n        ]\n    ]\n)\n</pre> roi = ee.Geometry.Polygon(     [         [             [-69.315491, -22.837104],             [-69.315491, -22.751488],             [-69.190006, -22.751488],             [-69.190006, -22.837104],             [-69.315491, -22.837104],         ]     ] ) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(roi, {}, \"ROI\")\nMap.centerObject(roi)\n</pre> Map.addLayer(roi, {}, \"ROI\") Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>title = \"Sierra Gorda copper mines, Chile\"\nout_gif = \"timelapse.gif\"\n</pre> title = \"Sierra Gorda copper mines, Chile\" out_gif = \"timelapse.gif\" In\u00a0[\u00a0]: Copied! <pre>geemap.landsat_timelapse(\n    roi,\n    out_gif,\n    start_year=2004,\n    end_year=2010,\n    frames_per_second=1,\n    title=title,\n    fading=False,\n)\n</pre> geemap.landsat_timelapse(     roi,     out_gif,     start_year=2004,     end_year=2010,     frames_per_second=1,     title=title,     fading=False, ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>out_fading_gif = \"timelapse_fading.gif\"\n</pre> out_fading_gif = \"timelapse_fading.gif\" In\u00a0[\u00a0]: Copied! <pre>geemap.landsat_timelapse(\n    roi,\n    out_fading_gif,\n    start_year=2004,\n    end_year=2010,\n    frames_per_second=1,\n    title=title,\n    fading=True,\n)\n</pre> geemap.landsat_timelapse(     roi,     out_fading_gif,     start_year=2004,     end_year=2010,     frames_per_second=1,     title=title,     fading=True, ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_fading_gif)\n</pre> geemap.show_image(out_fading_gif) <p></p>"},{"location":"notebooks/99_landsat_9/","title":"99 landsat 9","text":"<p>Uncomment the following line to install geemap if needed.</p> <p>Landsat 9 was successfully launched on Sept. 27, 2021. USGS has been providing Landsat data to the public since Feb. 10, 2022. Landsat 9 data can be downloaded from EarthExplorer. The Earth Engine team has been ingesting Landsat 9 into the Public Data Catalog. As of Feb. 14, 2022, although Landsat 9 data have not been publicly listed on the Earth Engine Datasets page, you can access the data through <code>ee.ImageCollection('LANDSAT/LC09/C02/T1_L2')</code> .</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap <p>Import libraries.</p> In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() <p>Find out how many Landsat imgaes are available.</p> In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2')\nprint(collection.size().getInfo())\n</pre> collection = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2') print(collection.size().getInfo()) <p>Create a median composite.</p> In\u00a0[\u00a0]: Copied! <pre>median = collection.median()\n</pre> median = collection.median() <p>Apply scaling factors. See https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1_L2#bands</p> In\u00a0[\u00a0]: Copied! <pre>def apply_scale_factors(image):\n    opticalBands = image.select('SR_B.').multiply(0.0000275).add(-0.2)\n    thermalBands = image.select('ST_B.*').multiply(0.00341802).add(149.0)\n    return image.addBands(opticalBands, None, True).addBands(thermalBands, None, True)\n</pre> def apply_scale_factors(image):     opticalBands = image.select('SR_B.').multiply(0.0000275).add(-0.2)     thermalBands = image.select('ST_B.*').multiply(0.00341802).add(149.0)     return image.addBands(opticalBands, None, True).addBands(thermalBands, None, True) In\u00a0[\u00a0]: Copied! <pre>dataset = apply_scale_factors(median)\n</pre> dataset = apply_scale_factors(median) <p>Specify visualization parameters.</p> In\u00a0[\u00a0]: Copied! <pre>vis_natural = {\n    'bands': ['SR_B4', 'SR_B3', 'SR_B2'],\n    'min': 0.0,\n    'max': 0.3,\n}\n\nvis_nir = {\n    'bands': ['SR_B5', 'SR_B4', 'SR_B3'],\n    'min': 0.0,\n    'max': 0.3,\n}\n</pre> vis_natural = {     'bands': ['SR_B4', 'SR_B3', 'SR_B2'],     'min': 0.0,     'max': 0.3, }  vis_nir = {     'bands': ['SR_B5', 'SR_B4', 'SR_B3'],     'min': 0.0,     'max': 0.3, } <p>Add data layers to the map.</p> In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(dataset, vis_natural, 'True color (432)')\nMap.addLayer(dataset, vis_nir, 'Color infrared (543)')\nMap\n</pre> Map.addLayer(dataset, vis_natural, 'True color (432)') Map.addLayer(dataset, vis_nir, 'Color infrared (543)') Map <p></p> <p>Create linked maps for visualizing images with different band combinations. For more information on common band combinations of Landsat 8/9, see https://gisgeography.com/landsat-8-bands-combinations/</p> <p>Specify visualization parameters.</p> In\u00a0[\u00a0]: Copied! <pre>vis_params = [\n    {'bands': ['SR_B4', 'SR_B3', 'SR_B2'], 'min': 0, 'max': 0.3},\n    {'bands': ['SR_B5', 'SR_B4', 'SR_B3'], 'min': 0, 'max': 0.3},\n    {'bands': ['SR_B7', 'SR_B6', 'SR_B4'], 'min': 0, 'max': 0.3},\n    {'bands': ['SR_B6', 'SR_B5', 'SR_B2'], 'min': 0, 'max': 0.3},\n]\n</pre> vis_params = [     {'bands': ['SR_B4', 'SR_B3', 'SR_B2'], 'min': 0, 'max': 0.3},     {'bands': ['SR_B5', 'SR_B4', 'SR_B3'], 'min': 0, 'max': 0.3},     {'bands': ['SR_B7', 'SR_B6', 'SR_B4'], 'min': 0, 'max': 0.3},     {'bands': ['SR_B6', 'SR_B5', 'SR_B2'], 'min': 0, 'max': 0.3}, ] <p>Specify labels for each layers.</p> In\u00a0[\u00a0]: Copied! <pre>labels = [\n    'Natural Color (4, 3, 2)',\n    'Color Infrared (5, 4, 3)',\n    'Short-Wave Infrared (7, 6 4)',\n    'Agriculture (6, 5, 2)',\n]\n</pre> labels = [     'Natural Color (4, 3, 2)',     'Color Infrared (5, 4, 3)',     'Short-Wave Infrared (7, 6 4)',     'Agriculture (6, 5, 2)', ] <p>Create linked maps.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"400px\",\n    center=[40, -100],\n    zoom=4,\n    ee_objects=[dataset],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n</pre> geemap.linked_maps(     rows=2,     cols=2,     height=\"400px\",     center=[40, -100],     zoom=4,     ee_objects=[dataset],     vis_params=vis_params,     labels=labels,     label_position=\"topright\", ) <p></p> <p>Create a split-panel map for comparing Landsat 8 and 9 images.</p> <p>Retrieve two sample images.</p> In\u00a0[\u00a0]: Copied! <pre>landsat8 = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_015043_20130402')\nlandsat9 = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_015043_20211231')\n</pre> landsat8 = ee.Image('LANDSAT/LC08/C02/T1_L2/LC08_015043_20130402') landsat9 = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_015043_20211231') <p>Apply scaling factors.</p> In\u00a0[\u00a0]: Copied! <pre>landsat8 = apply_scale_factors(landsat8)\nlandsat9 = apply_scale_factors(landsat9)\n</pre> landsat8 = apply_scale_factors(landsat8) landsat9 = apply_scale_factors(landsat9) <p>Generate Earth Engine layers.</p> In\u00a0[\u00a0]: Copied! <pre>left_layer = geemap.ee_tile_layer(landsat8, vis_natural, 'Landsat 8')\nright_layer = geemap.ee_tile_layer(landsat9, vis_natural, 'Landsat 9')\n</pre> left_layer = geemap.ee_tile_layer(landsat8, vis_natural, 'Landsat 8') right_layer = geemap.ee_tile_layer(landsat9, vis_natural, 'Landsat 9') <p>Create a split-panel map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(left_layer, right_layer)\nMap\n</pre> Map = geemap.Map() Map.split_map(left_layer, right_layer) Map <p></p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"workshops/AmericaView_2023/","title":"AmericaView 2023","text":"<p>Interactive Cloud Computing with Google Earth Engine and Geemap</p> <p>Introduction: This is a notebook prepared for the workshop at the AmericaView Annual Conference at Lafayette, Louisiana on March 13, 2023.</p> <p>Overview: Google Earth Engine (GEE) is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. It enables scientists, researchers, and developers to analyze and visualize changes on the Earth\u2019s surface. The geemap Python package provides GEE users with an intuitive interface to manipulate, analyze, and visualize geospatial big data interactively in a Jupyter-based environment. The topics will be covered in this workshop include: (1) introducing geemap and the Earth Engine Python API; (2) creating interactive maps; (3) searching GEE data catalog; (4) visualizing GEE datasets; (5) analyzing GEE datasets, and (6) exporting GEE datasets. More information about the geemap Python package can be found at https://geemap.org.</p> <p>Requirement: Please sign up for a Google Earth Engine account if you don\u2019t have one yet. No software installation is needed. You just need a browser with Internet access for this workshop.</p> In\u00a0[\u00a0]: Copied! <pre>%pip install geemap\n</pre> %pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() <p>To display it in a Jupyter notebook, simply ask for the object representation:</p> In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map <p>To customize the map, you can specify various keyword arguments, such as <code>center</code> ([lat, lon]), <code>zoom</code>, <code>width</code>, and <code>height</code>. The default <code>width</code> is <code>100%</code>, which takes up the entire cell width of the Jupyter notebook. The <code>height</code> argument accepts a number or a string. If a number is provided, it represents the height of the map in pixels. If a string is provided, the string must be in the format of a number followed by <code>px</code>, e.g., <code>600px</code>.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4, height=600)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4, height=600) Map <p>To hide a control, set <code>control_name</code> to <code>False</code>, e.g., <code>draw_ctrl=False</code>.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(data_ctrl=False, toolbar_ctrl=False, draw_ctrl=False)\nMap\n</pre> Map = geemap.Map(data_ctrl=False, toolbar_ctrl=False, draw_ctrl=False) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(basemap='HYBRID')\nMap\n</pre> Map = geemap.Map(basemap='HYBRID') Map <p>You can add as many basemaps as you like to the map. For example, the following code adds the <code>OpenTopoMap</code> basemap to the map above:</p> In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap('OpenTopoMap')\n</pre> Map.add_basemap('OpenTopoMap') <p>Print out the first 10 basemaps:</p> In\u00a0[\u00a0]: Copied! <pre>basemaps = list(geemap.basemaps.keys())\nlen(geemap.basemaps)\n</pre> basemaps = list(geemap.basemaps.keys()) len(geemap.basemaps) In\u00a0[\u00a0]: Copied! <pre>basemaps[:10]\n</pre> basemaps[:10] In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Terrain\",\n    attribution=\"Google\",\n)\nMap\n</pre> Map = geemap.Map() Map.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Terrain\",     attribution=\"Google\", ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nurl = 'https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?'\nMap.add_wms_layer(\n    url=url,\n    layers='NLCD_2019_Land_Cover_L48',\n    name='NLCD 2019',\n    format='image/png',\n    attribution='MRLC',\n    transparent=True,\n)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) url = 'https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?' Map.add_wms_layer(     url=url,     layers='NLCD_2019_Land_Cover_L48',     name='NLCD 2019',     format='image/png',     attribution='MRLC',     transparent=True, ) Map In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('USGS/SRTMGL1_003')\nimage\n</pre> image = ee.Image('USGS/SRTMGL1_003') image In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[21.79, 70.87], zoom=3)\nimage = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 6000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(image, vis_params, 'SRTM')\nMap\n</pre> Map = geemap.Map(center=[21.79, 70.87], zoom=3) image = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 6000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(image, vis_params, 'SRTM') Map In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection('COPERNICUS/S2_SR')\n</pre> collection = ee.ImageCollection('COPERNICUS/S2_SR') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ncollection = ee.ImageCollection('COPERNICUS/S2_SR')\nimage = collection.median()\n\nvis = {\n    'min': 0.0,\n    'max': 3000,\n    'bands': ['B4', 'B3', 'B2'],\n}\n\nMap.setCenter(83.277, 17.7009, 12)\nMap.addLayer(image, vis, 'Sentinel-2')\nMap\n</pre> Map = geemap.Map() collection = ee.ImageCollection('COPERNICUS/S2_SR') image = collection.median()  vis = {     'min': 0.0,     'max': 3000,     'bands': ['B4', 'B3', 'B2'], }  Map.setCenter(83.277, 17.7009, 12) Map.addLayer(image, vis, 'Sentinel-2') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ncollection = (\n    ee.ImageCollection('COPERNICUS/S2_SR')\n    .filterDate('2021-01-01', '2022-01-01')\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5))\n)\nimage = collection.median()\n\nvis = {\n    'min': 0.0,\n    'max': 3000,\n    'bands': ['B4', 'B3', 'B2'],\n}\n\nMap.setCenter(83.277, 17.7009, 12)\nMap.addLayer(image, vis, 'Sentinel-2')\nMap\n</pre> Map = geemap.Map() collection = (     ee.ImageCollection('COPERNICUS/S2_SR')     .filterDate('2021-01-01', '2022-01-01')     .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5)) ) image = collection.median()  vis = {     'min': 0.0,     'max': 3000,     'bands': ['B4', 'B3', 'B2'], }  Map.setCenter(83.277, 17.7009, 12) Map.addLayer(image, vis, 'Sentinel-2') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nfc = ee.FeatureCollection('TIGER/2016/Roads')\nMap.setCenter(-73.9596, 40.7688, 12)\nMap.addLayer(fc, {}, 'Census roads')\nMap\n</pre> Map = geemap.Map() fc = ee.FeatureCollection('TIGER/2016/Roads') Map.setCenter(-73.9596, 40.7688, 12) Map.addLayer(fc, {}, 'Census roads') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Louisiana'))\nMap.addLayer(fc, {}, 'Louisiana')\nMap.centerObject(fc)\nMap\n</pre> Map = geemap.Map() states = ee.FeatureCollection('TIGER/2018/States') fc = states.filter(ee.Filter.eq('NAME', 'Louisiana')) Map.addLayer(fc, {}, 'Louisiana') Map.centerObject(fc) Map In\u00a0[\u00a0]: Copied! <pre>feat = fc.first()\nfeat.toDictionary()\n</pre> feat = fc.first() feat.toDictionary() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.inList('NAME', ['California', 'Oregon', 'Washington']))\nMap.addLayer(fc, {}, 'West Coast')\nMap.centerObject(fc)\nMap\n</pre> Map = geemap.Map() states = ee.FeatureCollection('TIGER/2018/States') fc = states.filter(ee.Filter.inList('NAME', ['California', 'Oregon', 'Washington'])) Map.addLayer(fc, {}, 'West Coast') Map.centerObject(fc) Map In\u00a0[\u00a0]: Copied! <pre>region = Map.user_roi\nif region is None:\n    region = ee.Geometry.BBox(-88.40, 29.88, -77.90, 35.39)\n\nfc = ee.FeatureCollection('TIGER/2018/States').filterBounds(region)\nMap.addLayer(fc, {}, 'Southeastern U.S.')\nMap.centerObject(fc)\n</pre> region = Map.user_roi if region is None:     region = ee.Geometry.BBox(-88.40, 29.88, -77.90, 35.39)  fc = ee.FeatureCollection('TIGER/2018/States').filterBounds(region) Map.addLayer(fc, {}, 'Southeastern U.S.') Map.centerObject(fc) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {'color': '0000ffff', 'width': 2, 'lineType': 'solid', 'fillColor': 'FF000080'}\nMap.addLayer(states.style(**style), {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") style = {'color': '0000ffff', 'width': 2, 'lineType': 'solid', 'fillColor': 'FF000080'} Map.addLayer(states.style(**style), {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nvis_params = {\n    'color': '000000',\n    'colorOpacity': 1,\n    'pointSize': 3,\n    'pointShape': 'circle',\n    'width': 2,\n    'lineType': 'solid',\n    'fillColorOpacity': 0.66,\n}\npalette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") vis_params = {     'color': '000000',     'colorOpacity': 1,     'pointSize': 3,     'pointShape': 'circle',     'width': 2,     'lineType': 'solid',     'fillColorOpacity': 0.66, } palette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'] Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params ) Map In\u00a0[\u00a0]: Copied! <pre>dataset_xyz = ee.Image('USGS/SRTMGL1_003')\nMap.addLayer(dataset_xyz, {}, \"USGS/SRTMGL1_003\")\n</pre> dataset_xyz = ee.Image('USGS/SRTMGL1_003') Map.addLayer(dataset_xyz, {}, \"USGS/SRTMGL1_003\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map() dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(dem, vis_params, 'SRTM DEM') Map In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import DATA\n</pre> from geemap.datasets import DATA In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\ndataset = ee.Image(DATA.USGS_GAP_CONUS_2011)\nMap.addLayer(dataset, {}, 'GAP CONUS')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) dataset = ee.Image(DATA.USGS_GAP_CONUS_2011) Map.addLayer(dataset, {}, 'GAP CONUS') Map In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import get_metadata\n\nget_metadata(DATA.USGS_GAP_CONUS_2011)\n</pre> from geemap.datasets import get_metadata  get_metadata(DATA.USGS_GAP_CONUS_2011) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Load an image.\nimage = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318')\n\n# Define the visualization parameters.\nvizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n\n# Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10)\n# San Francisco Bay\nMap.addLayer(image, vizParams, 'False color composite')\n</pre> # Load an image. image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318')  # Define the visualization parameters. vizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}  # Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10) # San Francisco Bay Map.addLayer(image, vizParams, 'False color composite') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat7, landsat_vis, \"Landsat\")\n\nhyperion = ee.ImageCollection('EO1/HYPERION').filter(\n    ee.Filter.date('2016-01-01', '2017-03-01')\n)\n\nhyperion_vis = {\n    'min': 1000.0,\n    'max': 14000.0,\n    'gamma': 2.5,\n}\nMap.addLayer(hyperion, hyperion_vis, 'Hyperion')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] )  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat7, landsat_vis, \"Landsat\")  hyperion = ee.ImageCollection('EO1/HYPERION').filter(     ee.Filter.date('2016-01-01', '2017-03-01') )  hyperion_vis = {     'min': 1000.0,     'max': 14000.0,     'gamma': 2.5, } Map.addLayer(hyperion, hyperion_vis, 'Hyperion') Map In\u00a0[\u00a0]: Copied! <pre>Map.set_plot_options(add_marker_cluster=True, overlay=True)\n</pre> Map.set_plot_options(add_marker_cluster=True, overlay=True) In\u00a0[\u00a0]: Copied! <pre>legends = geemap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = geemap.builtin_legends for legend in legends:     print(legend) In\u00a0[\u00a0]: Copied! <pre>Map.add_legend(builtin_legend='NLCD')\n</pre> Map.add_legend(builtin_legend='NLCD') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap.add_basemap('HYBRID')\n\nnlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')\nlandcover = nlcd.select('landcover')\n\nMap.addLayer(landcover, {}, 'NLCD Land Cover 2019')\nMap.add_legend(\n    title=\"NLCD Land Cover Classification\", builtin_legend='NLCD', height='465px'\n)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map.add_basemap('HYBRID')  nlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019') landcover = nlcd.select('landcover')  Map.addLayer(landcover, {}, 'NLCD Land Cover 2019') Map.add_legend(     title=\"NLCD Land Cover Classification\", builtin_legend='NLCD', height='465px' ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(add_google_map=False)\n\nlabels = ['One', 'Two', 'Three', 'Four', 'ect']\n\n# colors can be defined using either hex code or RGB (0-255, 0-255, 0-255)\ncolors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']\n# legend_colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68 123)]\n\nMap.add_legend(labels=labels, colors=colors, position='bottomright')\nMap\n</pre> Map = geemap.Map(add_google_map=False)  labels = ['One', 'Two', 'Three', 'Four', 'ect']  # colors can be defined using either hex code or RGB (0-255, 0-255, 0-255) colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3'] # legend_colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68 123)]  Map.add_legend(labels=labels, colors=colors, position='bottomright') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\nlegend_dict = {\n    '11 Open Water': '466b9f',\n    '12 Perennial Ice/Snow': 'd1def8',\n    '21 Developed, Open Space': 'dec5c5',\n    '22 Developed, Low Intensity': 'd99282',\n    '23 Developed, Medium Intensity': 'eb0000',\n    '24 Developed High Intensity': 'ab0000',\n    '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',\n    '41 Deciduous Forest': '68ab5f',\n    '42 Evergreen Forest': '1c5f2c',\n    '43 Mixed Forest': 'b5c58f',\n    '51 Dwarf Scrub': 'af963c',\n    '52 Shrub/Scrub': 'ccb879',\n    '71 Grassland/Herbaceous': 'dfdfc2',\n    '72 Sedge/Herbaceous': 'd1d182',\n    '73 Lichens': 'a3cc51',\n    '74 Moss': '82ba9e',\n    '81 Pasture/Hay': 'dcd939',\n    '82 Cultivated Crops': 'ab6c28',\n    '90 Woody Wetlands': 'b8d9eb',\n    '95 Emergent Herbaceous Wetlands': '6c9fb8',\n}\n\nnlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')\nlandcover = nlcd.select('landcover')\n\nMap.addLayer(landcover, {}, 'NLCD Land Cover 2019')\nMap.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  legend_dict = {     '11 Open Water': '466b9f',     '12 Perennial Ice/Snow': 'd1def8',     '21 Developed, Open Space': 'dec5c5',     '22 Developed, Low Intensity': 'd99282',     '23 Developed, Medium Intensity': 'eb0000',     '24 Developed High Intensity': 'ab0000',     '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',     '41 Deciduous Forest': '68ab5f',     '42 Evergreen Forest': '1c5f2c',     '43 Mixed Forest': 'b5c58f',     '51 Dwarf Scrub': 'af963c',     '52 Shrub/Scrub': 'ccb879',     '71 Grassland/Herbaceous': 'dfdfc2',     '72 Sedge/Herbaceous': 'd1d182',     '73 Lichens': 'a3cc51',     '74 Moss': '82ba9e',     '81 Pasture/Hay': 'dcd939',     '82 Cultivated Crops': 'ab6c28',     '90 Woody Wetlands': 'b8d9eb',     '95 Emergent Herbaceous Wetlands': '6c9fb8', }  nlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019') landcover = nlcd.select('landcover')  Map.addLayer(landcover, {}, 'NLCD Land Cover 2019') Map.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM') Map In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\")\n</pre> Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\") In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\"\n)\n</pre> Map.add_colorbar(     vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\" ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n)\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     layer_name=\"SRTM DEM\",     orientation=\"vertical\",     transparent_bg=True, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(left_layer='HYBRID', right_layer='TERRAIN')\nMap\n</pre> Map = geemap.Map() Map.split_map(left_layer='HYBRID', right_layer='TERRAIN') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4, height=600)\n\nnlcd_2001 = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2001').select('landcover')\nnlcd_2019 = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019').select('landcover')\n\nleft_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001')\nright_layer = geemap.ee_tile_layer(nlcd_2019, {}, 'NLCD 2019')\n\nMap.split_map(left_layer, right_layer)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4, height=600)  nlcd_2001 = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2001').select('landcover') nlcd_2019 = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019').select('landcover')  left_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001') right_layer = geemap.ee_tile_layer(nlcd_2019, {}, 'NLCD 2019')  Map.split_map(left_layer, right_layer) Map In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection('COPERNICUS/S2')\n    .filterDate('2018-09-01', '2018-09-30')\n    .map(lambda img: img.divide(10000))\n    .median()\n)\n\nvis_params = [\n    {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n]\n\nlabels = [\n    'Natural Color (B4/B3/B2)',\n    'Land/Water (B8/B11/B4)',\n    'Color Infrared (B8/B4/B3)',\n    'Vegetation (B12/B11/B4)',\n]\n\ngeemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"300px\",\n    center=[38.4151, 21.2712],\n    zoom=12,\n    ee_objects=[image],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n</pre> image = (     ee.ImageCollection('COPERNICUS/S2')     .filterDate('2018-09-01', '2018-09-30')     .map(lambda img: img.divide(10000))     .median() )  vis_params = [     {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3}, ]  labels = [     'Natural Color (B4/B3/B2)',     'Land/Water (B8/B11/B4)',     'Color Infrared (B8/B4/B3)',     'Vegetation (B12/B11/B4)', ]  geemap.linked_maps(     rows=2,     cols=2,     height=\"300px\",     center=[38.4151, 21.2712],     zoom=12,     ee_objects=[image],     vis_params=vis_params,     labels=labels,     label_position=\"topright\", ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\ncollection = ee.ImageCollection('USGS/NLCD_RELEASES/2019_REL/NLCD').select('landcover')\nvis_params = {'bands': ['landcover']}\nyears = collection.aggregate_array('system:index').getInfo()\nyears\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) collection = ee.ImageCollection('USGS/NLCD_RELEASES/2019_REL/NLCD').select('landcover') vis_params = {'bands': ['landcover']} years = collection.aggregate_array('system:index').getInfo() years In\u00a0[\u00a0]: Copied! <pre>Map.ts_inspector(\n    left_ts=collection,\n    right_ts=collection,\n    left_names=years,\n    right_names=years,\n    left_vis=vis_params,\n    right_vis=vis_params,\n    width='80px',\n)\nMap\n</pre> Map.ts_inspector(     left_ts=collection,     right_ts=collection,     left_names=years,     right_names=years,     left_vis=vis_params,     right_vis=vis_params,     width='80px', ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = (\n    ee.ImageCollection('MODIS/MCD43A4_006_NDVI')\n    .filter(ee.Filter.date('2018-06-01', '2018-07-01'))\n    .select(\"NDVI\")\n)\nvis_params = {\n    'min': 0.0,\n    'max': 1.0,\n    'palette': 'ndvi',\n}\n\nMap.add_time_slider(collection, vis_params, time_interval=2)\nMap\n</pre> Map = geemap.Map()  collection = (     ee.ImageCollection('MODIS/MCD43A4_006_NDVI')     .filter(ee.Filter.date('2018-06-01', '2018-07-01'))     .select(\"NDVI\") ) vis_params = {     'min': 0.0,     'max': 1.0,     'palette': 'ndvi', }  Map.add_time_slider(collection, vis_params, time_interval=2) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = (\n    ee.ImageCollection('NOAA/GFS0P25')\n    .filterDate('2018-12-22', '2018-12-23')\n    .limit(24)\n    .select('temperature_2m_above_ground')\n)\n\nvis_params = {\n    'min': -40.0,\n    'max': 35.0,\n    'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'],\n}\n\nlabels = [str(n).zfill(2) + \":00\" for n in range(0, 24)]\nMap.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8)\nMap\n</pre> Map = geemap.Map()  collection = (     ee.ImageCollection('NOAA/GFS0P25')     .filterDate('2018-12-22', '2018-12-23')     .limit(24)     .select('temperature_2m_above_ground') )  vis_params = {     'min': -40.0,     'max': 35.0,     'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'], }  labels = [str(n).zfill(2) + \":00\" for n in range(0, 24)] Map.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[37.75, -122.45], zoom=12)\n\ncollection = (\n    ee.ImageCollection('COPERNICUS/S2_SR')\n    .filterBounds(ee.Geometry.Point([-122.45, 37.75]))\n    .filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10)\n)\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\n\nMap.add_time_slider(collection, vis_params)\nMap\n</pre> Map = geemap.Map(center=[37.75, -122.45], zoom=12)  collection = (     ee.ImageCollection('COPERNICUS/S2_SR')     .filterBounds(ee.Geometry.Point([-122.45, 37.75]))     .filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10) )  vis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}  Map.add_time_slider(collection, vis_params) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\n# Add NASA SRTM\ndem = ee.Image('USGS/SRTMGL1_003')\ndem_vis = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(dem, dem_vis, 'SRTM DEM')\n\n# Add 5-year Landsat TOA composite\nlandsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat, landsat_vis, \"Landsat\", False)\n\n# Add US Census States\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {'fillColor': '00000000'}\nMap.addLayer(states.style(**style), {}, 'US States')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  # Add NASA SRTM dem = ee.Image('USGS/SRTMGL1_003') dem_vis = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(dem, dem_vis, 'SRTM DEM')  # Add 5-year Landsat TOA composite landsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat, landsat_vis, \"Landsat\", False)  # Add US Census States states = ee.FeatureCollection(\"TIGER/2018/States\") style = {'fillColor': '00000000'} Map.addLayer(states.style(**style), {}, 'US States') Map In\u00a0[\u00a0]: Copied! <pre>out_dem_stats = 'dem_stats.csv'\ngeemap.zonal_stats(\n    dem, states, out_dem_stats, statistics_type='MEAN', scale=1000, return_fc=False\n)\n</pre> out_dem_stats = 'dem_stats.csv' geemap.zonal_stats(     dem, states, out_dem_stats, statistics_type='MEAN', scale=1000, return_fc=False ) In\u00a0[\u00a0]: Copied! <pre>out_landsat_stats = 'landsat_stats.csv'\ngeemap.zonal_stats(\n    landsat,\n    states,\n    out_landsat_stats,\n    statistics_type='MEAN',\n    scale=1000,\n    return_fc=False,\n)\n</pre> out_landsat_stats = 'landsat_stats.csv' geemap.zonal_stats(     landsat,     states,     out_landsat_stats,     statistics_type='MEAN',     scale=1000,     return_fc=False, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\n# Add NLCD data\ndataset = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')\nlandcover = dataset.select('landcover')\nMap.addLayer(landcover, {}, 'NLCD 2019')\n\n# Add US census states\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {'fillColor': '00000000'}\nMap.addLayer(states.style(**style), {}, 'US States')\n\n# Add NLCD legend\nMap.add_legend(title='NLCD Land Cover', builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  # Add NLCD data dataset = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019') landcover = dataset.select('landcover') Map.addLayer(landcover, {}, 'NLCD 2019')  # Add US census states states = ee.FeatureCollection(\"TIGER/2018/States\") style = {'fillColor': '00000000'} Map.addLayer(states.style(**style), {}, 'US States')  # Add NLCD legend Map.add_legend(title='NLCD Land Cover', builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>nlcd_stats = 'nlcd_stats.csv'\n\ngeemap.zonal_stats_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    statistics_type='SUM',\n    denominator=1e6,\n    decimal_places=2,\n)\n</pre> nlcd_stats = 'nlcd_stats.csv'  geemap.zonal_stats_by_group(     landcover,     states,     nlcd_stats,     statistics_type='SUM',     denominator=1e6,     decimal_places=2, ) In\u00a0[\u00a0]: Copied! <pre>nlcd_stats = 'nlcd_stats_pct.csv'\n\ngeemap.zonal_stats_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    statistics_type='PERCENTAGE',\n    denominator=1e6,\n    decimal_places=2,\n)\n</pre> nlcd_stats = 'nlcd_stats_pct.csv'  geemap.zonal_stats_by_group(     landcover,     states,     nlcd_stats,     statistics_type='PERCENTAGE',     denominator=1e6,     decimal_places=2, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\ndem = ee.Image('USGS/3DEP/10m')\nvis = {'min': 0, 'max': 4000, 'palette': 'terrain'}\nMap.addLayer(dem, vis, 'DEM')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) dem = ee.Image('USGS/3DEP/10m') vis = {'min': 0, 'max': 4000, 'palette': 'terrain'} Map.addLayer(dem, vis, 'DEM') Map In\u00a0[\u00a0]: Copied! <pre>landcover = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover')\nMap.addLayer(landcover, {}, 'NLCD 2019')\nMap.add_legend(title='NLCD Land Cover Classification', builtin_legend='NLCD')\n</pre> landcover = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover') Map.addLayer(landcover, {}, 'NLCD 2019') Map.add_legend(title='NLCD Land Cover Classification', builtin_legend='NLCD') In\u00a0[\u00a0]: Copied! <pre>stats = geemap.image_stats_by_zone(dem, landcover, reducer='MEAN')\nstats\n</pre> stats = geemap.image_stats_by_zone(dem, landcover, reducer='MEAN') stats In\u00a0[\u00a0]: Copied! <pre>stats.to_csv('mean.csv', index=False)\n</pre> stats.to_csv('mean.csv', index=False) In\u00a0[\u00a0]: Copied! <pre>geemap.image_stats_by_zone(dem, landcover, out_csv=\"std.csv\", reducer='STD')\n</pre> geemap.image_stats_by_zone(dem, landcover, out_csv=\"std.csv\", reducer='STD') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(\n    ['B5', 'B4', 'B3']\n)\n\nvis_params = {'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n\nMap.centerObject(image)\nMap.addLayer(image, vis_params, 'Landsat')\nMap\n</pre> Map = geemap.Map()  image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(     ['B5', 'B4', 'B3'] )  vis_params = {'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}  Map.centerObject(image) Map.addLayer(image, vis_params, 'Landsat') Map In\u00a0[\u00a0]: Copied! <pre>region = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252)\nfc = ee.FeatureCollection(region)\nstyle = {'color': 'ffff00ff', 'fillColor': '00000000'}\nMap.addLayer(fc.style(**style), {}, 'ROI')\nMap\n</pre> region = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252) fc = ee.FeatureCollection(region) style = {'color': 'ffff00ff', 'fillColor': '00000000'} Map.addLayer(fc.style(**style), {}, 'ROI') Map In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(image, filename=\"landsat.tif\", scale=30, region=region)\n</pre> geemap.ee_export_image(image, filename=\"landsat.tif\", scale=30, region=region) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_to_drive(\n    image, description='landsat', folder='export', region=region, scale=30\n)\n</pre> geemap.ee_export_image_to_drive(     image, description='landsat', folder='export', region=region, scale=30 ) In\u00a0[\u00a0]: Copied! <pre>assetId = 'landsat_sfo'\ngeemap.ee_export_image_to_asset(\n    image, description='landsat', assetId=assetId, region=region, scale=30\n)\n</pre> assetId = 'landsat_sfo' geemap.ee_export_image_to_asset(     image, description='landsat', assetId=assetId, region=region, scale=30 ) In\u00a0[\u00a0]: Copied! <pre>point = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(point)\n    .filterDate('2008-01-01', '2018-01-01')\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n</pre> point = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(point)     .filterDate('2008-01-01', '2018-01-01')     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) In\u00a0[\u00a0]: Copied! <pre>collection.aggregate_array('system:index')\n</pre> collection.aggregate_array('system:index') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection(collection, out_dir='.', scale=10)\n</pre> geemap.ee_export_image_collection(collection, out_dir='.', scale=10) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10)\n</pre> geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.eq('NAME', 'Louisiana'))\nMap.addLayer(fc, {}, 'Louisiana')\nMap.centerObject(fc)\nMap\n</pre> Map = geemap.Map() states = ee.FeatureCollection('TIGER/2018/States') fc = states.filter(ee.Filter.eq('NAME', 'Louisiana')) Map.addLayer(fc, {}, 'Louisiana') Map.centerObject(fc) Map In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_shp(fc, filename='louisiana.shp', selectors=None)\n</pre> geemap.ee_to_shp(fc, filename='louisiana.shp', selectors=None) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_geojson(fc, filename='louisiana.geojson')\n</pre> geemap.ee_to_geojson(fc, filename='louisiana.geojson') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_csv(fc, filename='louisiana.csv')\n</pre> geemap.ee_to_csv(fc, filename='louisiana.csv') In\u00a0[\u00a0]: Copied! <pre>df = geemap.ee_to_df(fc)\ndf\n</pre> df = geemap.ee_to_df(fc) df In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_vector_to_drive(\n    fc, description=\"louisiana\", fileFormat='SHP', folder=\"export\"\n)\n</pre> geemap.ee_export_vector_to_drive(     fc, description=\"louisiana\", fileFormat='SHP', folder=\"export\" ) In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\").filterMetadata(\n    'CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10\n)\n</pre> collection = ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\").filterMetadata(     'CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10 ) In\u00a0[\u00a0]: Copied! <pre>start_date = '2016-01-01'\nend_date = '2022-12-31'\nregion = ee.Geometry.BBox(-122.5549, 37.6968, -122.3446, 37.8111)\n</pre> start_date = '2016-01-01' end_date = '2022-12-31' region = ee.Geometry.BBox(-122.5549, 37.6968, -122.3446, 37.8111) In\u00a0[\u00a0]: Copied! <pre>images = geemap.create_timeseries(\n    collection, start_date, end_date, region, frequency='year', reducer='median'\n)\nimages\n</pre> images = geemap.create_timeseries(     collection, start_date, end_date, region, frequency='year', reducer='median' ) images In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\nlabels = [str(y) for y in range(2016, 2023)]\n\nMap.addLayer(images, vis_params, \"Sentinel-2\", False)\nMap.add_time_slider(images, vis_params, time_interval=2, labels=labels)\nMap.centerObject(region)\nMap\n</pre> Map = geemap.Map()  vis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]} labels = [str(y) for y in range(2016, 2023)]  Map.addLayer(images, vis_params, \"Sentinel-2\", False) Map.add_time_slider(images, vis_params, time_interval=2, labels=labels) Map.centerObject(region) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif='landsat.gif',\n    start_year=1984,\n    end_year=2022,\n    start_date='01-01',\n    end_date='12-31',\n    bands=['SWIR1', 'NIR', 'Red'],\n    frames_per_second=5,\n    title='Landsat Timelapse',\n    progress_bar_color='blue',\n    mp4=True,\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif='landsat.gif',     start_year=1984,     end_year=2022,     start_date='01-01',     end_date='12-31',     bands=['SWIR1', 'NIR', 'Red'],     frames_per_second=5,     title='Landsat Timelapse',     progress_bar_color='blue',     mp4=True, ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nroi = ee.Geometry.BBox(-115.5541, 35.8044, -113.9035, 36.5581)\nMap.addLayer(roi)\nMap.centerObject(roi)\nMap\n</pre> Map = geemap.Map() roi = ee.Geometry.BBox(-115.5541, 35.8044, -113.9035, 36.5581) Map.addLayer(roi) Map.centerObject(roi) Map In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif='las_vegas.gif',\n    start_year=1984,\n    end_year=2022,\n    bands=['NIR', 'Red', 'Green'],\n    frames_per_second=5,\n    title='Las Vegas, NV',\n    font_color='blue',\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif='las_vegas.gif',     start_year=1984,     end_year=2022,     bands=['NIR', 'Red', 'Green'],     frames_per_second=5,     title='Las Vegas, NV',     font_color='blue', ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nroi = ee.Geometry.BBox(113.8252, 22.1988, 114.0851, 22.3497)\nMap.addLayer(roi)\nMap.centerObject(roi)\nMap\n</pre> Map = geemap.Map() roi = ee.Geometry.BBox(113.8252, 22.1988, 114.0851, 22.3497) Map.addLayer(roi) Map.centerObject(roi) Map In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif='hong_kong.gif',\n    start_year=1990,\n    end_year=2022,\n    start_date='01-01',\n    end_date='12-31',\n    bands=['SWIR1', 'NIR', 'Red'],\n    frames_per_second=3,\n    title='Hong Kong',\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif='hong_kong.gif',     start_year=1990,     end_year=2022,     start_date='01-01',     end_date='12-31',     bands=['SWIR1', 'NIR', 'Red'],     frames_per_second=3,     title='Hong Kong', ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-18.6983, -36.1630, 52.2293, 38.1446)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(-18.6983, -36.1630, 52.2293, 38.1446)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.modis_ndvi_timelapse(\n    roi,\n    out_gif='ndvi.gif',\n    data='Terra',\n    band='NDVI',\n    start_date='2000-01-01',\n    end_date='2022-12-31',\n    frames_per_second=3,\n    title='MODIS NDVI Timelapse',\n    overlay_data='countries',\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.modis_ndvi_timelapse(     roi,     out_gif='ndvi.gif',     data='Terra',     band='NDVI',     start_date='2000-01-01',     end_date='2022-12-31',     frames_per_second=3,     title='MODIS NDVI Timelapse',     overlay_data='countries', ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>dataset = ee.Image('JRC/GSW1_4/GlobalSurfaceWater')\ndataset.bandNames()\n</pre> dataset = ee.Image('JRC/GSW1_4/GlobalSurfaceWater') dataset.bandNames() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map In\u00a0[\u00a0]: Copied! <pre>image = dataset.select(['occurrence'])\nregion = Map.user_roi  # Draw a polygon on the map\nif region is None:\n    region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531)\nvis_params = {'min': 0.0, 'max': 100.0, 'palette': ['ffffff', 'ffbbbb', '0000ff']}\nMap.addLayer(image, vis_params, 'Occurrence')\nMap.addLayer(region, {}, 'ROI', True, 0.5)\nMap.centerObject(region)\nMap.add_colorbar(vis_params, label='Water occurrence (%)', layer_name='Occurrence')\n</pre> image = dataset.select(['occurrence']) region = Map.user_roi  # Draw a polygon on the map if region is None:     region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531) vis_params = {'min': 0.0, 'max': 100.0, 'palette': ['ffffff', 'ffbbbb', '0000ff']} Map.addLayer(image, vis_params, 'Occurrence') Map.addLayer(region, {}, 'ROI', True, 0.5) Map.centerObject(region) Map.add_colorbar(vis_params, label='Water occurrence (%)', layer_name='Occurrence') In\u00a0[\u00a0]: Copied! <pre>df = geemap.image_histogram(\n    image,\n    region,\n    scale=30,\n    return_df=True,\n)\ndf\n</pre> df = geemap.image_histogram(     image,     region,     scale=30,     return_df=True, ) df In\u00a0[\u00a0]: Copied! <pre>hist = geemap.image_histogram(\n    image,\n    region,\n    scale=30,\n    x_label='Water Occurrence (%)',\n    y_label='Pixel Count',\n    title='Surface Water Occurrence',\n    layout_args={'title': dict(x=0.5)},\n    return_df=False,\n)\nhist\n</pre> hist = geemap.image_histogram(     image,     region,     scale=30,     x_label='Water Occurrence (%)',     y_label='Pixel Count',     title='Surface Water Occurrence',     layout_args={'title': dict(x=0.5)},     return_df=False, ) hist In\u00a0[\u00a0]: Copied! <pre>hist.update_layout(\n    autosize=False, width=800, height=400, margin=dict(l=30, r=20, b=10, t=50, pad=4)\n)\n</pre> hist.update_layout(     autosize=False, width=800, height=400, margin=dict(l=30, r=20, b=10, t=50, pad=4) ) In\u00a0[\u00a0]: Copied! <pre>dataset = ee.ImageCollection('JRC/GSW1_4/MonthlyHistory')\ndataset.size()\n</pre> dataset = ee.ImageCollection('JRC/GSW1_4/MonthlyHistory') dataset.size() In\u00a0[\u00a0]: Copied! <pre>dataset.aggregate_array(\"system:index\")\n</pre> dataset.aggregate_array(\"system:index\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>image = dataset.filterDate('2020-08-01', '2020-09-01').first()\nregion = Map.user_roi  # Draw a polygon on the map\nif region is None:\n    region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531)\nvis_params = {'min': 0.0, 'max': 2.0, 'palette': ['ffffff', 'fffcb8', '0905ff']}\n\nMap.addLayer(image, vis_params, 'Water')\nMap.addLayer(region, {}, 'ROI', True, 0.5)\nMap.centerObject(region)\n</pre> image = dataset.filterDate('2020-08-01', '2020-09-01').first() region = Map.user_roi  # Draw a polygon on the map if region is None:     region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531) vis_params = {'min': 0.0, 'max': 2.0, 'palette': ['ffffff', 'fffcb8', '0905ff']}  Map.addLayer(image, vis_params, 'Water') Map.addLayer(region, {}, 'ROI', True, 0.5) Map.centerObject(region) In\u00a0[\u00a0]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region, scale=30, frequency='month', denominator=1e4, y_label='Area (ha)'\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region, scale=30, frequency='month', denominator=1e4, y_label='Area (ha)' ) In\u00a0[\u00a0]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency='month',\n    denominator=1e4,\n    y_label='Area (ha)',\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency='month',     denominator=1e4,     y_label='Area (ha)', ) In\u00a0[\u00a0]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency='year',\n    reducer='mean',\n    denominator=1e4,\n    y_label='Area (ha)',\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency='year',     reducer='mean',     denominator=1e4,     y_label='Area (ha)', ) In\u00a0[\u00a0]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency='year',\n    reducer='max',\n    denominator=1e4,\n    y_label='Area (ha)',\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency='year',     reducer='max',     denominator=1e4,     y_label='Area (ha)', )"},{"location":"workshops/AmericaView_2023/#why-earth-engine-python-api-and-geemap","title":"Why Earth Engine Python API and geemap?\u00b6","text":"<p>Check out the slides here.</p>"},{"location":"workshops/AmericaView_2023/#install-packages","title":"Install packages\u00b6","text":""},{"location":"workshops/AmericaView_2023/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"workshops/AmericaView_2023/#authenticate-earth-engine","title":"Authenticate Earth Engine\u00b6","text":"<p>You will need to create a Google Cloud Project and enable the Earth Engine API for the project. You can find detailed instructions here.</p>"},{"location":"workshops/AmericaView_2023/#create-interactive-maps","title":"Create interactive maps\u00b6","text":"<p>Let's create an interactive map using the <code>ipyleaflet</code> plotting backend. The <code>geemap.Map</code> class inherits from the <code>ipyleaflet.Map</code> class. Therefore, you can use the same syntax to create an interactive map as you would with <code>ipyleaflet.Map</code>.</p>"},{"location":"workshops/AmericaView_2023/#adding-basemaps","title":"Adding basemaps\u00b6","text":"<p>There are several ways to add basemaps to a map. You can specify the basemap to use in the <code>basemap</code> keyword argument when creating the map. Alternatively, you can add basemap layers to the map using the <code>add_basemap</code> method. Geemap has hundreds of built-in basemaps available that can be easily added to the map with only one line of code.</p>"},{"location":"workshops/AmericaView_2023/#built-in-basemaps","title":"Built-in basemaps\u00b6","text":"<p>Create a map by specifying the basemap to use as follows. For example, the <code>HYBRID</code> basemap represents the Google Satellite Hybrid basemap.</p>"},{"location":"workshops/AmericaView_2023/#xyz-tiles","title":"XYZ tiles\u00b6","text":"<p>You can also add XYZ tile layers to the map using the <code>Map.add_tile_layer()</code> method. For example, the following code creates an interactive map and adds the Google Terrain basemap to it:</p>"},{"location":"workshops/AmericaView_2023/#wms-tiles","title":"WMS tiles\u00b6","text":"<p>Similarly, you can add WMS tile layers to the map using the <code>Map.add_wms_layer()</code> method. For example, the following code creates an interactive map and adds the National Land Cover Database (NLCD) 2019 basemap to it:</p>"},{"location":"workshops/AmericaView_2023/#earth-engine-data-types","title":"Earth Engine data types\u00b6","text":"<p>Earth Engine objects are server-side objects rather than client-side objects, which means that they are not stored locally on your computer. Similar to video streaming services (e.g., YouTube, Netflix, and Hulu), which store videos/movies on their servers, Earth Engine data are stored on the Earth Engine servers. We can stream geospatial data from Earth Engine on-the-fly without having to download the data just like we can watch videos from streaming services using a web browser without having to download the entire video to your computer.</p> <ul> <li>Image: the fundamental raster data type in Earth Engine.</li> <li>ImageCollection: a stack or time-series of images.</li> <li>Geometry: the fundamental vector data type in Earth Engine.</li> <li>Feature: a Geometry with attributes.</li> <li>FeatureCollection: a set of features.</li> </ul>"},{"location":"workshops/AmericaView_2023/#image","title":"Image\u00b6","text":"<p>Raster data in Earth Engine are represented as Image objects. Images are composed of one or more bands and each band has its own name, data type, scale, mask and projection. Each image has metadata stored as a set of properties.</p>"},{"location":"workshops/AmericaView_2023/#loading-earth-engine-images","title":"Loading Earth Engine images\u00b6","text":""},{"location":"workshops/AmericaView_2023/#visualizing-earth-engine-images","title":"Visualizing Earth Engine images\u00b6","text":""},{"location":"workshops/AmericaView_2023/#imagecollection","title":"ImageCollection\u00b6","text":"<p>An <code>ImageCollection</code> is a stack or sequence of images. An <code>ImageCollection</code> can be loaded by passing an Earth Engine asset ID into the <code>ImageCollection</code> constructor. You can find <code>ImageCollection</code> IDs in the Earth Engine Data Catalog.</p>"},{"location":"workshops/AmericaView_2023/#loading-image-collections","title":"Loading image collections\u00b6","text":"<p>For example, to load the image collection of the Sentinel-2 surface reflectance:</p>"},{"location":"workshops/AmericaView_2023/#visualizing-image-collections","title":"Visualizing image collections\u00b6","text":"<p>To visualize an Earth Engine ImageCollection, we need to convert an ImageCollection to an Image by compositing all the images in the collection to a single image representing, for example, the min, max, median, mean or standard deviation of the images. For example, to create a median value image from a collection, use the <code>collection.median()</code> method. Let's create a median image from the Sentinel-2 surface reflectance collection:</p>"},{"location":"workshops/AmericaView_2023/#filtering-image-collections","title":"Filtering image collections\u00b6","text":""},{"location":"workshops/AmericaView_2023/#featurecollection","title":"FeatureCollection\u00b6","text":"<p>A FeatureCollection is a collection of Features. A FeatureCollection is analogous to a GeoJSON FeatureCollection object, i.e., a collection of features with associated properties/attributes. Data contained in a shapefile can be represented as a FeatureCollection.</p>"},{"location":"workshops/AmericaView_2023/#loading-feature-collections","title":"Loading feature collections\u00b6","text":"<p>The Earth Engine Data Catalog hosts a variety of vector datasets (e.g,, US Census data, country boundaries, and more) as feature collections. You can find feature collection IDs by searching the data catalog. For example, to load the TIGER roads data by the U.S. Census Bureau:</p>"},{"location":"workshops/AmericaView_2023/#filtering-feature-collections","title":"Filtering feature collections\u00b6","text":""},{"location":"workshops/AmericaView_2023/#visualizing-feature-collections","title":"Visualizing feature collections\u00b6","text":""},{"location":"workshops/AmericaView_2023/#earth-engine-data-catalog","title":"Earth Engine Data Catalog\u00b6","text":"<p>The Earth Engine Data Catalog hosts a variety of geospatial datasets. As of March 2023, the catalog contains over 1,000 datasets with a total size of over 40 petabytes. Some notable datasets include: Landsat, Sentinel, MODIS, NAIP, etc. For a complete list of datasets in CSV or JSON formats, see the Earth Engine Datasets List.</p>"},{"location":"workshops/AmericaView_2023/#searching-for-datasets","title":"Searching for datasets\u00b6","text":"<p>The Earth Engine Data Catalog is searchable. You can search datasets by name, keyword, or tag. For example, enter \"elevation\" in the search box will filter the catalog to show only datasets containing \"elevation\" in their name, description, or tags. 52 datasets are returned for this search query. Scroll down the list to find the NASA SRTM Digital Elevation 30m dataset. On each dataset page, you can find the following information, including Dataset Availability, Dataset Provider, Earth Engine Snippet, Tags, Description, Code Example, and more (see {numref}<code>ch03_gee_srtm</code>). One important piece of information is the Image/ImageCollection/FeatureCollection ID of each dataset, which is essential for accessing the dataset through the Earth Engine JavaScript or Python APIs.</p> <p></p>"},{"location":"workshops/AmericaView_2023/#using-the-datasets-module","title":"Using the datasets module\u00b6","text":""},{"location":"workshops/AmericaView_2023/#using-the-inspector-tool","title":"Using the inspector tool\u00b6","text":""},{"location":"workshops/AmericaView_2023/#converting-javascript-to-python","title":"Converting JavaScript to Python\u00b6","text":"<p>Find some Earth Engine JavaScript code that you want to convert to Python. For example, you can grab some sample code from the Earth Engine Documentation.</p>"},{"location":"workshops/AmericaView_2023/#using-the-plotting-tool","title":"Using the plotting tool\u00b6","text":""},{"location":"workshops/AmericaView_2023/#creating-legends","title":"Creating legends\u00b6","text":""},{"location":"workshops/AmericaView_2023/#built-in-legends","title":"Built-in legends\u00b6","text":""},{"location":"workshops/AmericaView_2023/#custom-legends","title":"Custom legends\u00b6","text":""},{"location":"workshops/AmericaView_2023/#creating-color-bars","title":"Creating color bars\u00b6","text":""},{"location":"workshops/AmericaView_2023/#split-panel-maps","title":"Split-panel maps\u00b6","text":""},{"location":"workshops/AmericaView_2023/#linked-maps","title":"Linked maps\u00b6","text":""},{"location":"workshops/AmericaView_2023/#timeseries-inspector","title":"Timeseries inspector\u00b6","text":""},{"location":"workshops/AmericaView_2023/#time-slider","title":"Time slider\u00b6","text":""},{"location":"workshops/AmericaView_2023/#visualizing-vegetation-data","title":"Visualizing vegetation data\u00b6","text":""},{"location":"workshops/AmericaView_2023/#visualizing-weather-data","title":"Visualizing weather data\u00b6","text":""},{"location":"workshops/AmericaView_2023/#visualizing-sentinel-2-imagery","title":"Visualizing Sentinel-2 imagery\u00b6","text":""},{"location":"workshops/AmericaView_2023/#zonal-statistics-with-earth-engine","title":"Zonal statistics with Earth Engine\u00b6","text":""},{"location":"workshops/AmericaView_2023/#zonal-statistics","title":"Zonal statistics\u00b6","text":""},{"location":"workshops/AmericaView_2023/#zonal-statistics-by-group","title":"Zonal statistics by group\u00b6","text":""},{"location":"workshops/AmericaView_2023/#zonal-statistics-with-two-images","title":"Zonal statistics with two images\u00b6","text":""},{"location":"workshops/AmericaView_2023/#exporting-images","title":"Exporting images\u00b6","text":""},{"location":"workshops/AmericaView_2023/#to-local-drive","title":"To local drive\u00b6","text":""},{"location":"workshops/AmericaView_2023/#to-google-drive","title":"To Google Drive\u00b6","text":""},{"location":"workshops/AmericaView_2023/#to-asset","title":"To Asset\u00b6","text":""},{"location":"workshops/AmericaView_2023/#exporting-image-collections","title":"Exporting image collections\u00b6","text":""},{"location":"workshops/AmericaView_2023/#to-local-drive","title":"To local drive\u00b6","text":""},{"location":"workshops/AmericaView_2023/#to-google-drive","title":"To Google Drive\u00b6","text":""},{"location":"workshops/AmericaView_2023/#exporting-feature-collections","title":"Exporting feature collections\u00b6","text":""},{"location":"workshops/AmericaView_2023/#to-local-drive","title":"To local drive\u00b6","text":""},{"location":"workshops/AmericaView_2023/#to-google-drive","title":"To Google Drive\u00b6","text":""},{"location":"workshops/AmericaView_2023/#creating-timeseries","title":"Creating timeseries\u00b6","text":""},{"location":"workshops/AmericaView_2023/#creating-timelapse","title":"Creating timelapse\u00b6","text":""},{"location":"workshops/AmericaView_2023/#landsat-timelapse","title":"Landsat timelapse\u00b6","text":""},{"location":"workshops/AmericaView_2023/#modis-timelapse","title":"MODIS timelapse\u00b6","text":""},{"location":"workshops/AmericaView_2023/#analyzing-surface-water-dynamics","title":"Analyzing surface water dynamics\u00b6","text":""},{"location":"workshops/AmericaView_2023/#surface-water-occurrence","title":"Surface water occurrence\u00b6","text":""},{"location":"workshops/AmericaView_2023/#surface-water-monthly-history","title":"Surface water monthly history\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/","title":"Crop Mapping 2022","text":"<p>Cropland mapping with Google Earth Engine and geemap</p> <p>Useful links</p> <ul> <li>Google Earth Engine</li> <li>Sign up for an Earth Engine account</li> <li>Awesome GEE Community Datasets</li> <li>Geemap website</li> <li>Geemap book</li> <li>Geemap YouTube videos</li> </ul> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nesa_wms = 'https://services.terrascope.be/wms/v2'  # The WMS URL\ntcc_layer = 'WORLDCOVER_2020_S2_TCC'  # The true color composite imagery\nfcc_layer = 'WORLDCOVER_2020_S2_FCC'  # The false color composite imagery\nmap_layer = 'WORLDCOVER_2020_MAP'  # The land cover classification map\n\nMap.add_wms_layer(esa_wms, layers=tcc_layer, name='True Color', attribution='ESA')\nMap.add_wms_layer(esa_wms, layers=fcc_layer, name='False Color', attribution='ESA')\nMap.add_wms_layer(esa_wms, layers=map_layer, name='Classification', attribution='ESA')\n\nMap.add_legend(title='ESA Land Cover', builtin_legend='ESA_WorldCover')\nMap\n</pre> Map = geemap.Map()  esa_wms = 'https://services.terrascope.be/wms/v2'  # The WMS URL tcc_layer = 'WORLDCOVER_2020_S2_TCC'  # The true color composite imagery fcc_layer = 'WORLDCOVER_2020_S2_FCC'  # The false color composite imagery map_layer = 'WORLDCOVER_2020_MAP'  # The land cover classification map  Map.add_wms_layer(esa_wms, layers=tcc_layer, name='True Color', attribution='ESA') Map.add_wms_layer(esa_wms, layers=fcc_layer, name='False Color', attribution='ESA') Map.add_wms_layer(esa_wms, layers=map_layer, name='Classification', attribution='ESA')  Map.add_legend(title='ESA Land Cover', builtin_legend='ESA_WorldCover') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\n\nesa = ee.ImageCollection(\"ESA/WorldCover/v100\").first()\nesa_vis = {'bands': ['Map']}\n\nMap.addLayer(esa, esa_vis, \"ESA Land Cover\")\nMap.add_legend(title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover')\n\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID')  esa = ee.ImageCollection(\"ESA/WorldCover/v100\").first() esa_vis = {'bands': ['Map']}  Map.addLayer(esa, esa_vis, \"ESA Land Cover\") Map.add_legend(title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover')  Map In\u00a0[\u00a0]: Copied! <pre>histogram = geemap.image_histogram(\n    esa, scale=1000, x_label='Land Cover Type', y_label='Area (km2)'\n)\nhistogram\n</pre> histogram = geemap.image_histogram(     esa, scale=1000, x_label='Land Cover Type', y_label='Area (km2)' ) histogram In\u00a0[\u00a0]: Copied! <pre>df = geemap.image_histogram(esa, scale=1000, return_df=True)\ndf\n</pre> df = geemap.image_histogram(esa, scale=1000, return_df=True) df In\u00a0[\u00a0]: Copied! <pre>esa_labels = list(geemap.builtin_legends['ESA_WorldCover'].keys())\nesa_labels\n</pre> esa_labels = list(geemap.builtin_legends['ESA_WorldCover'].keys()) esa_labels In\u00a0[\u00a0]: Copied! <pre>df['label'] = esa_labels\ndf\n</pre> df['label'] = esa_labels df In\u00a0[\u00a0]: Copied! <pre>round(df['value'].sum() / 1e6, 2)\n</pre> round(df['value'].sum() / 1e6, 2) In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    df, x='label', y='value', x_label='Land Cover Type', y_label='Area (km2)'\n)\n</pre> geemap.bar_chart(     df, x='label', y='value', x_label='Land Cover Type', y_label='Area (km2)' ) In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(df, names='label', values='value', height=500)\n</pre> geemap.pie_chart(df, names='label', values='value', height=500) In\u00a0[\u00a0]: Copied! <pre>countries = ee.FeatureCollection(geemap.examples.get_ee_path('countries'))\nafrica = countries.filter(ee.Filter.eq('CONTINENT', 'Africa'))\nstyle = {'fillColor': '00000000'}\nMap.addLayer(countries.style(**style), {}, 'Countries', False)\nMap.addLayer(africa.style(**style), {}, 'Africa')\nMap.centerObject(africa)\nMap\n</pre> countries = ee.FeatureCollection(geemap.examples.get_ee_path('countries')) africa = countries.filter(ee.Filter.eq('CONTINENT', 'Africa')) style = {'fillColor': '00000000'} Map.addLayer(countries.style(**style), {}, 'Countries', False) Map.addLayer(africa.style(**style), {}, 'Africa') Map.centerObject(africa) Map In\u00a0[\u00a0]: Copied! <pre>cropland = esa.eq(40).clipToCollection(africa).selfMask()\nMap.addLayer(cropland, {'palette': ['f096ff']}, 'Cropland')\nMap.show_layer(name='ESA Land Cover', show=False)\n</pre> cropland = esa.eq(40).clipToCollection(africa).selfMask() Map.addLayer(cropland, {'palette': ['f096ff']}, 'Cropland') Map.show_layer(name='ESA Land Cover', show=False) In\u00a0[\u00a0]: Copied! <pre>geemap.zonal_stats(\n    cropland, africa, 'esa_cropland.csv', statistics_type='SUM', scale=1000\n)\n</pre> geemap.zonal_stats(     cropland, africa, 'esa_cropland.csv', statistics_type='SUM', scale=1000 ) In\u00a0[\u00a0]: Copied! <pre>df = geemap.csv_to_df('esa_cropland.csv')\ndf.head()\n</pre> df = geemap.csv_to_df('esa_cropland.csv') df.head() In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    df, x='NAME', y='sum', max_rows=30, x_label='Country', y_label='Area (km2)'\n)\n</pre> geemap.bar_chart(     df, x='NAME', y='sum', max_rows=30, x_label='Country', y_label='Area (km2)' ) In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(df, names='NAME', values='sum', max_rows=20, height=500)\n</pre> geemap.pie_chart(df, names='NAME', values='sum', max_rows=20, height=500) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\n\nesri = ee.ImageCollection(\n    'projects/sat-io/open-datasets/landcover/ESRI_Global-LULC_10m_TS'\n)\n\nesri_2017 = esri.filterDate('2017-01-01', '2017-12-31').mosaic()\nesri_2018 = esri.filterDate('2018-01-01', '2018-12-31').mosaic()\nesri_2019 = esri.filterDate('2019-01-01', '2019-12-31').mosaic()\nesri_2020 = esri.filterDate('2020-01-01', '2020-12-31').mosaic()\nesri_2021 = esri.filterDate('2021-01-01', '2021-12-31').mosaic()\n\nesri_vis = {'min': 1, 'max': 11, 'palette': 'esri_lulc'}\n\nMap.addLayer(esri_2017, esri_vis, 'ESRI LULC 2017')\nMap.addLayer(esri_2018, esri_vis, 'ESRI LULC 2018')\nMap.addLayer(esri_2019, esri_vis, 'ESRI LULC 2019')\nMap.addLayer(esri_2020, esri_vis, 'ESRI LULC 2020')\nMap.addLayer(esri_2021, esri_vis, 'ESRI LULC 2021')\n\nMap.add_legend(title='ESRI Land Cover', builtin_legend='ESRI_LandCover_TS')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID')  esri = ee.ImageCollection(     'projects/sat-io/open-datasets/landcover/ESRI_Global-LULC_10m_TS' )  esri_2017 = esri.filterDate('2017-01-01', '2017-12-31').mosaic() esri_2018 = esri.filterDate('2018-01-01', '2018-12-31').mosaic() esri_2019 = esri.filterDate('2019-01-01', '2019-12-31').mosaic() esri_2020 = esri.filterDate('2020-01-01', '2020-12-31').mosaic() esri_2021 = esri.filterDate('2021-01-01', '2021-12-31').mosaic()  esri_vis = {'min': 1, 'max': 11, 'palette': 'esri_lulc'}  Map.addLayer(esri_2017, esri_vis, 'ESRI LULC 2017') Map.addLayer(esri_2018, esri_vis, 'ESRI LULC 2018') Map.addLayer(esri_2019, esri_vis, 'ESRI LULC 2019') Map.addLayer(esri_2020, esri_vis, 'ESRI LULC 2020') Map.addLayer(esri_2021, esri_vis, 'ESRI LULC 2021')  Map.add_legend(title='ESRI Land Cover', builtin_legend='ESRI_LandCover_TS') Map In\u00a0[\u00a0]: Copied! <pre>images = ee.List([esri_2017, esri_2018, esri_2019, esri_2020, esri_2021])\ncollection = ee.ImageCollection.fromImages(images)\n</pre> images = ee.List([esri_2017, esri_2018, esri_2019, esri_2020, esri_2021]) collection = ee.ImageCollection.fromImages(images) In\u00a0[\u00a0]: Copied! <pre>years = [str(year) for year in range(2017, 2022)]\nyears\n</pre> years = [str(year) for year in range(2017, 2022)] years In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.ts_inspector(collection, years, esri_vis, width='80px')\nMap.add_legend(title='ESRI Land Cover', builtin_legend='ESRI_LandCover_TS')\nMap\n</pre> Map = geemap.Map() Map.ts_inspector(collection, years, esri_vis, width='80px') Map.add_legend(title='ESRI Land Cover', builtin_legend='ESRI_LandCover_TS') Map In\u00a0[\u00a0]: Copied! <pre>countries = ee.FeatureCollection(geemap.examples.get_ee_path('countries'))\nafrica = countries.filter(ee.Filter.eq('CONTINENT', 'Africa'))\n</pre> countries = ee.FeatureCollection(geemap.examples.get_ee_path('countries')) africa = countries.filter(ee.Filter.eq('CONTINENT', 'Africa')) In\u00a0[\u00a0]: Copied! <pre>cropland_col = collection.map(lambda img: img.eq(5).clipToCollection(africa).selfMask())\ncropland_ts = cropland_col.toBands().rename(years)\n</pre> cropland_col = collection.map(lambda img: img.eq(5).clipToCollection(africa).selfMask()) cropland_ts = cropland_col.toBands().rename(years) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstyle = {'fillColor': '00000000'}\nMap.addLayer(cropland_col.first(), {'palette': ['#ab6c28']}, 'first')\nMap.addLayer(countries.style(**style), {}, 'Countries', False)\nMap.addLayer(africa.style(**style), {}, 'Africa')\nMap.centerObject(africa)\n\nMap\n</pre> Map = geemap.Map()  style = {'fillColor': '00000000'} Map.addLayer(cropland_col.first(), {'palette': ['#ab6c28']}, 'first') Map.addLayer(countries.style(**style), {}, 'Countries', False) Map.addLayer(africa.style(**style), {}, 'Africa') Map.centerObject(africa)  Map In\u00a0[\u00a0]: Copied! <pre>cropland_ts.bandNames().getInfo()\n</pre> cropland_ts.bandNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>geemap.zonal_stats(\n    cropland_ts, africa, 'esri_cropland.csv', statistics_type='SUM', scale=1000\n)\n</pre> geemap.zonal_stats(     cropland_ts, africa, 'esri_cropland.csv', statistics_type='SUM', scale=1000 ) In\u00a0[\u00a0]: Copied! <pre>df = geemap.csv_to_df('esri_cropland.csv')\ndf.head()\n</pre> df = geemap.csv_to_df('esri_cropland.csv') df.head() In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(df, x='NAME', y=years, max_rows=20, legend_title='Year')\n</pre> geemap.bar_chart(df, x='NAME', y=years, max_rows=20, legend_title='Year') In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(df, names='NAME', values='2020', max_rows=20, height=500)\n</pre> geemap.pie_chart(df, names='NAME', values='2020', max_rows=20, height=500) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\n\ncropland_2017 = esri_2017.eq(5).selfMask()\ncropland_2021 = esri_2021.eq(5).selfMask()\n\ncropland_gain = esri_2017.neq(5).And(esri_2021.eq(5)).selfMask()\ncropland_loss = esri_2017.eq(5).And(esri_2021.neq(5)).selfMask()\n\nMap.addLayer(cropland_2017, {'palette': 'brown'}, 'Cropland 2017', False)\nMap.addLayer(cropland_2021, {'palette': 'cyan'}, 'Cropland 2021', False)\n\nMap.addLayer(cropland_gain, {'palette': 'yellow'}, 'Cropland gain')\nMap.addLayer(cropland_loss, {'palette': 'red'}, 'Cropland loss')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID')  cropland_2017 = esri_2017.eq(5).selfMask() cropland_2021 = esri_2021.eq(5).selfMask()  cropland_gain = esri_2017.neq(5).And(esri_2021.eq(5)).selfMask() cropland_loss = esri_2017.eq(5).And(esri_2021.neq(5)).selfMask()  Map.addLayer(cropland_2017, {'palette': 'brown'}, 'Cropland 2017', False) Map.addLayer(cropland_2021, {'palette': 'cyan'}, 'Cropland 2021', False)  Map.addLayer(cropland_gain, {'palette': 'yellow'}, 'Cropland gain') Map.addLayer(cropland_loss, {'palette': 'red'}, 'Cropland loss') Map In\u00a0[\u00a0]: Copied! <pre>geemap.zonal_stats(\n    cropland_gain,\n    countries,\n    'esri_cropland_gain.csv',\n    statistics_type='SUM',\n    scale=1000,\n)\n</pre> geemap.zonal_stats(     cropland_gain,     countries,     'esri_cropland_gain.csv',     statistics_type='SUM',     scale=1000, ) In\u00a0[\u00a0]: Copied! <pre>df = geemap.csv_to_df('esri_cropland_gain.csv')\ndf.head()\n</pre> df = geemap.csv_to_df('esri_cropland_gain.csv') df.head() In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    df,\n    x='NAME',\n    y='sum',\n    max_rows=30,\n    x_label='Country',\n    y_label='Area (km2)',\n    title='Cropland Gain',\n)\n</pre> geemap.bar_chart(     df,     x='NAME',     y='sum',     max_rows=30,     x_label='Country',     y_label='Area (km2)',     title='Cropland Gain', ) In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(\n    df, names='NAME', values='sum', max_rows=30, height=500, title='Cropland Gain'\n)\n</pre> geemap.pie_chart(     df, names='NAME', values='sum', max_rows=30, height=500, title='Cropland Gain' ) In\u00a0[\u00a0]: Copied! <pre>geemap.zonal_stats(\n    cropland_loss,\n    countries,\n    'esri_cropland_loss.csv',\n    statistics_type='SUM',\n    scale=1000,\n)\n</pre> geemap.zonal_stats(     cropland_loss,     countries,     'esri_cropland_loss.csv',     statistics_type='SUM',     scale=1000, ) In\u00a0[\u00a0]: Copied! <pre>df = geemap.csv_to_df('esri_cropland_loss.csv')\ndf.head()\n</pre> df = geemap.csv_to_df('esri_cropland_loss.csv') df.head() In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    df,\n    x='NAME',\n    y='sum',\n    max_rows=30,\n    x_label='Country',\n    y_label='Area (km2)',\n    title='Cropland Loss',\n)\n</pre> geemap.bar_chart(     df,     x='NAME',     y='sum',     max_rows=30,     x_label='Country',     y_label='Area (km2)',     title='Cropland Loss', ) In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(\n    df, names='NAME', values='sum', max_rows=30, height=500, title='Cropland Loss'\n)\n</pre> geemap.pie_chart(     df, names='NAME', values='sum', max_rows=30, height=500, title='Cropland Loss' ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nregion = ee.Geometry.BBox(-179, -89, 179, 89)\nstart_date = '2021-01-01'\nend_date = '2022-01-01'\n\ndw_class = geemap.dynamic_world(region, start_date, end_date, return_type='class')\ndw = geemap.dynamic_world(region, start_date, end_date, return_type='hillshade')\n\ndw_vis = {\"min\": 0, \"max\": 8, \"palette\": 'dw'}\n\nMap.addLayer(dw_class, dw_vis, 'DW Land Cover', False)\nMap.addLayer(dw, {}, 'DW Land Cover Hillshade')\n\nMap.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')\nMap.setCenter(-88.9088, 43.0006, 12)\nMap\n</pre> Map = geemap.Map()  region = ee.Geometry.BBox(-179, -89, 179, 89) start_date = '2021-01-01' end_date = '2022-01-01'  dw_class = geemap.dynamic_world(region, start_date, end_date, return_type='class') dw = geemap.dynamic_world(region, start_date, end_date, return_type='hillshade')  dw_vis = {\"min\": 0, \"max\": 8, \"palette\": 'dw'}  Map.addLayer(dw_class, dw_vis, 'DW Land Cover', False) Map.addLayer(dw, {}, 'DW Land Cover Hillshade')  Map.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World') Map.setCenter(-88.9088, 43.0006, 12) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[39.3322, -106.7349], zoom=10)\n\nleft_layer = geemap.ee_tile_layer(esa, esa_vis, \"ESA Land Cover\")\nright_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World Land Cover\")\n\nMap.split_map(left_layer, right_layer)\nMap.add_legend(\n    title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover', position='bottomleft'\n)\nMap.add_legend(\n    title=\"Dynamic World Land Cover\",\n    builtin_legend='Dynamic_World',\n    position='bottomright',\n)\nMap.setCenter(-88.9088, 43.0006, 12)\n\nMap\n</pre> Map = geemap.Map(center=[39.3322, -106.7349], zoom=10)  left_layer = geemap.ee_tile_layer(esa, esa_vis, \"ESA Land Cover\") right_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World Land Cover\")  Map.split_map(left_layer, right_layer) Map.add_legend(     title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover', position='bottomleft' ) Map.add_legend(     title=\"Dynamic World Land Cover\",     builtin_legend='Dynamic_World',     position='bottomright', ) Map.setCenter(-88.9088, 43.0006, 12)  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[-89.3998, 43.0886], zoom=10)\n\nleft_layer = geemap.ee_tile_layer(esri_2021, esri_vis, \"ESRI Land Cover\")\nright_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World Land Cover\")\n\nMap.split_map(left_layer, right_layer)\nMap.add_legend(\n    title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover', position='bottomleft'\n)\nMap.add_legend(\n    title=\"Dynamic World Land Cover\",\n    builtin_legend='Dynamic_World',\n    position='bottomright',\n)\nMap.setCenter(-88.9088, 43.0006, 12)\n\nMap\n</pre> Map = geemap.Map(center=[-89.3998, 43.0886], zoom=10)  left_layer = geemap.ee_tile_layer(esri_2021, esri_vis, \"ESRI Land Cover\") right_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World Land Cover\")  Map.split_map(left_layer, right_layer) Map.add_legend(     title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover', position='bottomleft' ) Map.add_legend(     title=\"Dynamic World Land Cover\",     builtin_legend='Dynamic_World',     position='bottomright', ) Map.setCenter(-88.9088, 43.0006, 12)  Map"},{"location":"workshops/Crop_Mapping_2022/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#esa-wordcover","title":"ESA WordCover\u00b6","text":"<p>The European Space Agency (ESA) WorldCover 10 m 2020 product provides a global land cover map for 2020 at 10 m resolution based on Sentinel-1 and Sentinel-2 data. The WorldCover product comes with 11 land cover classes and has been generated in the framework of the ESA WorldCover project, part of the 5th Earth Observation Envelope Programme (EOEP-5) of the European Space Agency.</p> <ul> <li>ESA WorldCover website</li> <li>EAS WroldCover in the Earth Engine Data Catalog</li> <li>User Manual and Validation Report</li> </ul>"},{"location":"workshops/Crop_Mapping_2022/#using-web-map-services","title":"Using Web Map Services\u00b6","text":"<p>The ESA WorldCover product can also be used within other websites or GIS clients by 'Web Map Services'. These services provide a direct link to the cached images and are the best option if you simply want to map the data and produce cartographic products. They are not suitable for analysis as the data are represented only as RGB images.</p> <ul> <li>WMTS: https://services.terrascope.be/wmts/v2</li> <li>WMS: https://services.terrascope.be/wms/v2</li> <li>Layers: WORLDCOVER_2020_MAP, WORLDCOVER_2020_S2_FCC, WORLDCOVER_2020_S2_TCC</li> </ul>"},{"location":"workshops/Crop_Mapping_2022/#using-earth-engine","title":"Using Earth Engine\u00b6","text":"<ul> <li>EAS WroldCover in the Earth Engine Data Catalog</li> </ul>"},{"location":"workshops/Crop_Mapping_2022/#creating-charts","title":"Creating charts\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#adding-administrative-boundaries","title":"Adding Administrative Boundaries\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#extracting-croplands","title":"Extracting Croplands\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#zonal-statistics","title":"Zonal Statistics\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#esri-global-land-cover","title":"ESRI GLobal Land Cover\u00b6","text":"<p>The ESRI GLobal Land Cover dataset is a global map of land use/land cover (LULC) derived from ESA Sentinel-2 imagery at 10m resolution. Each year is generated from Impact Observatory\u2019s deep learning AI land classification model used a massive training dataset of billions of human-labeled image pixels developed by the National Geographic Society. The global maps were produced by applying this model to the Sentinel-2 scene collection on Microsoft\u2019s Planetary Computer, processing over 400,000 Earth observations per year.</p> <ul> <li>https://livingatlas.arcgis.com/landcover/</li> <li>https://www.arcgis.com/home/item.html?id=d3da5dd386d140cf93fc9ecbf8da5e31</li> <li>https://samapriya.github.io/awesome-gee-community-datasets/projects/S2TSLULC/</li> </ul>"},{"location":"workshops/Crop_Mapping_2022/#using-awesome-gee-community-datasets","title":"Using Awesome GEE Community Datasets\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#using-timeseries-inspector","title":"Using Timeseries Inspector\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#extracting-croplands","title":"Extracting Croplands\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#zonal-statistics","title":"Zonal Statistics\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#analyzing-cropland-gain-and-loss","title":"Analyzing Cropland Gain and Loss\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#dynamic-world-land-cover","title":"Dynamic World Land Cover\u00b6","text":"<p>Dynamic World is a near realtime 10m resolution global land use land cover dataset, produced using deep learning, freely available and openly licensed. As a result of leveraging a novel deep learning approach, based on Sentinel-2 Top of Atmosphere, Dynamic World offers global land cover updating every 2-5 days depending on location.</p> <ul> <li>Dynamic World Website</li> <li>Dynamic World datasets on Earth Engine</li> </ul>"},{"location":"workshops/Crop_Mapping_2022/#classification-and-probability","title":"Classification and Probability\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#esa-land-cover-vs-dynamic-world","title":"ESA Land Cover vs. Dynamic World\u00b6","text":""},{"location":"workshops/Crop_Mapping_2022/#esri-land-cover-vs-dynamic-world","title":"ESRI Land Cover vs. Dynamic World\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/","title":"GEE Workshop 2021","text":"<p>Using Geemap for Geospatial Data Analysis and Visualization</p> <p>\u57fa\u4e8egeemap\u7684\u6570\u636e\u5206\u6790\u4e0e\u53ef\u89c6\u5316 - \u4ee5\u81ea\u52a8\u63d0\u53d6\u6cb3\u6d41\u4e2d\u5fc3\u7ebf\u548c\u5bbd\u5ea6\u4e3a\u6848\u4f8b</p> <p>This notebook was developed for the \u7b2c\u4e94\u5c4a\u201c\u5168\u56fd\u5730\u7403\u7a7a\u95f4\u5927\u6570\u636e\u4e0e\u4e91\u8ba1\u7b97\u201d\u7814\u8ba8\u4f1a.</p> <p>Authors: Qiusheng Wu</p> <p>Link to this notebook: https://gishub.org/gee_workshop_2021</p> In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap <p>Set you Internet proxy if needed. \u8bbe\u7f6e\u7f51\u7edc\u4ee3\u7406\u3002</p> <p></p> In\u00a0[\u00a0]: Copied! <pre># geemap.set_proxy(port=your-port-number)\n</pre> # geemap.set_proxy(port=your-port-number) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4, lite_mode=True)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4, lite_mode=True) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map In\u00a0[\u00a0]: Copied! <pre>from geemap.basemaps import basemaps\n</pre> from geemap.basemaps import basemaps In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap(basemaps.OpenTopoMap)\n</pre> Map.add_basemap(basemaps.OpenTopoMap) <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nurl = 'https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}'\nMap.add_tile_layer(url, name='Google Terrain', attribution='Google')\nMap\n</pre> Map = geemap.Map()  url = 'https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}' Map.add_tile_layer(url, name='Google Terrain', attribution='Google') Map In\u00a0[\u00a0]: Copied! <pre>naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?'\nMap.add_wms_layer(\n    url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True\n)\n</pre> naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?' Map.add_wms_layer(     url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Map.user_roi.getInfo()\n</pre> # Map.user_roi.getInfo() In\u00a0[\u00a0]: Copied! <pre># Map.user_rois.getInfo()\n</pre> # Map.user_rois.getInfo() In\u00a0[\u00a0]: Copied! <pre>js_snippet = \"\"\"\n// Load an image.\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\n\n// Define the visualization parameters.\nvar vizParams = {\n  bands: ['B5', 'B4', 'B3'],\n  min: 0,\n  max: 0.5,\n  gamma: [0.95, 1.1, 1]\n};\n\n// Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay\nMap.addLayer(image, vizParams, 'false color composite');\n\n\"\"\"\n</pre> js_snippet = \"\"\" // Load an image. var image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');  // Define the visualization parameters. var vizParams = {   bands: ['B5', 'B4', 'B3'],   min: 0,   max: 0.5,   gamma: [0.95, 1.1, 1] };  // Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay Map.addLayer(image, vizParams, 'false color composite');  \"\"\" In\u00a0[\u00a0]: Copied! <pre>geemap.js_snippet_to_py(\n    js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True\n)\n</pre> geemap.js_snippet_to_py(     js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True ) <p>You can also convert GEE JavaScript to Python without coding.</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine datasets\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\n\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine datasets dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\")  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>dem = ee.Image('CGIAR/SRTM90_V4')\nMap.addLayer(dem, {}, \"CGIAR/SRTM90_V4\")\n</pre> dem = ee.Image('CGIAR/SRTM90_V4') Map.addLayer(dem, {}, \"CGIAR/SRTM90_V4\") In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, \"DEM\")\n</pre> vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, \"DEM\") In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import DATA\n</pre> from geemap.datasets import DATA In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image(DATA.USGS_SRTMGL1_003)\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map()  dem = ee.Image(DATA.USGS_SRTMGL1_003)  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM') Map <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine datasets\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\n\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine datasets dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\")  Map <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat7, landsat_vis, \"Landsat\")\n\nhyperion = ee.ImageCollection('EO1/HYPERION').filter(\n    ee.Filter.date('2016-01-01', '2017-03-01')\n)\n\nhyperion_vis = {\n    'min': 1000.0,\n    'max': 14000.0,\n    'gamma': 2.5,\n}\nMap.addLayer(hyperion, hyperion_vis, 'Hyperion')\n\nMap\n</pre> Map = geemap.Map()  landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] )  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat7, landsat_vis, \"Landsat\")  hyperion = ee.ImageCollection('EO1/HYPERION').filter(     ee.Filter.date('2016-01-01', '2017-03-01') )  hyperion_vis = {     'min': 1000.0,     'max': 14000.0,     'gamma': 2.5, } Map.addLayer(hyperion, hyperion_vis, 'Hyperion')  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\ndem = ee.Image('USGS/SRTMGL1_003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap.addLayer(states, {}, \"US States\", True)\n\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  dem = ee.Image('USGS/SRTMGL1_003') states = ee.FeatureCollection(\"TIGER/2018/States\")  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map.addLayer(states, {}, \"US States\", True)  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},\n    'Landsat 7',\n)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] )  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},     'Landsat 7', ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'color': '000000',\n    'colorOpacity': 1,\n    'pointSize': 3,\n    'pointShape': 'circle',\n    'width': 2,\n    'lineType': 'solid',\n    'fillColorOpacity': 0.66,\n}\n\npalette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']\n\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\n</pre> vis_params = {     'color': '000000',     'colorOpacity': 1,     'pointSize': 3,     'pointShape': 'circle',     'width': 2,     'lineType': 'solid',     'fillColorOpacity': 0.66, }  palette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']  Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params ) In\u00a0[\u00a0]: Copied! <pre>legends = geemap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = geemap.builtin_legends for legend in legends:     print(legend) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover') Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlegend_dict = {\n    '11 Open Water': '466b9f',\n    '12 Perennial Ice/Snow': 'd1def8',\n    '21 Developed, Open Space': 'dec5c5',\n    '22 Developed, Low Intensity': 'd99282',\n    '23 Developed, Medium Intensity': 'eb0000',\n    '24 Developed High Intensity': 'ab0000',\n    '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',\n    '41 Deciduous Forest': '68ab5f',\n    '42 Evergreen Forest': '1c5f2c',\n    '43 Mixed Forest': 'b5c58f',\n    '51 Dwarf Scrub': 'af963c',\n    '52 Shrub/Scrub': 'ccb879',\n    '71 Grassland/Herbaceous': 'dfdfc2',\n    '72 Sedge/Herbaceous': 'd1d182',\n    '73 Lichens': 'a3cc51',\n    '74 Moss': '82ba9e',\n    '81 Pasture/Hay': 'dcd939',\n    '82 Cultivated Crops': 'ab6c28',\n    '90 Woody Wetlands': 'b8d9eb',\n    '95 Emergent Herbaceous Wetlands': '6c9fb8',\n}\n\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\n\nMap.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n</pre> Map = geemap.Map()  legend_dict = {     '11 Open Water': '466b9f',     '12 Perennial Ice/Snow': 'd1def8',     '21 Developed, Open Space': 'dec5c5',     '22 Developed, Low Intensity': 'd99282',     '23 Developed, Medium Intensity': 'eb0000',     '24 Developed High Intensity': 'ab0000',     '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',     '41 Deciduous Forest': '68ab5f',     '42 Evergreen Forest': '1c5f2c',     '43 Mixed Forest': 'b5c58f',     '51 Dwarf Scrub': 'af963c',     '52 Shrub/Scrub': 'ccb879',     '71 Grassland/Herbaceous': 'dfdfc2',     '72 Sedge/Herbaceous': 'd1d182',     '73 Lichens': 'a3cc51',     '74 Moss': '82ba9e',     '81 Pasture/Hay': 'dcd939',     '82 Cultivated Crops': 'ab6c28',     '90 Woody Wetlands': 'b8d9eb',     '95 Emergent Herbaceous Wetlands': '6c9fb8', }  landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover')  Map.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\n\ncolors = vis_params['palette']\nvmin = vis_params['min']\nvmax = vis_params['max']\n\nMap.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\")\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM')  colors = vis_params['palette'] vmin = vis_params['min'] vmax = vis_params['max']  Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\") Map In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\"\n)\n</pre> Map.add_colorbar(     vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\" ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n)\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     layer_name=\"SRTM DEM\",     orientation=\"vertical\",     transparent_bg=True, ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n    discrete=True,\n)\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     layer_name=\"SRTM DEM\",     orientation=\"vertical\",     transparent_bg=True,     discrete=True, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(left_layer='HYBRID', right_layer='TERRAIN')\nMap\n</pre> Map = geemap.Map() Map.split_map(left_layer='HYBRID', right_layer='TERRAIN') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(\n    left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover'\n)\nMap\n</pre> Map = geemap.Map() Map.split_map(     left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover' ) Map In\u00a0[\u00a0]: Copied! <pre>nlcd_2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover')\nnlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\n\nleft_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001')\nright_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')\n\nMap = geemap.Map()\nMap.split_map(left_layer, right_layer)\nMap\n</pre> nlcd_2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover') nlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')  left_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001') right_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')  Map = geemap.Map() Map.split_map(left_layer, right_layer) Map In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection('COPERNICUS/S2')\n    .filterDate('2018-09-01', '2018-09-30')\n    .map(lambda img: img.divide(10000))\n    .median()\n)\n\nvis_params = [\n    {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n]\n\nlabels = [\n    'Natural Color (B4/B3/B2)',\n    'Land/Water (B8/B11/B4)',\n    'Color Infrared (B8/B4/B3)',\n    'Vegetation (B12/B11/B4)',\n]\n\ngeemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"400px\",\n    center=[38.4151, 21.2712],\n    zoom=12,\n    ee_objects=[image],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n</pre> image = (     ee.ImageCollection('COPERNICUS/S2')     .filterDate('2018-09-01', '2018-09-30')     .map(lambda img: img.divide(10000))     .median() )  vis_params = [     {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3}, ]  labels = [     'Natural Color (B4/B3/B2)',     'Land/Water (B8/B11/B4)',     'Color Infrared (B8/B4/B3)',     'Vegetation (B12/B11/B4)', ]  geemap.linked_maps(     rows=2,     cols=2,     height=\"400px\",     center=[38.4151, 21.2712],     zoom=12,     ee_objects=[image],     vis_params=vis_params,     labels=labels,     label_position=\"topright\", ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('https://youtu.be/mA21Us_3m28')\n</pre> geemap.show_youtube('https://youtu.be/mA21Us_3m28') In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('https://youtu.be/kEltQkNia6o')\n</pre> geemap.show_youtube('https://youtu.be/kEltQkNia6o') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\n\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n\nvis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(centroid, 8)\nMap.addLayer(image, vis, \"Landsat-8\")\nMap\n</pre> Map = geemap.Map()  centroid = ee.Geometry.Point([-122.4439, 37.7538])  image = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()  vis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(centroid, 8) Map.addLayer(image, vis, \"Landsat-8\") Map In\u00a0[\u00a0]: Copied! <pre>image.propertyNames().getInfo()\n</pre> image.propertyNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>image.get('CLOUD_COVER').getInfo()\n</pre> image.get('CLOUD_COVER').getInfo() In\u00a0[\u00a0]: Copied! <pre>props = geemap.image_props(image)\nprops.getInfo()\n</pre> props = geemap.image_props(image) props.getInfo() In\u00a0[\u00a0]: Copied! <pre>stats = geemap.image_stats(image, scale=90)\nstats.getInfo()\n</pre> stats = geemap.image_stats(image, scale=90) stats.getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\n\n# Set visualization parameters.\ndem_vis = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine DEM to map\nMap.addLayer(dem, dem_vis, 'SRTM DEM')\n\n# Add Landsat data to map\nlandsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003')  # Set visualization parameters. dem_vis = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine DEM to map Map.addLayer(dem, dem_vis, 'SRTM DEM')  # Add Landsat data to map landsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') Map In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nout_dem_stats = os.path.join(out_dir, 'dem_stats.csv')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\n# Allowed output formats: csv, shp, json, kml, kmz\n# Allowed statistics type: MEAN, MAXIMUM, MINIMUM, MEDIAN, STD, MIN_MAX, VARIANCE, SUM\ngeemap.zonal_statistics(dem, states, out_dem_stats, statistics_type='MEAN', scale=1000)\n</pre> out_dir = os.path.expanduser('~/Downloads') out_dem_stats = os.path.join(out_dir, 'dem_stats.csv')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  # Allowed output formats: csv, shp, json, kml, kmz # Allowed statistics type: MEAN, MAXIMUM, MINIMUM, MEDIAN, STD, MIN_MAX, VARIANCE, SUM geemap.zonal_statistics(dem, states, out_dem_stats, statistics_type='MEAN', scale=1000) In\u00a0[\u00a0]: Copied! <pre>out_landsat_stats = os.path.join(out_dir, 'landsat_stats.csv')\ngeemap.zonal_statistics(\n    landsat, states, out_landsat_stats, statistics_type='SUM', scale=1000\n)\n</pre> out_landsat_stats = os.path.join(out_dir, 'landsat_stats.csv') geemap.zonal_statistics(     landsat, states, out_landsat_stats, statistics_type='SUM', scale=1000 ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndataset = ee.Image('USGS/NLCD/NLCD2016')\nlandcover = ee.Image(dataset.select('landcover'))\nMap.addLayer(landcover, {}, 'NLCD 2016')\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map()  dataset = ee.Image('USGS/NLCD/NLCD2016') landcover = ee.Image(dataset.select('landcover')) Map.addLayer(landcover, {}, 'NLCD 2016')  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nnlcd_stats = os.path.join(out_dir, 'nlcd_stats.csv')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\n# statistics_type can be either 'SUM' or 'PERCENTAGE'\n# denominator can be used to convert square meters to other areal units, such as square kilimeters\ngeemap.zonal_statistics_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    statistics_type='SUM',\n    denominator=1000000,\n    decimal_places=2,\n)\n</pre> out_dir = os.path.expanduser('~/Downloads') nlcd_stats = os.path.join(out_dir, 'nlcd_stats.csv')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  # statistics_type can be either 'SUM' or 'PERCENTAGE' # denominator can be used to convert square meters to other areal units, such as square kilimeters geemap.zonal_statistics_by_group(     landcover,     states,     nlcd_stats,     statistics_type='SUM',     denominator=1000000,     decimal_places=2, ) <p>Add data to the map</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\npoint = ee.Geometry.Point([-87.7719, 41.8799])\n\nimage = (\n    ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n    .filterBounds(point)\n    .filterDate('2019-01-01', '2019-12-31')\n    .sort('CLOUD_COVER')\n    .first()\n    .select('B[1-7]')\n)\n\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(point, 8)\nMap.addLayer(image, vis_params, \"Landsat-8\")\n\nMap\n</pre> Map = geemap.Map()  point = ee.Geometry.Point([-87.7719, 41.8799])  image = (     ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')     .filterBounds(point)     .filterDate('2019-01-01', '2019-12-31')     .sort('CLOUD_COVER')     .first()     .select('B[1-7]') )  vis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(point, 8) Map.addLayer(image, vis_params, \"Landsat-8\")  Map <p>Make training dataset</p> <p>There are several ways you can create a region for generating the training dataset.</p> <ul> <li>Draw a shape (e.g., rectangle) on the map and the use <code>region = Map.user_roi</code></li> <li>Define a geometry, such as <code>region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])</code></li> <li>Create a buffer zone around a point, such as <code>region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)</code></li> <li>If you don't define a region, it will use the image footprint by default</li> </ul> In\u00a0[\u00a0]: Copied! <pre>training = image.sample(\n    **{\n        #     'region': region,\n        'scale': 30,\n        'numPixels': 5000,\n        'seed': 0,\n        'geometries': True,  # Set this to False to ignore geometries\n    }\n)\n\nMap.addLayer(training, {}, 'training', False)\n</pre> training = image.sample(     **{         #     'region': region,         'scale': 30,         'numPixels': 5000,         'seed': 0,         'geometries': True,  # Set this to False to ignore geometries     } )  Map.addLayer(training, {}, 'training', False) <p>Train the clusterer</p> In\u00a0[\u00a0]: Copied! <pre># Instantiate the clusterer and train it.\nn_clusters = 5\nclusterer = ee.Clusterer.wekaKMeans(n_clusters).train(training)\n</pre> # Instantiate the clusterer and train it. n_clusters = 5 clusterer = ee.Clusterer.wekaKMeans(n_clusters).train(training) <p>Classify the image</p> In\u00a0[\u00a0]: Copied! <pre># Cluster the input using the trained clusterer.\nresult = image.cluster(clusterer)\n\n# # Display the clusters with random colors.\nMap.addLayer(result.randomVisualizer(), {}, 'clusters')\nMap\n</pre> # Cluster the input using the trained clusterer. result = image.cluster(clusterer)  # # Display the clusters with random colors. Map.addLayer(result.randomVisualizer(), {}, 'clusters') Map <p>Label the clusters</p> In\u00a0[\u00a0]: Copied! <pre>legend_keys = ['One', 'Two', 'Three', 'Four', 'ect']\nlegend_colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']\n\n# Reclassify the map\nresult = result.remap([0, 1, 2, 3, 4], [1, 2, 3, 4, 5])\n\nMap.addLayer(\n    result, {'min': 1, 'max': 5, 'palette': legend_colors}, 'Labelled clusters'\n)\nMap.add_legend(\n    legend_keys=legend_keys, legend_colors=legend_colors, position='bottomright'\n)\n</pre> legend_keys = ['One', 'Two', 'Three', 'Four', 'ect'] legend_colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']  # Reclassify the map result = result.remap([0, 1, 2, 3, 4], [1, 2, 3, 4, 5])  Map.addLayer(     result, {'min': 1, 'max': 5, 'palette': legend_colors}, 'Labelled clusters' ) Map.add_legend(     legend_keys=legend_keys, legend_colors=legend_colors, position='bottomright' ) <p>Visualize the result</p> In\u00a0[\u00a0]: Copied! <pre>print('Change layer opacity:')\ncluster_layer = Map.layers[-1]\ncluster_layer.interact(opacity=(0, 1, 0.1))\n</pre> print('Change layer opacity:') cluster_layer = Map.layers[-1] cluster_layer.interact(opacity=(0, 1, 0.1)) In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map <p>Export the result</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nout_file = os.path.join(out_dir, 'cluster.tif')\ngeemap.ee_export_image(result, filename=out_file, scale=90)\n</pre> out_dir = os.path.expanduser('~/Downloads') out_file = os.path.join(out_dir, 'cluster.tif') geemap.ee_export_image(result, filename=out_file, scale=90) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_to_drive(result, description='clusters', folder='export', scale=90)\n</pre> # geemap.ee_export_image_to_drive(result, description='clusters', folder='export', scale=90) <p>Source: https://developers.google.com/earth-engine/guides/classification</p> <p>The <code>Classifier</code> package handles supervised classification by traditional ML algorithms running in Earth Engine. These classifiers include CART, RandomForest, NaiveBayes and SVM. The general workflow for classification is:</p> <ol> <li>Collect training data. Assemble features which have a property that stores the known class label and properties storing numeric values for the predictors.</li> <li>Instantiate a classifier. Set its parameters if necessary.</li> <li>Train the classifier using the training data.</li> <li>Classify an image or feature collection.</li> <li>Estimate classification error with independent validation data.</li> </ol> <p>The training data is a <code>FeatureCollection</code> with a property storing the class label and properties storing predictor variables. Class labels should be consecutive, integers starting from 0. If necessary, use remap() to convert class values to consecutive integers. The predictors should be numeric.</p> <p></p> <p>Add data to the map</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\npoint = ee.Geometry.Point([-122.4439, 37.7538])\n\nimage = (\n    ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n    .filterBounds(point)\n    .filterDate('2016-01-01', '2016-12-31')\n    .sort('CLOUD_COVER')\n    .first()\n    .select('B[1-7]')\n)\n\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(point, 8)\nMap.addLayer(image, vis_params, \"Landsat-8\")\n\nMap\n</pre> Map = geemap.Map()  point = ee.Geometry.Point([-122.4439, 37.7538])  image = (     ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')     .filterBounds(point)     .filterDate('2016-01-01', '2016-12-31')     .sort('CLOUD_COVER')     .first()     .select('B[1-7]') )  vis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(point, 8) Map.addLayer(image, vis_params, \"Landsat-8\")  Map <p>Make training dataset</p> <p>There are several ways you can create a region for generating the training dataset.</p> <ul> <li>Draw a shape (e.g., rectangle) on the map and the use <code>region = Map.user_roi</code></li> <li>Define a geometry, such as <code>region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])</code></li> <li>Create a buffer zone around a point, such as <code>region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)</code></li> <li>If you don't define a region, it will use the image footprint by default</li> </ul> In\u00a0[\u00a0]: Copied! <pre># region = Map.user_roi\n# region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])\n# region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)\n</pre> # region = Map.user_roi # region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288]) # region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000) <p>In this example, we are going to use the USGS National Land Cover Database (NLCD) to create label dataset for training</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>nlcd = ee.Image('USGS/NLCD/NLCD2016').select('landcover').clip(image.geometry())\nMap.addLayer(nlcd, {}, 'NLCD')\nMap\n</pre> nlcd = ee.Image('USGS/NLCD/NLCD2016').select('landcover').clip(image.geometry()) Map.addLayer(nlcd, {}, 'NLCD') Map In\u00a0[\u00a0]: Copied! <pre># Make the training dataset.\npoints = nlcd.sample(\n    **{\n        'region': image.geometry(),\n        'scale': 30,\n        'numPixels': 5000,\n        'seed': 0,\n        'geometries': True,  # Set this to False to ignore geometries\n    }\n)\n\nMap.addLayer(points, {}, 'training', False)\n</pre> # Make the training dataset. points = nlcd.sample(     **{         'region': image.geometry(),         'scale': 30,         'numPixels': 5000,         'seed': 0,         'geometries': True,  # Set this to False to ignore geometries     } )  Map.addLayer(points, {}, 'training', False) <p>Train the classifier</p> In\u00a0[\u00a0]: Copied! <pre># Use these bands for prediction.\nbands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']\n\n\n# This property of the table stores the land cover labels.\nlabel = 'landcover'\n\n# Overlay the points on the imagery to get training.\ntraining = image.select(bands).sampleRegions(\n    **{'collection': points, 'properties': [label], 'scale': 30}\n)\n\n# Train a CART classifier with default parameters.\ntrained = ee.Classifier.smileCart().train(training, label, bands)\n</pre> # Use these bands for prediction. bands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']   # This property of the table stores the land cover labels. label = 'landcover'  # Overlay the points on the imagery to get training. training = image.select(bands).sampleRegions(     **{'collection': points, 'properties': [label], 'scale': 30} )  # Train a CART classifier with default parameters. trained = ee.Classifier.smileCart().train(training, label, bands) <p>Classify the image</p> In\u00a0[\u00a0]: Copied! <pre># Classify the image with the same bands used for training.\nresult = image.select(bands).classify(trained)\n\n# # Display the clusters with random colors.\nMap.addLayer(result.randomVisualizer(), {}, 'classfied')\nMap\n</pre> # Classify the image with the same bands used for training. result = image.select(bands).classify(trained)  # # Display the clusters with random colors. Map.addLayer(result.randomVisualizer(), {}, 'classfied') Map <p>Render categorical map</p> <p>To render a categorical map, we can set two image properties: <code>landcover_class_values</code> and <code>landcover_class_palette</code>. We can use the same style as the NLCD so that it is easy to compare the two maps.</p> In\u00a0[\u00a0]: Copied! <pre>class_values = nlcd.get('landcover_class_values').getInfo()\nclass_palette = nlcd.get('landcover_class_palette').getInfo()\n</pre> class_values = nlcd.get('landcover_class_values').getInfo() class_palette = nlcd.get('landcover_class_palette').getInfo() In\u00a0[\u00a0]: Copied! <pre>landcover = result.set('classification_class_values', class_values)\nlandcover = landcover.set('classification_class_palette', class_palette)\n</pre> landcover = result.set('classification_class_values', class_values) landcover = landcover.set('classification_class_palette', class_palette) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(landcover, {}, 'Land cover')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map.addLayer(landcover, {}, 'Land cover') Map.add_legend(builtin_legend='NLCD') Map <p>Visualize the result</p> In\u00a0[\u00a0]: Copied! <pre>print('Change layer opacity:')\ncluster_layer = Map.layers[-1]\ncluster_layer.interact(opacity=(0, 1, 0.1))\n</pre> print('Change layer opacity:') cluster_layer = Map.layers[-1] cluster_layer.interact(opacity=(0, 1, 0.1)) <p>Export the result</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nout_file = os.path.join(out_dir, 'landcover.tif')\n</pre> out_dir = os.path.expanduser('~/Downloads') out_file = os.path.join(out_dir, 'landcover.tif') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(landcover, filename=out_file, scale=900)\n</pre> geemap.ee_export_image(landcover, filename=out_file, scale=900) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_to_drive(landcover, description='landcover', folder='export', scale=900)\n</pre> # geemap.ee_export_image_to_drive(landcover, description='landcover', folder='export', scale=900) In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('https://youtu.be/VWh5PxXPZw0')\n</pre> geemap.show_youtube('https://youtu.be/VWh5PxXPZw0') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>import whiteboxgui\n</pre> import whiteboxgui In\u00a0[\u00a0]: Copied! <pre>whiteboxgui.show()\n</pre> whiteboxgui.show() In\u00a0[\u00a0]: Copied! <pre>whiteboxgui.show(tree=True)\n</pre> whiteboxgui.show(tree=True) <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nfrom geemap import cartoee\n</pre> import matplotlib.pyplot as plt from geemap import cartoee In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>srtm = ee.Image(\"CGIAR/SRTM90_V4\")\nregion = [-180, -60, 180, 85]  # define bounding box to request data\nvis = {'min': 0, 'max': 3000}  # define visualization parameters for image\n</pre> srtm = ee.Image(\"CGIAR/SRTM90_V4\") region = [-180, -60, 180, 85]  # define bounding box to request data vis = {'min': 0, 'max': 3000}  # define visualization parameters for image In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\ncmap = \"gist_earth\"  # colormap we want to use\n# cmap = \"terrain\"\n\n# use cartoee to get a map\nax = cartoee.get_map(srtm, region=region, vis_params=vis, cmap=cmap)\n\n# add a colorbar to the map using the visualization params we passed to the map\ncartoee.add_colorbar(\n    ax, vis, cmap=cmap, loc=\"right\", label=\"Elevation\", orientation=\"vertical\"\n)\n\n# add gridlines to the map at a specified interval\ncartoee.add_gridlines(ax, interval=[60, 30], linestyle=\"--\")\n\n# add coastlines using the cartopy api\nax.coastlines(color=\"red\")\n\nax.set_title(label='Global Elevation Map', fontsize=15)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  cmap = \"gist_earth\"  # colormap we want to use # cmap = \"terrain\"  # use cartoee to get a map ax = cartoee.get_map(srtm, region=region, vis_params=vis, cmap=cmap)  # add a colorbar to the map using the visualization params we passed to the map cartoee.add_colorbar(     ax, vis, cmap=cmap, loc=\"right\", label=\"Elevation\", orientation=\"vertical\" )  # add gridlines to the map at a specified interval cartoee.add_gridlines(ax, interval=[60, 30], linestyle=\"--\")  # add coastlines using the cartopy api ax.coastlines(color=\"red\")  ax.set_title(label='Global Elevation Map', fontsize=15)  plt.show() In\u00a0[\u00a0]: Copied! <pre># get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n\n# define the visualization parameters to view\nvis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3}\n</pre> # get a landsat image to visualize image = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')  # define the visualization parameters to view vis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3} In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# here is the bounding box of the map extent we want to use\n# formatted a [W,S,E,N]\nzoom_region = [-122.6265, 37.3458, -121.8025, 37.9178]\n\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.15, xtick_rotation=45, linestyle=\":\")\n\n# add coastline\nax.coastlines(color=\"yellow\")\n\n# add north arrow\ncartoee.add_north_arrow(\n    ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20\n)\n\n# add scale bar\ncartoee.add_scale_bar_lite(\n    ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\"\n)\n\nax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # here is the bounding box of the map extent we want to use # formatted a [W,S,E,N] zoom_region = [-122.6265, 37.3458, -121.8025, 37.9178]  # plot the map over the region of interest ax = cartoee.get_map(image, vis_params=vis, region=zoom_region)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.15, xtick_rotation=45, linestyle=\":\")  # add coastline ax.coastlines(color=\"yellow\")  # add north arrow cartoee.add_north_arrow(     ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20 )  # add scale bar cartoee.add_scale_bar_lite(     ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\" )  ax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)  plt.show() In\u00a0[\u00a0]: Copied! <pre>from matplotlib.lines import Line2D\n</pre> from matplotlib.lines import Line2D In\u00a0[\u00a0]: Copied! <pre># get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n\n# define the visualization parameters to view\nvis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3}\n</pre> # get a landsat image to visualize image = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')  # define the visualization parameters to view vis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3} In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# here is the bounding box of the map extent we want to use\n# formatted a [W,S,E,N]\nzoom_region = [-122.6265, 37.3458, -121.8025, 37.9178]\n\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.15, xtick_rotation=0, linestyle=\":\")\n\n# add coastline\nax.coastlines(color=\"cyan\")\n\n# add north arrow\ncartoee.add_north_arrow(\n    ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20\n)\n\n# add scale bar\ncartoee.add_scale_bar_lite(\n    ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\"\n)\n\nax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)\n\n# add legend\nlegend_elements = [\n    Line2D([], [], color='#00ffff', lw=2, label='Coastline'),\n    Line2D(\n        [],\n        [],\n        marker='o',\n        color='#A8321D',\n        label='City',\n        markerfacecolor='#A8321D',\n        markersize=10,\n        ls='',\n    ),\n]\n\ncartoee.add_legend(ax, legend_elements, loc='lower right')\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # here is the bounding box of the map extent we want to use # formatted a [W,S,E,N] zoom_region = [-122.6265, 37.3458, -121.8025, 37.9178]  # plot the map over the region of interest ax = cartoee.get_map(image, vis_params=vis, region=zoom_region)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.15, xtick_rotation=0, linestyle=\":\")  # add coastline ax.coastlines(color=\"cyan\")  # add north arrow cartoee.add_north_arrow(     ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20 )  # add scale bar cartoee.add_scale_bar_lite(     ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\" )  ax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)  # add legend legend_elements = [     Line2D([], [], color='#00ffff', lw=2, label='Coastline'),     Line2D(         [],         [],         marker='o',         color='#A8321D',         label='City',         markerfacecolor='#A8321D',         markersize=10,         ls='',     ), ]  cartoee.add_legend(ax, legend_elements, loc='lower right')  plt.show() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = (\n    ee.ImageCollection('MODIS/MCD43A4_006_NDVI')\n    .filter(ee.Filter.date('2018-04-01', '2018-05-01'))\n    .select(\"NDVI\")\n    .first()\n)\n\nvis_params = {\n    'min': 0.0,\n    'max': 1.0,\n    'palette': [\n        'FFFFFF',\n        'CE7E45',\n        'DF923D',\n        'F1B555',\n        'FCD163',\n        '99B718',\n        '74A901',\n        '66A000',\n        '529400',\n        '3E8601',\n        '207401',\n        '056201',\n        '004C00',\n        '023B01',\n        '012E01',\n        '011D01',\n        '011301',\n    ],\n}\nMap.setCenter(-7.03125, 31.0529339857, 2)\nMap.addLayer(image, vis_params, 'MODIS NDVI')\n\ncountries = geemap.shp_to_ee(\"../data/countries.shp\")\nstyle = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"}\nMap.addLayer(countries.style(**style), {}, \"Countries\")\n\nndvi = image.visualize(**vis_params)\nblend = ndvi.blend(countries.style(**style))\n\nMap.addLayer(blend, {}, \"Blend\")\n\nMap\n</pre> Map = geemap.Map()  image = (     ee.ImageCollection('MODIS/MCD43A4_006_NDVI')     .filter(ee.Filter.date('2018-04-01', '2018-05-01'))     .select(\"NDVI\")     .first() )  vis_params = {     'min': 0.0,     'max': 1.0,     'palette': [         'FFFFFF',         'CE7E45',         'DF923D',         'F1B555',         'FCD163',         '99B718',         '74A901',         '66A000',         '529400',         '3E8601',         '207401',         '056201',         '004C00',         '023B01',         '012E01',         '011D01',         '011301',     ], } Map.setCenter(-7.03125, 31.0529339857, 2) Map.addLayer(image, vis_params, 'MODIS NDVI')  countries = geemap.shp_to_ee(\"../data/countries.shp\") style = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"} Map.addLayer(countries.style(**style), {}, \"Countries\")  ndvi = image.visualize(**vis_params) blend = ndvi.blend(countries.style(**style))  Map.addLayer(blend, {}, \"Blend\")  Map In\u00a0[\u00a0]: Copied! <pre># specify region to focus on\nbbox = [-180, -88, 180, 88]\n</pre> # specify region to focus on bbox = [-180, -88, 180, 88] In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(blend, region=bbox)\ncb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')\n\nax.set_title(label='MODIS NDVI', fontsize=15)\n\n# ax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(blend, region=bbox) cb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')  ax.set_title(label='MODIS NDVI', fontsize=15)  # ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>import cartopy.crs as ccrs\n</pre> import cartopy.crs as ccrs In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\nprojection = ccrs.EqualEarth(central_longitude=-180)\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(blend, region=bbox, proj=projection)\ncb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')\n\nax.set_title(label='MODIS NDVI', fontsize=15)\n\n# ax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  projection = ccrs.EqualEarth(central_longitude=-180)  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(blend, region=bbox, proj=projection) cb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')  ax.set_title(label='MODIS NDVI', fontsize=15)  # ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>import cartopy.crs as ccrs\n</pre> import cartopy.crs as ccrs In\u00a0[\u00a0]: Copied! <pre># get an earth engine image of ocean data for Jan-Mar 2018\nocean = (\n    ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')\n    .filter(ee.Filter.date('2018-01-01', '2018-03-01'))\n    .median()\n    .select([\"sst\"], [\"SST\"])\n)\n</pre> # get an earth engine image of ocean data for Jan-Mar 2018 ocean = (     ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')     .filter(ee.Filter.date('2018-01-01', '2018-03-01'))     .median()     .select([\"sst\"], [\"SST\"]) ) In\u00a0[\u00a0]: Copied! <pre># set parameters for plotting\n# will plot the Sea Surface Temp with specific range and colormap\nvisualization = {'bands': \"SST\", 'min': -2, 'max': 30}\n# specify region to focus on\nbbox = [-180, -88, 180, 88]\n</pre> # set parameters for plotting # will plot the Sea Surface Temp with specific range and colormap visualization = {'bands': \"SST\", 'min': -2, 'max': 30} # specify region to focus on bbox = [-180, -88, 180, 88] In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(ocean, cmap='plasma', vis_params=visualization, region=bbox)\ncb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')\n\nax.set_title(label='Sea Surface Temperature', fontsize=15)\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(ocean, cmap='plasma', vis_params=visualization, region=bbox) cb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')  ax.set_title(label='Sea Surface Temperature', fontsize=15)  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new Mollweide projection centered on the Pacific\nprojection = ccrs.Mollweide(central_longitude=-180)\n\n# plot the result with cartoee using the Mollweide projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal'\n)\n\nax.set_title(\"Mollweide projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new Mollweide projection centered on the Pacific projection = ccrs.Mollweide(central_longitude=-180)  # plot the result with cartoee using the Mollweide projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal' )  ax.set_title(\"Mollweide projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new Robinson projection centered on the Pacific\nprojection = ccrs.Robinson(central_longitude=-180)\n\n# plot the result with cartoee using the Goode homolosine projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal'\n)\n\nax.set_title(\"Robinson projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new Robinson projection centered on the Pacific projection = ccrs.Robinson(central_longitude=-180)  # plot the result with cartoee using the Goode homolosine projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal' )  ax.set_title(\"Robinson projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new equal Earth projection focused on the Pacific\nprojection = ccrs.EqualEarth(central_longitude=-180)\n\n# plot the result with cartoee using the orographic projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical'\n)\n\nax.set_title(\"Equal Earth projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new equal Earth projection focused on the Pacific projection = ccrs.EqualEarth(central_longitude=-180)  # plot the result with cartoee using the orographic projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical' )  ax.set_title(\"Equal Earth projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new orographic projection focused on the Pacific\nprojection = ccrs.Orthographic(-130, -10)\n\n# plot the result with cartoee using the orographic projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical'\n)\n\nax.set_title(\"Orographic projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new orographic projection focused on the Pacific projection = ccrs.Orthographic(-130, -10)  # plot the result with cartoee using the orographic projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical' )  ax.set_title(\"Orographic projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 1)\n\nMap\n</pre> Map = geemap.Map()  image = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 1)  Map In\u00a0[\u00a0]: Copied! <pre># Draw any shapes on the map using the Drawing tools before executing this code block\nroi = Map.user_roi\n\nif roi is None:\n    roi = ee.Geometry.Polygon(\n        [\n            [\n                [-115.413031, 35.889467],\n                [-115.413031, 36.543157],\n                [-114.034328, 36.543157],\n                [-114.034328, 35.889467],\n                [-115.413031, 35.889467],\n            ]\n        ]\n    )\n</pre> # Draw any shapes on the map using the Drawing tools before executing this code block roi = Map.user_roi  if roi is None:     roi = ee.Geometry.Polygon(         [             [                 [-115.413031, 35.889467],                 [-115.413031, 36.543157],                 [-114.034328, 36.543157],                 [-114.034328, 35.889467],                 [-115.413031, 35.889467],             ]         ]     ) In\u00a0[\u00a0]: Copied! <pre># Set output directory\nout_dir = os.path.expanduser('~/Downloads')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\nfilename = os.path.join(out_dir, 'landsat.tif')\n</pre> # Set output directory out_dir = os.path.expanduser('~/Downloads')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  filename = os.path.join(out_dir, 'landsat.tif') <p>Exporting all bands as one single image</p> In\u00a0[\u00a0]: Copied! <pre>image = image.clip(roi).unmask()\ngeemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=False\n)\n</pre> image = image.clip(roi).unmask() geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=False ) <p>Exporting each band as one image</p> In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=True\n)\n</pre> geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=True ) <p>Export an image to Google Drive\u00b6</p> In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_to_drive(image, description='landsat', folder='export', region=roi, scale=30)\n</pre> # geemap.ee_export_image_to_drive(image, description='landsat', folder='export', region=roi, scale=30) In\u00a0[\u00a0]: Copied! <pre>loc = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(loc)\n    .filterDate('2008-01-01', '2020-01-01')\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n</pre> loc = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(loc)     .filterDate('2008-01-01', '2020-01-01')     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) In\u00a0[\u00a0]: Copied! <pre>collection.aggregate_array('system:index').getInfo()\n</pre> collection.aggregate_array('system:index').getInfo() In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection(collection, out_dir=out_dir)\n</pre> geemap.ee_export_image_collection(collection, out_dir=out_dir) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10)\n</pre> # geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10) In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nimg = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810').select(['B4', 'B5', 'B6'])\n\naoi = ee.Geometry.Polygon(\n    [[[-110.8, 44.7], [-110.8, 44.6], [-110.6, 44.6], [-110.6, 44.7]]], None, False\n)\n\nrgb_img = geemap.ee_to_numpy(img, region=aoi)\nprint(rgb_img.shape)\n</pre> import matplotlib.pyplot as plt  img = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810').select(['B4', 'B5', 'B6'])  aoi = ee.Geometry.Polygon(     [[[-110.8, 44.7], [-110.8, 44.6], [-110.6, 44.6], [-110.6, 44.7]]], None, False )  rgb_img = geemap.ee_to_numpy(img, region=aoi) print(rgb_img.shape) In\u00a0[\u00a0]: Copied! <pre>rgb_img_test = (255 * ((rgb_img[:, :, 0:3] - 100) / 3500)).astype('uint8')\nplt.imshow(rgb_img_test)\nplt.show()\n</pre> rgb_img_test = (255 * ((rgb_img[:, :, 0:3] - 100) / 3500)).astype('uint8') plt.imshow(rgb_img_test) plt.show() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(\n    landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7'\n)\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(     landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7' ) Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map <p>Download sample data</p> In\u00a0[\u00a0]: Copied! <pre>work_dir = os.path.expanduser('~/Downloads')\nin_shp = os.path.join(work_dir, 'us_cities.shp')\nif not os.path.exists(in_shp):\n    data_url = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip'\n    geemap.download_from_url(data_url, out_dir=work_dir)\n</pre> work_dir = os.path.expanduser('~/Downloads') in_shp = os.path.join(work_dir, 'us_cities.shp') if not os.path.exists(in_shp):     data_url = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip'     geemap.download_from_url(data_url, out_dir=work_dir) In\u00a0[\u00a0]: Copied! <pre>in_fc = geemap.shp_to_ee(in_shp)\nMap.addLayer(in_fc, {}, 'Cities')\n</pre> in_fc = geemap.shp_to_ee(in_shp) Map.addLayer(in_fc, {}, 'Cities') <p>Export pixel values as a shapefile</p> In\u00a0[\u00a0]: Copied! <pre>out_shp = os.path.join(work_dir, 'dem.shp')\ngeemap.extract_values_to_points(in_fc, dem, out_shp)\n</pre> out_shp = os.path.join(work_dir, 'dem.shp') geemap.extract_values_to_points(in_fc, dem, out_shp) <p>Export pixel values as a csv</p> In\u00a0[\u00a0]: Copied! <pre>out_csv = os.path.join(work_dir, 'landsat.csv')\ngeemap.extract_values_to_points(in_fc, landsat7, out_csv)\n</pre> out_csv = os.path.join(work_dir, 'landsat.csv') geemap.extract_values_to_points(in_fc, landsat7, out_csv) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nfc = ee.FeatureCollection('users/giswqs/public/countries')\nMap.addLayer(fc, {}, \"Countries\")\nMap\n</pre> Map = geemap.Map()  fc = ee.FeatureCollection('users/giswqs/public/countries') Map.addLayer(fc, {}, \"Countries\") Map In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nout_shp = os.path.join(out_dir, 'countries.shp')\n</pre> out_dir = os.path.expanduser('~/Downloads') out_shp = os.path.join(out_dir, 'countries.shp') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_shp(fc, filename=out_shp)\n</pre> geemap.ee_to_shp(fc, filename=out_shp) In\u00a0[\u00a0]: Copied! <pre>out_csv = os.path.join(out_dir, 'countries.csv')\ngeemap.ee_export_vector(fc, filename=out_csv)\n</pre> out_csv = os.path.join(out_dir, 'countries.csv') geemap.ee_export_vector(fc, filename=out_csv) In\u00a0[\u00a0]: Copied! <pre>out_kml = os.path.join(out_dir, 'countries.kml')\ngeemap.ee_export_vector(fc, filename=out_kml)\n</pre> out_kml = os.path.join(out_dir, 'countries.kml') geemap.ee_export_vector(fc, filename=out_kml) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_vector_to_drive(fc, description=\"countries\", folder=\"export\", file_format=\"shp\")\n</pre> # geemap.ee_export_vector_to_drive(fc, description=\"countries\", folder=\"export\", file_format=\"shp\") In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom geemap.algorithms import river\n</pre> import ee import geemap from geemap.algorithms import river <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map <p>Find an image by ROI.</p> In\u00a0[\u00a0]: Copied! <pre>point = ee.Geometry.Point([-88.08, 37.47])\n</pre> point = ee.Geometry.Point([-88.08, 37.47]) In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\")\n    .filterBounds(point)\n    .sort(\"CLOUD_COVER\")\n    .first()\n)\n</pre> image = (     ee.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\")     .filterBounds(point)     .sort(\"CLOUD_COVER\")     .first() ) <p>Add image to the map.</p> In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(image, {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}, \"Landsat\")\nMap.centerObject(image)\n</pre> Map.addLayer(image, {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}, \"Landsat\") Map.centerObject(image) <p>Extract river width for a single image.</p> In\u00a0[\u00a0]: Copied! <pre>river.rwc(image, folder=\"export\", water_method='Jones2019')\n</pre> river.rwc(image, folder=\"export\", water_method='Jones2019') <p>Add result to the map.</p> In\u00a0[\u00a0]: Copied! <pre>fc = ee.FeatureCollection(\"users/giswqs/public/river_width\")\nMap.addLayer(fc, {}, \"River width\")\n</pre> fc = ee.FeatureCollection(\"users/giswqs/public/river_width\") Map.addLayer(fc, {}, \"River width\") <p>Add Global River Width Dataset to the map.</p> In\u00a0[\u00a0]: Copied! <pre>water_mask = ee.ImageCollection(\n    \"projects/sat-io/open-datasets/GRWL/water_mask_v01_01\"\n).median()\nMap.addLayer(water_mask, {'min': 11, 'max': 125, 'palette': 'blue'}, 'GRWL Water Mask')\n</pre> water_mask = ee.ImageCollection(     \"projects/sat-io/open-datasets/GRWL/water_mask_v01_01\" ).median() Map.addLayer(water_mask, {'min': 11, 'max': 125, 'palette': 'blue'}, 'GRWL Water Mask') In\u00a0[\u00a0]: Copied! <pre>grwl_water_vector = ee.FeatureCollection(\n    \"projects/sat-io/open-datasets/GRWL/water_vector_v01_01\"\n)\nMap.addLayer(\n    grwl_water_vector.style(**{'fillColor': '00000000', 'color': 'FF5500'}),\n    {},\n    'GRWL Vector',\n)\n</pre> grwl_water_vector = ee.FeatureCollection(     \"projects/sat-io/open-datasets/GRWL/water_vector_v01_01\" ) Map.addLayer(     grwl_water_vector.style(**{'fillColor': '00000000', 'color': 'FF5500'}),     {},     'GRWL Vector', ) <p>Find images by ROI.</p> In\u00a0[\u00a0]: Copied! <pre>images = (\n    ee.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\")\n    .filterBounds(point)\n    .sort(\"CLOUD_COVER\")\n    .limit(3)\n)\n</pre> images = (     ee.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\")     .filterBounds(point)     .sort(\"CLOUD_COVER\")     .limit(3) ) <p>Get the list of image ids.</p> In\u00a0[\u00a0]: Copied! <pre>ids = images.aggregate_array(\"LANDSAT_ID\").getInfo()\nids\n</pre> ids = images.aggregate_array(\"LANDSAT_ID\").getInfo() ids <p>Extract river width for a list of images.</p> In\u00a0[\u00a0]: Copied! <pre>river.rwc_batch(ids, folder=\"export\", water_method='Jones2019')\n</pre> river.rwc_batch(ids, folder=\"export\", water_method='Jones2019')"},{"location":"workshops/GEE_Workshop_2021/#introduction","title":"Introduction\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#description","title":"Description\u00b6","text":"<p>Google Earth Engine (GEE) is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. It enables scientists, researchers, and developers to analyze and visualize changes on the Earth\u2019s surface. The geemap Python package provides GEE users with an intuitive interface to manipulate, analyze, and visualize geospatial big data interactively in a Jupyter-based environment. The topics will be covered in this workshop include:</p> <ol> <li>Introducing geemap and the Earth Engine Python API</li> <li>Creating interactive maps</li> <li>Searching GEE data catalog</li> <li>Displaying GEE datasets</li> <li>Classifying images using machine learning algorithms</li> <li>Computing statistics and exporting results</li> <li>Producing publication-quality maps</li> <li>Extracting river width and centerline</li> </ol> <p>This workshop is intended for scientific programmers, data scientists, geospatial analysts, and concerned citizens of Earth. The attendees are expected to have a basic understanding of Python and the Jupyter ecosystem. Familiarity with Earth science and geospatial datasets is useful but not required.</p> <p>\u4e2d\u6587\u7b80\u4ecb</p> <p>Geemap Python\u8f6f\u4ef6\u5305\u4e3aGEE\u7528\u6237\u63d0\u4f9b\u4e86\u4e00\u4e2a\u76f4\u89c2\u7684\u754c\u9762\uff0c\u53ef\u4ee5\u5728\u57fa\u4e8eJupyter\u7684\u73af\u5883\u4e2d\u4ee5\u4ea4\u4e92\u65b9\u5f0f\u64cd\u4f5c\u3001\u5206\u6790\u548c\u53ef\u89c6\u5316\u5730\u7406\u7a7a\u95f4\u5927\u6570\u636e\u3002\u672c\u6b21\u7814\u8ba8\u4f1a\u5c06\u6d89\u53ca\u7684\u4e3b\u9898\u5305\u62ec\uff1a</p> <ul> <li>\u4ecb\u7ecdGeemap\u548cEarth Engine Python API</li> <li>\u521b\u5efa\u4ea4\u4e92\u5f0f\u5730\u56fe</li> <li>\u641c\u7d22GEE\u6570\u636e\u76ee\u5f55</li> <li>\u5bf9\u65f6\u95f4\u5e8f\u5217\u6570\u636e\u8fdb\u884c\u53ef\u89c6\u5316</li> <li>\u4f7f\u7528\u673a\u5668\u5b66\u4e60\u7b97\u6cd5\u5bf9\u5f71\u50cf\u8fdb\u884c\u5206\u7c7b</li> <li>\u8ba1\u7b97\u7edf\u8ba1\u548c\u8f93\u51fa\u7ed3\u679c</li> <li>\u5236\u4f5c\u9ad8\u8d28\u91cf\u7684\u5730\u56fe</li> <li>\u81ea\u52a8\u63d0\u53d6\u6cb3\u6d41\u4e2d\u5fc3\u7ebf\u548c\u5bbd\u5ea6\u7b49</li> </ul>"},{"location":"workshops/GEE_Workshop_2021/#useful-links","title":"Useful links\u00b6","text":"<ul> <li>Google Earth Engine</li> <li>geemap.org</li> <li>Google Earth Engine and geemap Python Tutorials (55 videos with a total length of 15 hours)</li> <li>Spatial Data Management with Google Earth Engine (19 videos with a total length of 9 hours)</li> <li>Ask geemap questions on GitHub</li> </ul>"},{"location":"workshops/GEE_Workshop_2021/#prerequisite","title":"Prerequisite\u00b6","text":"<ul> <li>A Google Earth Engine account. Sigh up here if needed.</li> <li>Miniconda or Anaconda</li> </ul>"},{"location":"workshops/GEE_Workshop_2021/#set-up-a-conda-environment","title":"Set up a conda environment\u00b6","text":"<pre><code>conda create -n gee python=3.8\nconda activate gee\nconda install geopandas\nconda install mamba -c conda-forge\nmamba install geemap -c conda-forge\n</code></pre>"},{"location":"workshops/GEE_Workshop_2021/#geemap-basics","title":"geemap basics\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#customize-the-default-map","title":"Customize the default map\u00b6","text":"<p>You can specify the center(lat, lon) and zoom for the default map. The lite mode will only show the zoom in/out tool.</p>"},{"location":"workshops/GEE_Workshop_2021/#add-basemaps","title":"Add basemaps\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#change-basemaps-without-coding","title":"Change basemaps without coding\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#add-wms-and-xyz-tile-layers","title":"Add WMS and XYZ tile layers\u00b6","text":"<p>Examples: https://viewer.nationalmap.gov/services/</p>"},{"location":"workshops/GEE_Workshop_2021/#use-drawing-tools","title":"Use drawing tools\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#convert-gee-javascript-to-python","title":"Convert GEE JavaScript to Python\u00b6","text":"<p>https://developers.google.com/earth-engine/guides/image_visualization</p>"},{"location":"workshops/GEE_Workshop_2021/#earth-engine-datasets","title":"Earth Engine datasets\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#load-earth-engine-datasets","title":"Load Earth Engine datasets\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#search-the-earth-engine-data-catalog","title":"Search the Earth Engine Data Catalog\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#use-the-datasets-module","title":"Use the datasets module\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#use-the-inspector-tool","title":"Use the Inspector tool\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#data-visualization","title":"Data visualization\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#use-the-plotting-tool","title":"Use the Plotting tool\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#change-layer-opacity","title":"Change layer opacity\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#visualize-raster-data","title":"Visualize raster data\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#visualize-vector-data","title":"Visualize vector data\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#add-a-legend","title":"Add a legend\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#add-a-colorbar","title":"Add a colorbar\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#create-a-split-panel-map","title":"Create a split-panel map\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#create-linked-maps","title":"Create linked maps\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#create-timelapse-animations","title":"Create timelapse animations\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#create-time-series-composites","title":"Create time-series composites\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#data-analysis","title":"Data analysis\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#descriptive-statistics","title":"Descriptive statistics\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#zonal-statistics","title":"Zonal statistics\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#zonal-statistics-by-group","title":"Zonal statistics by group\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#unsupervised-classification","title":"Unsupervised classification\u00b6","text":"<p>Source: https://developers.google.com/earth-engine/guides/clustering</p> <p>The <code>ee.Clusterer</code> package handles unsupervised classification (or clustering) in Earth Engine. These algorithms are currently based on the algorithms with the same name in Weka. More details about each Clusterer are available in the reference docs in the Code Editor.</p> <p>Clusterers are used in the same manner as classifiers in Earth Engine. The general workflow for clustering is:</p> <ol> <li>Assemble features with numeric properties in which to find clusters.</li> <li>Instantiate a clusterer. Set its parameters if necessary.</li> <li>Train the clusterer using the training data.</li> <li>Apply the clusterer to an image or feature collection.</li> <li>Label the clusters.</li> </ol> <p>The training data is a <code>FeatureCollection</code> with properties that will be input to the clusterer. Unlike classifiers, there is no input class value for an <code>Clusterer</code>. Like classifiers, the data for the train and apply steps are expected to have the same number of values. When a trained clusterer is applied to an image or table, it assigns an integer cluster ID to each pixel or feature.</p> <p>Here is a simple example of building and using an ee.Clusterer:</p> <p></p>"},{"location":"workshops/GEE_Workshop_2021/#supervised-classification","title":"Supervised classification\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#training-sample-creation","title":"Training sample creation\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#whiteboxtools","title":"WhiteboxTools\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#map-making","title":"Map making\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#plot-a-single-band-image","title":"Plot a single band image\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#plot-an-rgb-image","title":"Plot an RGB image\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#add-map-elements","title":"Add map elements\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#plot-multiple-layers","title":"Plot multiple layers\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#use-custom-projections","title":"Use custom projections\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#data-export","title":"Data export\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#export-eeimage","title":"Export ee.Image\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#export-eeimagecollection","title":"Export ee.ImageCollection\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#extract-pixels-as-a-numpy-array","title":"Extract pixels as a numpy array\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#export-pixel-values-to-points","title":"Export pixel values to points\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#export-eefeaturecollection","title":"Export ee.FeatureCollection\u00b6","text":""},{"location":"workshops/GEE_Workshop_2021/#extracting-river-width-and-centerline","title":"Extracting river width and centerline\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/","title":"GEE Workshop 2022 Part1","text":"In\u00a0[\u00a0]: Copied! <pre># pip install geemap\n</pre> # pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>myList = ee.List.sequence(1, 10)\nprint(myList.getInfo())\n</pre> myList = ee.List.sequence(1, 10) print(myList.getInfo()) In\u00a0[\u00a0]: Copied! <pre>def computeSquares(number):\n    return ee.Number(number).pow(2)\n\n\nsquares = myList.map(computeSquares)\nprint(squares.getInfo())\n</pre> def computeSquares(number):     return ee.Number(number).pow(2)   squares = myList.map(computeSquares) print(squares.getInfo()) In\u00a0[\u00a0]: Copied! <pre>squares = myList.map(lambda number: ee.Number(number).pow(2))\nprint(squares.getInfo())\n</pre> squares = myList.map(lambda number: ee.Number(number).pow(2)) print(squares.getInfo()) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nfc = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017').filter(\n    ee.Filter.eq('country_na', 'Netherlands')\n)\n\nMap.addLayer(fc, {'color': 'ff000000'}, \"Netherlands\")\nMap.centerObject(fc)\nMap\n</pre> Map = geemap.Map() fc = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017').filter(     ee.Filter.eq('country_na', 'Netherlands') )  Map.addLayer(fc, {'color': 'ff000000'}, \"Netherlands\") Map.centerObject(fc) Map In\u00a0[\u00a0]: Copied! <pre>years = ee.List.sequence(2013, 2021)\n</pre> years = ee.List.sequence(2013, 2021) In\u00a0[\u00a0]: Copied! <pre>def yearly_image(year):\n    start_date = ee.Date.fromYMD(year, 1, 1)\n    end_date = start_date.advance(1, \"year\")\n\n    collection = (\n        ee.ImageCollection('LANDSAT/LC08/C01/T1')\n        .filterDate(start_date, end_date)\n        .filterBounds(fc)\n    )\n\n    image = ee.Algorithms.Landsat.simpleComposite(collection).clipToCollection(fc)\n\n    return image\n</pre> def yearly_image(year):     start_date = ee.Date.fromYMD(year, 1, 1)     end_date = start_date.advance(1, \"year\")      collection = (         ee.ImageCollection('LANDSAT/LC08/C01/T1')         .filterDate(start_date, end_date)         .filterBounds(fc)     )      image = ee.Algorithms.Landsat.simpleComposite(collection).clipToCollection(fc)      return image In\u00a0[\u00a0]: Copied! <pre>images = years.map(yearly_image)\n</pre> images = years.map(yearly_image) In\u00a0[\u00a0]: Copied! <pre>vis_params = {'bands': ['B5', 'B4', 'B3'], 'max': 128}\nfor index in range(0, 9):\n    image = ee.Image(images.get(index))\n    layer_name = \"Year \" + str(index + 2013)\n    Map.addLayer(image, vis_params, layer_name)\n</pre> vis_params = {'bands': ['B5', 'B4', 'B3'], 'max': 128} for index in range(0, 9):     image = ee.Image(images.get(index))     layer_name = \"Year \" + str(index + 2013)     Map.addLayer(image, vis_params, layer_name) In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\").filterMetadata(\n    'CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10\n)\n</pre> collection = ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\").filterMetadata(     'CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10 ) In\u00a0[\u00a0]: Copied! <pre>start_date = '2016-01-01'\nend_date = '2022-12-31'\nregion = ee.Geometry.BBox(-122.5549, 37.6968, -122.3446, 37.8111)\n</pre> start_date = '2016-01-01' end_date = '2022-12-31' region = ee.Geometry.BBox(-122.5549, 37.6968, -122.3446, 37.8111) In\u00a0[\u00a0]: Copied! <pre>images = geemap.create_timeseries(\n    collection, start_date, end_date, region, frequency='year', reducer='median'\n)\nimages.size().getInfo()\n</pre> images = geemap.create_timeseries(     collection, start_date, end_date, region, frequency='year', reducer='median' ) images.size().getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\nlabels = [str(y) for y in range(2016, 2023)]\n\nMap.addLayer(images, vis_params, \"Sentinel-2\", False)\nMap.add_time_slider(images, vis_params, time_interval=2, labels=labels)\nMap.centerObject(region)\nMap\n</pre> Map = geemap.Map()  vis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]} labels = [str(y) for y in range(2016, 2023)]  Map.addLayer(images, vis_params, \"Sentinel-2\", False) Map.add_time_slider(images, vis_params, time_interval=2, labels=labels) Map.centerObject(region) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-99.1019, 47.1274, -99.0334, 47.1562)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(-99.1019, 47.1274, -99.0334, 47.1562)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>collection = geemap.naip_timeseries(roi, start_year=2009, end_year=2022, RGBN=True)\n</pre> collection = geemap.naip_timeseries(roi, start_year=2009, end_year=2022, RGBN=True) In\u00a0[\u00a0]: Copied! <pre>years = geemap.image_dates(collection, date_format='YYYY').getInfo()\nprint(years)\n</pre> years = geemap.image_dates(collection, date_format='YYYY').getInfo() print(years) In\u00a0[\u00a0]: Copied! <pre>size = len(years)\nimages = collection.toList(size)\nfor i in range(size):\n    image = ee.Image(images.get(i))\n    Map.addLayer(image, {'bands': ['N', 'R', 'G']}, years[i])\nMap\n</pre> size = len(years) images = collection.toList(size) for i in range(size):     image = ee.Image(images.get(i))     Map.addLayer(image, {'bands': ['N', 'R', 'G']}, years[i]) Map In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.naip_timelapse(\n    roi,\n    out_gif=\"naip.gif\",\n    bands=['N', 'R', 'G'],\n    frames_per_second=3,\n    title='NAIP Timelapse',\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.naip_timelapse(     roi,     out_gif=\"naip.gif\",     bands=['N', 'R', 'G'],     frames_per_second=3,     title='NAIP Timelapse', ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif='landsat.gif',\n    start_year=1984,\n    end_year=2022,\n    start_date='01-01',\n    end_date='12-31',\n    bands=['SWIR1', 'NIR', 'Red'],\n    frames_per_second=5,\n    title='Landsat Timelapse',\n    progress_bar_color='blue',\n    mp4=True,\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif='landsat.gif',     start_year=1984,     end_year=2022,     start_date='01-01',     end_date='12-31',     bands=['SWIR1', 'NIR', 'Red'],     frames_per_second=5,     title='Landsat Timelapse',     progress_bar_color='blue',     mp4=True, ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nroi = ee.Geometry.BBox(-115.5541, 35.8044, -113.9035, 36.5581)\nMap.addLayer(roi)\nMap.centerObject(roi)\nMap\n</pre> Map = geemap.Map() roi = ee.Geometry.BBox(-115.5541, 35.8044, -113.9035, 36.5581) Map.addLayer(roi) Map.centerObject(roi) Map In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif='las_vegas.gif',\n    start_year=1984,\n    end_year=2022,\n    bands=['NIR', 'Red', 'Green'],\n    frames_per_second=5,\n    title='Las Vegas, NV',\n    font_color='blue',\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif='las_vegas.gif',     start_year=1984,     end_year=2022,     bands=['NIR', 'Red', 'Green'],     frames_per_second=5,     title='Las Vegas, NV',     font_color='blue', ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nroi = ee.Geometry.BBox(113.8252, 22.1988, 114.0851, 22.3497)\nMap.addLayer(roi)\nMap.centerObject(roi)\nMap\n</pre> Map = geemap.Map() roi = ee.Geometry.BBox(113.8252, 22.1988, 114.0851, 22.3497) Map.addLayer(roi) Map.centerObject(roi) Map In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif='hong_kong.gif',\n    start_year=1990,\n    end_year=2022,\n    start_date='01-01',\n    end_date='12-31',\n    bands=['SWIR1', 'NIR', 'Red'],\n    frames_per_second=3,\n    title='Hong Kong',\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif='hong_kong.gif',     start_year=1990,     end_year=2022,     start_date='01-01',     end_date='12-31',     bands=['SWIR1', 'NIR', 'Red'],     frames_per_second=3,     title='Hong Kong', ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(117.1132, 3.5227, 117.2214, 3.5843)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(117.1132, 3.5227, 117.2214, 3.5843)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.sentinel1_timelapse(\n    roi,\n    out_gif='sentinel1.gif',\n    start_year=2019,\n    end_year=2019,\n    start_date='04-01',\n    end_date='08-01',\n    frequency='day',\n    vis_params={\"min\": -30, \"max\": 0},\n    palette=\"Greys\",\n    frames_per_second=3,\n    title='Sentinel-1 Timelapse',\n    add_colorbar=True,\n    colorbar_bg_color='gray',\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.sentinel1_timelapse(     roi,     out_gif='sentinel1.gif',     start_year=2019,     end_year=2019,     start_date='04-01',     end_date='08-01',     frequency='day',     vis_params={\"min\": -30, \"max\": 0},     palette=\"Greys\",     frames_per_second=3,     title='Sentinel-1 Timelapse',     add_colorbar=True,     colorbar_bg_color='gray', ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.sentinel2_timelapse(\n    roi,\n    out_gif='sentinel2.gif',\n    start_year=2016,\n    end_year=2021,\n    start_date='01-01',\n    end_date='12-31',\n    frequency='year',\n    bands=['SWIR1', 'NIR', 'Red'],\n    frames_per_second=3,\n    title='Sentinel-2 Timelapse',\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.sentinel2_timelapse(     roi,     out_gif='sentinel2.gif',     start_year=2016,     end_year=2021,     start_date='01-01',     end_date='12-31',     frequency='year',     bands=['SWIR1', 'NIR', 'Red'],     frames_per_second=3,     title='Sentinel-2 Timelapse', ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-18.6983, -36.1630, 52.2293, 38.1446)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(-18.6983, -36.1630, 52.2293, 38.1446)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.modis_ndvi_timelapse(\n    roi,\n    out_gif='ndvi.gif',\n    data='Terra',\n    band='NDVI',\n    start_date='2000-01-01',\n    end_date='2021-12-31',\n    frames_per_second=3,\n    title='MODIS NDVI Timelapse',\n    overlay_data='countries',\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.modis_ndvi_timelapse(     roi,     out_gif='ndvi.gif',     data='Terra',     band='NDVI',     start_date='2000-01-01',     end_date='2021-12-31',     frames_per_second=3,     title='MODIS NDVI Timelapse',     overlay_data='countries', ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-171.21, -57.13, 177.53, 79.99)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(-171.21, -57.13, 177.53, 79.99)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.modis_ocean_color_timelapse(\n    satellite='Aqua',\n    start_date='2018-01-01',\n    end_date='2020-12-31',\n    roi=roi,\n    frequency='month',\n    out_gif='temperature.gif',\n    overlay_data='continents',\n    overlay_color='yellow',\n    overlay_opacity=0.5,\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.modis_ocean_color_timelapse(     satellite='Aqua',     start_date='2018-01-01',     end_date='2020-12-31',     roi=roi,     frequency='month',     out_gif='temperature.gif',     overlay_data='continents',     overlay_color='yellow',     overlay_opacity=0.5, ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(167.1898, -28.5757, 202.6258, -12.4411)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(167.1898, -28.5757, 202.6258, -12.4411)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>start_date = \"2022-01-15T03:00:00\"\nend_date = \"2022-01-15T07:00:00\"\ndata = \"GOES-17\"\nscan = \"full_disk\"\n</pre> start_date = \"2022-01-15T03:00:00\" end_date = \"2022-01-15T07:00:00\" data = \"GOES-17\" scan = \"full_disk\" In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.goes_timelapse(\n    roi, \"goes.gif\", start_date, end_date, data, scan, framesPerSecond=5\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.goes_timelapse(     roi, \"goes.gif\", start_date, end_date, data, scan, framesPerSecond=5 ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>roi = ee.Geometry.BBox(-159.5954, 24.5178, -114.2438, 60.4088)\nstart_date = \"2021-10-24T14:00:00\"\nend_date = \"2021-10-25T01:00:00\"\ndata = \"GOES-17\"\nscan = \"full_disk\"\n</pre> roi = ee.Geometry.BBox(-159.5954, 24.5178, -114.2438, 60.4088) start_date = \"2021-10-24T14:00:00\" end_date = \"2021-10-25T01:00:00\" data = \"GOES-17\" scan = \"full_disk\" In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.goes_timelapse(\n    roi, \"hurricane.gif\", start_date, end_date, data, scan, framesPerSecond=5\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.goes_timelapse(     roi, \"hurricane.gif\", start_date, end_date, data, scan, framesPerSecond=5 ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nroi = ee.Geometry.BBox(-121.0034, 36.8488, -117.9052, 39.0490)\nMap.addLayer(roi)\nMap.centerObject(roi)\nMap\n</pre> Map = geemap.Map() roi = ee.Geometry.BBox(-121.0034, 36.8488, -117.9052, 39.0490) Map.addLayer(roi) Map.centerObject(roi) Map In\u00a0[\u00a0]: Copied! <pre>start_date = \"2020-09-05T15:00:00\"\nend_date = \"2020-09-06T02:00:00\"\ndata = \"GOES-17\"\nscan = \"full_disk\"\n</pre> start_date = \"2020-09-05T15:00:00\" end_date = \"2020-09-06T02:00:00\" data = \"GOES-17\" scan = \"full_disk\" In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.goes_fire_timelapse(\n    roi, \"fire.gif\", start_date, end_date, data, scan, framesPerSecond=5\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.goes_fire_timelapse(     roi, \"fire.gif\", start_date, end_date, data, scan, framesPerSecond=5 ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>in_gif = \"https://i.imgur.com/ZWSZC5z.gif\"\n</pre> in_gif = \"https://i.imgur.com/ZWSZC5z.gif\" In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(in_gif)\n</pre> geemap.show_image(in_gif) In\u00a0[\u00a0]: Copied! <pre>out_gif = \"gif_fading.gif\"\ngeemap.gif_fading(in_gif, out_gif, verbose=False)\ngeemap.show_image(out_gif)\n</pre> out_gif = \"gif_fading.gif\" geemap.gif_fading(in_gif, out_gif, verbose=False) geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>roi = ee.Geometry.BBox(-69.3154, -22.8371, -69.1900, -22.7614)\n</pre> roi = ee.Geometry.BBox(-69.3154, -22.8371, -69.1900, -22.7614) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif='mines.gif',\n    start_year=2004,\n    end_year=2010,\n    frames_per_second=1,\n    title='Copper mines, Chile',\n    fading=True,\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif='mines.gif',     start_year=2004,     end_year=2010,     frames_per_second=1,     title='Copper mines, Chile',     fading=True, ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>url = 'https://github.com/gee-community/geemap/raw/master/examples/data/animation.gif'\nfilename = 'animation.gif'\ngeemap.download_file(url, filename)\n</pre> url = 'https://github.com/gee-community/geemap/raw/master/examples/data/animation.gif' filename = 'animation.gif' geemap.download_file(url, filename) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(filename)\n</pre> geemap.show_image(filename) In\u00a0[\u00a0]: Copied! <pre>out_gif = 'timelapse.gif'\ngeemap.add_text_to_gif(\n    filename,\n    out_gif,\n    xy=('5%', '5%'),\n    text_sequence=1984,\n    font_size=30,\n    font_color='#0000ff',\n    duration=100,\n)\n</pre> out_gif = 'timelapse.gif' geemap.add_text_to_gif(     filename,     out_gif,     xy=('5%', '5%'),     text_sequence=1984,     font_size=30,     font_color='#0000ff',     duration=100, ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>geemap.add_text_to_gif(\n    out_gif, out_gif, xy=('35%', '85%'), text_sequence=\"Las Vegas\", font_color='black'\n)\n</pre> geemap.add_text_to_gif(     out_gif, out_gif, xy=('35%', '85%'), text_sequence=\"Las Vegas\", font_color='black' ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\ngeemap.ee_initialize()\n\n# Define an area of interest geometry with a global non-polar extent.\naoi = ee.Geometry.Polygon(\n    [[[-179.0, 78.0], [-179.0, -58.0], [179.0, -58.0], [179.0, 78.0]]], None, False\n)\n\n# Import hourly predicted temperature image collection for northern winter\n# solstice. Note that predictions extend for 384 hours; limit the collection\n# to the first 24 hours.\ntempCol = (\n    ee.ImageCollection('NOAA/GFS0P25')\n    .filterDate('2018-12-22', '2018-12-23')\n    .limit(24)\n    .select('temperature_2m_above_ground')\n)\n\n# Define arguments for animation function parameters.\nvideoArgs = {\n    'dimensions': 768,\n    'region': aoi,\n    'framesPerSecond': 10,\n    'crs': 'EPSG:3857',\n    'min': -40.0,\n    'max': 35.0,\n    'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'],\n}\n</pre> import ee import geemap  geemap.ee_initialize()  # Define an area of interest geometry with a global non-polar extent. aoi = ee.Geometry.Polygon(     [[[-179.0, 78.0], [-179.0, -58.0], [179.0, -58.0], [179.0, 78.0]]], None, False )  # Import hourly predicted temperature image collection for northern winter # solstice. Note that predictions extend for 384 hours; limit the collection # to the first 24 hours. tempCol = (     ee.ImageCollection('NOAA/GFS0P25')     .filterDate('2018-12-22', '2018-12-23')     .limit(24)     .select('temperature_2m_above_ground') )  # Define arguments for animation function parameters. videoArgs = {     'dimensions': 768,     'region': aoi,     'framesPerSecond': 10,     'crs': 'EPSG:3857',     'min': -40.0,     'max': 35.0,     'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'], } In\u00a0[\u00a0]: Copied! <pre>saved_gif = 'temperature.gif'\ngeemap.download_ee_video(tempCol, videoArgs, saved_gif)\n</pre> saved_gif = 'temperature.gif' geemap.download_ee_video(tempCol, videoArgs, saved_gif) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(saved_gif)\n</pre> geemap.show_image(saved_gif) In\u00a0[\u00a0]: Copied! <pre>text = [str(n).zfill(2) + \":00\" for n in range(0, 24)]\nprint(text)\n</pre> text = [str(n).zfill(2) + \":00\" for n in range(0, 24)] print(text) In\u00a0[\u00a0]: Copied! <pre>out_gif = 'output2.gif'\n</pre> out_gif = 'output2.gif' In\u00a0[\u00a0]: Copied! <pre>geemap.add_text_to_gif(\n    saved_gif,\n    out_gif,\n    xy=('3%', '5%'),\n    text_sequence=text,\n    font_size=30,\n    font_color='#ffffff',\n)\n</pre> geemap.add_text_to_gif(     saved_gif,     out_gif,     xy=('3%', '5%'),     text_sequence=text,     font_size=30,     font_color='#ffffff', ) In\u00a0[\u00a0]: Copied! <pre>geemap.add_text_to_gif(\n    out_gif,\n    out_gif,\n    xy=('32%', '92%'),\n    text_sequence='NOAA GFS Hourly Temperature',\n    font_color='white',\n)\n</pre> geemap.add_text_to_gif(     out_gif,     out_gif,     xy=('32%', '92%'),     text_sequence='NOAA GFS Hourly Temperature',     font_color='white', ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>url = 'https://i.imgur.com/MSde1om.gif'\nin_gif = 'temp.gif'\ngeemap.download_file(url, 'temp.gif')\n</pre> url = 'https://i.imgur.com/MSde1om.gif' in_gif = 'temp.gif' geemap.download_file(url, 'temp.gif') In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(in_gif)\n</pre> geemap.show_image(in_gif) In\u00a0[\u00a0]: Copied! <pre>noaa_logo = 'https://bit.ly/3ahJoMq'\nee_logo = 'https://i.imgur.com/Qbvacvm.jpg'\n</pre> noaa_logo = 'https://bit.ly/3ahJoMq' ee_logo = 'https://i.imgur.com/Qbvacvm.jpg' In\u00a0[\u00a0]: Copied! <pre>out_gif = 'output.gif'\n</pre> out_gif = 'output.gif' In\u00a0[\u00a0]: Copied! <pre>geemap.add_image_to_gif(\n    in_gif, out_gif, in_image=noaa_logo, xy=('2%', '80%'), image_size=(80, 80)\n)\n</pre> geemap.add_image_to_gif(     in_gif, out_gif, in_image=noaa_logo, xy=('2%', '80%'), image_size=(80, 80) ) In\u00a0[\u00a0]: Copied! <pre>geemap.add_image_to_gif(\n    out_gif, out_gif, in_image=ee_logo, xy=('13%', '79%'), image_size=(85, 85)\n)\n</pre> geemap.add_image_to_gif(     out_gif, out_gif, in_image=ee_logo, xy=('13%', '79%'), image_size=(85, 85) ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif) In\u00a0[\u00a0]: Copied! <pre>width = 250\nheight = 30\npalette = ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']\nlabels = [-40, 35]\ncolorbar = geemap.create_colorbar(\n    width=width,\n    height=height,\n    palette=palette,\n    vertical=False,\n    add_labels=True,\n    font_size=20,\n    labels=labels,\n)\n</pre> width = 250 height = 30 palette = ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'] labels = [-40, 35] colorbar = geemap.create_colorbar(     width=width,     height=height,     palette=palette,     vertical=False,     add_labels=True,     font_size=20,     labels=labels, ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(colorbar)\n</pre> geemap.show_image(colorbar) In\u00a0[\u00a0]: Copied! <pre>geemap.add_image_to_gif(\n    out_gif, out_gif, in_image=colorbar, xy=('69%', '89%'), image_size=(250, 250)\n)\n</pre> geemap.add_image_to_gif(     out_gif, out_gif, in_image=colorbar, xy=('69%', '89%'), image_size=(250, 250) ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_image(out_gif)\n</pre> geemap.show_image(out_gif)"},{"location":"workshops/GEE_Workshop_2022_Part1/#creating-satellite-image-time-series-and-timelapse-animations","title":"Creating Satellite Image Time Series and Timelapse Animations\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#the-map-function","title":"The map function\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#creating-cloud-free-composites","title":"Creating cloud-free composites\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#creating-timeseries","title":"Creating timeseries\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#naip-timelapse","title":"NAIP timelapse\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#landsat-timelapse","title":"Landsat timelapse\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#sentinel-1-timelapse","title":"Sentinel-1 timelapse\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#sentinel-2-timelapse","title":"Sentinel-2 timelapse\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#modis-timelapse","title":"MODIS timelapse\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#modis-ndvi","title":"MODIS NDVI\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#modis-temperature","title":"MODIS temperature\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#goes-timelapse","title":"GOES timelapse\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#fading-effects","title":"Fading effects\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#adding-animated-text","title":"Adding animated text\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#add-animated-text-to-an-existing-gif","title":"Add animated text to an existing GIF\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#add-animated-text-to-gif","title":"Add animated text to GIF\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#add-place-name","title":"Add place name\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#create-gif-from-earth-engine-data","title":"Create GIF from Earth Engine data\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#prepare-for-an-imagecollection","title":"Prepare for an ImageCollection\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#save-the-gif-to-local-drive","title":"Save the GIF to local drive\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#generate-an-hourly-text-sequence","title":"Generate an hourly text sequence\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#add-text-to-gif","title":"Add text to GIF\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#adding-colorbar-to-an-image","title":"Adding colorbar to an image\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#download-a-gif","title":"Download a GIF\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#get-image-urls","title":"Get image URLs\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#set-output-gif-path","title":"Set output GIF path\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#add-images-to-gif","title":"Add images to GIF\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#display-output-gif","title":"Display output GIF\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#create-a-colorbar","title":"Create a colorbar\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part1/#add-colorbar-to-gif","title":"Add colorbar to GIF\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part2/","title":"GEE Workshop 2022 Part2","text":"In\u00a0[\u00a0]: Copied! <pre># pip install geemap\n</pre> # pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map In\u00a0[\u00a0]: Copied! <pre># Set the region of interest by simply drawing a polygon on the map\nregion = Map.user_roi\nif region is None:\n    region = ee.Geometry.BBox(-89.7088, 42.9006, -89.0647, 43.2167)\n    Map.addLayer(region, {}, 'Region')\n\nMap.centerObject(region)\n</pre> # Set the region of interest by simply drawing a polygon on the map region = Map.user_roi if region is None:     region = ee.Geometry.BBox(-89.7088, 42.9006, -89.0647, 43.2167)     Map.addLayer(region, {}, 'Region')  Map.centerObject(region) In\u00a0[\u00a0]: Copied! <pre># Set the date range\nstart_date = '2021-01-01'\nend_date = '2022-01-01'\n</pre> # Set the date range start_date = '2021-01-01' end_date = '2022-01-01' In\u00a0[\u00a0]: Copied! <pre># Create a Sentinel-2 image composite\nimage = geemap.dynamic_world_s2(region, start_date, end_date, clip=True)\nvis_params = {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 3000}\nMap.addLayer(image, vis_params, 'Sentinel-2 image')\n</pre> # Create a Sentinel-2 image composite image = geemap.dynamic_world_s2(region, start_date, end_date, clip=True) vis_params = {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 3000} Map.addLayer(image, vis_params, 'Sentinel-2 image') In\u00a0[\u00a0]: Copied! <pre># Create Dynamic World land cover composite\nlandcover = geemap.dynamic_world(\n    region, start_date, end_date, clip=True, return_type='class'\n)\n\ndwVisParams = {\n    \"min\": 0,\n    \"max\": 8,\n    \"palette\": [\n        \"#419BDF\",\n        \"#397D49\",\n        \"#88B053\",\n        \"#7A87C6\",\n        \"#E49635\",\n        \"#DFC35A\",\n        \"#C4281B\",\n        \"#A59B8F\",\n        \"#B39FE1\",\n    ],\n}\n\nMap.addLayer(landcover, dwVisParams, 'Land Cover Class')\nMap\n</pre> # Create Dynamic World land cover composite landcover = geemap.dynamic_world(     region, start_date, end_date, clip=True, return_type='class' )  dwVisParams = {     \"min\": 0,     \"max\": 8,     \"palette\": [         \"#419BDF\",         \"#397D49\",         \"#88B053\",         \"#7A87C6\",         \"#E49635\",         \"#DFC35A\",         \"#C4281B\",         \"#A59B8F\",         \"#B39FE1\",     ], }  Map.addLayer(landcover, dwVisParams, 'Land Cover Class') Map In\u00a0[\u00a0]: Copied! <pre>Map.add_legend(title='Dynamic World Land Cover', builtin_legend='Dynamic_World')\n</pre> Map.add_legend(title='Dynamic World Land Cover', builtin_legend='Dynamic_World') In\u00a0[\u00a0]: Copied! <pre>landcover = geemap.dynamic_world(\n    region, start_date, end_date, clip=True, return_type='visualize'\n)\nMap.addLayer(landcover, {}, 'Land Cover Visualize')\n</pre> landcover = geemap.dynamic_world(     region, start_date, end_date, clip=True, return_type='visualize' ) Map.addLayer(landcover, {}, 'Land Cover Visualize') In\u00a0[\u00a0]: Copied! <pre>landcover = geemap.dynamic_world(\n    region, start_date, end_date, clip=True, return_type='probability'\n)\nMap.addLayer(landcover, {}, 'Land Cover Probability')\n</pre> landcover = geemap.dynamic_world(     region, start_date, end_date, clip=True, return_type='probability' ) Map.addLayer(landcover, {}, 'Land Cover Probability') In\u00a0[\u00a0]: Copied! <pre># Create Dynamic World land cover composite\nlandcover = geemap.dynamic_world(\n    region, start_date, end_date, clip=True, return_type='hillshade'\n)\nMap.addLayer(landcover, {}, 'Land Cover')\n</pre> # Create Dynamic World land cover composite landcover = geemap.dynamic_world(     region, start_date, end_date, clip=True, return_type='hillshade' ) Map.addLayer(landcover, {}, 'Land Cover') <p>Visualizing ESA Global Land Cover.</p> In\u00a0[\u00a0]: Copied! <pre>start_date = '2021-01-01'\nend_date = '2022-01-01'\nregion = ee.Geometry.BBox(-179, -89, 179, 89)\n</pre> start_date = '2021-01-01' end_date = '2022-01-01' region = ee.Geometry.BBox(-179, -89, 179, 89) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nesa = ee.ImageCollection(\"ESA/WorldCover/v200\").first()\nesa_vis = {'bands': ['Map']}\n\nMap.addLayer(esa, esa_vis, \"ESA LC 2021\")\nMap.add_legend(title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover')\n\nMap\n</pre> Map = geemap.Map()  esa = ee.ImageCollection(\"ESA/WorldCover/v200\").first() esa_vis = {'bands': ['Map']}  Map.addLayer(esa, esa_vis, \"ESA LC 2021\") Map.add_legend(title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover')  Map <p>Visualizing ESRI Global Land Cover.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nesri = (\n    ee.ImageCollection(\n        \"projects/sat-io/open-datasets/landcover/ESRI_Global-LULC_10m_TS\"\n    )\n    .filterDate(start_date, end_date)\n    .mosaic()\n)\nesri_vis = {\n    'min': 1,\n    'max': 11,\n    'palette': [\n        \"#1A5BAB\",\n        \"#358221\",\n        \"#000000\",\n        \"#87D19E\",\n        \"#FFDB5C\",\n        \"#000000\",\n        \"#ED022A\",\n        \"#EDE9E4\",\n        \"#F2FAFF\",\n        \"#C8C8C8\",\n        \"#C6AD8D\",\n    ],\n}\n\nMap.addLayer(esri, esri_vis, \"ESRI LC 2021\")\nMap.add_legend(title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover_TS')\n\nMap\n</pre> Map = geemap.Map()  esri = (     ee.ImageCollection(         \"projects/sat-io/open-datasets/landcover/ESRI_Global-LULC_10m_TS\"     )     .filterDate(start_date, end_date)     .mosaic() ) esri_vis = {     'min': 1,     'max': 11,     'palette': [         \"#1A5BAB\",         \"#358221\",         \"#000000\",         \"#87D19E\",         \"#FFDB5C\",         \"#000000\",         \"#ED022A\",         \"#EDE9E4\",         \"#F2FAFF\",         \"#C8C8C8\",         \"#C6AD8D\",     ], }  Map.addLayer(esri, esri_vis, \"ESRI LC 2021\") Map.add_legend(title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover_TS')  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndw_class = geemap.dynamic_world(region, start_date, end_date, return_type='class')\ndw = geemap.dynamic_world(region, start_date, end_date, return_type='hillshade')\n\ndw_vis = {\n    \"min\": 0,\n    \"max\": 8,\n    \"palette\": [\n        \"#419BDF\",\n        \"#397D49\",\n        \"#88B053\",\n        \"#7A87C6\",\n        \"#E49635\",\n        \"#DFC35A\",\n        \"#C4281B\",\n        \"#A59B8F\",\n        \"#B39FE1\",\n    ],\n}\n\nMap.addLayer(dw_class, dw_vis, 'DW LC 2021', False)\nMap.addLayer(dw, {}, 'DW LC Hillshade')\n\nMap.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')\nMap.setCenter(-88.9088, 43.0006, 12)\nMap\n</pre> Map = geemap.Map()  dw_class = geemap.dynamic_world(region, start_date, end_date, return_type='class') dw = geemap.dynamic_world(region, start_date, end_date, return_type='hillshade')  dw_vis = {     \"min\": 0,     \"max\": 8,     \"palette\": [         \"#419BDF\",         \"#397D49\",         \"#88B053\",         \"#7A87C6\",         \"#E49635\",         \"#DFC35A\",         \"#C4281B\",         \"#A59B8F\",         \"#B39FE1\",     ], }  Map.addLayer(dw_class, dw_vis, 'DW LC 2021', False) Map.addLayer(dw, {}, 'DW LC Hillshade')  Map.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World') Map.setCenter(-88.9088, 43.0006, 12) Map <p>Comparing Dynamic World and ESA Land Cover.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[39.3322, -106.7349], zoom=10)\n\nleft_layer = geemap.ee_tile_layer(esa, esa_vis, \"ESA LC\")\nright_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World LC\")\n\nMap.split_map(left_layer, right_layer)\nMap.add_legend(\n    title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover', position='bottomleft'\n)\nMap.add_legend(\n    title=\"Dynamic World Land Cover\",\n    builtin_legend='Dynamic_World',\n    position='bottomright',\n)\nMap.setCenter(-88.9088, 43.0006, 12)\n\nMap\n</pre> Map = geemap.Map(center=[39.3322, -106.7349], zoom=10)  left_layer = geemap.ee_tile_layer(esa, esa_vis, \"ESA LC\") right_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World LC\")  Map.split_map(left_layer, right_layer) Map.add_legend(     title=\"ESA Land Cover\", builtin_legend='ESA_WorldCover', position='bottomleft' ) Map.add_legend(     title=\"Dynamic World Land Cover\",     builtin_legend='Dynamic_World',     position='bottomright', ) Map.setCenter(-88.9088, 43.0006, 12)  Map <p>Comparing Dynamic World with ESRI Land Cover.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[-89.3998, 43.0886], zoom=10)\n\nleft_layer = geemap.ee_tile_layer(esri, esri_vis, \"ESRI LC\")\nright_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World LC\")\n\nMap.split_map(left_layer, right_layer)\nMap.add_legend(\n    title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover_TS', position='bottomleft'\n)\nMap.add_legend(\n    title=\"Dynamic World Land Cover\",\n    builtin_legend='Dynamic_World',\n    position='bottomright',\n)\nMap.setCenter(-88.9088, 43.0006, 12)\n\nMap\n</pre> Map = geemap.Map(center=[-89.3998, 43.0886], zoom=10)  left_layer = geemap.ee_tile_layer(esri, esri_vis, \"ESRI LC\") right_layer = geemap.ee_tile_layer(dw, {}, \"Dynamic World LC\")  Map.split_map(left_layer, right_layer) Map.add_legend(     title=\"ESRI Land Cover\", builtin_legend='ESRI_LandCover_TS', position='bottomleft' ) Map.add_legend(     title=\"Dynamic World Land Cover\",     builtin_legend='Dynamic_World',     position='bottomright', ) Map.setCenter(-88.9088, 43.0006, 12)  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map In\u00a0[\u00a0]: Copied! <pre># Set the region of interest by simply drawing a polygon on the map\nregion = Map.user_roi\nif region is None:\n    region = ee.Geometry.BBox(-89.7088, 42.9006, -89.0647, 43.2167)\n    Map.addLayer(region, {}, 'Region')\n\nMap.centerObject(region)\n</pre> # Set the region of interest by simply drawing a polygon on the map region = Map.user_roi if region is None:     region = ee.Geometry.BBox(-89.7088, 42.9006, -89.0647, 43.2167)     Map.addLayer(region, {}, 'Region')  Map.centerObject(region) In\u00a0[\u00a0]: Copied! <pre># Set the date range\nstart_date = '2017-01-01'\nend_date = '2023-01-01'\n</pre> # Set the date range start_date = '2017-01-01' end_date = '2023-01-01' In\u00a0[\u00a0]: Copied! <pre>images = geemap.dynamic_world_timeseries(\n    region, start_date, end_date, frequency='year', return_type=\"class\"\n)\n</pre> images = geemap.dynamic_world_timeseries(     region, start_date, end_date, frequency='year', return_type=\"class\" ) In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    \"min\": 0,\n    \"max\": 8,\n    \"palette\": [\n        \"#419BDF\",\n        \"#397D49\",\n        \"#88B053\",\n        \"#7A87C6\",\n        \"#E49635\",\n        \"#DFC35A\",\n        \"#C4281B\",\n        \"#A59B8F\",\n        \"#B39FE1\",\n    ],\n}\nMap.addLayer(images.first(), vis_params, 'First image')\nMap.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')\nMap\n</pre> vis_params = {     \"min\": 0,     \"max\": 8,     \"palette\": [         \"#419BDF\",         \"#397D49\",         \"#88B053\",         \"#7A87C6\",         \"#E49635\",         \"#DFC35A\",         \"#C4281B\",         \"#A59B8F\",         \"#B39FE1\",     ], } Map.addLayer(images.first(), vis_params, 'First image') Map.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World') Map In\u00a0[\u00a0]: Copied! <pre>Map.ts_inspector(images, left_vis=vis_params, date_format='YYYY')\n</pre> Map.ts_inspector(images, left_vis=vis_params, date_format='YYYY') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap.centerObject(region)\n\nimages = geemap.dynamic_world_timeseries(\n    region, start_date, end_date, frequency='year', return_type=\"hillshade\"\n)\nMap.ts_inspector(images, date_format='YYYY')\nMap.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')\n\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map.centerObject(region)  images = geemap.dynamic_world_timeseries(     region, start_date, end_date, frequency='year', return_type=\"hillshade\" ) Map.ts_inspector(images, date_format='YYYY') Map.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')  Map <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ndataset = ee.ImageCollection(\"ESA/WorldCover/v200\").first()\nMap.addLayer(dataset, {'bands': ['Map']}, 'ESA Land Cover')\nMap.add_legend(title='ESA Land Cover Type', builtin_legend='ESA_WorldCover')\nMap\n</pre> Map = geemap.Map() dataset = ee.ImageCollection(\"ESA/WorldCover/v200\").first() Map.addLayer(dataset, {'bands': ['Map']}, 'ESA Land Cover') Map.add_legend(title='ESA Land Cover Type', builtin_legend='ESA_WorldCover') Map In\u00a0[\u00a0]: Copied! <pre>df = geemap.image_area_by_group(\n    dataset, scale=1000, denominator=1e6, decimal_places=4, verbose=True\n)\ndf\n</pre> df = geemap.image_area_by_group(     dataset, scale=1000, denominator=1e6, decimal_places=4, verbose=True ) df In\u00a0[\u00a0]: Copied! <pre>df.to_csv('esa2021.csv')\n</pre> df.to_csv('esa2021.csv') In\u00a0[\u00a0]: Copied! <pre>esa_dict = {\n    \"10 Trees\": \"006400\",\n    \"20 Shrubland\": \"ffbb22\",\n    \"30 Grassland\": \"ffff4c\",\n    \"40 Cropland\": \"f096ff\",\n    \"50 Built-up\": \"fa0000\",\n    \"60 Barren / sparse vegetation\": \"b4b4b4\",\n    \"70 Snow and ice\": \"f0f0f0\",\n    \"80 Open water\": \"0064c8\",\n    \"90 Herbaceous wetland\": \"0096a0\",\n    \"95 Mangroves\": \"00cf75\",\n    \"100 Moss and lichen\": \"fae6a0\",\n}\nclasses = list(esa_dict.keys())\nclasses\n</pre> esa_dict = {     \"10 Trees\": \"006400\",     \"20 Shrubland\": \"ffbb22\",     \"30 Grassland\": \"ffff4c\",     \"40 Cropland\": \"f096ff\",     \"50 Built-up\": \"fa0000\",     \"60 Barren / sparse vegetation\": \"b4b4b4\",     \"70 Snow and ice\": \"f0f0f0\",     \"80 Open water\": \"0064c8\",     \"90 Herbaceous wetland\": \"0096a0\",     \"95 Mangroves\": \"00cf75\",     \"100 Moss and lichen\": \"fae6a0\", } classes = list(esa_dict.keys()) classes In\u00a0[\u00a0]: Copied! <pre>df['class'] = classes\n</pre> df['class'] = classes In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    df,\n    x='class',\n    y='area',\n    x_label='Land Cover Type',\n    y_label='Area (km2)',\n)\n</pre> geemap.bar_chart(     df,     x='class',     y='area',     x_label='Land Cover Type',     y_label='Area (km2)', ) In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(df, names='class', values='area', height=500)\n</pre> geemap.pie_chart(df, names='class', values='area', height=500) In\u00a0[\u00a0]: Copied! <pre>countries = ee.FeatureCollection(geemap.examples.get_ee_path('countries'))\nMap.addLayer(countries, {}, 'Countries')\nMap\n</pre> countries = ee.FeatureCollection(geemap.examples.get_ee_path('countries')) Map.addLayer(countries, {}, 'Countries') Map In\u00a0[\u00a0]: Copied! <pre>geemap.zonal_stats_by_group(\n    dataset,\n    countries,\n    'esa_2021_country.csv',\n    statistics_type='SUM',\n    denominator=1e6,\n    scale=1000,\n)\n</pre> geemap.zonal_stats_by_group(     dataset,     countries,     'esa_2021_country.csv',     statistics_type='SUM',     denominator=1e6,     scale=1000, ) In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    'esa_2021_country.csv',\n    x='NAME',\n    y='Class_10',\n    max_rows=30,\n    x_label='Country',\n    y_label='Forest Area (km2)',\n)\n</pre> geemap.bar_chart(     'esa_2021_country.csv',     x='NAME',     y='Class_10',     max_rows=30,     x_label='Country',     y_label='Forest Area (km2)', ) In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    'esa_2021_country.csv',\n    x='NAME',\n    y='Class_40',\n    max_rows=30,\n    x_label='Country',\n    y_label='Cropland Area (km2)',\n)\n</pre> geemap.bar_chart(     'esa_2021_country.csv',     x='NAME',     y='Class_40',     max_rows=30,     x_label='Country',     y_label='Cropland Area (km2)', ) In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    'esa_2021_country.csv',\n    x='NAME',\n    y=['Class_10', 'Class_20', 'Class_30', 'Class_40'],\n    max_rows=10,\n    x_label='Country',\n)\n</pre> geemap.bar_chart(     'esa_2021_country.csv',     x='NAME',     y=['Class_10', 'Class_20', 'Class_30', 'Class_40'],     max_rows=10,     x_label='Country', ) In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(\n    'esa_2021_country.csv', names='NAME', values='Class_10', max_rows=30, height=500\n)\n</pre> geemap.pie_chart(     'esa_2021_country.csv', names='NAME', values='Class_10', max_rows=30, height=500 ) In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(\n    'esa_2021_country.csv', names='NAME', values='Class_40', max_rows=30, height=500\n)\n</pre> geemap.pie_chart(     'esa_2021_country.csv', names='NAME', values='Class_40', max_rows=30, height=500 ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') In\u00a0[\u00a0]: Copied! <pre>dataset = ee.Image('UMD/hansen/global_forest_change_2021_v1_9')\n</pre> dataset = ee.Image('UMD/hansen/global_forest_change_2021_v1_9') In\u00a0[\u00a0]: Copied! <pre>dataset.bandNames().getInfo()\n</pre> dataset.bandNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>first_bands = ['first_b50', 'first_b40', 'first_b30']\nfirst_image = dataset.select(first_bands)\nMap.addLayer(first_image, {'bands': first_bands, 'gamma': 1.5}, 'Year 2000 Bands 5/4/3')\nMap\n</pre> first_bands = ['first_b50', 'first_b40', 'first_b30'] first_image = dataset.select(first_bands) Map.addLayer(first_image, {'bands': first_bands, 'gamma': 1.5}, 'Year 2000 Bands 5/4/3') Map In\u00a0[\u00a0]: Copied! <pre>last_bands = ['last_b50', 'last_b40', 'last_b30']\nlast_image = dataset.select(last_bands)\nMap.addLayer(last_image, {'bands': last_bands, 'gamma': 1.5}, 'Year 2021 Bands 5/4/3')\n</pre> last_bands = ['last_b50', 'last_b40', 'last_b30'] last_image = dataset.select(last_bands) Map.addLayer(last_image, {'bands': last_bands, 'gamma': 1.5}, 'Year 2021 Bands 5/4/3') In\u00a0[\u00a0]: Copied! <pre>treecover = dataset.select(['treecover2000'])\n\ntreeCoverVisParam = {'min': 0, 'max': 100, 'palette': ['black', 'green']}\n\nname1 = 'Tree cover (%)'\nMap.addLayer(treecover, treeCoverVisParam, name1)\nMap.add_colorbar(treeCoverVisParam, label=name1, layer_name=name1)\nMap\n</pre> treecover = dataset.select(['treecover2000'])  treeCoverVisParam = {'min': 0, 'max': 100, 'palette': ['black', 'green']}  name1 = 'Tree cover (%)' Map.addLayer(treecover, treeCoverVisParam, name1) Map.add_colorbar(treeCoverVisParam, label=name1, layer_name=name1) Map In\u00a0[\u00a0]: Copied! <pre>threshold = 10\ntreecover_bin = treecover.gte(threshold).selfMask()\ntreeVisParam = {'palette': ['green']}\nMap.addLayer(treecover_bin, treeVisParam, 'Tree cover bin')\n</pre> threshold = 10 treecover_bin = treecover.gte(threshold).selfMask() treeVisParam = {'palette': ['green']} Map.addLayer(treecover_bin, treeVisParam, 'Tree cover bin') In\u00a0[\u00a0]: Copied! <pre>treeloss_year = dataset.select(['lossyear'])\n\ntreeLossVisParam = {'min': 0, 'max': 21, 'palette': ['yellow', 'red']}\n\nlayer_name = 'Tree loss year'\nMap.addLayer(treeloss_year, treeLossVisParam, layer_name)\nMap.add_colorbar(treeLossVisParam, label=layer_name, layer_name=layer_name)\n</pre> treeloss_year = dataset.select(['lossyear'])  treeLossVisParam = {'min': 0, 'max': 21, 'palette': ['yellow', 'red']}  layer_name = 'Tree loss year' Map.addLayer(treeloss_year, treeLossVisParam, layer_name) Map.add_colorbar(treeLossVisParam, label=layer_name, layer_name=layer_name) In\u00a0[\u00a0]: Copied! <pre>treeloss = dataset.select(['loss']).selfMask()\nMap.addLayer(treeloss, {'palette': 'red'}, 'Tree loss')\nMap\n</pre> treeloss = dataset.select(['loss']).selfMask() Map.addLayer(treeloss, {'palette': 'red'}, 'Tree loss') Map In\u00a0[\u00a0]: Copied! <pre>treegain = dataset.select(['gain']).selfMask()\nMap.addLayer(treegain, {'palette': 'yellow'}, 'Tree gain')\nMap\n</pre> treegain = dataset.select(['gain']).selfMask() Map.addLayer(treegain, {'palette': 'yellow'}, 'Tree gain') Map In\u00a0[\u00a0]: Copied! <pre>countries = ee.FeatureCollection(geemap.examples.get_ee_path('countries'))\n</pre> countries = ee.FeatureCollection(geemap.examples.get_ee_path('countries')) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_df(countries)\n</pre> geemap.ee_to_df(countries) In\u00a0[\u00a0]: Copied! <pre>style = {'color': '#ffff0088', 'fillColor': '#00000000'}\nMap.addLayer(countries.style(**style), {}, 'Countries')\n</pre> style = {'color': '#ffff0088', 'fillColor': '#00000000'} Map.addLayer(countries.style(**style), {}, 'Countries') <p>Forest area analysis</p> In\u00a0[\u00a0]: Copied! <pre>geemap.zonal_stats_by_group(\n    treecover_bin,\n    countries,\n    'forest_cover.csv',\n    statistics_type='SUM',\n    denominator=1e6,\n    scale=1000,\n)\n</pre> geemap.zonal_stats_by_group(     treecover_bin,     countries,     'forest_cover.csv',     statistics_type='SUM',     denominator=1e6,     scale=1000, ) In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(\n    'forest_cover.csv', names='NAME', values='Class_sum', max_rows=20, height=600\n)\n</pre> geemap.pie_chart(     'forest_cover.csv', names='NAME', values='Class_sum', max_rows=20, height=600 ) In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    'forest_cover.csv',\n    x='NAME',\n    y='Class_sum',\n    max_rows=20,\n    x_label='Country',\n    y_label='Forest area (km2)',\n)\n</pre> geemap.bar_chart(     'forest_cover.csv',     x='NAME',     y='Class_sum',     max_rows=20,     x_label='Country',     y_label='Forest area (km2)', ) <p>Forest loss analysis.</p> In\u00a0[\u00a0]: Copied! <pre>geemap.zonal_stats_by_group(\n    treeloss,\n    countries,\n    'treeloss.csv',\n    statistics_type='SUM',\n    denominator=1e6,\n    scale=1000,\n)\n</pre> geemap.zonal_stats_by_group(     treeloss,     countries,     'treeloss.csv',     statistics_type='SUM',     denominator=1e6,     scale=1000, ) In\u00a0[\u00a0]: Copied! <pre>geemap.pie_chart(\n    'treeloss.csv', names='NAME', values='Class_sum', max_rows=20, height=600\n)\n</pre> geemap.pie_chart(     'treeloss.csv', names='NAME', values='Class_sum', max_rows=20, height=600 ) In\u00a0[\u00a0]: Copied! <pre>geemap.bar_chart(\n    'treeloss.csv',\n    x='NAME',\n    y='Class_sum',\n    max_rows=20,\n    x_label='Country',\n    y_label='Forest loss area (km2)',\n)\n</pre> geemap.bar_chart(     'treeloss.csv',     x='NAME',     y='Class_sum',     max_rows=20,     x_label='Country',     y_label='Forest loss area (km2)', ) In\u00a0[\u00a0]: Copied! <pre>dataset = ee.Image('JRC/GSW1_3/GlobalSurfaceWater')\ndataset.bandNames().getInfo()\n</pre> dataset = ee.Image('JRC/GSW1_3/GlobalSurfaceWater') dataset.bandNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\n\nimage = dataset.select(['occurrence'])\nregion = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531)\n\nvis_params = {'min': 0.0, 'max': 100.0, 'palette': ['ffffff', 'ffbbbb', '0000ff']}\n\nMap.addLayer(image, vis_params, 'Occurrence')\nMap.addLayer(region, {}, 'ROI', True, 0.5)\nMap.centerObject(region)\nMap.add_colorbar(vis_params, label='Water occurrence (%)', layer_name='Occurrence')\n\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID')  image = dataset.select(['occurrence']) region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531)  vis_params = {'min': 0.0, 'max': 100.0, 'palette': ['ffffff', 'ffbbbb', '0000ff']}  Map.addLayer(image, vis_params, 'Occurrence') Map.addLayer(region, {}, 'ROI', True, 0.5) Map.centerObject(region) Map.add_colorbar(vis_params, label='Water occurrence (%)', layer_name='Occurrence')  Map In\u00a0[\u00a0]: Copied! <pre>hist = geemap.image_histogram(\n    image,\n    region,\n    scale=30,\n    x_label='Frequency',\n    y_label='Pixel Count',\n    title='Water Occurrence',\n    return_df=False,\n)\nhist\n</pre> hist = geemap.image_histogram(     image,     region,     scale=30,     x_label='Frequency',     y_label='Pixel Count',     title='Water Occurrence',     return_df=False, ) hist In\u00a0[\u00a0]: Copied! <pre>dataset = ee.ImageCollection('JRC/GSW1_3/MonthlyHistory')\nsize = dataset.size()\nprint(size.getInfo())\n</pre> dataset = ee.ImageCollection('JRC/GSW1_3/MonthlyHistory') size = dataset.size() print(size.getInfo()) In\u00a0[\u00a0]: Copied! <pre># dataset.aggregate_array(\"system:index\").getInfo()\n</pre> # dataset.aggregate_array(\"system:index\").getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = dataset.filterDate('2020-08-01', '2020-09-01').first()\nregion = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531)\n\nvis_params = {'min': 0.0, 'max': 2.0, 'palette': ['ffffff', 'fffcb8', '0905ff']}\n\nMap.addLayer(image, vis_params, 'Water')\nMap.addLayer(region, {}, 'ROI', True, 0.5)\nMap.centerObject(region)\nMap\n</pre> Map = geemap.Map()  image = dataset.filterDate('2020-08-01', '2020-09-01').first() region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531)  vis_params = {'min': 0.0, 'max': 2.0, 'palette': ['ffffff', 'fffcb8', '0905ff']}  Map.addLayer(image, vis_params, 'Water') Map.addLayer(region, {}, 'ROI', True, 0.5) Map.centerObject(region) Map In\u00a0[\u00a0]: Copied! <pre>df = geemap.jrc_hist_monthly_history(\n    region=region, scale=30, frequency='month', denominator=1e4, return_df=True\n)\ndf\n</pre> df = geemap.jrc_hist_monthly_history(     region=region, scale=30, frequency='month', denominator=1e4, return_df=True ) df In\u00a0[\u00a0]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region, scale=30, frequency='month', denominator=1e4, y_label='Area (ha)'\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region, scale=30, frequency='month', denominator=1e4, y_label='Area (ha)' ) In\u00a0[\u00a0]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency='month',\n    y_label='Area (ha)',\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency='month',     y_label='Area (ha)', ) In\u00a0[\u00a0]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency='month',\n    y_label='Area (ha)',\n    color='month',\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency='month',     y_label='Area (ha)',     color='month', ) In\u00a0[\u00a0]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency='year',\n    reducer='mean',\n    y_label='Area (ha)',\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency='year',     reducer='mean',     y_label='Area (ha)', ) In\u00a0[\u00a0]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency='year',\n    reducer='max',\n    y_label='Area (ha)',\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency='year',     reducer='max',     y_label='Area (ha)', )"},{"location":"workshops/GEE_Workshop_2022_Part2/#visualizing-and-analyzing-global-land-cover-data","title":"Visualizing and Analyzing Global Land Cover Data\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part2/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part2/#visualizing-global-land-cover-data-products","title":"Visualizing Global Land Cover Data Products\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part2/#creating-dynamic-world-land-cover-composites","title":"Creating Dynamic World Land Cover Composites\u00b6","text":"<ul> <li>App: https://www.dynamicworld.app</li> <li>App2: https://earthoutreach.users.earthengine.app/view/dynamicworld</li> <li>Paper: https://doi.org/10.1038/s41597-022-01307-4</li> <li>Model: https://github.com/google/dynamicworld</li> <li>Training data: https://doi.pangaea.de/10.1594/PANGAEA.933475</li> <li>Data: https://developers.google.com/earth-engine/datasets/catalog/GOOGLE_DYNAMICWORLD_V1</li> <li>JavaScript tutorial: https://developers.google.com/earth-engine/tutorials/community/introduction-to-dynamic-world-pt-1</li> </ul>"},{"location":"workshops/GEE_Workshop_2022_Part2/#comparing-global-land-cover-data-products","title":"Comparing Global Land Cover Data Products\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part2/#creating-dynamic-world-time-series","title":"Creating Dynamic World Time Series\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part2/#analyzing-global-land-cover-data","title":"Analyzing Global Land Cover Data\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part2/#forest-cover-change-analysis","title":"Forest cover change analysis\u00b6","text":"<p>https://developers.google.com/earth-engine/datasets/catalog/UMD_hansen_global_forest_change_2021_v1_9</p>"},{"location":"workshops/GEE_Workshop_2022_Part2/#surface-water-change-analysis","title":"Surface water change analysis\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part2/#surface-water-occurrence","title":"Surface water occurrence\u00b6","text":""},{"location":"workshops/GEE_Workshop_2022_Part2/#surace-water-monthly-history","title":"Surace water monthly history\u00b6","text":""},{"location":"workshops/GeoPython_2021/","title":"GeoPython 2021","text":"<p>Interactive mapping and analysis of geospatial big data using geemap and Google Earth Engine</p> <p>This notebook was developed for the geemap workshop at the GeoPython 2021 Conference.</p> <p>Authors: Qiusheng Wu, Kel Markert</p> <p>Link to this notebook: https://gishub.org/geopython</p> <p>Recorded video: https://www.youtube.com/watch?v=wGjpjh9IQ5I</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4, lite_mode=True)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4, lite_mode=True) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap('OpenTopoMap')\n</pre> Map.add_basemap('OpenTopoMap') In\u00a0[\u00a0]: Copied! <pre>for basemap in geemap.basemaps.keys():\n    print(basemap)\n</pre> for basemap in geemap.basemaps.keys():     print(basemap) <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nurl = 'https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}'\nMap.add_tile_layer(url, name='Google Terrain', attribution='Google')\nMap\n</pre> Map = geemap.Map()  url = 'https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}' Map.add_tile_layer(url, name='Google Terrain', attribution='Google') Map In\u00a0[\u00a0]: Copied! <pre>naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?'\nMap.add_wms_layer(\n    url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True\n)\n</pre> naip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?' Map.add_wms_layer(     url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Map.user_roi.getInfo()\n</pre> # Map.user_roi.getInfo() In\u00a0[\u00a0]: Copied! <pre># Map.user_rois.getInfo()\n</pre> # Map.user_rois.getInfo() In\u00a0[\u00a0]: Copied! <pre>js_snippet = \"\"\"\n// Load an image.\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\n\n// Define the visualization parameters.\nvar vizParams = {\n  bands: ['B5', 'B4', 'B3'],\n  min: 0,\n  max: 0.5,\n  gamma: [0.95, 1.1, 1]\n};\n\n// Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay\nMap.addLayer(image, vizParams, 'false color composite');\n\n\"\"\"\n</pre> js_snippet = \"\"\" // Load an image. var image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');  // Define the visualization parameters. var vizParams = {   bands: ['B5', 'B4', 'B3'],   min: 0,   max: 0.5,   gamma: [0.95, 1.1, 1] };  // Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay Map.addLayer(image, vizParams, 'false color composite');  \"\"\" In\u00a0[\u00a0]: Copied! <pre>geemap.js_snippet_to_py(\n    js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True\n)\n</pre> geemap.js_snippet_to_py(     js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True ) <p>You can also convert GEE JavaScript to Python without coding.</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine datasets\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\n\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine datasets dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\")  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>dem = ee.Image('CGIAR/SRTM90_V4')\nMap.addLayer(dem, {}, \"CGIAR/SRTM90_V4\")\n</pre> dem = ee.Image('CGIAR/SRTM90_V4') Map.addLayer(dem, {}, \"CGIAR/SRTM90_V4\") In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, \"DEM\")\n</pre> vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, \"DEM\") In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import DATA\n</pre> from geemap.datasets import DATA In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image(DATA.USGS_SRTMGL1_003)\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map()  dem = ee.Image(DATA.USGS_SRTMGL1_003)  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM') Map <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine datasets\ndem = ee.Image('USGS/SRTMGL1_003')\nlandcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(landcover, {}, 'Land cover')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\n\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine datasets dem = ee.Image('USGS/SRTMGL1_003') landcover = ee.Image(\"ESA/GLOBCOVER_L4_200901_200912_V2_3\").select('landcover') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(landcover, {}, 'Land cover') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\")  Map <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat7, landsat_vis, \"Landsat\")\n\nhyperion = ee.ImageCollection('EO1/HYPERION').filter(\n    ee.Filter.date('2016-01-01', '2017-03-01')\n)\n\nhyperion_vis = {\n    'min': 1000.0,\n    'max': 14000.0,\n    'gamma': 2.5,\n}\nMap.addLayer(hyperion, hyperion_vis, 'Hyperion')\n\nMap\n</pre> Map = geemap.Map()  landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] )  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat7, landsat_vis, \"Landsat\")  hyperion = ee.ImageCollection('EO1/HYPERION').filter(     ee.Filter.date('2016-01-01', '2017-03-01') )  hyperion_vis = {     'min': 1000.0,     'max': 14000.0,     'gamma': 2.5, } Map.addLayer(hyperion, hyperion_vis, 'Hyperion')  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\ndem = ee.Image('USGS/SRTMGL1_003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap.addLayer(states, {}, \"US States\", True)\n\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  dem = ee.Image('USGS/SRTMGL1_003') states = ee.FeatureCollection(\"TIGER/2018/States\")  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map.addLayer(states, {}, \"US States\", True)  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},\n    'Landsat 7',\n)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] )  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},     'Landsat 7', ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'color': '000000',\n    'colorOpacity': 1,\n    'pointSize': 3,\n    'pointShape': 'circle',\n    'width': 2,\n    'lineType': 'solid',\n    'fillColorOpacity': 0.66,\n}\n\npalette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']\n\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\n</pre> vis_params = {     'color': '000000',     'colorOpacity': 1,     'pointSize': 3,     'pointShape': 'circle',     'width': 2,     'lineType': 'solid',     'fillColorOpacity': 0.66, }  palette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']  Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params ) In\u00a0[\u00a0]: Copied! <pre>legends = geemap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = geemap.builtin_legends for legend in legends:     print(legend) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover') Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlegend_dict = {\n    '11 Open Water': '466b9f',\n    '12 Perennial Ice/Snow': 'd1def8',\n    '21 Developed, Open Space': 'dec5c5',\n    '22 Developed, Low Intensity': 'd99282',\n    '23 Developed, Medium Intensity': 'eb0000',\n    '24 Developed High Intensity': 'ab0000',\n    '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',\n    '41 Deciduous Forest': '68ab5f',\n    '42 Evergreen Forest': '1c5f2c',\n    '43 Mixed Forest': 'b5c58f',\n    '51 Dwarf Scrub': 'af963c',\n    '52 Shrub/Scrub': 'ccb879',\n    '71 Grassland/Herbaceous': 'dfdfc2',\n    '72 Sedge/Herbaceous': 'd1d182',\n    '73 Lichens': 'a3cc51',\n    '74 Moss': '82ba9e',\n    '81 Pasture/Hay': 'dcd939',\n    '82 Cultivated Crops': 'ab6c28',\n    '90 Woody Wetlands': 'b8d9eb',\n    '95 Emergent Herbaceous Wetlands': '6c9fb8',\n}\n\nlandcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\nMap.addLayer(landcover, {}, 'NLCD Land Cover')\n\nMap.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n</pre> Map = geemap.Map()  legend_dict = {     '11 Open Water': '466b9f',     '12 Perennial Ice/Snow': 'd1def8',     '21 Developed, Open Space': 'dec5c5',     '22 Developed, Low Intensity': 'd99282',     '23 Developed, Medium Intensity': 'eb0000',     '24 Developed High Intensity': 'ab0000',     '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',     '41 Deciduous Forest': '68ab5f',     '42 Evergreen Forest': '1c5f2c',     '43 Mixed Forest': 'b5c58f',     '51 Dwarf Scrub': 'af963c',     '52 Shrub/Scrub': 'ccb879',     '71 Grassland/Herbaceous': 'dfdfc2',     '72 Sedge/Herbaceous': 'd1d182',     '73 Lichens': 'a3cc51',     '74 Moss': '82ba9e',     '81 Pasture/Hay': 'dcd939',     '82 Cultivated Crops': 'ab6c28',     '90 Woody Wetlands': 'b8d9eb',     '95 Emergent Herbaceous Wetlands': '6c9fb8', }  landcover = ee.Image('USGS/NLCD/NLCD2016').select('landcover') Map.addLayer(landcover, {}, 'NLCD Land Cover')  Map.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\n\ncolors = vis_params['palette']\nvmin = vis_params['min']\nvmax = vis_params['max']\n\nMap.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\")\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM')  colors = vis_params['palette'] vmin = vis_params['min'] vmax = vis_params['max']  Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\") Map In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\"\n)\n</pre> Map.add_colorbar(     vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\" ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n)\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     layer_name=\"SRTM DEM\",     orientation=\"vertical\",     transparent_bg=True, ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n    discrete=True,\n)\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     layer_name=\"SRTM DEM\",     orientation=\"vertical\",     transparent_bg=True,     discrete=True, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(left_layer='HYBRID', right_layer='TERRAIN')\nMap\n</pre> Map = geemap.Map() Map.split_map(left_layer='HYBRID', right_layer='TERRAIN') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(\n    left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover'\n)\nMap\n</pre> Map = geemap.Map() Map.split_map(     left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover' ) Map In\u00a0[\u00a0]: Copied! <pre>nlcd_2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover')\nnlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')\n\nleft_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001')\nright_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')\n\nMap = geemap.Map()\nMap.split_map(left_layer, right_layer)\nMap\n</pre> nlcd_2001 = ee.Image('USGS/NLCD/NLCD2001').select('landcover') nlcd_2016 = ee.Image('USGS/NLCD/NLCD2016').select('landcover')  left_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001') right_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')  Map = geemap.Map() Map.split_map(left_layer, right_layer) Map In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection('COPERNICUS/S2')\n    .filterDate('2018-09-01', '2018-09-30')\n    .map(lambda img: img.divide(10000))\n    .median()\n)\n\nvis_params = [\n    {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n]\n\nlabels = [\n    'Natural Color (B4/B3/B2)',\n    'Land/Water (B8/B11/B4)',\n    'Color Infrared (B8/B4/B3)',\n    'Vegetation (B12/B11/B4)',\n]\n\ngeemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"400px\",\n    center=[38.4151, 21.2712],\n    zoom=12,\n    ee_objects=[image],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n</pre> image = (     ee.ImageCollection('COPERNICUS/S2')     .filterDate('2018-09-01', '2018-09-30')     .map(lambda img: img.divide(10000))     .median() )  vis_params = [     {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3}, ]  labels = [     'Natural Color (B4/B3/B2)',     'Land/Water (B8/B11/B4)',     'Color Infrared (B8/B4/B3)',     'Vegetation (B12/B11/B4)', ]  geemap.linked_maps(     rows=2,     cols=2,     height=\"400px\",     center=[38.4151, 21.2712],     zoom=12,     ee_objects=[image],     vis_params=vis_params,     labels=labels,     label_position=\"topright\", ) In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('https://youtu.be/mA21Us_3m28')\n</pre> geemap.show_youtube('https://youtu.be/mA21Us_3m28') In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('https://youtu.be/kEltQkNia6o')\n</pre> geemap.show_youtube('https://youtu.be/kEltQkNia6o') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\n\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n\nvis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(centroid, 8)\nMap.addLayer(image, vis, \"Landsat-8\")\nMap\n</pre> Map = geemap.Map()  centroid = ee.Geometry.Point([-122.4439, 37.7538])  image = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()  vis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(centroid, 8) Map.addLayer(image, vis, \"Landsat-8\") Map In\u00a0[\u00a0]: Copied! <pre>image.propertyNames().getInfo()\n</pre> image.propertyNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>image.get('CLOUD_COVER').getInfo()\n</pre> image.get('CLOUD_COVER').getInfo() In\u00a0[\u00a0]: Copied! <pre>props = geemap.image_props(image)\nprops.getInfo()\n</pre> props = geemap.image_props(image) props.getInfo() In\u00a0[\u00a0]: Copied! <pre>stats = geemap.image_stats(image, scale=90)\nstats.getInfo()\n</pre> stats = geemap.image_stats(image, scale=90) stats.getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\n\n# Set visualization parameters.\ndem_vis = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine DEM to map\nMap.addLayer(dem, dem_vis, 'SRTM DEM')\n\n# Add Landsat data to map\nlandsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003')  # Set visualization parameters. dem_vis = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine DEM to map Map.addLayer(dem, dem_vis, 'SRTM DEM')  # Add Landsat data to map landsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') Map In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nout_dem_stats = os.path.join(out_dir, 'dem_stats.csv')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\n# Allowed output formats: csv, shp, json, kml, kmz\n# Allowed statistics type: MEAN, MAXIMUM, MINIMUM, MEDIAN, STD, MIN_MAX, VARIANCE, SUM\ngeemap.zonal_statistics(dem, states, out_dem_stats, statistics_type='MEAN', scale=1000)\n</pre> out_dir = os.path.expanduser('~/Downloads') out_dem_stats = os.path.join(out_dir, 'dem_stats.csv')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  # Allowed output formats: csv, shp, json, kml, kmz # Allowed statistics type: MEAN, MAXIMUM, MINIMUM, MEDIAN, STD, MIN_MAX, VARIANCE, SUM geemap.zonal_statistics(dem, states, out_dem_stats, statistics_type='MEAN', scale=1000) In\u00a0[\u00a0]: Copied! <pre>out_landsat_stats = os.path.join(out_dir, 'landsat_stats.csv')\ngeemap.zonal_statistics(\n    landsat, states, out_landsat_stats, statistics_type='SUM', scale=1000\n)\n</pre> out_landsat_stats = os.path.join(out_dir, 'landsat_stats.csv') geemap.zonal_statistics(     landsat, states, out_landsat_stats, statistics_type='SUM', scale=1000 ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndataset = ee.Image('USGS/NLCD/NLCD2016')\nlandcover = ee.Image(dataset.select('landcover'))\nMap.addLayer(landcover, {}, 'NLCD 2016')\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map()  dataset = ee.Image('USGS/NLCD/NLCD2016') landcover = ee.Image(dataset.select('landcover')) Map.addLayer(landcover, {}, 'NLCD 2016')  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nnlcd_stats = os.path.join(out_dir, 'nlcd_stats.csv')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\n# statistics_type can be either 'SUM' or 'PERCENTAGE'\n# denominator can be used to convert square meters to other areal units, such as square kilimeters\ngeemap.zonal_statistics_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    statistics_type='SUM',\n    denominator=1000000,\n    decimal_places=2,\n)\n</pre> out_dir = os.path.expanduser('~/Downloads') nlcd_stats = os.path.join(out_dir, 'nlcd_stats.csv')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  # statistics_type can be either 'SUM' or 'PERCENTAGE' # denominator can be used to convert square meters to other areal units, such as square kilimeters geemap.zonal_statistics_by_group(     landcover,     states,     nlcd_stats,     statistics_type='SUM',     denominator=1000000,     decimal_places=2, ) <p>Add data to the map</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\npoint = ee.Geometry.Point([-87.7719, 41.8799])\n\nimage = (\n    ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n    .filterBounds(point)\n    .filterDate('2019-01-01', '2019-12-31')\n    .sort('CLOUD_COVER')\n    .first()\n    .select('B[1-7]')\n)\n\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(point, 8)\nMap.addLayer(image, vis_params, \"Landsat-8\")\n\nMap\n</pre> Map = geemap.Map()  point = ee.Geometry.Point([-87.7719, 41.8799])  image = (     ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')     .filterBounds(point)     .filterDate('2019-01-01', '2019-12-31')     .sort('CLOUD_COVER')     .first()     .select('B[1-7]') )  vis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(point, 8) Map.addLayer(image, vis_params, \"Landsat-8\")  Map <p>Make training dataset</p> <p>There are several ways you can create a region for generating the training dataset.</p> <ul> <li>Draw a shape (e.g., rectangle) on the map and the use <code>region = Map.user_roi</code></li> <li>Define a geometry, such as <code>region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])</code></li> <li>Create a buffer zone around a point, such as <code>region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)</code></li> <li>If you don't define a region, it will use the image footprint by default</li> </ul> In\u00a0[\u00a0]: Copied! <pre>training = image.sample(\n    **{\n        #     'region': region,\n        'scale': 30,\n        'numPixels': 5000,\n        'seed': 0,\n        'geometries': True,  # Set this to False to ignore geometries\n    }\n)\n\nMap.addLayer(training, {}, 'training', False)\n</pre> training = image.sample(     **{         #     'region': region,         'scale': 30,         'numPixels': 5000,         'seed': 0,         'geometries': True,  # Set this to False to ignore geometries     } )  Map.addLayer(training, {}, 'training', False) <p>Train the clusterer</p> In\u00a0[\u00a0]: Copied! <pre># Instantiate the clusterer and train it.\nn_clusters = 5\nclusterer = ee.Clusterer.wekaKMeans(n_clusters).train(training)\n</pre> # Instantiate the clusterer and train it. n_clusters = 5 clusterer = ee.Clusterer.wekaKMeans(n_clusters).train(training) <p>Classify the image</p> In\u00a0[\u00a0]: Copied! <pre># Cluster the input using the trained clusterer.\nresult = image.cluster(clusterer)\n\n# # Display the clusters with random colors.\nMap.addLayer(result.randomVisualizer(), {}, 'clusters')\nMap\n</pre> # Cluster the input using the trained clusterer. result = image.cluster(clusterer)  # # Display the clusters with random colors. Map.addLayer(result.randomVisualizer(), {}, 'clusters') Map <p>Label the clusters</p> In\u00a0[\u00a0]: Copied! <pre>legend_keys = ['One', 'Two', 'Three', 'Four', 'ect']\nlegend_colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']\n\n# Reclassify the map\nresult = result.remap([0, 1, 2, 3, 4], [1, 2, 3, 4, 5])\n\nMap.addLayer(\n    result, {'min': 1, 'max': 5, 'palette': legend_colors}, 'Labelled clusters'\n)\nMap.add_legend(\n    legend_keys=legend_keys, legend_colors=legend_colors, position='bottomright'\n)\n</pre> legend_keys = ['One', 'Two', 'Three', 'Four', 'ect'] legend_colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']  # Reclassify the map result = result.remap([0, 1, 2, 3, 4], [1, 2, 3, 4, 5])  Map.addLayer(     result, {'min': 1, 'max': 5, 'palette': legend_colors}, 'Labelled clusters' ) Map.add_legend(     legend_keys=legend_keys, legend_colors=legend_colors, position='bottomright' ) <p>Visualize the result</p> In\u00a0[\u00a0]: Copied! <pre>print('Change layer opacity:')\ncluster_layer = Map.layers[-1]\ncluster_layer.interact(opacity=(0, 1, 0.1))\n</pre> print('Change layer opacity:') cluster_layer = Map.layers[-1] cluster_layer.interact(opacity=(0, 1, 0.1)) In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map <p>Export the result</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nout_file = os.path.join(out_dir, 'cluster.tif')\ngeemap.ee_export_image(result, filename=out_file, scale=90)\n</pre> out_dir = os.path.expanduser('~/Downloads') out_file = os.path.join(out_dir, 'cluster.tif') geemap.ee_export_image(result, filename=out_file, scale=90) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_to_drive(result, description='clusters', folder='export', scale=90)\n</pre> # geemap.ee_export_image_to_drive(result, description='clusters', folder='export', scale=90) <p>Source: https://developers.google.com/earth-engine/guides/classification</p> <p>The <code>Classifier</code> package handles supervised classification by traditional ML algorithms running in Earth Engine. These classifiers include CART, RandomForest, NaiveBayes and SVM. The general workflow for classification is:</p> <ol> <li>Collect training data. Assemble features which have a property that stores the known class label and properties storing numeric values for the predictors.</li> <li>Instantiate a classifier. Set its parameters if necessary.</li> <li>Train the classifier using the training data.</li> <li>Classify an image or feature collection.</li> <li>Estimate classification error with independent validation data.</li> </ol> <p>The training data is a <code>FeatureCollection</code> with a property storing the class label and properties storing predictor variables. Class labels should be consecutive, integers starting from 0. If necessary, use remap() to convert class values to consecutive integers. The predictors should be numeric.</p> <p></p> <p>Add data to the map</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\npoint = ee.Geometry.Point([-122.4439, 37.7538])\n\nimage = (\n    ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')\n    .filterBounds(point)\n    .filterDate('2016-01-01', '2016-12-31')\n    .sort('CLOUD_COVER')\n    .first()\n    .select('B[1-7]')\n)\n\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(point, 8)\nMap.addLayer(image, vis_params, \"Landsat-8\")\n\nMap\n</pre> Map = geemap.Map()  point = ee.Geometry.Point([-122.4439, 37.7538])  image = (     ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')     .filterBounds(point)     .filterDate('2016-01-01', '2016-12-31')     .sort('CLOUD_COVER')     .first()     .select('B[1-7]') )  vis_params = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(point, 8) Map.addLayer(image, vis_params, \"Landsat-8\")  Map <p>Make training dataset</p> <p>There are several ways you can create a region for generating the training dataset.</p> <ul> <li>Draw a shape (e.g., rectangle) on the map and the use <code>region = Map.user_roi</code></li> <li>Define a geometry, such as <code>region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])</code></li> <li>Create a buffer zone around a point, such as <code>region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)</code></li> <li>If you don't define a region, it will use the image footprint by default</li> </ul> In\u00a0[\u00a0]: Copied! <pre># region = Map.user_roi\n# region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288])\n# region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000)\n</pre> # region = Map.user_roi # region = ee.Geometry.Rectangle([-122.6003, 37.4831, -121.8036, 37.8288]) # region = ee.Geometry.Point([-122.4439, 37.7538]).buffer(10000) <p>In this example, we are going to use the USGS National Land Cover Database (NLCD) to create label dataset for training</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>nlcd = ee.Image('USGS/NLCD/NLCD2016').select('landcover').clip(image.geometry())\nMap.addLayer(nlcd, {}, 'NLCD')\nMap\n</pre> nlcd = ee.Image('USGS/NLCD/NLCD2016').select('landcover').clip(image.geometry()) Map.addLayer(nlcd, {}, 'NLCD') Map In\u00a0[\u00a0]: Copied! <pre># Make the training dataset.\npoints = nlcd.sample(\n    **{\n        'region': image.geometry(),\n        'scale': 30,\n        'numPixels': 5000,\n        'seed': 0,\n        'geometries': True,  # Set this to False to ignore geometries\n    }\n)\n\nMap.addLayer(points, {}, 'training', False)\n</pre> # Make the training dataset. points = nlcd.sample(     **{         'region': image.geometry(),         'scale': 30,         'numPixels': 5000,         'seed': 0,         'geometries': True,  # Set this to False to ignore geometries     } )  Map.addLayer(points, {}, 'training', False) <p>Train the classifier</p> In\u00a0[\u00a0]: Copied! <pre># Use these bands for prediction.\nbands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']\n\n\n# This property of the table stores the land cover labels.\nlabel = 'landcover'\n\n# Overlay the points on the imagery to get training.\ntraining = image.select(bands).sampleRegions(\n    **{'collection': points, 'properties': [label], 'scale': 30}\n)\n\n# Train a CART classifier with default parameters.\ntrained = ee.Classifier.smileCart().train(training, label, bands)\n</pre> # Use these bands for prediction. bands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']   # This property of the table stores the land cover labels. label = 'landcover'  # Overlay the points on the imagery to get training. training = image.select(bands).sampleRegions(     **{'collection': points, 'properties': [label], 'scale': 30} )  # Train a CART classifier with default parameters. trained = ee.Classifier.smileCart().train(training, label, bands) <p>Classify the image</p> In\u00a0[\u00a0]: Copied! <pre># Classify the image with the same bands used for training.\nresult = image.select(bands).classify(trained)\n\n# # Display the clusters with random colors.\nMap.addLayer(result.randomVisualizer(), {}, 'classfied')\nMap\n</pre> # Classify the image with the same bands used for training. result = image.select(bands).classify(trained)  # # Display the clusters with random colors. Map.addLayer(result.randomVisualizer(), {}, 'classfied') Map <p>Render categorical map</p> <p>To render a categorical map, we can set two image properties: <code>landcover_class_values</code> and <code>landcover_class_palette</code>. We can use the same style as the NLCD so that it is easy to compare the two maps.</p> In\u00a0[\u00a0]: Copied! <pre>class_values = nlcd.get('landcover_class_values').getInfo()\nclass_palette = nlcd.get('landcover_class_palette').getInfo()\n</pre> class_values = nlcd.get('landcover_class_values').getInfo() class_palette = nlcd.get('landcover_class_palette').getInfo() In\u00a0[\u00a0]: Copied! <pre>landcover = result.set('classification_class_values', class_values)\nlandcover = landcover.set('classification_class_palette', class_palette)\n</pre> landcover = result.set('classification_class_values', class_values) landcover = landcover.set('classification_class_palette', class_palette) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(landcover, {}, 'Land cover')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map.addLayer(landcover, {}, 'Land cover') Map.add_legend(builtin_legend='NLCD') Map <p>Visualize the result</p> In\u00a0[\u00a0]: Copied! <pre>print('Change layer opacity:')\ncluster_layer = Map.layers[-1]\ncluster_layer.interact(opacity=(0, 1, 0.1))\n</pre> print('Change layer opacity:') cluster_layer = Map.layers[-1] cluster_layer.interact(opacity=(0, 1, 0.1)) <p>Export the result</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nout_file = os.path.join(out_dir, 'landcover.tif')\n</pre> out_dir = os.path.expanduser('~/Downloads') out_file = os.path.join(out_dir, 'landcover.tif') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(landcover, filename=out_file, scale=900)\n</pre> geemap.ee_export_image(landcover, filename=out_file, scale=900) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_to_drive(landcover, description='landcover', folder='export', scale=900)\n</pre> # geemap.ee_export_image_to_drive(landcover, description='landcover', folder='export', scale=900) In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube('https://youtu.be/VWh5PxXPZw0')\n</pre> geemap.show_youtube('https://youtu.be/VWh5PxXPZw0') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>import whiteboxgui\n</pre> import whiteboxgui In\u00a0[\u00a0]: Copied! <pre>whiteboxgui.show()\n</pre> whiteboxgui.show() In\u00a0[\u00a0]: Copied! <pre>whiteboxgui.show(tree=True)\n</pre> whiteboxgui.show(tree=True) <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nfrom geemap import cartoee\n</pre> import matplotlib.pyplot as plt from geemap import cartoee In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>srtm = ee.Image(\"CGIAR/SRTM90_V4\")\nregion = [-180, -60, 180, 85]  # define bounding box to request data\nvis = {'min': 0, 'max': 3000}  # define visualization parameters for image\n</pre> srtm = ee.Image(\"CGIAR/SRTM90_V4\") region = [-180, -60, 180, 85]  # define bounding box to request data vis = {'min': 0, 'max': 3000}  # define visualization parameters for image In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\ncmap = \"gist_earth\"  # colormap we want to use\n# cmap = \"terrain\"\n\n# use cartoee to get a map\nax = cartoee.get_map(srtm, region=region, vis_params=vis, cmap=cmap)\n\n# add a colorbar to the map using the visualization params we passed to the map\ncartoee.add_colorbar(\n    ax, vis, cmap=cmap, loc=\"right\", label=\"Elevation\", orientation=\"vertical\"\n)\n\n# add gridlines to the map at a specified interval\ncartoee.add_gridlines(ax, interval=[60, 30], linestyle=\"--\")\n\n# add coastlines using the cartopy api\nax.coastlines(color=\"red\")\n\nax.set_title(label='Global Elevation Map', fontsize=15)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  cmap = \"gist_earth\"  # colormap we want to use # cmap = \"terrain\"  # use cartoee to get a map ax = cartoee.get_map(srtm, region=region, vis_params=vis, cmap=cmap)  # add a colorbar to the map using the visualization params we passed to the map cartoee.add_colorbar(     ax, vis, cmap=cmap, loc=\"right\", label=\"Elevation\", orientation=\"vertical\" )  # add gridlines to the map at a specified interval cartoee.add_gridlines(ax, interval=[60, 30], linestyle=\"--\")  # add coastlines using the cartopy api ax.coastlines(color=\"red\")  ax.set_title(label='Global Elevation Map', fontsize=15)  plt.show() In\u00a0[\u00a0]: Copied! <pre># get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n\n# define the visualization parameters to view\nvis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3}\n</pre> # get a landsat image to visualize image = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')  # define the visualization parameters to view vis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3} In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# here is the bounding box of the map extent we want to use\n# formatted a [W,S,E,N]\nzoom_region = [-122.6265, 37.3458, -121.8025, 37.9178]\n\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.15, xtick_rotation=45, linestyle=\":\")\n\n# add coastline\nax.coastlines(color=\"yellow\")\n\n# add north arrow\ncartoee.add_north_arrow(\n    ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20\n)\n\n# add scale bar\ncartoee.add_scale_bar_lite(\n    ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\"\n)\n\nax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # here is the bounding box of the map extent we want to use # formatted a [W,S,E,N] zoom_region = [-122.6265, 37.3458, -121.8025, 37.9178]  # plot the map over the region of interest ax = cartoee.get_map(image, vis_params=vis, region=zoom_region)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.15, xtick_rotation=45, linestyle=\":\")  # add coastline ax.coastlines(color=\"yellow\")  # add north arrow cartoee.add_north_arrow(     ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20 )  # add scale bar cartoee.add_scale_bar_lite(     ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\" )  ax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)  plt.show() In\u00a0[\u00a0]: Copied! <pre>from matplotlib.lines import Line2D\n</pre> from matplotlib.lines import Line2D In\u00a0[\u00a0]: Copied! <pre># get a landsat image to visualize\nimage = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')\n\n# define the visualization parameters to view\nvis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3}\n</pre> # get a landsat image to visualize image = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_044034_20140318')  # define the visualization parameters to view vis = {\"bands\": ['B5', 'B4', 'B3'], \"min\": 0, \"max\": 5000, \"gamma\": 1.3} In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# here is the bounding box of the map extent we want to use\n# formatted a [W,S,E,N]\nzoom_region = [-122.6265, 37.3458, -121.8025, 37.9178]\n\n# plot the map over the region of interest\nax = cartoee.get_map(image, vis_params=vis, region=zoom_region)\n\n# add the gridlines and specify that the xtick labels be rotated 45 degrees\ncartoee.add_gridlines(ax, interval=0.15, xtick_rotation=0, linestyle=\":\")\n\n# add coastline\nax.coastlines(color=\"cyan\")\n\n# add north arrow\ncartoee.add_north_arrow(\n    ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20\n)\n\n# add scale bar\ncartoee.add_scale_bar_lite(\n    ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\"\n)\n\nax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)\n\n# add legend\nlegend_elements = [\n    Line2D([], [], color='#00ffff', lw=2, label='Coastline'),\n    Line2D(\n        [],\n        [],\n        marker='o',\n        color='#A8321D',\n        label='City',\n        markerfacecolor='#A8321D',\n        markersize=10,\n        ls='',\n    ),\n]\n\ncartoee.add_legend(ax, legend_elements, loc='lower right')\n\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # here is the bounding box of the map extent we want to use # formatted a [W,S,E,N] zoom_region = [-122.6265, 37.3458, -121.8025, 37.9178]  # plot the map over the region of interest ax = cartoee.get_map(image, vis_params=vis, region=zoom_region)  # add the gridlines and specify that the xtick labels be rotated 45 degrees cartoee.add_gridlines(ax, interval=0.15, xtick_rotation=0, linestyle=\":\")  # add coastline ax.coastlines(color=\"cyan\")  # add north arrow cartoee.add_north_arrow(     ax, text=\"N\", xy=(0.05, 0.25), text_color=\"white\", arrow_color=\"white\", fontsize=20 )  # add scale bar cartoee.add_scale_bar_lite(     ax, length=10, xy=(0.1, 0.05), fontsize=20, color=\"white\", unit=\"km\" )  ax.set_title(label='Landsat False Color Composite (Band 5/4/3)', fontsize=15)  # add legend legend_elements = [     Line2D([], [], color='#00ffff', lw=2, label='Coastline'),     Line2D(         [],         [],         marker='o',         color='#A8321D',         label='City',         markerfacecolor='#A8321D',         markersize=10,         ls='',     ), ]  cartoee.add_legend(ax, legend_elements, loc='lower right')  plt.show() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = (\n    ee.ImageCollection('MODIS/MCD43A4_006_NDVI')\n    .filter(ee.Filter.date('2018-04-01', '2018-05-01'))\n    .select(\"NDVI\")\n    .first()\n)\n\nvis_params = {\n    'min': 0.0,\n    'max': 1.0,\n    'palette': [\n        'FFFFFF',\n        'CE7E45',\n        'DF923D',\n        'F1B555',\n        'FCD163',\n        '99B718',\n        '74A901',\n        '66A000',\n        '529400',\n        '3E8601',\n        '207401',\n        '056201',\n        '004C00',\n        '023B01',\n        '012E01',\n        '011D01',\n        '011301',\n    ],\n}\nMap.setCenter(-7.03125, 31.0529339857, 2)\nMap.addLayer(image, vis_params, 'MODIS NDVI')\n\ncountries = geemap.shp_to_ee(\"../data/countries.shp\")\nstyle = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"}\nMap.addLayer(countries.style(**style), {}, \"Countries\")\n\nndvi = image.visualize(**vis_params)\nblend = ndvi.blend(countries.style(**style))\n\nMap.addLayer(blend, {}, \"Blend\")\n\nMap\n</pre> Map = geemap.Map()  image = (     ee.ImageCollection('MODIS/MCD43A4_006_NDVI')     .filter(ee.Filter.date('2018-04-01', '2018-05-01'))     .select(\"NDVI\")     .first() )  vis_params = {     'min': 0.0,     'max': 1.0,     'palette': [         'FFFFFF',         'CE7E45',         'DF923D',         'F1B555',         'FCD163',         '99B718',         '74A901',         '66A000',         '529400',         '3E8601',         '207401',         '056201',         '004C00',         '023B01',         '012E01',         '011D01',         '011301',     ], } Map.setCenter(-7.03125, 31.0529339857, 2) Map.addLayer(image, vis_params, 'MODIS NDVI')  countries = geemap.shp_to_ee(\"../data/countries.shp\") style = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"} Map.addLayer(countries.style(**style), {}, \"Countries\")  ndvi = image.visualize(**vis_params) blend = ndvi.blend(countries.style(**style))  Map.addLayer(blend, {}, \"Blend\")  Map In\u00a0[\u00a0]: Copied! <pre># specify region to focus on\nbbox = [-180, -88, 180, 88]\n</pre> # specify region to focus on bbox = [-180, -88, 180, 88] In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(blend, region=bbox)\ncb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')\n\nax.set_title(label='MODIS NDVI', fontsize=15)\n\n# ax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(blend, region=bbox) cb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')  ax.set_title(label='MODIS NDVI', fontsize=15)  # ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>import cartopy.crs as ccrs\n</pre> import cartopy.crs as ccrs In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\nprojection = ccrs.EqualEarth(central_longitude=-180)\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(blend, region=bbox, proj=projection)\ncb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')\n\nax.set_title(label='MODIS NDVI', fontsize=15)\n\n# ax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  projection = ccrs.EqualEarth(central_longitude=-180)  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(blend, region=bbox, proj=projection) cb = cartoee.add_colorbar(ax, vis_params=vis_params, loc='right')  ax.set_title(label='MODIS NDVI', fontsize=15)  # ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>import cartopy.crs as ccrs\n</pre> import cartopy.crs as ccrs In\u00a0[\u00a0]: Copied! <pre># get an earth engine image of ocean data for Jan-Mar 2018\nocean = (\n    ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')\n    .filter(ee.Filter.date('2018-01-01', '2018-03-01'))\n    .median()\n    .select([\"sst\"], [\"SST\"])\n)\n</pre> # get an earth engine image of ocean data for Jan-Mar 2018 ocean = (     ee.ImageCollection('NASA/OCEANDATA/MODIS-Terra/L3SMI')     .filter(ee.Filter.date('2018-01-01', '2018-03-01'))     .median()     .select([\"sst\"], [\"SST\"]) ) In\u00a0[\u00a0]: Copied! <pre># set parameters for plotting\n# will plot the Sea Surface Temp with specific range and colormap\nvisualization = {'bands': \"SST\", 'min': -2, 'max': 30}\n# specify region to focus on\nbbox = [-180, -88, 180, 88]\n</pre> # set parameters for plotting # will plot the Sea Surface Temp with specific range and colormap visualization = {'bands': \"SST\", 'min': -2, 'max': 30} # specify region to focus on bbox = [-180, -88, 180, 88] In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# plot the result with cartoee using a PlateCarre projection (default)\nax = cartoee.get_map(ocean, cmap='plasma', vis_params=visualization, region=bbox)\ncb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')\n\nax.set_title(label='Sea Surface Temperature', fontsize=15)\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # plot the result with cartoee using a PlateCarre projection (default) ax = cartoee.get_map(ocean, cmap='plasma', vis_params=visualization, region=bbox) cb = cartoee.add_colorbar(ax, vis_params=visualization, loc='right', cmap='plasma')  ax.set_title(label='Sea Surface Temperature', fontsize=15)  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new Mollweide projection centered on the Pacific\nprojection = ccrs.Mollweide(central_longitude=-180)\n\n# plot the result with cartoee using the Mollweide projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal'\n)\n\nax.set_title(\"Mollweide projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new Mollweide projection centered on the Pacific projection = ccrs.Mollweide(central_longitude=-180)  # plot the result with cartoee using the Mollweide projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal' )  ax.set_title(\"Mollweide projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new Robinson projection centered on the Pacific\nprojection = ccrs.Robinson(central_longitude=-180)\n\n# plot the result with cartoee using the Goode homolosine projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal'\n)\n\nax.set_title(\"Robinson projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new Robinson projection centered on the Pacific projection = ccrs.Robinson(central_longitude=-180)  # plot the result with cartoee using the Goode homolosine projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='bottom', cmap='plasma', orientation='horizontal' )  ax.set_title(\"Robinson projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new equal Earth projection focused on the Pacific\nprojection = ccrs.EqualEarth(central_longitude=-180)\n\n# plot the result with cartoee using the orographic projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical'\n)\n\nax.set_title(\"Equal Earth projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new equal Earth projection focused on the Pacific projection = ccrs.EqualEarth(central_longitude=-180)  # plot the result with cartoee using the orographic projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical' )  ax.set_title(\"Equal Earth projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(15, 10))\n\n# create a new orographic projection focused on the Pacific\nprojection = ccrs.Orthographic(-130, -10)\n\n# plot the result with cartoee using the orographic projection\nax = cartoee.get_map(\n    ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection\n)\ncb = cartoee.add_colorbar(\n    ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical'\n)\n\nax.set_title(\"Orographic projection\")\n\nax.coastlines()\nplt.show()\n</pre> fig = plt.figure(figsize=(15, 10))  # create a new orographic projection focused on the Pacific projection = ccrs.Orthographic(-130, -10)  # plot the result with cartoee using the orographic projection ax = cartoee.get_map(     ocean, vis_params=visualization, region=bbox, cmap='plasma', proj=projection ) cb = cartoee.add_colorbar(     ax, vis_params=visualization, loc='right', cmap='plasma', orientation='vertical' )  ax.set_title(\"Orographic projection\")  ax.coastlines() plt.show() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlon = -115.1585\nlat = 36.1500\nstart_year = 1984\nend_year = 2000\n\npoint = ee.Geometry.Point(lon, lat)\nyears = ee.List.sequence(start_year, end_year)\n\n\ndef get_best_image(year):\n    start_date = ee.Date.fromYMD(year, 1, 1)\n    end_date = ee.Date.fromYMD(year, 12, 31)\n    image = (\n        ee.ImageCollection(\"LANDSAT/LT05/C01/T1_SR\")\n        .filterBounds(point)\n        .filterDate(start_date, end_date)\n        .sort(\"CLOUD_COVER\")\n        .first()\n    )\n    return ee.Image(image)\n\n\ncollection = ee.ImageCollection(years.map(get_best_image))\n\nvis_params = {\"bands\": ['B4', 'B3', 'B2'], \"min\": 0, \"max\": 5000}\n\nimage = ee.Image(collection.first())\nMap.addLayer(image, vis_params, 'First image')\nMap.setCenter(lon, lat, 8)\nMap\n</pre> Map = geemap.Map()  lon = -115.1585 lat = 36.1500 start_year = 1984 end_year = 2000  point = ee.Geometry.Point(lon, lat) years = ee.List.sequence(start_year, end_year)   def get_best_image(year):     start_date = ee.Date.fromYMD(year, 1, 1)     end_date = ee.Date.fromYMD(year, 12, 31)     image = (         ee.ImageCollection(\"LANDSAT/LT05/C01/T1_SR\")         .filterBounds(point)         .filterDate(start_date, end_date)         .sort(\"CLOUD_COVER\")         .first()     )     return ee.Image(image)   collection = ee.ImageCollection(years.map(get_best_image))  vis_params = {\"bands\": ['B4', 'B3', 'B2'], \"min\": 0, \"max\": 5000}  image = ee.Image(collection.first()) Map.addLayer(image, vis_params, 'First image') Map.setCenter(lon, lat, 8) Map In\u00a0[\u00a0]: Copied! <pre>w = 0.4\nh = 0.3\n\nregion = [lon - w, lat - h, lon + w, lat + h]\n\nfig = plt.figure(figsize=(10, 8))\n\n# use cartoee to get a map\nax = cartoee.get_map(image, region=region, vis_params=vis_params)\n\n# add gridlines to the map at a specified interval\ncartoee.add_gridlines(ax, interval=[0.2, 0.2], linestyle=\":\")\n\n# add north arrow\nnorth_arrow_dict = {\n    \"text\": \"N\",\n    \"xy\": (0.1, 0.3),\n    \"arrow_length\": 0.15,\n    \"text_color\": \"white\",\n    \"arrow_color\": \"white\",\n    \"fontsize\": 20,\n    \"width\": 5,\n    \"headwidth\": 15,\n    \"ha\": \"center\",\n    \"va\": \"center\",\n}\ncartoee.add_north_arrow(ax, **north_arrow_dict)\n\n# add scale bar\nscale_bar_dict = {\n    \"length\": 10,\n    \"xy\": (0.1, 0.05),\n    \"linewidth\": 3,\n    \"fontsize\": 20,\n    \"color\": \"white\",\n    \"unit\": \"km\",\n    \"ha\": \"center\",\n    \"va\": \"bottom\",\n}\ncartoee.add_scale_bar_lite(ax, **scale_bar_dict)\n\nax.set_title(label='Las Vegas, NV', fontsize=15)\n\nplt.show()\n</pre> w = 0.4 h = 0.3  region = [lon - w, lat - h, lon + w, lat + h]  fig = plt.figure(figsize=(10, 8))  # use cartoee to get a map ax = cartoee.get_map(image, region=region, vis_params=vis_params)  # add gridlines to the map at a specified interval cartoee.add_gridlines(ax, interval=[0.2, 0.2], linestyle=\":\")  # add north arrow north_arrow_dict = {     \"text\": \"N\",     \"xy\": (0.1, 0.3),     \"arrow_length\": 0.15,     \"text_color\": \"white\",     \"arrow_color\": \"white\",     \"fontsize\": 20,     \"width\": 5,     \"headwidth\": 15,     \"ha\": \"center\",     \"va\": \"center\", } cartoee.add_north_arrow(ax, **north_arrow_dict)  # add scale bar scale_bar_dict = {     \"length\": 10,     \"xy\": (0.1, 0.05),     \"linewidth\": 3,     \"fontsize\": 20,     \"color\": \"white\",     \"unit\": \"km\",     \"ha\": \"center\",     \"va\": \"bottom\", } cartoee.add_scale_bar_lite(ax, **scale_bar_dict)  ax.set_title(label='Las Vegas, NV', fontsize=15)  plt.show() In\u00a0[\u00a0]: Copied! <pre>cartoee.get_image_collection_gif(\n    ee_ic=collection,\n    out_dir=os.path.expanduser(\"~/Downloads/timelapse\"),\n    out_gif=\"animation.gif\",\n    vis_params=vis_params,\n    region=region,\n    fps=5,\n    mp4=True,\n    grid_interval=(0.2, 0.2),\n    plot_title=\"Las Vegas, NV\",\n    date_format='YYYY-MM-dd',\n    fig_size=(10, 8),\n    dpi_plot=100,\n    file_format=\"png\",\n    north_arrow_dict=north_arrow_dict,\n    scale_bar_dict=scale_bar_dict,\n    verbose=True,\n)\n</pre> cartoee.get_image_collection_gif(     ee_ic=collection,     out_dir=os.path.expanduser(\"~/Downloads/timelapse\"),     out_gif=\"animation.gif\",     vis_params=vis_params,     region=region,     fps=5,     mp4=True,     grid_interval=(0.2, 0.2),     plot_title=\"Las Vegas, NV\",     date_format='YYYY-MM-dd',     fig_size=(10, 8),     dpi_plot=100,     file_format=\"png\",     north_arrow_dict=north_arrow_dict,     scale_bar_dict=scale_bar_dict,     verbose=True, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 1)\n\nMap\n</pre> Map = geemap.Map()  image = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 1)  Map In\u00a0[\u00a0]: Copied! <pre># Draw any shapes on the map using the Drawing tools before executing this code block\nroi = Map.user_roi\n\nif roi is None:\n    roi = ee.Geometry.Polygon(\n        [\n            [\n                [-115.413031, 35.889467],\n                [-115.413031, 36.543157],\n                [-114.034328, 36.543157],\n                [-114.034328, 35.889467],\n                [-115.413031, 35.889467],\n            ]\n        ]\n    )\n</pre> # Draw any shapes on the map using the Drawing tools before executing this code block roi = Map.user_roi  if roi is None:     roi = ee.Geometry.Polygon(         [             [                 [-115.413031, 35.889467],                 [-115.413031, 36.543157],                 [-114.034328, 36.543157],                 [-114.034328, 35.889467],                 [-115.413031, 35.889467],             ]         ]     ) In\u00a0[\u00a0]: Copied! <pre># Set output directory\nout_dir = os.path.expanduser('~/Downloads')\n\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\n\nfilename = os.path.join(out_dir, 'landsat.tif')\n</pre> # Set output directory out_dir = os.path.expanduser('~/Downloads')  if not os.path.exists(out_dir):     os.makedirs(out_dir)  filename = os.path.join(out_dir, 'landsat.tif') <p>Exporting all bands as one single image</p> In\u00a0[\u00a0]: Copied! <pre>image = image.clip(roi).unmask()\ngeemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=False\n)\n</pre> image = image.clip(roi).unmask() geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=False ) <p>Exporting each band as one image</p> In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=True\n)\n</pre> geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=True ) <p>Export an image to Google Drive\u00b6</p> In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_to_drive(image, description='landsat', folder='export', region=roi, scale=30)\n</pre> # geemap.ee_export_image_to_drive(image, description='landsat', folder='export', region=roi, scale=30) In\u00a0[\u00a0]: Copied! <pre>loc = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(loc)\n    .filterDate('2008-01-01', '2020-01-01')\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n</pre> loc = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(loc)     .filterDate('2008-01-01', '2020-01-01')     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) In\u00a0[\u00a0]: Copied! <pre>collection.aggregate_array('system:index').getInfo()\n</pre> collection.aggregate_array('system:index').getInfo() In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection(collection, out_dir=out_dir)\n</pre> geemap.ee_export_image_collection(collection, out_dir=out_dir) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10)\n</pre> # geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10) In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nimg = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810').select(['B4', 'B5', 'B6'])\n\naoi = ee.Geometry.Polygon(\n    [[[-110.8, 44.7], [-110.8, 44.6], [-110.6, 44.6], [-110.6, 44.7]]], None, False\n)\n\nrgb_img = geemap.ee_to_numpy(img, region=aoi)\nprint(rgb_img.shape)\n</pre> import matplotlib.pyplot as plt  img = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810').select(['B4', 'B5', 'B6'])  aoi = ee.Geometry.Polygon(     [[[-110.8, 44.7], [-110.8, 44.6], [-110.6, 44.6], [-110.6, 44.7]]], None, False )  rgb_img = geemap.ee_to_numpy(img, region=aoi) print(rgb_img.shape) In\u00a0[\u00a0]: Copied! <pre>rgb_img_test = (255 * ((rgb_img[:, :, 0:3] - 100) / 3500)).astype('uint8')\nplt.imshow(rgb_img_test)\nplt.show()\n</pre> rgb_img_test = (255 * ((rgb_img[:, :, 0:3] - 100) / 3500)).astype('uint8') plt.imshow(rgb_img_test) plt.show() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(\n    landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7'\n)\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(     landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7' ) Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map <p>Download sample data</p> In\u00a0[\u00a0]: Copied! <pre>work_dir = os.path.expanduser('~/Downloads')\nin_shp = os.path.join(work_dir, 'us_cities.shp')\nif not os.path.exists(in_shp):\n    data_url = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip'\n    geemap.download_from_url(data_url, out_dir=work_dir)\n</pre> work_dir = os.path.expanduser('~/Downloads') in_shp = os.path.join(work_dir, 'us_cities.shp') if not os.path.exists(in_shp):     data_url = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip'     geemap.download_from_url(data_url, out_dir=work_dir) In\u00a0[\u00a0]: Copied! <pre>in_fc = geemap.shp_to_ee(in_shp)\nMap.addLayer(in_fc, {}, 'Cities')\n</pre> in_fc = geemap.shp_to_ee(in_shp) Map.addLayer(in_fc, {}, 'Cities') <p>Export pixel values as a shapefile</p> In\u00a0[\u00a0]: Copied! <pre>out_shp = os.path.join(work_dir, 'dem.shp')\ngeemap.extract_values_to_points(in_fc, dem, out_shp)\n</pre> out_shp = os.path.join(work_dir, 'dem.shp') geemap.extract_values_to_points(in_fc, dem, out_shp) <p>Export pixel values as a csv</p> In\u00a0[\u00a0]: Copied! <pre>out_csv = os.path.join(work_dir, 'landsat.csv')\ngeemap.extract_values_to_points(in_fc, landsat7, out_csv)\n</pre> out_csv = os.path.join(work_dir, 'landsat.csv') geemap.extract_values_to_points(in_fc, landsat7, out_csv) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nfc = ee.FeatureCollection('users/giswqs/public/countries')\nMap.addLayer(fc, {}, \"Countries\")\nMap\n</pre> Map = geemap.Map()  fc = ee.FeatureCollection('users/giswqs/public/countries') Map.addLayer(fc, {}, \"Countries\") Map In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\nout_shp = os.path.join(out_dir, 'countries.shp')\n</pre> out_dir = os.path.expanduser('~/Downloads') out_shp = os.path.join(out_dir, 'countries.shp') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_shp(fc, filename=out_shp)\n</pre> geemap.ee_to_shp(fc, filename=out_shp) In\u00a0[\u00a0]: Copied! <pre>out_csv = os.path.join(out_dir, 'countries.csv')\ngeemap.ee_export_vector(fc, filename=out_csv)\n</pre> out_csv = os.path.join(out_dir, 'countries.csv') geemap.ee_export_vector(fc, filename=out_csv) In\u00a0[\u00a0]: Copied! <pre>out_kml = os.path.join(out_dir, 'countries.kml')\ngeemap.ee_export_vector(fc, filename=out_kml)\n</pre> out_kml = os.path.join(out_dir, 'countries.kml') geemap.ee_export_vector(fc, filename=out_kml) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_vector_to_drive(fc, description=\"countries\", folder=\"export\", file_format=\"shp\")\n</pre> # geemap.ee_export_vector_to_drive(fc, description=\"countries\", folder=\"export\", file_format=\"shp\") <p>Steps to deploy an Earth Engine App:</p> <ol> <li>Install ngrok by following the instruction</li> <li>Download the notebook 71_timelapse.ipynb</li> <li>Run this from the command line: <code>voila --no-browser 71_timelapse.ipynb</code></li> <li>Run this from the command line: <code>ngrok http 8866</code></li> <li>Copy the link from the ngrok terminal window. The links looks like the following: https://randomstring.ngrok.io</li> <li>Share the link with anyone.</li> </ol> <p>Optional steps:</p> <ul> <li>To show code cells from you app, run this from the command line: <code>voila --no-browser --strip_sources=False 71_timelapse.ipynb</code></li> <li>To protect your app with a password, run this: <code>ngrok http -auth=\"username:password\" 8866</code></li> <li>To run python simple http server in the directory, run this:<code>sudo python -m http.server 80</code></li> </ul> In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube(\"https://youtu.be/eRDZBVJcNCk\")\n</pre> geemap.show_youtube(\"https://youtu.be/eRDZBVJcNCk\") <p>Steps to deploy an Earth Engine App:</p> <ul> <li>Sign up for a free heroku account.</li> <li>Follow the instructions to install Git and Heroku Command Line Interface (CLI).</li> <li>Authenticate heroku using the <code>heroku login</code> command.</li> <li>Clone this repository: https://github.com/gee-community/geemap-heroku</li> <li>Create your own Earth Engine notebook and put it under the <code>notebooks</code> directory.</li> <li>Add Python dependencies in the <code>requirements.txt</code> file if needed.</li> <li>Edit the <code>Procfile</code> file by replacing <code>notebooks/geemap.ipynb</code> with the path to your own notebook.</li> <li>Commit changes to the repository by using <code>git add . &amp;&amp; git commit -am \"message\"</code>.</li> <li>Create a heroku app: <code>heroku create</code></li> <li>Run the <code>config_vars.py</code> script to extract Earth Engine token from your computer and set it as an environment variable on heroku: <code>python config_vars.py</code></li> <li>Deploy your code to heroku: <code>git push heroku master</code></li> <li>Open your heroku app: <code>heroku open</code></li> </ul> <p>Optional steps:</p> <ul> <li>To specify a name for your app, use <code>heroku apps:create example</code></li> <li>To preview your app locally, use <code>heroku local web</code></li> <li>To hide code cells from your app, you can edit the <code>Procfile</code> file and set <code>--strip_sources=True</code></li> <li>To periodically check for idle kernels, you can edit the <code>Procfile</code> file and set <code>--MappingKernelManager.cull_interval=60 --MappingKernelManager.cull_idle_timeout=120</code></li> <li>To view information about your running app, use <code>heroku logs --tail</code></li> <li>To set an environment variable on heroku, use <code>heroku config:set NAME=VALUE</code></li> <li>To view environment variables for your app, use <code>heroku config</code></li> </ul> In\u00a0[\u00a0]: Copied! <pre>geemap.show_youtube(\"https://youtu.be/nsIjfD83ggA\")\n</pre> geemap.show_youtube(\"https://youtu.be/nsIjfD83ggA\")"},{"location":"workshops/GeoPython_2021/#introduction","title":"Introduction\u00b6","text":""},{"location":"workshops/GeoPython_2021/#description","title":"Description\u00b6","text":"<p>Google Earth Engine (GEE) is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. It enables scientists, researchers, and developers to analyze and visualize changes on the Earth\u2019s surface. The geemap Python package provides GEE users with an intuitive interface to manipulate, analyze, and visualize geospatial big data interactively in a Jupyter-based environment. The topics to be covered in this workshop include:</p> <ol> <li>Introducing geemap and the Earth Engine Python API</li> <li>Creating interactive maps</li> <li>Searching GEE data catalog</li> <li>Displaying GEE datasets</li> <li>Classifying images using machine learning algorithms</li> <li>Computing statistics and exporting results</li> <li>Producing publication-quality maps</li> <li>Building and deploying interactive web apps, among others</li> </ol> <p>This workshop is intended for scientific programmers, data scientists, geospatial analysts, and concerned citizens of Earth. The attendees are expected to have a basic understanding of Python and the Jupyter ecosystem. Familiarity with Earth science and geospatial datasets is useful but not required.</p>"},{"location":"workshops/GeoPython_2021/#useful-links","title":"Useful links\u00b6","text":"<ul> <li>GeoPython 2021 Conference website</li> <li>Google Earth Engine</li> <li>geemap.org</li> <li>Google Earth Engine and geemap Python Tutorials (55 videos with a total length of 15 hours)</li> <li>Spatial Data Management with Google Earth Engine (19 videos with a total length of 9 hours)</li> <li>Ask geemap questions on GitHub</li> </ul>"},{"location":"workshops/GeoPython_2021/#prerequisite","title":"Prerequisite\u00b6","text":"<ul> <li>A Google Earth Engine account. Sign up here if needed.</li> <li>Miniconda or Anaconda</li> </ul>"},{"location":"workshops/GeoPython_2021/#set-up-a-conda-environment","title":"Set up a conda environment\u00b6","text":"<pre><code>conda create -n geo python=3.8\nconda activate geo\nconda install geemap -c conda-forge\nconda install jupyter_contrib_nbextensions -c conda-forge\njupyter contrib nbextension install --user\n</code></pre>"},{"location":"workshops/GeoPython_2021/#geemap-basics","title":"geemap basics\u00b6","text":""},{"location":"workshops/GeoPython_2021/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"workshops/GeoPython_2021/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"workshops/GeoPython_2021/#customize-the-default-map","title":"Customize the default map\u00b6","text":"<p>You can specify the center(lat, lon) and zoom for the default map. The lite mode will only show the zoom in/out tool.</p>"},{"location":"workshops/GeoPython_2021/#add-basemaps","title":"Add basemaps\u00b6","text":""},{"location":"workshops/GeoPython_2021/#change-basemaps-without-coding","title":"Change basemaps without coding\u00b6","text":""},{"location":"workshops/GeoPython_2021/#add-wms-and-xyz-tile-layers","title":"Add WMS and XYZ tile layers\u00b6","text":"<p>Examples: https://viewer.nationalmap.gov/services/</p>"},{"location":"workshops/GeoPython_2021/#use-drawing-tools","title":"Use drawing tools\u00b6","text":""},{"location":"workshops/GeoPython_2021/#convert-gee-javascript-to-python","title":"Convert GEE JavaScript to Python\u00b6","text":"<p>https://developers.google.com/earth-engine/guides/image_visualization</p>"},{"location":"workshops/GeoPython_2021/#earth-engine-datasets","title":"Earth Engine datasets\u00b6","text":""},{"location":"workshops/GeoPython_2021/#load-earth-engine-datasets","title":"Load Earth Engine datasets\u00b6","text":""},{"location":"workshops/GeoPython_2021/#search-the-earth-engine-data-catalog","title":"Search the Earth Engine Data Catalog\u00b6","text":""},{"location":"workshops/GeoPython_2021/#use-the-datasets-module","title":"Use the datasets module\u00b6","text":""},{"location":"workshops/GeoPython_2021/#use-the-inspector-tool","title":"Use the Inspector tool\u00b6","text":""},{"location":"workshops/GeoPython_2021/#data-visualization","title":"Data visualization\u00b6","text":""},{"location":"workshops/GeoPython_2021/#use-the-plotting-tool","title":"Use the Plotting tool\u00b6","text":""},{"location":"workshops/GeoPython_2021/#change-layer-opacity","title":"Change layer opacity\u00b6","text":""},{"location":"workshops/GeoPython_2021/#visualize-raster-data","title":"Visualize raster data\u00b6","text":""},{"location":"workshops/GeoPython_2021/#visualize-vector-data","title":"Visualize vector data\u00b6","text":""},{"location":"workshops/GeoPython_2021/#add-a-legend","title":"Add a legend\u00b6","text":""},{"location":"workshops/GeoPython_2021/#add-a-colorbar","title":"Add a colorbar\u00b6","text":""},{"location":"workshops/GeoPython_2021/#create-a-split-panel-map","title":"Create a split-panel map\u00b6","text":""},{"location":"workshops/GeoPython_2021/#create-linked-maps","title":"Create linked maps\u00b6","text":""},{"location":"workshops/GeoPython_2021/#create-timelapse-animations","title":"Create timelapse animations\u00b6","text":""},{"location":"workshops/GeoPython_2021/#create-time-series-composites","title":"Create time-series composites\u00b6","text":""},{"location":"workshops/GeoPython_2021/#data-analysis","title":"Data analysis\u00b6","text":""},{"location":"workshops/GeoPython_2021/#descriptive-statistics","title":"Descriptive statistics\u00b6","text":""},{"location":"workshops/GeoPython_2021/#zonal-statistics","title":"Zonal statistics\u00b6","text":""},{"location":"workshops/GeoPython_2021/#zonal-statistics-by-group","title":"Zonal statistics by group\u00b6","text":""},{"location":"workshops/GeoPython_2021/#unsupervised-classification","title":"Unsupervised classification\u00b6","text":"<p>Source: https://developers.google.com/earth-engine/guides/clustering</p> <p>The <code>ee.Clusterer</code> package handles unsupervised classification (or clustering) in Earth Engine. These algorithms are currently based on the algorithms with the same name in Weka. More details about each Clusterer are available in the reference docs in the Code Editor.</p> <p>Clusterers are used in the same manner as classifiers in Earth Engine. The general workflow for clustering is:</p> <ol> <li>Assemble features with numeric properties in which to find clusters.</li> <li>Instantiate a clusterer. Set its parameters if necessary.</li> <li>Train the clusterer using the training data.</li> <li>Apply the clusterer to an image or feature collection.</li> <li>Label the clusters.</li> </ol> <p>The training data is a <code>FeatureCollection</code> with properties that will be input to the clusterer. Unlike classifiers, there is no input class value for an <code>Clusterer</code>. Like classifiers, the data for the train and apply steps are expected to have the same number of values. When a trained clusterer is applied to an image or table, it assigns an integer cluster ID to each pixel or feature.</p> <p>Here is a simple example of building and using an ee.Clusterer:</p> <p></p>"},{"location":"workshops/GeoPython_2021/#supervised-classification","title":"Supervised classification\u00b6","text":""},{"location":"workshops/GeoPython_2021/#training-sample-creation","title":"Training sample creation\u00b6","text":""},{"location":"workshops/GeoPython_2021/#whiteboxtools","title":"WhiteboxTools\u00b6","text":""},{"location":"workshops/GeoPython_2021/#map-making","title":"Map making\u00b6","text":""},{"location":"workshops/GeoPython_2021/#plot-a-single-band-image","title":"Plot a single band image\u00b6","text":""},{"location":"workshops/GeoPython_2021/#plot-an-rgb-image","title":"Plot an RGB image\u00b6","text":""},{"location":"workshops/GeoPython_2021/#add-map-elements","title":"Add map elements\u00b6","text":""},{"location":"workshops/GeoPython_2021/#plot-multiple-layers","title":"Plot multiple layers\u00b6","text":""},{"location":"workshops/GeoPython_2021/#use-custom-projections","title":"Use custom projections\u00b6","text":""},{"location":"workshops/GeoPython_2021/#create-timelapse-animations","title":"Create timelapse animations\u00b6","text":""},{"location":"workshops/GeoPython_2021/#data-export","title":"Data export\u00b6","text":""},{"location":"workshops/GeoPython_2021/#export-eeimage","title":"Export ee.Image\u00b6","text":""},{"location":"workshops/GeoPython_2021/#export-eeimagecollection","title":"Export ee.ImageCollection\u00b6","text":""},{"location":"workshops/GeoPython_2021/#extract-pixels-as-a-numpy-array","title":"Extract pixels as a numpy array\u00b6","text":""},{"location":"workshops/GeoPython_2021/#export-pixel-values-to-points","title":"Export pixel values to points\u00b6","text":""},{"location":"workshops/GeoPython_2021/#export-eefeaturecollection","title":"Export ee.FeatureCollection\u00b6","text":""},{"location":"workshops/GeoPython_2021/#web-apps","title":"Web apps\u00b6","text":""},{"location":"workshops/GeoPython_2021/#deploy-web-apps-using-ngrok","title":"Deploy web apps using ngrok\u00b6","text":""},{"location":"workshops/GeoPython_2021/#deploy-web-apps-using-heroku","title":"Deploy web apps using Heroku\u00b6","text":""},{"location":"workshops/Japan_2022/","title":"Japan 2022","text":"<p>Introduction to Earth Engine and Geemap</p> <p>A workshop at Nagoya University, Japan.</p> <p>Useful links</p> <ul> <li>Google Earth Engine</li> <li>Sign up for an Earth Engine account</li> <li>Awesome GEE Community Datasets</li> <li>Geemap website</li> <li>Geemap book</li> <li>Geemap YouTube videos</li> <li>Streamlit Web App</li> </ul> In\u00a0[\u00a0]: Copied! <pre># pip install geemap\n</pre> # pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\n\nee.Authenticate()\n</pre> import ee  ee.Authenticate() <p>Following the instructions here to authenticate your Earth Engine account.</p> In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4, height=600)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4, height=600) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(data_ctrl=False, toolbar_ctrl=False, draw_ctrl=False)\nMap\n</pre> Map = geemap.Map(data_ctrl=False, toolbar_ctrl=False, draw_ctrl=False) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(lite_mode=True)\nMap\n</pre> Map = geemap.Map(lite_mode=True) Map In\u00a0[\u00a0]: Copied! <pre>Map.save('ipyleaflet.html')\n</pre> Map.save('ipyleaflet.html') In\u00a0[\u00a0]: Copied! <pre>import geemap\n</pre> import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(basemap='HYBRID')\nMap\n</pre> Map = geemap.Map(basemap='HYBRID') Map In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap('OpenTopoMap')\n</pre> Map.add_basemap('OpenTopoMap') In\u00a0[\u00a0]: Copied! <pre>for basemap in geemap.basemaps.keys():\n    print(basemap)\n</pre> for basemap in geemap.basemaps.keys():     print(basemap) In\u00a0[\u00a0]: Copied! <pre>len(geemap.basemaps)\n</pre> len(geemap.basemaps) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('USGS/SRTMGL1_003')\n</pre> image = ee.Image('USGS/SRTMGL1_003') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[21.79, 70.87], zoom=3)\nimage = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 6000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(image, vis_params, 'SRTM')\nMap\n</pre> Map = geemap.Map(center=[21.79, 70.87], zoom=3) image = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 6000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(image, vis_params, 'SRTM') Map In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection('COPERNICUS/S2_SR')\n</pre> collection = ee.ImageCollection('COPERNICUS/S2_SR') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ncollection = ee.ImageCollection('COPERNICUS/S2_SR')\nimage = collection.median()\n\nvis = {\n    'min': 0.0,\n    'max': 3000,\n    'bands': ['B4', 'B3', 'B2'],\n}\n\nMap.setCenter(83.277, 17.7009, 12)\nMap.addLayer(image, vis, 'Sentinel-2')\nMap\n</pre> Map = geemap.Map() collection = ee.ImageCollection('COPERNICUS/S2_SR') image = collection.median()  vis = {     'min': 0.0,     'max': 3000,     'bands': ['B4', 'B3', 'B2'], }  Map.setCenter(83.277, 17.7009, 12) Map.addLayer(image, vis, 'Sentinel-2') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ncollection = (\n    ee.ImageCollection('COPERNICUS/S2_SR')\n    .filterDate('2021-01-01', '2022-01-01')\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5))\n)\nimage = collection.median()\n\nvis = {\n    'min': 0.0,\n    'max': 3000,\n    'bands': ['B4', 'B3', 'B2'],\n}\n\nMap.setCenter(83.277, 17.7009, 12)\nMap.addLayer(image, vis, 'Sentinel-2')\nMap\n</pre> Map = geemap.Map() collection = (     ee.ImageCollection('COPERNICUS/S2_SR')     .filterDate('2021-01-01', '2022-01-01')     .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5)) ) image = collection.median()  vis = {     'min': 0.0,     'max': 3000,     'bands': ['B4', 'B3', 'B2'], }  Map.setCenter(83.277, 17.7009, 12) Map.addLayer(image, vis, 'Sentinel-2') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\npoint = ee.Geometry.Point([1.5, 1.5])\n\nlineString = ee.Geometry.LineString([[-35, -10], [35, -10], [35, 10], [-35, 10]])\n\nlinearRing = ee.Geometry.LinearRing(\n    [[-35, -10], [35, -10], [35, 10], [-35, 10], [-35, -10]]\n)\n\nrectangle = ee.Geometry.Rectangle([-40, -20, 40, 20])\n\npolygon = ee.Geometry.Polygon([[[-5, 40], [65, 40], [65, 60], [-5, 60], [-5, 60]]])\n\nMap.addLayer(point, {}, 'Point')\nMap.addLayer(lineString, {}, 'LineString')\nMap.addLayer(linearRing, {}, 'LinearRing')\nMap.addLayer(rectangle, {}, 'Rectangle')\nMap.addLayer(polygon, {}, 'Polygon')\nMap\n</pre> Map = geemap.Map()  point = ee.Geometry.Point([1.5, 1.5])  lineString = ee.Geometry.LineString([[-35, -10], [35, -10], [35, 10], [-35, 10]])  linearRing = ee.Geometry.LinearRing(     [[-35, -10], [35, -10], [35, 10], [-35, 10], [-35, -10]] )  rectangle = ee.Geometry.Rectangle([-40, -20, 40, 20])  polygon = ee.Geometry.Polygon([[[-5, 40], [65, 40], [65, 60], [-5, 60], [-5, 60]]])  Map.addLayer(point, {}, 'Point') Map.addLayer(lineString, {}, 'LineString') Map.addLayer(linearRing, {}, 'LinearRing') Map.addLayer(rectangle, {}, 'Rectangle') Map.addLayer(polygon, {}, 'Polygon') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\npoint = ee.Geometry.Point([1.5, 1.5])\n\nlineString = ee.Geometry.LineString(\n    [[-35, -10], [35, -10], [35, 10], [-35, 10]], None, False\n)\n\nlinearRing = ee.Geometry.LinearRing(\n    [[-35, -10], [35, -10], [35, 10], [-35, 10], [-35, -10]], None, False\n)\n\nrectangle = ee.Geometry.Rectangle([-40, -20, 40, 20], None, False)\n\npolygon = ee.Geometry.Polygon(\n    [[[-5, 40], [65, 40], [65, 60], [-5, 60], [-5, 60]]], None, False\n)\n\nMap.addLayer(point, {}, 'Point')\nMap.addLayer(lineString, {}, 'LineString')\nMap.addLayer(linearRing, {}, 'LinearRing')\nMap.addLayer(rectangle, {}, 'Rectangle')\nMap.addLayer(polygon, {}, 'Polygon')\nMap\n</pre> Map = geemap.Map()  point = ee.Geometry.Point([1.5, 1.5])  lineString = ee.Geometry.LineString(     [[-35, -10], [35, -10], [35, 10], [-35, 10]], None, False )  linearRing = ee.Geometry.LinearRing(     [[-35, -10], [35, -10], [35, 10], [-35, 10], [-35, -10]], None, False )  rectangle = ee.Geometry.Rectangle([-40, -20, 40, 20], None, False)  polygon = ee.Geometry.Polygon(     [[[-5, 40], [65, 40], [65, 60], [-5, 60], [-5, 60]]], None, False )  Map.addLayer(point, {}, 'Point') Map.addLayer(lineString, {}, 'LineString') Map.addLayer(linearRing, {}, 'LinearRing') Map.addLayer(rectangle, {}, 'Rectangle') Map.addLayer(polygon, {}, 'Polygon') Map In\u00a0[\u00a0]: Copied! <pre>if Map.user_roi is not None:\n    print(Map.user_roi.getInfo())\n</pre> if Map.user_roi is not None:     print(Map.user_roi.getInfo()) In\u00a0[\u00a0]: Copied! <pre># Create an ee.Geometry.\npolygon = ee.Geometry.Polygon(\n    [[[-35, -10], [35, -10], [35, 10], [-35, 10], [-35, -10]]], None, False\n)\n\n# Create a Feature from the Geometry.\npolyFeature = ee.Feature(polygon, {'foo': 42, 'bar': 'tart'})\n</pre> # Create an ee.Geometry. polygon = ee.Geometry.Polygon(     [[[-35, -10], [35, -10], [35, 10], [-35, 10], [-35, -10]]], None, False )  # Create a Feature from the Geometry. polyFeature = ee.Feature(polygon, {'foo': 42, 'bar': 'tart'}) In\u00a0[\u00a0]: Copied! <pre>polyFeature.getInfo()\n</pre> polyFeature.getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.addLayer(polyFeature, {}, 'feature')\nMap\n</pre> Map = geemap.Map() Map.addLayer(polyFeature, {}, 'feature') Map In\u00a0[\u00a0]: Copied! <pre># Create a dictionary of properties, some of which may be computed values.\nprops = {'foo': ee.Number(8).add(88), 'bar': 'nihao'}\n\n# Create a None geometry feature with the dictionary of properties.\nnowhereFeature = ee.Feature(None, props)\n\nnowhereFeature.getInfo()\n</pre> # Create a dictionary of properties, some of which may be computed values. props = {'foo': ee.Number(8).add(88), 'bar': 'nihao'}  # Create a None geometry feature with the dictionary of properties. nowhereFeature = ee.Feature(None, props)  nowhereFeature.getInfo() In\u00a0[\u00a0]: Copied! <pre># Make a feature and set some properties.\nfeature = (\n    ee.Feature(ee.Geometry.Point([-122.22599, 37.17605]))\n    .set('genus', 'Sequoia')\n    .set('species', 'sempervirens')\n)\n\n# Overwrite the old properties with a new dictionary.\nnewDict = {'genus': 'Brachyramphus', 'presence': 1, 'species': 'marmoratus'}\nfeature = feature.set(newDict)\n\n# Check the result.\nfeature.getInfo()\n</pre> # Make a feature and set some properties. feature = (     ee.Feature(ee.Geometry.Point([-122.22599, 37.17605]))     .set('genus', 'Sequoia')     .set('species', 'sempervirens') )  # Overwrite the old properties with a new dictionary. newDict = {'genus': 'Brachyramphus', 'presence': 1, 'species': 'marmoratus'} feature = feature.set(newDict)  # Check the result. feature.getInfo() In\u00a0[\u00a0]: Copied! <pre>prop = feature.get('species')\nprop.getInfo()\n</pre> prop = feature.get('species') prop.getInfo() In\u00a0[\u00a0]: Copied! <pre>props = feature.toDictionary()\nprops.getInfo()\n</pre> props = feature.toDictionary() props.getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nfc = ee.FeatureCollection('TIGER/2016/Roads')\nMap.setCenter(-73.9596, 40.7688, 12)\nMap.addLayer(fc, {}, 'Census roads')\nMap\n</pre> Map = geemap.Map() fc = ee.FeatureCollection('TIGER/2016/Roads') Map.setCenter(-73.9596, 40.7688, 12) Map.addLayer(fc, {}, 'Census roads') Map In\u00a0[\u00a0]: Copied! <pre># Make a list of Features.\nfeatures = [\n    ee.Feature(ee.Geometry.Rectangle(30.01, 59.80, 30.59, 60.15), {'name': 'Voronoi'}),\n    ee.Feature(ee.Geometry.Point(-73.96, 40.781), {'name': 'Thiessen'}),\n    ee.Feature(ee.Geometry.Point(6.4806, 50.8012), {'name': 'Dirichlet'}),\n]\n\n# Create a FeatureCollection from the list and print it.\nfromList = ee.FeatureCollection(features)\n</pre> # Make a list of Features. features = [     ee.Feature(ee.Geometry.Rectangle(30.01, 59.80, 30.59, 60.15), {'name': 'Voronoi'}),     ee.Feature(ee.Geometry.Point(-73.96, 40.781), {'name': 'Thiessen'}),     ee.Feature(ee.Geometry.Point(6.4806, 50.8012), {'name': 'Dirichlet'}), ]  # Create a FeatureCollection from the list and print it. fromList = ee.FeatureCollection(features) In\u00a0[\u00a0]: Copied! <pre>fromList.getInfo()\n</pre> fromList.getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nstates = ee.FeatureCollection('TIGER/2018/States')\nfeat = states.filter(ee.Filter.eq('NAME', 'Texas'))\nMap.addLayer(feat, {}, 'Texas')\nMap.centerObject(feat)\nMap\n</pre> Map = geemap.Map() states = ee.FeatureCollection('TIGER/2018/States') feat = states.filter(ee.Filter.eq('NAME', 'Texas')) Map.addLayer(feat, {}, 'Texas') Map.centerObject(feat) Map In\u00a0[\u00a0]: Copied! <pre>texas = feat.first()\ntexas.toDictionary().getInfo()\n</pre> texas = feat.first() texas.toDictionary().getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nstates = ee.FeatureCollection('TIGER/2018/States')\nfc = states.filter(ee.Filter.inList('NAME', ['California', 'Oregon', 'Washington']))\nMap.addLayer(fc, {}, 'West Coast')\nMap.centerObject(fc)\nMap\n</pre> Map = geemap.Map() states = ee.FeatureCollection('TIGER/2018/States') fc = states.filter(ee.Filter.inList('NAME', ['California', 'Oregon', 'Washington'])) Map.addLayer(fc, {}, 'West Coast') Map.centerObject(fc) Map In\u00a0[\u00a0]: Copied! <pre>region = Map.user_roi\nif region is None:\n    region = ee.Geometry.BBox(-88.40, 29.88, -77.90, 35.39)\n\nfc = ee.FeatureCollection('TIGER/2018/States').filterBounds(region)\nMap.addLayer(fc, {}, 'Southeastern U.S.')\nMap.centerObject(fc)\n</pre> region = Map.user_roi if region is None:     region = ee.Geometry.BBox(-88.40, 29.88, -77.90, 35.39)  fc = ee.FeatureCollection('TIGER/2018/States').filterBounds(region) Map.addLayer(fc, {}, 'Southeastern U.S.') Map.centerObject(fc) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nimage = ee.Image().paint(states, 0, 3)\nMap.addLayer(image, {'palette': 'red'}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") image = ee.Image().paint(states, 0, 3) Map.addLayer(image, {'palette': 'red'}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {'color': '0000ffff', 'width': 2, 'lineType': 'solid', 'fillColor': 'FF000080'}\nMap.addLayer(states.style(**style), {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") style = {'color': '0000ffff', 'width': 2, 'lineType': 'solid', 'fillColor': 'FF000080'} Map.addLayer(states.style(**style), {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nvis_params = {\n    'color': '000000',\n    'colorOpacity': 1,\n    'pointSize': 3,\n    'pointShape': 'circle',\n    'width': 2,\n    'lineType': 'solid',\n    'fillColorOpacity': 0.66,\n}\npalette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") vis_params = {     'color': '000000',     'colorOpacity': 1,     'pointSize': 3,     'pointShape': 'circle',     'width': 2,     'lineType': 'solid',     'fillColorOpacity': 0.66, } palette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'] Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[28.00142, -81.7424], zoom=13)\nMap.add_basemap('HYBRID')\n</pre> Map = geemap.Map(center=[28.00142, -81.7424], zoom=13) Map.add_basemap('HYBRID') In\u00a0[\u00a0]: Copied! <pre>types = [\n    \"Freshwater Forested/Shrub Wetland\",\n    \"Freshwater Emergent Wetland\",\n    \"Freshwater Pond\",\n    \"Estuarine and Marine Wetland\",\n    \"Riverine\",\n    \"Lake\",\n    \"Estuarine and Marine Deepwater\",\n    \"Other\",\n]\n\ncolors = [\n    \"#008837\",\n    \"#7FC31C\",\n    \"#688CC0\",\n    \"#66C2A5\",\n    \"#0190BF\",\n    \"#13007C\",\n    \"#007C88\",\n    \"#B28653\",\n]\n\nfillColor = [c + \"A8\" for c in colors]\n</pre> types = [     \"Freshwater Forested/Shrub Wetland\",     \"Freshwater Emergent Wetland\",     \"Freshwater Pond\",     \"Estuarine and Marine Wetland\",     \"Riverine\",     \"Lake\",     \"Estuarine and Marine Deepwater\",     \"Other\", ]  colors = [     \"#008837\",     \"#7FC31C\",     \"#688CC0\",     \"#66C2A5\",     \"#0190BF\",     \"#13007C\",     \"#007C88\",     \"#B28653\", ]  fillColor = [c + \"A8\" for c in colors] In\u00a0[\u00a0]: Copied! <pre>fc = ee.FeatureCollection(\"projects/sat-io/open-datasets/NWI/wetlands/FL_Wetlands\")\nstyled_fc = geemap.ee_vector_style(\n    fc, column='WETLAND_TY', labels=types, fillColor=fillColor, color='00000000'\n)\n</pre> fc = ee.FeatureCollection(\"projects/sat-io/open-datasets/NWI/wetlands/FL_Wetlands\") styled_fc = geemap.ee_vector_style(     fc, column='WETLAND_TY', labels=types, fillColor=fillColor, color='00000000' ) In\u00a0[\u00a0]: Copied! <pre>Map.addLayer(styled_fc, {}, 'NWI')\nMap.add_legend(title='Wetland Type', labels=types, colors=colors)\nMap\n</pre> Map.addLayer(styled_fc, {}, 'NWI') Map.add_legend(title='Wetland Type', labels=types, colors=colors) Map In\u00a0[\u00a0]: Copied! <pre>fuels = [\n    'Coal',\n    'Oil',\n    'Gas',\n    'Hydro',\n    'Nuclear',\n    'Solar',\n    'Waste',\n    'Wind',\n    'Geothermal',\n    'Biomass',\n]\ncolors = [\n    '000000',\n    '593704',\n    'BC80BD',\n    '0565A6',\n    'E31A1C',\n    'FF7F00',\n    '6A3D9A',\n    '5CA2D1',\n    'FDBF6F',\n    '229A00',\n]\n</pre> fuels = [     'Coal',     'Oil',     'Gas',     'Hydro',     'Nuclear',     'Solar',     'Waste',     'Wind',     'Geothermal',     'Biomass', ] colors = [     '000000',     '593704',     'BC80BD',     '0565A6',     'E31A1C',     'FF7F00',     '6A3D9A',     '5CA2D1',     'FDBF6F',     '229A00', ] In\u00a0[\u00a0]: Copied! <pre>fc = ee.FeatureCollection(\"WRI/GPPD/power_plants\").filter(\n    ee.Filter.inList('fuel1', fuels)\n)\nstyled_fc = geemap.ee_vector_style(fc, column=\"fuel1\", labels=fuels, color=colors)\n</pre> fc = ee.FeatureCollection(\"WRI/GPPD/power_plants\").filter(     ee.Filter.inList('fuel1', fuels) ) styled_fc = geemap.ee_vector_style(fc, column=\"fuel1\", labels=fuels, color=colors) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap.addLayer(styled_fc, {}, 'Power Plants')\nMap.add_legend(title=\"Power Plant Fuel Type\", labels=fuels, colors=colors)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map.addLayer(styled_fc, {}, 'Power Plants') Map.add_legend(title=\"Power Plant Fuel Type\", labels=fuels, colors=colors) Map In\u00a0[\u00a0]: Copied! <pre>types = ['I', 'U', 'S', 'M', 'C', 'O']\nlabels = ['Interstate', 'U.S.', 'State recognized', 'Common Name', 'County', 'Other']\ncolors = ['E31A1C', 'FF7F00', '6A3D9A', '000000', 'FDBF6F', '229A00']\nwidth = [8, 5, 4, 2, 1, 1]\n</pre> types = ['I', 'U', 'S', 'M', 'C', 'O'] labels = ['Interstate', 'U.S.', 'State recognized', 'Common Name', 'County', 'Other'] colors = ['E31A1C', 'FF7F00', '6A3D9A', '000000', 'FDBF6F', '229A00'] width = [8, 5, 4, 2, 1, 1] In\u00a0[\u00a0]: Copied! <pre>fc = ee.FeatureCollection('TIGER/2016/Roads')\nstyled_fc = geemap.ee_vector_style(\n    fc, column='rttyp', labels=types, color=colors, width=width\n)\n</pre> fc = ee.FeatureCollection('TIGER/2016/Roads') styled_fc = geemap.ee_vector_style(     fc, column='rttyp', labels=types, color=colors, width=width ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40.7424, -73.9724], zoom=13)\nMap.addLayer(styled_fc, {}, 'Census Roads')\nMap.add_legend(title='Route Type', labels=labels, colors=colors)\nMap\n</pre> Map = geemap.Map(center=[40.7424, -73.9724], zoom=13) Map.addLayer(styled_fc, {}, 'Census Roads') Map.add_legend(title='Route Type', labels=labels, colors=colors) Map In\u00a0[\u00a0]: Copied! <pre>dataset_xyz = ee.Image('USGS/SRTMGL1_003')\nMap.addLayer(dataset_xyz, {}, \"USGS/SRTMGL1_003\")\n</pre> dataset_xyz = ee.Image('USGS/SRTMGL1_003') Map.addLayer(dataset_xyz, {}, \"USGS/SRTMGL1_003\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map() dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(dem, vis_params, 'SRTM DEM') Map In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import DATA\n</pre> from geemap.datasets import DATA In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\ndataset = ee.Image(DATA.USGS_GAP_CONUS_2011)\nMap.addLayer(dataset, {}, 'GAP CONUS')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) dataset = ee.Image(DATA.USGS_GAP_CONUS_2011) Map.addLayer(dataset, {}, 'GAP CONUS') Map In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import get_metadata\n\nget_metadata(DATA.USGS_GAP_CONUS_2011)\n</pre> from geemap.datasets import get_metadata  get_metadata(DATA.USGS_GAP_CONUS_2011) In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503')\n</pre> image = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503') In\u00a0[\u00a0]: Copied! <pre>image.bandNames().getInfo()\n</pre> image.bandNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>image.select('SR_B1').projection().getInfo()\n</pre> image.select('SR_B1').projection().getInfo() In\u00a0[\u00a0]: Copied! <pre>image.select('SR_B1').projection().nominalScale().getInfo()\n</pre> image.select('SR_B1').projection().nominalScale().getInfo() In\u00a0[\u00a0]: Copied! <pre>image.propertyNames().getInfo()\n</pre> image.propertyNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>image.get('CLOUD_COVER').getInfo()\n</pre> image.get('CLOUD_COVER').getInfo() In\u00a0[\u00a0]: Copied! <pre>image.get('DATE_ACQUIRED').getInfo()\n</pre> image.get('DATE_ACQUIRED').getInfo() In\u00a0[\u00a0]: Copied! <pre>image.get('system:time_start').getInfo()\n</pre> image.get('system:time_start').getInfo() In\u00a0[\u00a0]: Copied! <pre>date = ee.Date(image.get('system:time_start'))\ndate.format('YYYY-MM-dd').getInfo()\n</pre> date = ee.Date(image.get('system:time_start')) date.format('YYYY-MM-dd').getInfo() In\u00a0[\u00a0]: Copied! <pre>image.toDictionary().getInfo()\n</pre> image.toDictionary().getInfo() In\u00a0[\u00a0]: Copied! <pre>props = geemap.image_props(image)\nprops.getInfo()\n</pre> props = geemap.image_props(image) props.getInfo() In\u00a0[\u00a0]: Copied! <pre>image = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503')\ngeemap.image_min_value(image).getInfo()\n</pre> image = ee.Image('LANDSAT/LC09/C02/T1_L2/LC09_044034_20220503') geemap.image_min_value(image).getInfo() In\u00a0[\u00a0]: Copied! <pre>geemap.image_max_value(image).getInfo()\n</pre> geemap.image_max_value(image).getInfo() In\u00a0[\u00a0]: Copied! <pre>geemap.image_mean_value(image).getInfo()\n</pre> geemap.image_mean_value(image).getInfo() In\u00a0[\u00a0]: Copied! <pre>geemap.image_stats(image).getInfo()\n</pre> geemap.image_stats(image).getInfo() In\u00a0[\u00a0]: Copied! <pre># Create an interactive map\nMap = geemap.Map(center=(40, -100), zoom=4)\n\n# Add Earth Engine datasets\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to the map\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\n\n# Display the map\nMap\n</pre> # Create an interactive map Map = geemap.Map(center=(40, -100), zoom=4)  # Add Earth Engine datasets dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to the map Map.addLayer(dem, vis_params, 'SRTM DEM') Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2.0},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\")  # Display the map Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat7, landsat_vis, \"Landsat\")\n\nhyperion = ee.ImageCollection('EO1/HYPERION').filter(\n    ee.Filter.date('2016-01-01', '2017-03-01')\n)\n\nhyperion_vis = {\n    'min': 1000.0,\n    'max': 14000.0,\n    'gamma': 2.5,\n}\nMap.addLayer(hyperion, hyperion_vis, 'Hyperion')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] )  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat7, landsat_vis, \"Landsat\")  hyperion = ee.ImageCollection('EO1/HYPERION').filter(     ee.Filter.date('2016-01-01', '2017-03-01') )  hyperion_vis = {     'min': 1000.0,     'max': 14000.0,     'gamma': 2.5, } Map.addLayer(hyperion, hyperion_vis, 'Hyperion') Map In\u00a0[\u00a0]: Copied! <pre>Map.set_plot_options(add_marker_cluster=True, overlay=True)\n</pre> Map.set_plot_options(add_marker_cluster=True, overlay=True) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\ndem = ee.Image('USGS/SRTMGL1_003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap.addLayer(states, {}, \"US States\", True)\n\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  dem = ee.Image('USGS/SRTMGL1_003') states = ee.FeatureCollection(\"TIGER/2018/States\")  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map.addLayer(states, {}, \"US States\", True)  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[12, 69], zoom=3)\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map(center=[12, 69], zoom=3) dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(dem, vis_params, 'SRTM DEM') Map In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'bands': ['elevation'],\n    'palette': ['333399', ' 00b2b2', ' 99eb85', ' ccbe7d', ' 997c76', ' ffffff'],\n    'min': 0.0,\n    'max': 6000.0,\n    'opacity': 1.0,\n    'gamma': 1.0,\n}\n</pre> vis_params = {     'bands': ['elevation'],     'palette': ['333399', ' 00b2b2', ' 99eb85', ' ccbe7d', ' 997c76', ' ffffff'],     'min': 0.0,     'max': 6000.0,     'opacity': 1.0,     'gamma': 1.0, } In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nvis_params = {\n    'min': 20,\n    'max': 200,\n    'gamma': 2,\n    'bands': ['B4', 'B3', 'B2'],\n}\nMap.addLayer(landsat7, vis_params, 'Landsat 7')\nMap\n</pre> Map = geemap.Map() landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') vis_params = {     'min': 20,     'max': 200,     'gamma': 2,     'bands': ['B4', 'B3', 'B2'], } Map.addLayer(landsat7, vis_params, 'Landsat 7') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map() states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'color': 'ff0000ff',\n    'width': 2,\n    'lineType': 'solid',\n    'fillColor': '00000000',\n}\n</pre> vis_params = {     'color': 'ff0000ff',     'width': 2,     'lineType': 'solid',     'fillColor': '00000000', } In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states.style(**vis_params), {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states.style(**vis_params), {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>legends = geemap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = geemap.builtin_legends for legend in legends:     print(legend) In\u00a0[\u00a0]: Copied! <pre>Map.add_legend(builtin_legend='NLCD')\n</pre> Map.add_legend(builtin_legend='NLCD') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap.add_basemap('HYBRID')\n\nnlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')\nlandcover = nlcd.select('landcover')\n\nMap.addLayer(landcover, {}, 'NLCD Land Cover 2019')\nMap.add_legend(\n    title=\"NLCD Land Cover Classification\", builtin_legend='NLCD', height='465px'\n)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map.add_basemap('HYBRID')  nlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019') landcover = nlcd.select('landcover')  Map.addLayer(landcover, {}, 'NLCD Land Cover 2019') Map.add_legend(     title=\"NLCD Land Cover Classification\", builtin_legend='NLCD', height='465px' ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(add_google_map=False)\n\nlabels = ['One', 'Two', 'Three', 'Four', 'ect']\n\n# colors can be defined using either hex code or RGB (0-255, 0-255, 0-255)\ncolors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3']\n# legend_colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68 123)]\n\nMap.add_legend(labels=labels, colors=colors, position='bottomright')\nMap\n</pre> Map = geemap.Map(add_google_map=False)  labels = ['One', 'Two', 'Three', 'Four', 'ect']  # colors can be defined using either hex code or RGB (0-255, 0-255, 0-255) colors = ['#8DD3C7', '#FFFFB3', '#BEBADA', '#FB8072', '#80B1D3'] # legend_colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68 123)]  Map.add_legend(labels=labels, colors=colors, position='bottomright') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\nlegend_dict = {\n    '11 Open Water': '466b9f',\n    '12 Perennial Ice/Snow': 'd1def8',\n    '21 Developed, Open Space': 'dec5c5',\n    '22 Developed, Low Intensity': 'd99282',\n    '23 Developed, Medium Intensity': 'eb0000',\n    '24 Developed High Intensity': 'ab0000',\n    '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',\n    '41 Deciduous Forest': '68ab5f',\n    '42 Evergreen Forest': '1c5f2c',\n    '43 Mixed Forest': 'b5c58f',\n    '51 Dwarf Scrub': 'af963c',\n    '52 Shrub/Scrub': 'ccb879',\n    '71 Grassland/Herbaceous': 'dfdfc2',\n    '72 Sedge/Herbaceous': 'd1d182',\n    '73 Lichens': 'a3cc51',\n    '74 Moss': '82ba9e',\n    '81 Pasture/Hay': 'dcd939',\n    '82 Cultivated Crops': 'ab6c28',\n    '90 Woody Wetlands': 'b8d9eb',\n    '95 Emergent Herbaceous Wetlands': '6c9fb8',\n}\n\nnlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')\nlandcover = nlcd.select('landcover')\n\nMap.addLayer(landcover, {}, 'NLCD Land Cover 2019')\nMap.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  legend_dict = {     '11 Open Water': '466b9f',     '12 Perennial Ice/Snow': 'd1def8',     '21 Developed, Open Space': 'dec5c5',     '22 Developed, Low Intensity': 'd99282',     '23 Developed, Medium Intensity': 'eb0000',     '24 Developed High Intensity': 'ab0000',     '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',     '41 Deciduous Forest': '68ab5f',     '42 Evergreen Forest': '1c5f2c',     '43 Mixed Forest': 'b5c58f',     '51 Dwarf Scrub': 'af963c',     '52 Shrub/Scrub': 'ccb879',     '71 Grassland/Herbaceous': 'dfdfc2',     '72 Sedge/Herbaceous': 'd1d182',     '73 Lichens': 'a3cc51',     '74 Moss': '82ba9e',     '81 Pasture/Hay': 'dcd939',     '82 Cultivated Crops': 'ab6c28',     '90 Woody Wetlands': 'b8d9eb',     '95 Emergent Herbaceous Wetlands': '6c9fb8', }  nlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019') landcover = nlcd.select('landcover')  Map.addLayer(landcover, {}, 'NLCD Land Cover 2019') Map.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM') Map In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\")\n</pre> Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\") In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\"\n)\n</pre> Map.add_colorbar(     vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\" ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n)\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     layer_name=\"SRTM DEM\",     orientation=\"vertical\",     transparent_bg=True, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4, add_google_map=False)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {'color': 'black', 'fillColor': \"00000000\"}\nMap.addLayer(states.style(**style), {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4, add_google_map=False) states = ee.FeatureCollection(\"TIGER/2018/States\") style = {'color': 'black', 'fillColor': \"00000000\"} Map.addLayer(states.style(**style), {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map.add_labels(\n    data=states,\n    column=\"STUSPS\",\n    font_size=\"12pt\",\n    font_color=\"blue\",\n    font_family=\"arial\",\n    font_weight=\"bold\",\n    draggable=True,\n)\n</pre> Map.add_labels(     data=states,     column=\"STUSPS\",     font_size=\"12pt\",     font_color=\"blue\",     font_family=\"arial\",     font_weight=\"bold\",     draggable=True, ) In\u00a0[\u00a0]: Copied! <pre>Map.remove_labels()\n</pre> Map.remove_labels() In\u00a0[\u00a0]: Copied! <pre>centroids = geemap.vector_centroids(states)\ndf = geemap.ee_to_df(centroids)\ndf\n</pre> centroids = geemap.vector_centroids(states) df = geemap.ee_to_df(centroids) df In\u00a0[\u00a0]: Copied! <pre>Map.add_labels(\n    data=df,\n    column=\"STUSPS\",\n    font_size=\"12pt\",\n    font_color=\"blue\",\n    font_family=\"arial\",\n    font_weight=\"bold\",\n    x='longitude',\n    y='latitude',\n)\nMap\n</pre> Map.add_labels(     data=df,     column=\"STUSPS\",     font_size=\"12pt\",     font_color=\"blue\",     font_family=\"arial\",     font_weight=\"bold\",     x='longitude',     y='latitude', ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(left_layer='HYBRID', right_layer='TERRAIN')\nMap\n</pre> Map = geemap.Map() Map.split_map(left_layer='HYBRID', right_layer='TERRAIN') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4, height=600)\n\nnlcd_2001 = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2001').select('landcover')\nnlcd_2019 = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019').select('landcover')\n\nleft_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001')\nright_layer = geemap.ee_tile_layer(nlcd_2019, {}, 'NLCD 2019')\n\nMap.split_map(left_layer, right_layer)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4, height=600)  nlcd_2001 = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2001').select('landcover') nlcd_2019 = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019').select('landcover')  left_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001') right_layer = geemap.ee_tile_layer(nlcd_2019, {}, 'NLCD 2019')  Map.split_map(left_layer, right_layer) Map In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection('COPERNICUS/S2')\n    .filterDate('2018-09-01', '2018-09-30')\n    .map(lambda img: img.divide(10000))\n    .median()\n)\n\nvis_params = [\n    {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n]\n\nlabels = [\n    'Natural Color (B4/B3/B2)',\n    'Land/Water (B8/B11/B4)',\n    'Color Infrared (B8/B4/B3)',\n    'Vegetation (B12/B11/B4)',\n]\n\ngeemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"300px\",\n    center=[38.4151, 21.2712],\n    zoom=12,\n    ee_objects=[image],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n</pre> image = (     ee.ImageCollection('COPERNICUS/S2')     .filterDate('2018-09-01', '2018-09-30')     .map(lambda img: img.divide(10000))     .median() )  vis_params = [     {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3}, ]  labels = [     'Natural Color (B4/B3/B2)',     'Land/Water (B8/B11/B4)',     'Color Infrared (B8/B4/B3)',     'Vegetation (B12/B11/B4)', ]  geemap.linked_maps(     rows=2,     cols=2,     height=\"300px\",     center=[38.4151, 21.2712],     zoom=12,     ee_objects=[image],     vis_params=vis_params,     labels=labels,     label_position=\"topright\", ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\ncollection = ee.ImageCollection('USGS/NLCD_RELEASES/2019_REL/NLCD').select('landcover')\nvis_params = {'bands': ['landcover']}\nyears = collection.aggregate_array('system:index').getInfo()\nyears\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) collection = ee.ImageCollection('USGS/NLCD_RELEASES/2019_REL/NLCD').select('landcover') vis_params = {'bands': ['landcover']} years = collection.aggregate_array('system:index').getInfo() years In\u00a0[\u00a0]: Copied! <pre>Map.ts_inspector(\n    left_ts=collection,\n    right_ts=collection,\n    left_names=years,\n    right_names=years,\n    left_vis=vis_params,\n    right_vis=vis_params,\n    width='80px',\n)\nMap\n</pre> Map.ts_inspector(     left_ts=collection,     right_ts=collection,     left_names=years,     right_names=years,     left_vis=vis_params,     right_vis=vis_params,     width='80px', ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = (\n    ee.ImageCollection('MODIS/MCD43A4_006_NDVI')\n    .filter(ee.Filter.date('2018-06-01', '2018-07-01'))\n    .select(\"NDVI\")\n)\nvis_params = {\n    'min': 0.0,\n    'max': 1.0,\n    'palette': [\n        'FFFFFF',\n        'CE7E45',\n        'DF923D',\n        'F1B555',\n        'FCD163',\n        '99B718',\n        '74A901',\n        '66A000',\n        '529400',\n        '3E8601',\n        '207401',\n        '056201',\n        '004C00',\n        '023B01',\n        '012E01',\n        '011D01',\n        '011301',\n    ],\n}\n\nMap.add_time_slider(collection, vis_params, time_interval=2)\nMap\n</pre> Map = geemap.Map()  collection = (     ee.ImageCollection('MODIS/MCD43A4_006_NDVI')     .filter(ee.Filter.date('2018-06-01', '2018-07-01'))     .select(\"NDVI\") ) vis_params = {     'min': 0.0,     'max': 1.0,     'palette': [         'FFFFFF',         'CE7E45',         'DF923D',         'F1B555',         'FCD163',         '99B718',         '74A901',         '66A000',         '529400',         '3E8601',         '207401',         '056201',         '004C00',         '023B01',         '012E01',         '011D01',         '011301',     ], }  Map.add_time_slider(collection, vis_params, time_interval=2) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = (\n    ee.ImageCollection('NOAA/GFS0P25')\n    .filterDate('2018-12-22', '2018-12-23')\n    .limit(24)\n    .select('temperature_2m_above_ground')\n)\n\nvis_params = {\n    'min': -40.0,\n    'max': 35.0,\n    'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'],\n}\n\nlabels = [str(n).zfill(2) + \":00\" for n in range(0, 24)]\nMap.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8)\nMap\n</pre> Map = geemap.Map()  collection = (     ee.ImageCollection('NOAA/GFS0P25')     .filterDate('2018-12-22', '2018-12-23')     .limit(24)     .select('temperature_2m_above_ground') )  vis_params = {     'min': -40.0,     'max': 35.0,     'palette': ['blue', 'purple', 'cyan', 'green', 'yellow', 'red'], }  labels = [str(n).zfill(2) + \":00\" for n in range(0, 24)] Map.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[37.75, -122.45], zoom=12)\n\ncollection = (\n    ee.ImageCollection('COPERNICUS/S2_SR')\n    .filterBounds(ee.Geometry.Point([-122.45, 37.75]))\n    .filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10)\n)\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\n\nMap.add_time_slider(collection, vis_params)\nMap\n</pre> Map = geemap.Map(center=[37.75, -122.45], zoom=12)  collection = (     ee.ImageCollection('COPERNICUS/S2_SR')     .filterBounds(ee.Geometry.Point([-122.45, 37.75]))     .filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 10) )  vis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}  Map.add_time_slider(collection, vis_params) Map In\u00a0[\u00a0]: Copied! <pre>import geemap.colormaps as cm\n\nMap = geemap.Map()\n\ndem = ee.Image(\"USGS/SRTMGL1_003\")\nhillshade = ee.Terrain.hillshade(dem)\n\nvis = {'min': 0, 'max': 6000, 'palette': cm.palettes.terrain}\nblend = geemap.blend(top_layer=dem, top_vis=vis)\n\nMap.addLayer(hillshade, {}, 'Hillshade')\nMap.addLayer(blend, {}, 'Shaded relief')\n\nMap.add_colorbar(vis, label='Elevation (m)')\nMap.setCenter(91.4206, 27.3225, zoom=9)\nMap\n</pre> import geemap.colormaps as cm  Map = geemap.Map()  dem = ee.Image(\"USGS/SRTMGL1_003\") hillshade = ee.Terrain.hillshade(dem)  vis = {'min': 0, 'max': 6000, 'palette': cm.palettes.terrain} blend = geemap.blend(top_layer=dem, top_vis=vis)  Map.addLayer(hillshade, {}, 'Hillshade') Map.addLayer(blend, {}, 'Shaded relief')  Map.add_colorbar(vis, label='Elevation (m)') Map.setCenter(91.4206, 27.3225, zoom=9) Map In\u00a0[\u00a0]: Copied! <pre>left_layer = geemap.ee_tile_layer(blend, {}, \"Shaded relief\")\nright_layer = geemap.ee_tile_layer(hillshade, {}, \"Hillshade\")\nMap.split_map(left_layer, right_layer)\n</pre> left_layer = geemap.ee_tile_layer(blend, {}, \"Shaded relief\") right_layer = geemap.ee_tile_layer(hillshade, {}, \"Hillshade\") Map.split_map(left_layer, right_layer) In\u00a0[\u00a0]: Copied! <pre>nlcd = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover')\nnlcd_vis = {'bands': ['landcover']}\nblend = geemap.blend(nlcd, dem, top_vis=nlcd_vis, expression='a*b')\nMap.addLayer(blend, {}, 'Blend NLCD')\nMap.add_legend(builtin_legend='NLCD', title='NLCD Land Cover')\nMap.setCenter(-118.1310, 35.6816, 10)\n</pre> nlcd = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover') nlcd_vis = {'bands': ['landcover']} blend = geemap.blend(nlcd, dem, top_vis=nlcd_vis, expression='a*b') Map.addLayer(blend, {}, 'Blend NLCD') Map.add_legend(builtin_legend='NLCD', title='NLCD Land Cover') Map.setCenter(-118.1310, 35.6816, 10) In\u00a0[\u00a0]: Copied! <pre>import geemap.colormaps as cm\n</pre> import geemap.colormaps as cm In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nimage = ee.Image(\"USGS/SRTMGL1_003\")\nhillshade = ee.Terrain.hillshade(image)\nMap.addLayer(hillshade, {}, \"Hillshade\")\nMap\n</pre> Map = geemap.Map() image = ee.Image(\"USGS/SRTMGL1_003\") hillshade = ee.Terrain.hillshade(image) Map.addLayer(hillshade, {}, \"Hillshade\") Map In\u00a0[\u00a0]: Copied! <pre>vis_params = {'min': 0, \"max\": 5000, \"palette\": cm.palettes.dem}\nMap.addLayer(image, vis_params, \"dem\", True, 0.5)\nMap.add_colorbar(vis_params, label='Elevation (m)')\n</pre> vis_params = {'min': 0, \"max\": 5000, \"palette\": cm.palettes.dem} Map.addLayer(image, vis_params, \"dem\", True, 0.5) Map.add_colorbar(vis_params, label='Elevation (m)') In\u00a0[\u00a0]: Copied! <pre>contours = geemap.create_contours(image, 0, 5000, 100, region=None)\nMap.addLayer(contours, {'palette': 'black'}, 'contours')\nMap.setCenter(-119.3678, 37.1671, 12)\n</pre> contours = geemap.create_contours(image, 0, 5000, 100, region=None) Map.addLayer(contours, {'palette': 'black'}, 'contours') Map.setCenter(-119.3678, 37.1671, 12) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\nvis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(centroid, 8)\nMap.addLayer(image, vis, \"Landsat-8\")\nMap\n</pre> Map = geemap.Map()  centroid = ee.Geometry.Point([-122.4439, 37.7538]) image = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first() vis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(centroid, 8) Map.addLayer(image, vis, \"Landsat-8\") Map In\u00a0[\u00a0]: Copied! <pre>image.propertyNames().getInfo()\n</pre> image.propertyNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>image.get('CLOUD_COVER').getInfo()  # 0.05\n</pre> image.get('CLOUD_COVER').getInfo()  # 0.05 In\u00a0[\u00a0]: Copied! <pre>props = geemap.image_props(image)\nprops.getInfo()\n</pre> props = geemap.image_props(image) props.getInfo() In\u00a0[\u00a0]: Copied! <pre>stats = geemap.image_stats(image, scale=30)\nstats.getInfo()\n</pre> stats = geemap.image_stats(image, scale=30) stats.getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\n# Add NASA SRTM\ndem = ee.Image('USGS/SRTMGL1_003')\ndem_vis = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(dem, dem_vis, 'SRTM DEM')\n\n# Add 5-year Landsat TOA composite\nlandsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat, landsat_vis, \"Landsat\", False)\n\n# Add US Census States\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {'fillColor': '00000000'}\nMap.addLayer(states.style(**style), {}, 'US States')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  # Add NASA SRTM dem = ee.Image('USGS/SRTMGL1_003') dem_vis = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(dem, dem_vis, 'SRTM DEM')  # Add 5-year Landsat TOA composite landsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat, landsat_vis, \"Landsat\", False)  # Add US Census States states = ee.FeatureCollection(\"TIGER/2018/States\") style = {'fillColor': '00000000'} Map.addLayer(states.style(**style), {}, 'US States') Map In\u00a0[\u00a0]: Copied! <pre>out_dem_stats = 'dem_stats.csv'\ngeemap.zonal_stats(\n    dem, states, out_dem_stats, statistics_type='MEAN', scale=1000, return_fc=False\n)\n</pre> out_dem_stats = 'dem_stats.csv' geemap.zonal_stats(     dem, states, out_dem_stats, statistics_type='MEAN', scale=1000, return_fc=False ) In\u00a0[\u00a0]: Copied! <pre>out_landsat_stats = 'landsat_stats.csv'\ngeemap.zonal_stats(\n    landsat,\n    states,\n    out_landsat_stats,\n    statistics_type='MEAN',\n    scale=1000,\n    return_fc=False,\n)\n</pre> out_landsat_stats = 'landsat_stats.csv' geemap.zonal_stats(     landsat,     states,     out_landsat_stats,     statistics_type='MEAN',     scale=1000,     return_fc=False, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\n# Add NLCD data\ndataset = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')\nlandcover = dataset.select('landcover')\nMap.addLayer(landcover, {}, 'NLCD 2019')\n\n# Add US census states\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {'fillColor': '00000000'}\nMap.addLayer(states.style(**style), {}, 'US States')\n\n# Add NLCD legend\nMap.add_legend(title='NLCD Land Cover', builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  # Add NLCD data dataset = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019') landcover = dataset.select('landcover') Map.addLayer(landcover, {}, 'NLCD 2019')  # Add US census states states = ee.FeatureCollection(\"TIGER/2018/States\") style = {'fillColor': '00000000'} Map.addLayer(states.style(**style), {}, 'US States')  # Add NLCD legend Map.add_legend(title='NLCD Land Cover', builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>nlcd_stats = 'nlcd_stats.csv'\n\ngeemap.zonal_stats_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    statistics_type='SUM',\n    denominator=1e6,\n    decimal_places=2,\n)\n</pre> nlcd_stats = 'nlcd_stats.csv'  geemap.zonal_stats_by_group(     landcover,     states,     nlcd_stats,     statistics_type='SUM',     denominator=1e6,     decimal_places=2, ) In\u00a0[\u00a0]: Copied! <pre>nlcd_stats = 'nlcd_stats_pct.csv'\n\ngeemap.zonal_stats_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    statistics_type='PERCENTAGE',\n    denominator=1e6,\n    decimal_places=2,\n)\n</pre> nlcd_stats = 'nlcd_stats_pct.csv'  geemap.zonal_stats_by_group(     landcover,     states,     nlcd_stats,     statistics_type='PERCENTAGE',     denominator=1e6,     decimal_places=2, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\ndem = ee.Image('USGS/3DEP/10m')\nvis = {'min': 0, 'max': 4000, 'palette': 'terrain'}\nMap.addLayer(dem, vis, 'DEM')\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) dem = ee.Image('USGS/3DEP/10m') vis = {'min': 0, 'max': 4000, 'palette': 'terrain'} Map.addLayer(dem, vis, 'DEM') Map In\u00a0[\u00a0]: Copied! <pre>landcover = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover')\nMap.addLayer(landcover, {}, 'NLCD 2019')\nMap.add_legend(title='NLCD Land Cover Classification', builtin_legend='NLCD')\n</pre> landcover = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select('landcover') Map.addLayer(landcover, {}, 'NLCD 2019') Map.add_legend(title='NLCD Land Cover Classification', builtin_legend='NLCD') In\u00a0[\u00a0]: Copied! <pre>stats = geemap.image_stats_by_zone(dem, landcover, reducer='MEAN')\nstats\n</pre> stats = geemap.image_stats_by_zone(dem, landcover, reducer='MEAN') stats In\u00a0[\u00a0]: Copied! <pre>stats.to_csv('mean.csv', index=False)\n</pre> stats.to_csv('mean.csv', index=False) In\u00a0[\u00a0]: Copied! <pre>geemap.image_stats_by_zone(dem, landcover, out_csv=\"std.csv\", reducer='STD')\n</pre> geemap.image_stats_by_zone(dem, landcover, out_csv=\"std.csv\", reducer='STD') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},\n    'Landsat 7',\n)\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},     'Landsat 7', ) Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map In\u00a0[\u00a0]: Copied! <pre>in_shp = 'us_cities.shp'\nurl = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip'\ngeemap.download_file(url)\n</pre> in_shp = 'us_cities.shp' url = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip' geemap.download_file(url) In\u00a0[\u00a0]: Copied! <pre>in_fc = geemap.shp_to_ee(in_shp)\nMap.addLayer(in_fc, {}, 'Cities')\n</pre> in_fc = geemap.shp_to_ee(in_shp) Map.addLayer(in_fc, {}, 'Cities') In\u00a0[\u00a0]: Copied! <pre>geemap.extract_values_to_points(in_fc, dem, out_fc=\"dem.shp\")\n</pre> geemap.extract_values_to_points(in_fc, dem, out_fc=\"dem.shp\") In\u00a0[\u00a0]: Copied! <pre>geemap.shp_to_gdf(\"dem.shp\")\n</pre> geemap.shp_to_gdf(\"dem.shp\") In\u00a0[\u00a0]: Copied! <pre>geemap.extract_values_to_points(in_fc, landsat7, 'landsat.csv')\n</pre> geemap.extract_values_to_points(in_fc, landsat7, 'landsat.csv') In\u00a0[\u00a0]: Copied! <pre>geemap.csv_to_df('landsat.csv')\n</pre> geemap.csv_to_df('landsat.csv') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap.add_basemap(\"TERRAIN\")\n\nimage = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(image, vis_params, 'SRTM DEM', True, 0.5)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map.add_basemap(\"TERRAIN\")  image = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(image, vis_params, 'SRTM DEM', True, 0.5) Map In\u00a0[\u00a0]: Copied! <pre>line = Map.user_roi\nif line is None:\n    line = ee.Geometry.LineString(\n        [[-120.2232, 36.3148], [-118.9269, 36.7121], [-117.2022, 36.7562]]\n    )\n    Map.addLayer(line, {}, \"ROI\")\nMap.centerObject(line)\n</pre> line = Map.user_roi if line is None:     line = ee.Geometry.LineString(         [[-120.2232, 36.3148], [-118.9269, 36.7121], [-117.2022, 36.7562]]     )     Map.addLayer(line, {}, \"ROI\") Map.centerObject(line) In\u00a0[\u00a0]: Copied! <pre>reducer = 'mean'\ntransect = geemap.extract_transect(\n    image, line, n_segments=100, reducer=reducer, to_pandas=True\n)\ntransect\n</pre> reducer = 'mean' transect = geemap.extract_transect(     image, line, n_segments=100, reducer=reducer, to_pandas=True ) transect In\u00a0[\u00a0]: Copied! <pre>geemap.line_chart(\n    data=transect,\n    x='distance',\n    y='mean',\n    markers=True,\n    x_label='Distance (m)',\n    y_label='Elevation (m)',\n    height=400,\n)\n</pre> geemap.line_chart(     data=transect,     x='distance',     y='mean',     markers=True,     x_label='Distance (m)',     y_label='Elevation (m)',     height=400, ) In\u00a0[\u00a0]: Copied! <pre>transect.to_csv('transect.csv')\n</pre> transect.to_csv('transect.csv') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = (\n    ee.ImageCollection('MODIS/061/MOD13A2')\n    .filterDate('2015-01-01', '2019-12-31')\n    .select('NDVI')\n)\n\nimage = collection.toBands()\n\nndvi_vis = {\n    'min': 0.0,\n    'max': 9000.0,\n    'palette': 'ndvi',\n}\n\nMap.addLayer(image, {}, 'MODIS NDVI Time-series')\nMap.addLayer(image.select(0), ndvi_vis, 'First image')\n\nMap\n</pre> Map = geemap.Map()  collection = (     ee.ImageCollection('MODIS/061/MOD13A2')     .filterDate('2015-01-01', '2019-12-31')     .select('NDVI') )  image = collection.toBands()  ndvi_vis = {     'min': 0.0,     'max': 9000.0,     'palette': 'ndvi', }  Map.addLayer(image, {}, 'MODIS NDVI Time-series') Map.addLayer(image.select(0), ndvi_vis, 'First image')  Map In\u00a0[\u00a0]: Copied! <pre>dates = geemap.image_dates(collection).getInfo()\ndates\n</pre> dates = geemap.image_dates(collection).getInfo() dates In\u00a0[\u00a0]: Copied! <pre>len(dates)\n</pre> len(dates) In\u00a0[\u00a0]: Copied! <pre>Map.set_plot_options(add_marker_cluster=True)\nMap.roi_reducer = ee.Reducer.mean()\nMap\n</pre> Map.set_plot_options(add_marker_cluster=True) Map.roi_reducer = ee.Reducer.mean() Map In\u00a0[\u00a0]: Copied! <pre>Map.extract_values_to_points('ndvi.csv')\n</pre> Map.extract_values_to_points('ndvi.csv') In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\")\nimage = geemap.image_count(\n    collection, region=None, start_date='2021-01-01', end_date='2022-01-01', clip=False\n)\n</pre> collection = ee.ImageCollection(\"LANDSAT/LC08/C02/T1_L2\") image = geemap.image_count(     collection, region=None, start_date='2021-01-01', end_date='2022-01-01', clip=False ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nvis = {'min': 0, 'max': 60, 'palette': 'coolwarm'}\nMap.addLayer(image, vis, 'Image Count')\nMap.add_colorbar(vis, label='Landsat 8 Image Count')\n\ncountries = ee.FeatureCollection(geemap.examples.get_ee_path('countries'))\nstyle = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"}\nMap.addLayer(countries.style(**style), {}, \"Countries\")\nMap\n</pre> Map = geemap.Map() vis = {'min': 0, 'max': 60, 'palette': 'coolwarm'} Map.addLayer(image, vis, 'Image Count') Map.add_colorbar(vis, label='Landsat 8 Image Count')  countries = ee.FeatureCollection(geemap.examples.get_ee_path('countries')) style = {\"color\": \"00000088\", \"width\": 1, \"fillColor\": \"00000000\"} Map.addLayer(countries.style(**style), {}, \"Countries\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = ee.ImageCollection('LANDSAT/LC08/C02/T1').filterDate(\n    '2021-01-01', '2022-01-01'\n)\n\ncomposite = ee.Algorithms.Landsat.simpleComposite(collection)\n\nvis_params = {'bands': ['B5', 'B4', 'B3'], 'max': 128}\n\nMap.setCenter(-122.3578, 37.7726, 10)\nMap.addLayer(composite, vis_params, 'TOA composite')\nMap\n</pre> Map = geemap.Map()  collection = ee.ImageCollection('LANDSAT/LC08/C02/T1').filterDate(     '2021-01-01', '2022-01-01' )  composite = ee.Algorithms.Landsat.simpleComposite(collection)  vis_params = {'bands': ['B5', 'B4', 'B3'], 'max': 128}  Map.setCenter(-122.3578, 37.7726, 10) Map.addLayer(composite, vis_params, 'TOA composite') Map In\u00a0[\u00a0]: Copied! <pre>customComposite = ee.Algorithms.Landsat.simpleComposite(\n    **{'collection': collection, 'percentile': 30, 'cloudScoreRange': 5}\n)\n\nMap.addLayer(customComposite, vis_params, 'Custom TOA composite')\nMap.setCenter(-105.4317, 52.5536, 11)\n</pre> customComposite = ee.Algorithms.Landsat.simpleComposite(     **{'collection': collection, 'percentile': 30, 'cloudScoreRange': 5} )  Map.addLayer(customComposite, vis_params, 'Custom TOA composite') Map.setCenter(-105.4317, 52.5536, 11) In\u00a0[\u00a0]: Copied! <pre>vis_params = [\n    {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 128},\n    {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 128},\n    {'bands': ['B7', 'B6', 'B4'], 'min': 0, 'max': 128},\n    {'bands': ['B6', 'B5', 'B2'], 'min': 0, 'max': 128},\n]\n\nlabels = [\n    'Natural Color (4, 3, 2)',\n    'Color Infrared (5, 4, 3)',\n    'Short-Wave Infrared (7, 6 4)',\n    'Agriculture (6, 5, 2)',\n]\n</pre> vis_params = [     {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 128},     {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 128},     {'bands': ['B7', 'B6', 'B4'], 'min': 0, 'max': 128},     {'bands': ['B6', 'B5', 'B2'], 'min': 0, 'max': 128}, ]  labels = [     'Natural Color (4, 3, 2)',     'Color Infrared (5, 4, 3)',     'Short-Wave Infrared (7, 6 4)',     'Agriculture (6, 5, 2)', ] In\u00a0[\u00a0]: Copied! <pre>geemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"300px\",\n    center=[37.7726, -122.1578],\n    zoom=9,\n    ee_objects=[composite],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n</pre> geemap.linked_maps(     rows=2,     cols=2,     height=\"300px\",     center=[37.7726, -122.1578],     zoom=9,     ee_objects=[composite],     vis_params=vis_params,     labels=labels,     label_position=\"topright\", ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(\n    ['B5', 'B4', 'B3']\n)\n\nvis_params = {'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n\nMap.centerObject(image)\nMap.addLayer(image, vis_params, 'Landsat')\nMap\n</pre> Map = geemap.Map()  image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318').select(     ['B5', 'B4', 'B3'] )  vis_params = {'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}  Map.centerObject(image) Map.addLayer(image, vis_params, 'Landsat') Map In\u00a0[\u00a0]: Copied! <pre>region = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252)\nfc = ee.FeatureCollection(region)\nstyle = {'color': 'ffff00ff', 'fillColor': '00000000'}\nMap.addLayer(fc.style(**style), {}, 'ROI')\nMap\n</pre> region = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252) fc = ee.FeatureCollection(region) style = {'color': 'ffff00ff', 'fillColor': '00000000'} Map.addLayer(fc.style(**style), {}, 'ROI') Map In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(image, filename=\"landsat.tif\", scale=30, region=region)\n</pre> geemap.ee_export_image(image, filename=\"landsat.tif\", scale=30, region=region) In\u00a0[\u00a0]: Copied! <pre>projection = image.select(0).projection().getInfo()\nprojection\n</pre> projection = image.select(0).projection().getInfo() projection In\u00a0[\u00a0]: Copied! <pre>crs = projection['crs']\ncrs_transform = projection['transform']\n</pre> crs = projection['crs'] crs_transform = projection['transform'] In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(\n    image,\n    filename=\"landsat_crs.tif\",\n    crs=crs,\n    crs_transform=crs_transform,\n    region=region,\n)\n</pre> geemap.ee_export_image(     image,     filename=\"landsat_crs.tif\",     crs=crs,     crs_transform=crs_transform,     region=region, ) In\u00a0[\u00a0]: Copied! <pre>geemap.download_ee_image(image, filename='landsat_full.tif', scale=60)\n</pre> geemap.download_ee_image(image, filename='landsat_full.tif', scale=60) In\u00a0[\u00a0]: Copied! <pre>fishnet = geemap.fishnet(image.geometry(), rows=4, cols=4, delta=0.5)\nstyle = {'color': 'ffff00ff', 'fillColor': '00000000'}\nMap.addLayer(fishnet.style(**style), {}, 'Fishnet')\nMap\n</pre> fishnet = geemap.fishnet(image.geometry(), rows=4, cols=4, delta=0.5) style = {'color': 'ffff00ff', 'fillColor': '00000000'} Map.addLayer(fishnet.style(**style), {}, 'Fishnet') Map In\u00a0[\u00a0]: Copied! <pre>geemap.download_ee_image_tiles(\n    image, fishnet, out_dir=\".\", prefix=\"landsat_\", crs=\"EPSG:3857\", scale=30\n)\n</pre> geemap.download_ee_image_tiles(     image, fishnet, out_dir=\".\", prefix=\"landsat_\", crs=\"EPSG:3857\", scale=30 ) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_to_drive(\n    image, description='landsat', folder='export', region=region, scale=30\n)\n</pre> geemap.ee_export_image_to_drive(     image, description='landsat', folder='export', region=region, scale=30 ) In\u00a0[\u00a0]: Copied! <pre>assetId = 'landsat_sfo'\ngeemap.ee_export_image_to_asset(\n    image, description='landsat', assetId=assetId, region=region, scale=30\n)\n</pre> assetId = 'landsat_sfo' geemap.ee_export_image_to_asset(     image, description='landsat', assetId=assetId, region=region, scale=30 ) In\u00a0[\u00a0]: Copied! <pre>region = ee.Geometry.BBox(-122.5003, 37.7233, -122.3410, 37.8026)\nrgb_img = geemap.ee_to_numpy(image, region=region)\n</pre> region = ee.Geometry.BBox(-122.5003, 37.7233, -122.3410, 37.8026) rgb_img = geemap.ee_to_numpy(image, region=region) In\u00a0[\u00a0]: Copied! <pre>print(rgb_img.shape)\n</pre> print(rgb_img.shape) In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nrgb_img_test = (255 * ((rgb_img[:, :, 0:3]) + 0.2)).astype('uint8')\nplt.imshow(rgb_img_test)\nplt.show()\n</pre> import matplotlib.pyplot as plt  rgb_img_test = (255 * ((rgb_img[:, :, 0:3]) + 0.2)).astype('uint8') plt.imshow(rgb_img_test) plt.show() In\u00a0[\u00a0]: Copied! <pre>point = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(point)\n    .filterDate('2008-01-01', '2018-01-01')\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n</pre> point = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(point)     .filterDate('2008-01-01', '2018-01-01')     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) In\u00a0[\u00a0]: Copied! <pre>collection.aggregate_array('system:index').getInfo()\n</pre> collection.aggregate_array('system:index').getInfo() In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser('~/Downloads')\ngeemap.ee_export_image_collection(collection, out_dir=out_dir, scale=10)\n</pre> out_dir = os.path.expanduser('~/Downloads') geemap.ee_export_image_collection(collection, out_dir=out_dir, scale=10) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10)\n</pre> geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection_to_asset(collection)\n</pre> geemap.ee_export_image_collection_to_asset(collection) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nfc = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017').filter(\n    ee.Filter.eq('wld_rgn', 'Europe')\n)\n\nMap.addLayer(fc, {}, \"Europe\")\nMap.centerObject(fc, 3)\nMap\n</pre> Map = geemap.Map() fc = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017').filter(     ee.Filter.eq('wld_rgn', 'Europe') )  Map.addLayer(fc, {}, \"Europe\") Map.centerObject(fc, 3) Map In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_shp(fc, filename='europe.shp', selectors=None)\n</pre> geemap.ee_to_shp(fc, filename='europe.shp', selectors=None) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_vector(fc, filename='europe2.shp')\n</pre> geemap.ee_export_vector(fc, filename='europe2.shp') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_geojson(fc, filename='europe.geojson')\n</pre> geemap.ee_to_geojson(fc, filename='europe.geojson') In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_csv(fc, filename='europe.csv')\n</pre> geemap.ee_to_csv(fc, filename='europe.csv') In\u00a0[\u00a0]: Copied! <pre>gdf = geemap.ee_to_gdf(fc)\ngdf\n</pre> gdf = geemap.ee_to_gdf(fc) gdf In\u00a0[\u00a0]: Copied! <pre>df = geemap.ee_to_df(fc)\ndf\n</pre> df = geemap.ee_to_df(fc) df In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_vector_to_drive(\n    fc, description=\"europe\", fileFormat='SHP', folder=\"export\"\n)\n</pre> geemap.ee_export_vector_to_drive(     fc, description=\"europe\", fileFormat='SHP', folder=\"export\" ) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_vector_to_asset(fc, description='Exporting Europe', assetId='europe')\n</pre> geemap.ee_export_vector_to_asset(fc, description='Exporting Europe', assetId='europe') In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nimage = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\nMap.addLayer(image, vis_params, 'SRTM DEM', True)\nMap\n</pre> Map = geemap.Map() image = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], } Map.addLayer(image, vis_params, 'SRTM DEM', True) Map In\u00a0[\u00a0]: Copied! <pre>Map.to_html(\n    filename=\"mymap.html\", title=\"Earth Engine Map\", width='100%', height='800px'\n)\n</pre> Map.to_html(     filename=\"mymap.html\", title=\"Earth Engine Map\", width='100%', height='800px' )"},{"location":"workshops/Japan_2022/#installing-geemap","title":"Installing geemap\u00b6","text":"<p>Press Ctrl + / to uncomment the following line to install geemap. Restart the kernel/runtime after installation.</p>"},{"location":"workshops/Japan_2022/#earth-engine-authentication","title":"Earth Engine authentication\u00b6","text":""},{"location":"workshops/Japan_2022/#creating-interactive-maps","title":"Creating interactive maps\u00b6","text":""},{"location":"workshops/Japan_2022/#adding-basemaps","title":"Adding basemaps\u00b6","text":""},{"location":"workshops/Japan_2022/#built-in-basemaps","title":"Built-in basemaps\u00b6","text":""},{"location":"workshops/Japan_2022/#basemap-gui","title":"Basemap GUI\u00b6","text":""},{"location":"workshops/Japan_2022/#earth-engine-data-types","title":"Earth Engine data types\u00b6","text":""},{"location":"workshops/Japan_2022/#image","title":"Image\u00b6","text":""},{"location":"workshops/Japan_2022/#loading-earth-engine-images","title":"Loading Earth Engine images\u00b6","text":""},{"location":"workshops/Japan_2022/#visualizing-earth-engine-images","title":"Visualizing Earth Engine images\u00b6","text":""},{"location":"workshops/Japan_2022/#imagecollection","title":"ImageCollection\u00b6","text":""},{"location":"workshops/Japan_2022/#loading-image-collections","title":"Loading image collections\u00b6","text":""},{"location":"workshops/Japan_2022/#visualizing-image-collections","title":"Visualizing image collections\u00b6","text":""},{"location":"workshops/Japan_2022/#filtering-image-collections","title":"Filtering image collections\u00b6","text":""},{"location":"workshops/Japan_2022/#geometry","title":"Geometry\u00b6","text":""},{"location":"workshops/Japan_2022/#geometry-types","title":"Geometry types\u00b6","text":""},{"location":"workshops/Japan_2022/#creating-geometry-objects","title":"Creating Geometry objects\u00b6","text":""},{"location":"workshops/Japan_2022/#using-drawing-tools","title":"Using drawing tools\u00b6","text":""},{"location":"workshops/Japan_2022/#feature","title":"Feature\u00b6","text":""},{"location":"workshops/Japan_2022/#creating-feature-objects","title":"Creating Feature objects\u00b6","text":""},{"location":"workshops/Japan_2022/#setting-feature-properties","title":"Setting Feature properties\u00b6","text":""},{"location":"workshops/Japan_2022/#getting-feature-properties","title":"Getting Feature properties\u00b6","text":""},{"location":"workshops/Japan_2022/#featurecollection","title":"FeatureCollection\u00b6","text":""},{"location":"workshops/Japan_2022/#loading-feature-collections","title":"Loading feature collections\u00b6","text":""},{"location":"workshops/Japan_2022/#creating-feature-collections","title":"Creating feature collections\u00b6","text":""},{"location":"workshops/Japan_2022/#filtering-feature-collections","title":"Filtering feature collections\u00b6","text":""},{"location":"workshops/Japan_2022/#visualizing-feature-collections","title":"Visualizing feature collections\u00b6","text":""},{"location":"workshops/Japan_2022/#styling-by-attribute","title":"Styling by attribute\u00b6","text":""},{"location":"workshops/Japan_2022/#earth-engine-data-catalog","title":"Earth Engine Data Catalog\u00b6","text":""},{"location":"workshops/Japan_2022/#searching-for-datasets","title":"Searching for datasets\u00b6","text":""},{"location":"workshops/Japan_2022/#using-the-datasets-module","title":"Using the datasets module\u00b6","text":""},{"location":"workshops/Japan_2022/#getting-image-metadata","title":"Getting image metadata\u00b6","text":""},{"location":"workshops/Japan_2022/#calculating-descriptive-statistics","title":"Calculating descriptive statistics\u00b6","text":""},{"location":"workshops/Japan_2022/#using-the-inspector-tool","title":"Using the inspector tool\u00b6","text":""},{"location":"workshops/Japan_2022/#using-the-plotting-tool","title":"Using the plotting tool\u00b6","text":""},{"location":"workshops/Japan_2022/#changing-layer-opacity","title":"Changing layer opacity\u00b6","text":""},{"location":"workshops/Japan_2022/#visualizing-raster-data","title":"Visualizing raster data\u00b6","text":""},{"location":"workshops/Japan_2022/#single-band-images","title":"Single-band images\u00b6","text":""},{"location":"workshops/Japan_2022/#multi-band-images","title":"Multi-band images\u00b6","text":""},{"location":"workshops/Japan_2022/#visualizing-vector-data","title":"Visualizing vector data\u00b6","text":""},{"location":"workshops/Japan_2022/#creating-legends","title":"Creating legends\u00b6","text":""},{"location":"workshops/Japan_2022/#built-in-legends","title":"Built-in legends\u00b6","text":""},{"location":"workshops/Japan_2022/#custom-legends","title":"Custom legends\u00b6","text":""},{"location":"workshops/Japan_2022/#creating-color-bars","title":"Creating color bars\u00b6","text":""},{"location":"workshops/Japan_2022/#displaying-labels","title":"Displaying labels\u00b6","text":""},{"location":"workshops/Japan_2022/#split-panel-maps","title":"Split-panel maps\u00b6","text":""},{"location":"workshops/Japan_2022/#linked-maps","title":"Linked maps\u00b6","text":""},{"location":"workshops/Japan_2022/#timeseries-inspector","title":"Timeseries inspector\u00b6","text":""},{"location":"workshops/Japan_2022/#visualizing-image-collections","title":"Visualizing image collections\u00b6","text":""},{"location":"workshops/Japan_2022/#time-slider","title":"Time slider\u00b6","text":""},{"location":"workshops/Japan_2022/#visualizing-vegetation-data","title":"Visualizing vegetation data\u00b6","text":""},{"location":"workshops/Japan_2022/#visualizing-weather-data","title":"Visualizing weather data\u00b6","text":""},{"location":"workshops/Japan_2022/#visualizing-sentinel-2-imagery","title":"Visualizing Sentinel-2 imagery\u00b6","text":""},{"location":"workshops/Japan_2022/#shaded-relief-maps","title":"Shaded relief maps\u00b6","text":""},{"location":"workshops/Japan_2022/#elevation-contours","title":"Elevation contours\u00b6","text":""},{"location":"workshops/Japan_2022/#image-descriptive-statistics","title":"Image descriptive statistics\u00b6","text":""},{"location":"workshops/Japan_2022/#zonal-statistics-with-earth-engine","title":"Zonal statistics with Earth Engine\u00b6","text":""},{"location":"workshops/Japan_2022/#zonal-statistics","title":"Zonal statistics\u00b6","text":""},{"location":"workshops/Japan_2022/#zonal-statistics-by-group","title":"Zonal statistics by group\u00b6","text":""},{"location":"workshops/Japan_2022/#zonal-statistics-with-two-images","title":"Zonal statistics with two images\u00b6","text":""},{"location":"workshops/Japan_2022/#extracting-pixel-values","title":"Extracting pixel values\u00b6","text":""},{"location":"workshops/Japan_2022/#extracting-values-to-points","title":"Extracting values to points\u00b6","text":""},{"location":"workshops/Japan_2022/#extracting-pixel-values-along-a-transect","title":"Extracting pixel values along a transect\u00b6","text":""},{"location":"workshops/Japan_2022/#interactive-region-reduction","title":"Interactive region reduction\u00b6","text":""},{"location":"workshops/Japan_2022/#mapping-available-image-count","title":"Mapping available image count\u00b6","text":""},{"location":"workshops/Japan_2022/#cloud-free-composites","title":"Cloud-free composites\u00b6","text":""},{"location":"workshops/Japan_2022/#exporting-images","title":"Exporting images\u00b6","text":""},{"location":"workshops/Japan_2022/#to-local-drive","title":"To local drive\u00b6","text":""},{"location":"workshops/Japan_2022/#to-google-drive","title":"To Google Drive\u00b6","text":""},{"location":"workshops/Japan_2022/#to-asset","title":"To Asset\u00b6","text":""},{"location":"workshops/Japan_2022/#to-numpy-array","title":"To NumPy array\u00b6","text":""},{"location":"workshops/Japan_2022/#exporting-image-collections","title":"Exporting image collections\u00b6","text":""},{"location":"workshops/Japan_2022/#to-local-drive","title":"To local drive\u00b6","text":""},{"location":"workshops/Japan_2022/#to-google-drive","title":"To Google Drive\u00b6","text":""},{"location":"workshops/Japan_2022/#to-assets","title":"To Assets\u00b6","text":""},{"location":"workshops/Japan_2022/#exporting-feature-collections","title":"Exporting feature collections\u00b6","text":""},{"location":"workshops/Japan_2022/#to-local-drive","title":"To local drive\u00b6","text":""},{"location":"workshops/Japan_2022/#to-google-drive","title":"To Google Drive\u00b6","text":""},{"location":"workshops/Japan_2022/#to-asset","title":"To Asset\u00b6","text":""},{"location":"workshops/Japan_2022/#exporting-maps","title":"Exporting maps\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/","title":"SRM Workshop 2022","text":"<p>Interactive mapping and analysis of geospatial big data using geemap and Google Earth Engine</p> <p>This notebook was developed for the geemap workshop at the Society for Range Management (SRM) 2022 Annual Meeting.</p> <p>Authors: Qiusheng Wu</p> <p>Link to this notebook: https://gishub.org/SRM</p> In\u00a0[\u00a0]: Copied! <pre>import subprocess\n\ntry:\n    import geemap\nexcept ImportError:\n    print('Installing geemap ...')\n    subprocess.check_call([\"python\", '-m', 'pip', 'install', 'geemap'])\n</pre> import subprocess  try:     import geemap except ImportError:     print('Installing geemap ...')     subprocess.check_call([\"python\", '-m', 'pip', 'install', 'geemap']) In\u00a0[\u00a0]: Copied! <pre>import os\nimport ee\nimport geemap\n</pre> import os import ee import geemap In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4, draw_ctrl=False, toolbar_ctrl=False)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4, draw_ctrl=False, toolbar_ctrl=False) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\nMap.add_basemap('OpenTopoMap')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID') Map.add_basemap('OpenTopoMap') Map <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Map.user_roi.getInfo()\n</pre> # Map.user_roi.getInfo() In\u00a0[\u00a0]: Copied! <pre># Map.user_rois.getInfo()\n</pre> # Map.user_rois.getInfo() In\u00a0[\u00a0]: Copied! <pre>js_snippet = \"\"\"\n// Load an image.\nvar image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');\n\n// Define the visualization parameters.\nvar vizParams = {\n  bands: ['B5', 'B4', 'B3'],\n  min: 0,\n  max: 0.5,\n  gamma: [0.95, 1.1, 1]\n};\n\n// Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay\nMap.addLayer(image, vizParams, 'false color composite');\n\n\"\"\"\n</pre> js_snippet = \"\"\" // Load an image. var image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318');  // Define the visualization parameters. var vizParams = {   bands: ['B5', 'B4', 'B3'],   min: 0,   max: 0.5,   gamma: [0.95, 1.1, 1] };  // Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10); // San Francisco Bay Map.addLayer(image, vizParams, 'false color composite');  \"\"\" In\u00a0[\u00a0]: Copied! <pre>geemap.js_snippet_to_py(\n    js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True\n)\n</pre> geemap.js_snippet_to_py(     js_snippet, add_new_cell=True, import_ee=True, import_geemap=True, show_map=True ) In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nMap = geemap.Map()\n\n# Load an image.\nimage = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')\n\n# Define the visualization parameters.\nvizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}\n\n# Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10)\n# San Francisco Bay\nMap.addLayer(image, vizParams, 'False color composite')\nMap\n</pre> import ee import geemap  Map = geemap.Map()  # Load an image. image = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')  # Define the visualization parameters. vizParams = {'bands': ['B5', 'B4', 'B3'], 'min': 0, 'max': 0.5, 'gamma': [0.95, 1.1, 1]}  # Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10) # San Francisco Bay Map.addLayer(image, vizParams, 'False color composite') Map <p>You can also convert GEE JavaScript to Python without coding.</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine datasets\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\n\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine datasets dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003') states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 1.5},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\")  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>dem = ee.Image('CGIAR/SRTM90_V4')\nMap.addLayer(dem, {}, \"CGIAR/SRTM90_V4\")\n</pre> dem = ee.Image('CGIAR/SRTM90_V4') Map.addLayer(dem, {}, \"CGIAR/SRTM90_V4\") In\u00a0[\u00a0]: Copied! <pre>hillshade = ee.Terrain.hillshade(dem)\nMap.addLayer(hillshade, {}, 'Hillshade')\n</pre> hillshade = ee.Terrain.hillshade(dem) Map.addLayer(hillshade, {}, 'Hillshade') In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, \"DEM\", True, 0.5)\n</pre> vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, \"DEM\", True, 0.5) In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import DATA\n</pre> from geemap.datasets import DATA In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image(DATA.USGS_SRTMGL1_003)\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\nMap\n</pre> Map = geemap.Map()  dem = ee.Image(DATA.USGS_SRTMGL1_003)  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM') Map <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine datasets\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5)\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 180, 'gamma': 1.5},\n    'Landsat 7',\n)\nMap.addLayer(states, {}, \"US States\")\n\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine datasets dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(dem, vis_params, 'SRTM DEM', True, 0.5) Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 180, 'gamma': 1.5},     'Landsat 7', ) Map.addLayer(states, {}, \"US States\")  Map <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat7, landsat_vis, \"Landsat\")\n\nhyperion = ee.ImageCollection('EO1/HYPERION').filter(\n    ee.Filter.date('2016-01-01', '2017-03-01')\n)\n\nhyperion_vis = {\n    'min': 1000.0,\n    'max': 14000.0,\n    'gamma': 2.5,\n}\nMap.addLayer(hyperion, hyperion_vis, 'Hyperion')\n\nMap\n</pre> Map = geemap.Map()  landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] )  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat7, landsat_vis, \"Landsat\")  hyperion = ee.ImageCollection('EO1/HYPERION').filter(     ee.Filter.date('2016-01-01', '2017-03-01') )  hyperion_vis = {     'min': 1000.0,     'max': 14000.0,     'gamma': 2.5, } Map.addLayer(hyperion, hyperion_vis, 'Hyperion')  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\ndem = ee.Image('USGS/SRTMGL1_003')\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap.addLayer(states, {}, \"US States\", True)\n\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  dem = ee.Image('USGS/SRTMGL1_003') states = ee.FeatureCollection(\"TIGER/2018/States\")  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map.addLayer(states, {}, \"US States\", True)  Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(\n    ['B1', 'B2', 'B3', 'B4', 'B5', 'B7']\n)\n\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap.addLayer(\n    landsat7,\n    {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},\n    'Landsat 7',\n)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003').select(     ['B1', 'B2', 'B3', 'B4', 'B5', 'B7'] )  vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map.addLayer(     landsat7,     {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200, 'gamma': 2},     'Landsat 7', ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map()  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>vis_params = {\n    'color': '000000',\n    'colorOpacity': 1,\n    'pointSize': 3,\n    'pointShape': 'circle',\n    'width': 2,\n    'lineType': 'solid',\n    'fillColorOpacity': 0.66,\n}\n\npalette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']\n\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\n</pre> vis_params = {     'color': '000000',     'colorOpacity': 1,     'pointSize': 3,     'pointShape': 'circle',     'width': 2,     'lineType': 'solid',     'fillColorOpacity': 0.66, }  palette = ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5']  Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params ) In\u00a0[\u00a0]: Copied! <pre>legends = geemap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = geemap.builtin_legends for legend in legends:     print(legend) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap('HYBRID')\n\ndataset = ee.ImageCollection('USGS/NLCD_RELEASES/2016_REL')\nnlcd2016 = dataset.filter(ee.Filter.eq('system:index', '2016')).first()\nlandcover = nlcd2016.select('landcover')\n\nMap.addLayer(landcover, {}, 'NLCD Land Cover 2016')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map() Map.add_basemap('HYBRID')  dataset = ee.ImageCollection('USGS/NLCD_RELEASES/2016_REL') nlcd2016 = dataset.filter(ee.Filter.eq('system:index', '2016')).first() landcover = nlcd2016.select('landcover')  Map.addLayer(landcover, {}, 'NLCD Land Cover 2016') Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nlegend_dict = {\n    '11 Open Water': '466b9f',\n    '12 Perennial Ice/Snow': 'd1def8',\n    '21 Developed, Open Space': 'dec5c5',\n    '22 Developed, Low Intensity': 'd99282',\n    '23 Developed, Medium Intensity': 'eb0000',\n    '24 Developed High Intensity': 'ab0000',\n    '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',\n    '41 Deciduous Forest': '68ab5f',\n    '42 Evergreen Forest': '1c5f2c',\n    '43 Mixed Forest': 'b5c58f',\n    '51 Dwarf Scrub': 'af963c',\n    '52 Shrub/Scrub': 'ccb879',\n    '71 Grassland/Herbaceous': 'dfdfc2',\n    '72 Sedge/Herbaceous': 'd1d182',\n    '73 Lichens': 'a3cc51',\n    '74 Moss': '82ba9e',\n    '81 Pasture/Hay': 'dcd939',\n    '82 Cultivated Crops': 'ab6c28',\n    '90 Woody Wetlands': 'b8d9eb',\n    '95 Emergent Herbaceous Wetlands': '6c9fb8',\n}\n\ndataset = ee.ImageCollection('USGS/NLCD_RELEASES/2016_REL')\nnlcd2016 = dataset.filter(ee.Filter.eq('system:index', '2016')).first()\nlandcover = nlcd2016.select('landcover')\n\nMap.addLayer(landcover, {}, 'NLCD Land Cover 2016')\nMap.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n</pre> Map = geemap.Map()  legend_dict = {     '11 Open Water': '466b9f',     '12 Perennial Ice/Snow': 'd1def8',     '21 Developed, Open Space': 'dec5c5',     '22 Developed, Low Intensity': 'd99282',     '23 Developed, Medium Intensity': 'eb0000',     '24 Developed High Intensity': 'ab0000',     '31 Barren Land (Rock/Sand/Clay)': 'b3ac9f',     '41 Deciduous Forest': '68ab5f',     '42 Evergreen Forest': '1c5f2c',     '43 Mixed Forest': 'b5c58f',     '51 Dwarf Scrub': 'af963c',     '52 Shrub/Scrub': 'ccb879',     '71 Grassland/Herbaceous': 'dfdfc2',     '72 Sedge/Herbaceous': 'd1d182',     '73 Lichens': 'a3cc51',     '74 Moss': '82ba9e',     '81 Pasture/Hay': 'dcd939',     '82 Cultivated Crops': 'ab6c28',     '90 Woody Wetlands': 'b8d9eb',     '95 Emergent Herbaceous Wetlands': '6c9fb8', }  dataset = ee.ImageCollection('USGS/NLCD_RELEASES/2016_REL') nlcd2016 = dataset.filter(ee.Filter.eq('system:index', '2016')).first() landcover = nlcd2016.select('landcover')  Map.addLayer(landcover, {}, 'NLCD Land Cover 2016') Map.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image('USGS/SRTMGL1_003')\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\nMap.addLayer(dem, vis_params, 'SRTM DEM')\n\ncolors = vis_params['palette']\nvmin = vis_params['min']\nvmax = vis_params['max']\n\nMap.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\")\nMap\n</pre> Map = geemap.Map()  dem = ee.Image('USGS/SRTMGL1_003') vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  Map.addLayer(dem, vis_params, 'SRTM DEM')  colors = vis_params['palette'] vmin = vis_params['min'] vmax = vis_params['max']  Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\") Map In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\"\n)\n</pre> Map.add_colorbar(     vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\" ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n)\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     layer_name=\"SRTM DEM\",     orientation=\"vertical\",     transparent_bg=True, ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n    discrete=True,\n)\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     layer_name=\"SRTM DEM\",     orientation=\"vertical\",     transparent_bg=True,     discrete=True, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(left_layer='HYBRID', right_layer='TERRAIN')\nMap\n</pre> Map = geemap.Map() Map.split_map(left_layer='HYBRID', right_layer='TERRAIN') Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\nMap.split_map(\n    left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover'\n)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4) Map.split_map(     left_layer='NLCD 2016 CONUS Land Cover', right_layer='NLCD 2001 CONUS Land Cover' ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\ndataset = ee.ImageCollection('USGS/NLCD_RELEASES/2016_REL')\nnlcd_2001 = (\n    dataset.filter(ee.Filter.eq('system:index', '2001')).first().select('landcover')\n)\nnlcd_2016 = (\n    dataset.filter(ee.Filter.eq('system:index', '2016')).first().select('landcover')\n)\n\nleft_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001')\nright_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')\n\nMap.split_map(left_layer, right_layer)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  dataset = ee.ImageCollection('USGS/NLCD_RELEASES/2016_REL') nlcd_2001 = (     dataset.filter(ee.Filter.eq('system:index', '2001')).first().select('landcover') ) nlcd_2016 = (     dataset.filter(ee.Filter.eq('system:index', '2016')).first().select('landcover') )  left_layer = geemap.ee_tile_layer(nlcd_2001, {}, 'NLCD 2001') right_layer = geemap.ee_tile_layer(nlcd_2016, {}, 'NLCD 2016')  Map.split_map(left_layer, right_layer) Map In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection('COPERNICUS/S2')\n    .filterDate('2018-09-01', '2018-09-30')\n    .map(lambda img: img.divide(10000))\n    .median()\n)\n\nvis_params = [\n    {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n    {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},\n]\n\nlabels = [\n    'Natural Color (B4/B3/B2)',\n    'Land/Water (B8/B11/B4)',\n    'Color Infrared (B8/B4/B3)',\n    'Vegetation (B12/B11/B4)',\n]\n\ngeemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"400px\",\n    center=[38.4151, 21.2712],\n    zoom=12,\n    ee_objects=[image],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n</pre> image = (     ee.ImageCollection('COPERNICUS/S2')     .filterDate('2018-09-01', '2018-09-30')     .map(lambda img: img.divide(10000))     .median() )  vis_params = [     {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B11', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B8', 'B4', 'B3'], 'min': 0, 'max': 0.3, 'gamma': 1.3},     {'bands': ['B12', 'B12', 'B4'], 'min': 0, 'max': 0.3, 'gamma': 1.3}, ]  labels = [     'Natural Color (B4/B3/B2)',     'Land/Water (B8/B11/B4)',     'Color Infrared (B8/B4/B3)',     'Vegetation (B12/B11/B4)', ]  geemap.linked_maps(     rows=2,     cols=2,     height=\"400px\",     center=[38.4151, 21.2712],     zoom=12,     ee_objects=[image],     vis_params=vis_params,     labels=labels,     label_position=\"topright\", ) In\u00a0[\u00a0]: Copied! <pre>import geemap.colormaps as cm\n</pre> import geemap.colormaps as cm In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection(\n    'projects/rangeland-analysis-platform/vegetation-cover-v3'\n).select('TRE')\n</pre> collection = ee.ImageCollection(     'projects/rangeland-analysis-platform/vegetation-cover-v3' ).select('TRE') In\u00a0[\u00a0]: Copied! <pre>years = collection.aggregate_array('year').getInfo()\nyears\n</pre> years = collection.aggregate_array('year').getInfo() years In\u00a0[\u00a0]: Copied! <pre>names = [str(i) for i in years]\nnames\n</pre> names = [str(i) for i in years] names In\u00a0[\u00a0]: Copied! <pre>palette = cm.palettes.ndvi\npalette\n</pre> palette = cm.palettes.ndvi palette In\u00a0[\u00a0]: Copied! <pre>vis_params = {'min': 0, 'max': 50, 'palette': palette}\n</pre> vis_params = {'min': 0, 'max': 50, 'palette': palette} In\u00a0[\u00a0]: Copied! <pre># Map.addLayer(collection.first(), {}, \"First image\")\nMap.ts_inspector(\n    left_ts=collection,\n    right_ts=collection,\n    left_names=names,\n    right_names=names,\n    left_vis=vis_params,\n    right_vis=vis_params,\n)\nMap\n</pre> # Map.addLayer(collection.first(), {}, \"First image\") Map.ts_inspector(     left_ts=collection,     right_ts=collection,     left_names=names,     right_names=names,     left_vis=vis_params,     right_vis=vis_params, ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncentroid = ee.Geometry.Point([-122.4439, 37.7538])\n\nimage = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()\n\nvis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}\n\nMap.centerObject(centroid, 8)\nMap.addLayer(image, vis, \"Landsat-8\")\nMap\n</pre> Map = geemap.Map()  centroid = ee.Geometry.Point([-122.4439, 37.7538])  image = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').filterBounds(centroid).first()  vis = {'min': 0, 'max': 3000, 'bands': ['B5', 'B4', 'B3']}  Map.centerObject(centroid, 8) Map.addLayer(image, vis, \"Landsat-8\") Map In\u00a0[\u00a0]: Copied! <pre>image.propertyNames().getInfo()\n</pre> image.propertyNames().getInfo() In\u00a0[\u00a0]: Copied! <pre>image.get('CLOUD_COVER').getInfo()\n</pre> image.get('CLOUD_COVER').getInfo() In\u00a0[\u00a0]: Copied! <pre>props = geemap.image_props(image)\nprops.getInfo()\n</pre> props = geemap.image_props(image) props.getInfo() In\u00a0[\u00a0]: Copied! <pre>stats = geemap.image_stats(image, scale=90)\nstats.getInfo()\n</pre> stats = geemap.image_stats(image, scale=90) stats.getInfo() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\n\n# Set visualization parameters.\ndem_vis = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine DEM to map\nMap.addLayer(dem, dem_vis, 'SRTM DEM')\n\n# Add Landsat data to map\nlandsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(landsat, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003')  # Set visualization parameters. dem_vis = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine DEM to map Map.addLayer(dem, dem_vis, 'SRTM DEM')  # Add Landsat data to map landsat = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(landsat, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\")  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') Map In\u00a0[\u00a0]: Copied! <pre>out_dem_stats = 'dem_stats.csv'\n\n# Allowed output formats: csv, shp, json, kml, kmz\n# Allowed statistics type: MEAN, MAXIMUM, MINIMUM, MEDIAN, STD, MIN_MAX, VARIANCE, SUM\ngeemap.zonal_statistics(dem, states, out_dem_stats, statistics_type='MEAN', scale=1000)\n</pre> out_dem_stats = 'dem_stats.csv'  # Allowed output formats: csv, shp, json, kml, kmz # Allowed statistics type: MEAN, MAXIMUM, MINIMUM, MEDIAN, STD, MIN_MAX, VARIANCE, SUM geemap.zonal_statistics(dem, states, out_dem_stats, statistics_type='MEAN', scale=1000) In\u00a0[\u00a0]: Copied! <pre>out_landsat_stats = 'landsat_stats.csv'\ngeemap.zonal_statistics(\n    landsat, states, out_landsat_stats, statistics_type='SUM', scale=1000\n)\n</pre> out_landsat_stats = 'landsat_stats.csv' geemap.zonal_statistics(     landsat, states, out_landsat_stats, statistics_type='SUM', scale=1000 ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndataset = ee.ImageCollection('USGS/NLCD_RELEASES/2016_REL')\nnlcd2016 = dataset.filter(ee.Filter.eq('system:index', '2016')).first()\nlandcover = nlcd2016.select('landcover')\nMap.addLayer(landcover, {}, 'NLCD 2016')\n\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, 'US States')\nMap.add_legend(builtin_legend='NLCD')\nMap\n</pre> Map = geemap.Map()  dataset = ee.ImageCollection('USGS/NLCD_RELEASES/2016_REL') nlcd2016 = dataset.filter(ee.Filter.eq('system:index', '2016')).first() landcover = nlcd2016.select('landcover') Map.addLayer(landcover, {}, 'NLCD 2016')  states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, 'US States') Map.add_legend(builtin_legend='NLCD') Map In\u00a0[\u00a0]: Copied! <pre>nlcd_stats = 'nlcd_stats.csv'\n\n# statistics_type can be either 'SUM' or 'PERCENTAGE'\n# denominator can be used to convert square meters to other areal units, such as square kilimeters\ngeemap.zonal_statistics_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    statistics_type='SUM',\n    denominator=1000000,\n    decimal_places=2,\n)\n</pre> nlcd_stats = 'nlcd_stats.csv'  # statistics_type can be either 'SUM' or 'PERCENTAGE' # denominator can be used to convert square meters to other areal units, such as square kilimeters geemap.zonal_statistics_by_group(     landcover,     states,     nlcd_stats,     statistics_type='SUM',     denominator=1000000,     decimal_places=2, ) In\u00a0[\u00a0]: Copied! <pre>import whiteboxgui\n</pre> import whiteboxgui In\u00a0[\u00a0]: Copied! <pre>whiteboxgui.show()\n</pre> whiteboxgui.show() In\u00a0[\u00a0]: Copied! <pre>whiteboxgui.show(tree=True)\n</pre> whiteboxgui.show(tree=True) <p></p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\nlandsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4}\nMap.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 1)\n\nMap\n</pre> Map = geemap.Map()  image = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  landsat_vis = {'bands': ['B4', 'B3', 'B2'], 'gamma': 1.4} Map.addLayer(image, landsat_vis, \"LE7_TOA_5YEAR/1999_2003\", True, 1)  Map In\u00a0[\u00a0]: Copied! <pre># Draw any shapes on the map using the Drawing tools before executing this code block\nroi = Map.user_roi\n\nif roi is None:\n    roi = ee.Geometry.Polygon(\n        [\n            [\n                [-115.413031, 35.889467],\n                [-115.413031, 36.543157],\n                [-114.034328, 36.543157],\n                [-114.034328, 35.889467],\n                [-115.413031, 35.889467],\n            ]\n        ]\n    )\n</pre> # Draw any shapes on the map using the Drawing tools before executing this code block roi = Map.user_roi  if roi is None:     roi = ee.Geometry.Polygon(         [             [                 [-115.413031, 35.889467],                 [-115.413031, 36.543157],                 [-114.034328, 36.543157],                 [-114.034328, 35.889467],                 [-115.413031, 35.889467],             ]         ]     ) In\u00a0[\u00a0]: Copied! <pre>filename = 'landsat.tif'\n</pre> filename = 'landsat.tif' <p>Exporting all bands as one single image</p> In\u00a0[\u00a0]: Copied! <pre>image = image.clip(roi).unmask()\ngeemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=False\n)\n</pre> image = image.clip(roi).unmask() geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=False ) <p>Exporting each band as one image</p> In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(\n    image, filename=filename, scale=90, region=roi, file_per_band=True\n)\n</pre> geemap.ee_export_image(     image, filename=filename, scale=90, region=roi, file_per_band=True ) <p>Export an image to Google Drive\u00b6</p> In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_to_drive(image, description='landsat', folder='export', region=roi, scale=30)\n</pre> # geemap.ee_export_image_to_drive(image, description='landsat', folder='export', region=roi, scale=30) In\u00a0[\u00a0]: Copied! <pre>loc = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection('USDA/NAIP/DOQQ')\n    .filterBounds(loc)\n    .filterDate('2008-01-01', '2020-01-01')\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n</pre> loc = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection('USDA/NAIP/DOQQ')     .filterBounds(loc)     .filterDate('2008-01-01', '2020-01-01')     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) In\u00a0[\u00a0]: Copied! <pre>collection.aggregate_array('system:index').getInfo()\n</pre> collection.aggregate_array('system:index').getInfo() In\u00a0[\u00a0]: Copied! <pre>out_dir = os.getcwd()\ngeemap.ee_export_image_collection(collection, out_dir=out_dir)\n</pre> out_dir = os.getcwd() geemap.ee_export_image_collection(collection, out_dir=out_dir) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10)\n</pre> # geemap.ee_export_image_collection_to_drive(collection, folder='export', scale=10) In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nimg = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810').select(['B4', 'B5', 'B6'])\n\naoi = ee.Geometry.Polygon(\n    [[[-110.8, 44.7], [-110.8, 44.6], [-110.6, 44.6], [-110.6, 44.7]]], None, False\n)\n\nrgb_img = geemap.ee_to_numpy(img, region=aoi)\nprint(rgb_img.shape)\n</pre> import matplotlib.pyplot as plt  img = ee.Image('LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810').select(['B4', 'B5', 'B6'])  aoi = ee.Geometry.Polygon(     [[[-110.8, 44.7], [-110.8, 44.6], [-110.6, 44.6], [-110.6, 44.7]]], None, False )  rgb_img = geemap.ee_to_numpy(img, region=aoi) print(rgb_img.shape) In\u00a0[\u00a0]: Copied! <pre>rgb_img_test = (255 * ((rgb_img[:, :, 0:3] - 100) / 3500)).astype('uint8')\nplt.imshow(rgb_img_test)\nplt.show()\n</pre> rgb_img_test = (255 * ((rgb_img[:, :, 0:3] - 100) / 3500)).astype('uint8') plt.imshow(rgb_img_test) plt.show() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\n# Add Earth Engine dataset\ndem = ee.Image('USGS/SRTMGL1_003')\nlandsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')\n\n# Set visualization parameters.\nvis_params = {\n    'min': 0,\n    'max': 4000,\n    'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'],\n}\n\n# Add Earth Engine layers to Map\nMap.addLayer(\n    landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7'\n)\nMap.addLayer(dem, vis_params, 'SRTM DEM', True, 1)\nMap\n</pre> Map = geemap.Map()  # Add Earth Engine dataset dem = ee.Image('USGS/SRTMGL1_003') landsat7 = ee.Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')  # Set visualization parameters. vis_params = {     'min': 0,     'max': 4000,     'palette': ['006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5'], }  # Add Earth Engine layers to Map Map.addLayer(     landsat7, {'bands': ['B4', 'B3', 'B2'], 'min': 20, 'max': 200}, 'Landsat 7' ) Map.addLayer(dem, vis_params, 'SRTM DEM', True, 1) Map <p>Download sample data</p> In\u00a0[\u00a0]: Copied! <pre>work_dir = os.getcwd()\nin_shp = os.path.join(work_dir, 'us_cities.shp')\nif not os.path.exists(in_shp):\n    data_url = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip'\n    geemap.download_from_url(data_url, out_dir=work_dir)\n</pre> work_dir = os.getcwd() in_shp = os.path.join(work_dir, 'us_cities.shp') if not os.path.exists(in_shp):     data_url = 'https://github.com/giswqs/data/raw/main/us/us_cities.zip'     geemap.download_from_url(data_url, out_dir=work_dir) In\u00a0[\u00a0]: Copied! <pre>in_fc = geemap.shp_to_ee(in_shp)\nMap.addLayer(in_fc, {}, 'Cities')\n</pre> in_fc = geemap.shp_to_ee(in_shp) Map.addLayer(in_fc, {}, 'Cities') <p>Export pixel values as a shapefile</p> In\u00a0[\u00a0]: Copied! <pre>out_shp = os.path.join(work_dir, 'dem.shp')\ngeemap.extract_values_to_points(in_fc, dem, out_shp)\n</pre> out_shp = os.path.join(work_dir, 'dem.shp') geemap.extract_values_to_points(in_fc, dem, out_shp) <p>Export pixel values as a csv</p> In\u00a0[\u00a0]: Copied! <pre>out_csv = os.path.join(work_dir, 'landsat.csv')\ngeemap.extract_values_to_points(in_fc, landsat7, out_csv)\n</pre> out_csv = os.path.join(work_dir, 'landsat.csv') geemap.extract_values_to_points(in_fc, landsat7, out_csv) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nfc = ee.FeatureCollection('users/giswqs/public/countries')\nMap.addLayer(fc, {}, \"Countries\")\nMap\n</pre> Map = geemap.Map()  fc = ee.FeatureCollection('users/giswqs/public/countries') Map.addLayer(fc, {}, \"Countries\") Map In\u00a0[\u00a0]: Copied! <pre>out_shp = 'countries.shp'\n</pre> out_shp = 'countries.shp' In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_shp(fc, filename=out_shp)\n</pre> geemap.ee_to_shp(fc, filename=out_shp) In\u00a0[\u00a0]: Copied! <pre>out_csv = os.path.join(out_dir, 'countries.csv')\ngeemap.ee_export_vector(fc, filename=out_csv)\n</pre> out_csv = os.path.join(out_dir, 'countries.csv') geemap.ee_export_vector(fc, filename=out_csv) In\u00a0[\u00a0]: Copied! <pre>out_kml = os.path.join(out_dir, 'countries.kml')\ngeemap.ee_export_vector(fc, filename=out_kml)\n</pre> out_kml = os.path.join(out_dir, 'countries.kml') geemap.ee_export_vector(fc, filename=out_kml) In\u00a0[\u00a0]: Copied! <pre># geemap.ee_export_vector_to_drive(fc, description=\"countries\", folder=\"export\", file_format=\"shp\")\n</pre> # geemap.ee_export_vector_to_drive(fc, description=\"countries\", folder=\"export\", file_format=\"shp\")"},{"location":"workshops/SRM_Workshop_2022/#introduction","title":"Introduction\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#description","title":"Description\u00b6","text":"<p>Google Earth Engine (GEE) is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. It enables scientists, researchers, and developers to analyze and visualize changes on the Earth\u2019s surface. The geemap Python package provides GEE users with an intuitive interface to manipulate, analyze, and visualize geospatial big data interactively in a Jupyter-based environment. The topics to be covered in this workshop include:</p> <ol> <li>Introducing geemap</li> <li>Creating interactive maps</li> <li>Searching GEE data catalog</li> <li>Data Visualization</li> <li>Data Analysis</li> <li>Data Export</li> </ol> <p>This workshop is intended for scientific programmers, data scientists, geospatial analysts, and concerned citizens of Earth. The attendees are expected to have a basic understanding of Python and the Jupyter ecosystem. Familiarity with Earth science and geospatial datasets is useful but not required.</p>"},{"location":"workshops/SRM_Workshop_2022/#useful-links","title":"Useful links\u00b6","text":"<ul> <li>Streamlit Geospatial</li> <li>Google Earth Engine</li> <li>geemap.org</li> <li>Google Earth Engine and geemap Python Tutorials (55 videos with a total length of 15 hours)</li> <li>Spatial Data Management with Google Earth Engine (19 videos with a total length of 9 hours)</li> <li>Ask geemap questions on GitHub</li> </ul>"},{"location":"workshops/SRM_Workshop_2022/#prerequisite","title":"Prerequisite\u00b6","text":"<ul> <li>A Google Earth Engine account. Sigh up here if needed.</li> <li>Miniconda or Anaconda has been installed on your computer.</li> </ul>"},{"location":"workshops/SRM_Workshop_2022/#set-up-a-conda-environment","title":"Set up a conda environment\u00b6","text":"<pre><code>conda create -n gee python=3.9\nconda activate gee\nconda install geopandas\nconda install mamba -c conda-forge\nmamba install geemap localtileserver -c conda-forge\n\n</code></pre>"},{"location":"workshops/SRM_Workshop_2022/#launch-jupyterlab","title":"Launch JupyterLab\u00b6","text":"<p>Open Anaconda Prompt or the Terminal and enter the following commands.</p> <pre><code>conda activate gee\njupyter lab\n</code></pre>"},{"location":"workshops/SRM_Workshop_2022/#geemap-basics","title":"Geemap basics\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#install-geemap","title":"Install geemap\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#customize-the-default-map","title":"Customize the default map\u00b6","text":"<p>You can specify the center(lat, lon) and zoom for the default map. You can also set the visibility of the controls.</p>"},{"location":"workshops/SRM_Workshop_2022/#add-basemaps","title":"Add basemaps\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#change-basemaps-interactively","title":"Change basemaps interactively\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#use-drawing-tools","title":"Use drawing tools\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#convert-gee-javascript-to-python","title":"Convert GEE JavaScript to Python\u00b6","text":"<p>https://developers.google.com/earth-engine/guides/image_visualization</p>"},{"location":"workshops/SRM_Workshop_2022/#earth-engine-datasets","title":"Earth Engine datasets\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#load-earth-engine-datasets","title":"Load Earth Engine datasets\u00b6","text":"<p>More GEE datasets can be found at https://developers.google.com/earth-engine/datasets/</p>"},{"location":"workshops/SRM_Workshop_2022/#search-the-earth-engine-data-catalog","title":"Search the Earth Engine Data Catalog\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#use-the-datasets-module","title":"Use the datasets module\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#use-the-inspector-tool","title":"Use the Inspector tool\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#data-visualization","title":"Data visualization\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#use-the-plotting-tool","title":"Use the Plotting tool\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#change-layer-opacity","title":"Change layer opacity\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#visualize-raster-data","title":"Visualize raster data\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#visualize-vector-data","title":"Visualize vector data\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#add-a-legend","title":"Add a legend\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#add-a-colorbar","title":"Add a colorbar\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#create-a-split-panel-map","title":"Create a split-panel map\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#create-linked-maps","title":"Create linked maps\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#use-timeseries-inspector","title":"Use timeseries inspector\u00b6","text":"<p>Using data from the Rangeland Analysis Platform.</p> <ul> <li>Vegetation cover dataset: <code>ee.ImageCollection('projects/rangeland-analysis-platform/vegetation-cover-v3')</code></li> <li>Rangeland production dataset: <code>ee.ImageCollection('projects/rangeland-analysis-platform/npp-partitioned-v3')</code></li> </ul>"},{"location":"workshops/SRM_Workshop_2022/#data-analysis","title":"Data analysis\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#descriptive-statistics","title":"Descriptive statistics\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#zonal-statistics","title":"Zonal statistics\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#zonal-statistics-by-group","title":"Zonal statistics by group\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#whiteboxtools","title":"WhiteboxTools\u00b6","text":"<p>https://www.whiteboxgeo.com/manual/wbt_book/intro.html</p>"},{"location":"workshops/SRM_Workshop_2022/#data-export","title":"Data export\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#export-eeimage","title":"Export ee.Image\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#export-eeimagecollection","title":"Export ee.ImageCollection\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#extract-pixels-as-a-numpy-array","title":"Extract pixels as a numpy array\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#export-pixel-values-to-points","title":"Export pixel values to points\u00b6","text":""},{"location":"workshops/SRM_Workshop_2022/#export-eefeaturecollection","title":"Export ee.FeatureCollection\u00b6","text":""}]}